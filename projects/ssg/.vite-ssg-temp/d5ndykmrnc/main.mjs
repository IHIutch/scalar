import { ViteSSG } from "vite-ssg/single-page";
import { ref, defineComponent, computed, onMounted, onUnmounted, h as h$3, Fragment, watchEffect, watch, provide, inject, Teleport, reactive, unref, cloneVNode, nextTick, shallowRef, defineAsyncComponent, toRaw, openBlock, createElementBlock, renderSlot, createElementVNode, createVNode, withCtx, renderList, createBlock, createCommentVNode, readonly, normalizeStyle, normalizeClass, mergeProps, toDisplayString, createTextVNode, getCurrentScope, onScopeDispose, getCurrentInstance, resolveDynamicComponent, isRef, useCssVars, pushScopeId, popScopeId, createStaticVNode, withDirectives, vShow, useSSRContext } from "vue";
import { ssrRenderAttrs, ssrRenderComponent } from "vue/server-renderer";
import proc$1 from "node:process";
import path$3 from "node:path";
import { fileURLToPath } from "node:url";
let Schema$1 = class Schema {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property, normal, space2) {
    this.property = property;
    this.normal = normal;
    if (space2) {
      this.space = space2;
    }
  }
};
Schema$1.prototype.property = {};
Schema$1.prototype.normal = {};
Schema$1.prototype.space = null;
function merge$1(definitions, space2) {
  const property = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions.length) {
    Object.assign(property, definitions[index2].property);
    Object.assign(normal, definitions[index2].normal);
  }
  return new Schema$1(property, normal, space2);
}
function normalize$2(value) {
  return value.toLowerCase();
}
let Info$1 = class Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
};
Info$1.prototype.space = null;
Info$1.prototype.boolean = false;
Info$1.prototype.booleanish = false;
Info$1.prototype.overloadedBoolean = false;
Info$1.prototype.number = false;
Info$1.prototype.commaSeparated = false;
Info$1.prototype.spaceSeparated = false;
Info$1.prototype.commaOrSpaceSeparated = false;
Info$1.prototype.mustUseProperty = false;
Info$1.prototype.defined = false;
let powers$1 = 0;
const boolean$1 = increment$1();
const booleanish$1 = increment$1();
const overloadedBoolean$1 = increment$1();
const number$2 = increment$1();
const spaceSeparated$1 = increment$1();
const commaSeparated$1 = increment$1();
const commaOrSpaceSeparated$1 = increment$1();
function increment$1() {
  return 2 ** ++powers$1;
}
const types$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: boolean$1,
  booleanish: booleanish$1,
  commaOrSpaceSeparated: commaOrSpaceSeparated$1,
  commaSeparated: commaSeparated$1,
  number: number$2,
  overloadedBoolean: overloadedBoolean$1,
  spaceSeparated: spaceSeparated$1
}, Symbol.toStringTag, { value: "Module" }));
const checks$1 = Object.keys(types$2);
let DefinedInfo$1 = class DefinedInfo extends Info$1 {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property, attribute, mask, space2) {
    let index2 = -1;
    super(property, attribute);
    mark$1(this, "space", space2);
    if (typeof mask === "number") {
      while (++index2 < checks$1.length) {
        const check = checks$1[index2];
        mark$1(this, checks$1[index2], (mask & types$2[check]) === types$2[check]);
      }
    }
  }
};
DefinedInfo$1.prototype.defined = true;
function mark$1(values, key2, value) {
  if (value) {
    values[key2] = value;
  }
}
const own$i = {}.hasOwnProperty;
function create$3(definition2) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition2.properties) {
    if (own$i.call(definition2.properties, prop)) {
      const value = definition2.properties[prop];
      const info = new DefinedInfo$1(
        prop,
        definition2.transform(definition2.attributes || {}, prop),
        value,
        definition2.space
      );
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property[prop] = info;
      normal[normalize$2(prop)] = prop;
      normal[normalize$2(info.attribute)] = prop;
    }
  }
  return new Schema$1(property, normal, definition2.space);
}
const xlink$1 = create$3({
  space: "xlink",
  transform(_10, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
const xml$2 = create$3({
  space: "xml",
  transform(_10, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform$1(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
function caseInsensitiveTransform$1(attributes, property) {
  return caseSensitiveTransform$1(attributes, property.toLowerCase());
}
const xmlns$1 = create$3({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform$1,
  properties: { xmlns: null, xmlnsXLink: null }
});
const aria$2 = create$3({
  transform(_10, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish$1,
    ariaAutoComplete: null,
    ariaBusy: booleanish$1,
    ariaChecked: booleanish$1,
    ariaColCount: number$2,
    ariaColIndex: number$2,
    ariaColSpan: number$2,
    ariaControls: spaceSeparated$1,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated$1,
    ariaDetails: null,
    ariaDisabled: booleanish$1,
    ariaDropEffect: spaceSeparated$1,
    ariaErrorMessage: null,
    ariaExpanded: booleanish$1,
    ariaFlowTo: spaceSeparated$1,
    ariaGrabbed: booleanish$1,
    ariaHasPopup: null,
    ariaHidden: booleanish$1,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated$1,
    ariaLevel: number$2,
    ariaLive: null,
    ariaModal: booleanish$1,
    ariaMultiLine: booleanish$1,
    ariaMultiSelectable: booleanish$1,
    ariaOrientation: null,
    ariaOwns: spaceSeparated$1,
    ariaPlaceholder: null,
    ariaPosInSet: number$2,
    ariaPressed: booleanish$1,
    ariaReadOnly: booleanish$1,
    ariaRelevant: null,
    ariaRequired: booleanish$1,
    ariaRoleDescription: spaceSeparated$1,
    ariaRowCount: number$2,
    ariaRowIndex: number$2,
    ariaRowSpan: number$2,
    ariaSelected: booleanish$1,
    ariaSetSize: number$2,
    ariaSort: null,
    ariaValueMax: number$2,
    ariaValueMin: number$2,
    ariaValueNow: number$2,
    ariaValueText: null,
    role: null
  }
});
const html$8 = create$3({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform$1,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated$1,
    acceptCharset: spaceSeparated$1,
    accessKey: spaceSeparated$1,
    action: null,
    allow: null,
    allowFullScreen: boolean$1,
    allowPaymentRequest: boolean$1,
    allowUserMedia: boolean$1,
    alt: null,
    as: null,
    async: boolean$1,
    autoCapitalize: null,
    autoComplete: spaceSeparated$1,
    autoFocus: boolean$1,
    autoPlay: boolean$1,
    blocking: spaceSeparated$1,
    capture: boolean$1,
    charSet: null,
    checked: boolean$1,
    cite: null,
    className: spaceSeparated$1,
    cols: number$2,
    colSpan: null,
    content: null,
    contentEditable: booleanish$1,
    controls: boolean$1,
    controlsList: spaceSeparated$1,
    coords: number$2 | commaSeparated$1,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean$1,
    defer: boolean$1,
    dir: null,
    dirName: null,
    disabled: boolean$1,
    download: overloadedBoolean$1,
    draggable: booleanish$1,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean$1,
    formTarget: null,
    headers: spaceSeparated$1,
    height: number$2,
    hidden: boolean$1,
    high: number$2,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated$1,
    httpEquiv: spaceSeparated$1,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean$1,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean$1,
    itemId: null,
    itemProp: spaceSeparated$1,
    itemRef: spaceSeparated$1,
    itemScope: boolean$1,
    itemType: spaceSeparated$1,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean$1,
    low: number$2,
    manifest: null,
    max: null,
    maxLength: number$2,
    media: null,
    method: null,
    min: null,
    minLength: number$2,
    multiple: boolean$1,
    muted: boolean$1,
    name: null,
    nonce: null,
    noModule: boolean$1,
    noValidate: boolean$1,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean$1,
    optimum: number$2,
    pattern: null,
    ping: spaceSeparated$1,
    placeholder: null,
    playsInline: boolean$1,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean$1,
    referrerPolicy: null,
    rel: spaceSeparated$1,
    required: boolean$1,
    reversed: boolean$1,
    rows: number$2,
    rowSpan: number$2,
    sandbox: spaceSeparated$1,
    scope: null,
    scoped: boolean$1,
    seamless: boolean$1,
    selected: boolean$1,
    shape: null,
    size: number$2,
    sizes: null,
    slot: null,
    span: number$2,
    spellCheck: booleanish$1,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number$2,
    step: null,
    style: null,
    tabIndex: number$2,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean$1,
    useMap: null,
    value: booleanish$1,
    width: number$2,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated$1,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number$2,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number$2,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean$1,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean$1,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number$2,
    // `<img>` and `<object>`
    leftMargin: number$2,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number$2,
    // `<body>`
    marginWidth: number$2,
    // `<body>`
    noResize: boolean$1,
    // `<frame>`
    noHref: boolean$1,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean$1,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean$1,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number$2,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish$1,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number$2,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number$2,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean$1,
    disableRemotePlayback: boolean$1,
    prefix: null,
    property: null,
    results: number$2,
    security: null,
    unselectable: null
  }
});
const svg$3 = create$3({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform$1,
  properties: {
    about: commaOrSpaceSeparated$1,
    accentHeight: number$2,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number$2,
    amplitude: number$2,
    arabicForm: null,
    ascent: number$2,
    attributeName: null,
    attributeType: null,
    azimuth: number$2,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number$2,
    by: null,
    calcMode: null,
    capHeight: number$2,
    className: spaceSeparated$1,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number$2,
    diffuseConstant: number$2,
    direction: null,
    display: null,
    dur: null,
    divisor: number$2,
    dominantBaseline: null,
    download: boolean$1,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number$2,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number$2,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number$2,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated$1,
    g2: commaSeparated$1,
    glyphName: commaSeparated$1,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number$2,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number$2,
    horizOriginX: number$2,
    horizOriginY: number$2,
    id: null,
    ideographic: number$2,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number$2,
    k: number$2,
    k1: number$2,
    k2: number$2,
    k3: number$2,
    k4: number$2,
    kernelMatrix: commaOrSpaceSeparated$1,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number$2,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number$2,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number$2,
    overlineThickness: number$2,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number$2,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated$1,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number$2,
    pointsAtY: number$2,
    pointsAtZ: number$2,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated$1,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated$1,
    rev: commaOrSpaceSeparated$1,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated$1,
    requiredFeatures: commaOrSpaceSeparated$1,
    requiredFonts: commaOrSpaceSeparated$1,
    requiredFormats: commaOrSpaceSeparated$1,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number$2,
    specularExponent: number$2,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number$2,
    strikethroughThickness: number$2,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated$1,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number$2,
    strokeOpacity: number$2,
    strokeWidth: null,
    style: null,
    surfaceScale: number$2,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated$1,
    tabIndex: number$2,
    tableValues: null,
    target: null,
    targetX: number$2,
    targetY: number$2,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated$1,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number$2,
    underlineThickness: number$2,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number$2,
    values: null,
    vAlphabetic: number$2,
    vMathematical: number$2,
    vectorEffect: null,
    vHanging: number$2,
    vIdeographic: number$2,
    version: null,
    vertAdvY: number$2,
    vertOriginX: number$2,
    vertOriginY: number$2,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number$2,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
const valid$1 = /^data[-\w.:]+$/i;
const dash$1 = /-[a-z]/g;
const cap$1 = /[A-Z]/g;
function find$2(schema, value) {
  const normal = normalize$2(value);
  let prop = value;
  let Type = Info$1;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid$1.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash$1, camelcase$1);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash$1.test(rest)) {
        let dashes = rest.replace(cap$1, kebab$1);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo$1;
  }
  return new Type(prop, value);
}
function kebab$1($02) {
  return "-" + $02.toLowerCase();
}
function camelcase$1($02) {
  return $02.charAt(1).toUpperCase();
}
const html$7 = merge$1([xml$2, xlink$1, xmlns$1, aria$2, html$8], "html");
const svg$2 = merge$1([xml$2, xlink$1, xmlns$1, aria$2, svg$3], "svg");
function parse$2(value) {
  const tokens = [];
  const input = String(value || "");
  let index2 = input.indexOf(",");
  let start = 0;
  let end = false;
  while (!end) {
    if (index2 === -1) {
      index2 = input.length;
      end = true;
    }
    const token = input.slice(start, index2).trim();
    if (token || !end) {
      tokens.push(token);
    }
    start = index2 + 1;
    index2 = input.indexOf(",", start);
  }
  return tokens;
}
function stringify$3(values, options) {
  const settings = options || {};
  const input = values[values.length - 1] === "" ? [...values, ""] : values;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
const search$1 = /[#.]/g;
function parseSelector(selector, defaultTagName) {
  const value = selector || "";
  const props = {};
  let start = 0;
  let previous2;
  let tagName;
  while (start < value.length) {
    search$1.lastIndex = start;
    const match = search$1.exec(value);
    const subvalue = value.slice(start, match ? match.index : value.length);
    if (subvalue) {
      if (!previous2) {
        tagName = subvalue;
      } else if (previous2 === "#") {
        props.id = subvalue;
      } else if (Array.isArray(props.className)) {
        props.className.push(subvalue);
      } else {
        props.className = [subvalue];
      }
      start += subvalue.length;
    }
    if (match) {
      previous2 = match[0];
      start++;
    }
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: tagName || defaultTagName || "div",
    properties: props,
    children: []
  };
}
function parse$1(value) {
  const input = String(value || "").trim();
  return input ? input.split(/[ \t\n\r\f]+/g) : [];
}
function stringify$2(values) {
  return values.join(" ").trim();
}
const buttonTypes = /* @__PURE__ */ new Set(["button", "menu", "reset", "submit"]);
const own$h = {}.hasOwnProperty;
function createH(schema, defaultTagName, caseSensitive) {
  const adjust = caseSensitive && createAdjustMap(caseSensitive);
  function h10(selector, properties2, ...children2) {
    let index2 = -1;
    let node2;
    if (selector === void 0 || selector === null) {
      node2 = { type: "root", children: [] };
      const child = (
        /** @type {Child} */
        properties2
      );
      children2.unshift(child);
    } else {
      node2 = parseSelector(selector, defaultTagName);
      node2.tagName = node2.tagName.toLowerCase();
      if (adjust && own$h.call(adjust, node2.tagName)) {
        node2.tagName = adjust[node2.tagName];
      }
      if (isProperties(properties2, node2.tagName)) {
        let key2;
        for (key2 in properties2) {
          if (own$h.call(properties2, key2)) {
            addProperty(schema, node2.properties, key2, properties2[key2]);
          }
        }
      } else {
        children2.unshift(properties2);
      }
    }
    while (++index2 < children2.length) {
      addChild(node2.children, children2[index2]);
    }
    if (node2.type === "element" && node2.tagName === "template") {
      node2.content = { type: "root", children: node2.children };
      node2.children = [];
    }
    return node2;
  }
  return h10;
}
function isProperties(value, name2) {
  if (value === null || value === void 0 || typeof value !== "object" || Array.isArray(value)) {
    return false;
  }
  if (name2 === "input" || !value.type || typeof value.type !== "string") {
    return true;
  }
  if ("children" in value && Array.isArray(value.children)) {
    return false;
  }
  if (name2 === "button") {
    return buttonTypes.has(value.type.toLowerCase());
  }
  return !("value" in value);
}
function addProperty(schema, properties2, key2, value) {
  const info = find$2(schema, key2);
  let index2 = -1;
  let result;
  if (value === void 0 || value === null)
    return;
  if (typeof value === "number") {
    if (Number.isNaN(value))
      return;
    result = value;
  } else if (typeof value === "boolean") {
    result = value;
  } else if (typeof value === "string") {
    if (info.spaceSeparated) {
      result = parse$1(value);
    } else if (info.commaSeparated) {
      result = parse$2(value);
    } else if (info.commaOrSpaceSeparated) {
      result = parse$1(parse$2(value).join(" "));
    } else {
      result = parsePrimitive(info, info.property, value);
    }
  } else if (Array.isArray(value)) {
    result = value.concat();
  } else {
    result = info.property === "style" ? style$1(value) : String(value);
  }
  if (Array.isArray(result)) {
    const finalResult = [];
    while (++index2 < result.length) {
      const value2 = (
        /** @type {number | string} */
        parsePrimitive(info, info.property, result[index2])
      );
      finalResult[index2] = value2;
    }
    result = finalResult;
  }
  if (info.property === "className" && Array.isArray(properties2.className)) {
    const value2 = (
      /** @type {number | string} */
      result
    );
    result = properties2.className.concat(value2);
  }
  properties2[info.property] = result;
}
function addChild(nodes, value) {
  let index2 = -1;
  if (value === void 0 || value === null)
    ;
  else if (typeof value === "string" || typeof value === "number") {
    nodes.push({ type: "text", value: String(value) });
  } else if (Array.isArray(value)) {
    while (++index2 < value.length) {
      addChild(nodes, value[index2]);
    }
  } else if (typeof value === "object" && "type" in value) {
    if (value.type === "root") {
      addChild(nodes, value.children);
    } else {
      nodes.push(value);
    }
  } else {
    throw new Error("Expected node, nodes, or string, got `" + value + "`");
  }
}
function parsePrimitive(info, name2, value) {
  if (typeof value === "string") {
    if (info.number && value && !Number.isNaN(Number(value))) {
      return Number(value);
    }
    if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize$2(value) === normalize$2(name2))) {
      return true;
    }
  }
  return value;
}
function style$1(value) {
  const result = [];
  let key2;
  for (key2 in value) {
    if (own$h.call(value, key2)) {
      result.push([key2, value[key2]].join(": "));
    }
  }
  return result.join("; ");
}
function createAdjustMap(values) {
  const result = {};
  let index2 = -1;
  while (++index2 < values.length) {
    result[values[index2].toLowerCase()] = values[index2];
  }
  return result;
}
const svgCaseSensitiveTagNames = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
];
const h$2 = createH(html$7, "div");
createH(svg$2, "g", svgCaseSensitiveTagNames);
const emptyOptions$b = {};
function rehypeDocument(options) {
  const settings = options || emptyOptions$b;
  const css2 = toList(settings.css);
  const dir = settings.dir;
  const js = toList(settings.js);
  const language2 = settings.language || "en";
  const link2 = toList(settings.link);
  let meta2 = toList(settings.meta);
  const script = toList(settings.script);
  const style2 = toList(settings.style);
  const title = settings.title;
  if (settings.responsive !== false) {
    meta2 = [
      { content: "width=device-width, initial-scale=1", name: "viewport" },
      ...meta2
    ];
  }
  return function(tree, file) {
    var _a2, _b2;
    const titleText = ((_a2 = file.data.meta) == null ? void 0 : _a2.title) || ((_b2 = file.data.matter) == null ? void 0 : _b2.title) || title || file.stem;
    const contents = tree.type === "root" ? [...tree.children] : [tree];
    const head2 = [{ type: "text", value: "\n" }, h$2("meta", { charSet: "utf-8" })];
    let index2 = -1;
    if (contents.length > 0) {
      contents.unshift({ type: "text", value: "\n" });
    }
    if (titleText) {
      head2.push({ type: "text", value: "\n" }, h$2("title", titleText));
    }
    while (++index2 < meta2.length) {
      head2.push({ type: "text", value: "\n" }, h$2("meta", meta2[index2]));
    }
    index2 = -1;
    while (++index2 < link2.length) {
      head2.push({ type: "text", value: "\n" }, h$2("link", link2[index2]));
    }
    index2 = -1;
    while (++index2 < style2.length) {
      head2.push({ type: "text", value: "\n" }, h$2("style", style2[index2]));
    }
    index2 = -1;
    while (++index2 < css2.length) {
      head2.push(
        { type: "text", value: "\n" },
        h$2("link", { href: css2[index2], rel: "stylesheet" })
      );
    }
    head2.push({ type: "text", value: "\n" });
    index2 = -1;
    while (++index2 < script.length) {
      contents.push({ type: "text", value: "\n" }, h$2("script", script[index2]));
    }
    index2 = -1;
    while (++index2 < js.length) {
      contents.push({ type: "text", value: "\n" }, h$2("script", { src: js[index2] }));
    }
    contents.push({ type: "text", value: "\n" });
    return {
      type: "root",
      children: [
        { type: "doctype" },
        { type: "text", value: "\n" },
        h$2("html", { dir, lang: language2 }, [
          { type: "text", value: "\n" },
          h$2("head", head2),
          { type: "text", value: "\n" },
          h$2("body", contents),
          { type: "text", value: "\n" }
        ]),
        { type: "text", value: "\n" }
      ]
    };
  };
}
function toList(value) {
  return value === null || value === void 0 ? [] : Array.isArray(value) ? value : [value];
}
const VOID = -1;
const PRIMITIVE = 0;
const ARRAY = 1;
const OBJECT = 2;
const DATE = 3;
const REGEXP = 4;
const MAP = 5;
const SET$1 = 6;
const ERROR = 7;
const BIGINT = 8;
const env = typeof self === "object" ? self : globalThis;
const deserializer = ($10, _10) => {
  const as2 = (out, index2) => {
    $10.set(index2, out);
    return out;
  };
  const unpair = (index2) => {
    if ($10.has(index2))
      return $10.get(index2);
    const [type, value] = _10[index2];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as2(value, index2);
      case ARRAY: {
        const arr = as2([], index2);
        for (const index3 of value)
          arr.push(unpair(index3));
        return arr;
      }
      case OBJECT: {
        const object = as2({}, index2);
        for (const [key2, index3] of value)
          object[unpair(key2)] = unpair(index3);
        return object;
      }
      case DATE:
        return as2(new Date(value), index2);
      case REGEXP: {
        const { source: source2, flags } = value;
        return as2(new RegExp(source2, flags), index2);
      }
      case MAP: {
        const map2 = as2(/* @__PURE__ */ new Map(), index2);
        for (const [key2, index3] of value)
          map2.set(unpair(key2), unpair(index3));
        return map2;
      }
      case SET$1: {
        const set = as2(/* @__PURE__ */ new Set(), index2);
        for (const index3 of value)
          set.add(unpair(index3));
        return set;
      }
      case ERROR: {
        const { name: name2, message } = value;
        return as2(new env[name2](message), index2);
      }
      case BIGINT:
        return as2(BigInt(value), index2);
      case "BigInt":
        return as2(Object(BigInt(value)), index2);
    }
    return as2(new env[type](value), index2);
  };
  return unpair;
};
const deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
const EMPTY = "";
const { toString: toString$5 } = {};
const { keys } = Object;
const typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString$5.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET$1, EMPTY];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
const shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
const serializer = (strict, json2, $10, _10) => {
  const as2 = (out, value) => {
    const index2 = _10.push(out) - 1;
    $10.set(value, index2);
    return index2;
  };
  const pair = (value) => {
    if ($10.has(value))
      return $10.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as2([VOID], value);
        }
        return as2([TYPE, entry], value);
      }
      case ARRAY: {
        if (type)
          return as2([type, [...value]], value);
        const arr = [];
        const index2 = as2([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index2;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as2([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as2([type, value.valueOf()], value);
          }
        }
        if (json2 && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index2 = as2([TYPE, entries], value);
        for (const key2 of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key2])))
            entries.push([pair(key2), pair(value[key2])]);
        }
        return index2;
      }
      case DATE:
        return as2([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source: source2, flags } = value;
        return as2([TYPE, { source: source2, flags }], value);
      }
      case MAP: {
        const entries = [];
        const index2 = as2([TYPE, entries], value);
        for (const [key2, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key2)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key2), pair(entry)]);
        }
        return index2;
      }
      case SET$1: {
        const entries = [];
        const index2 = as2([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index2;
      }
    }
    const { message } = value;
    return as2([TYPE, { name: type, message }], value);
  };
  return pair;
};
const serialize$1 = (value, { json: json2, lossy } = {}) => {
  const _10 = [];
  return serializer(!(json2 || lossy), !!json2, /* @__PURE__ */ new Map(), _10)(value), _10;
};
const structuredClone$1 = typeof structuredClone === "function" ? (
  /* c8 ignore start */
  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize$1(any, options)) : structuredClone(any)
) : (any, options) => deserialize(serialize$1(any, options));
const isElement$1 = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((element?: null | undefined) => false) &
   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)
   * )}
   */
  /**
   * @param {unknown} [element]
   * @param {Test | undefined} [test]
   * @param {number | null | undefined} [index]
   * @param {Parents | null | undefined} [parent]
   * @param {unknown} [context]
   * @returns {boolean}
   */
  // eslint-disable-next-line max-params
  function(element2, test, index2, parent, context) {
    const check = convertElement$1(test);
    if (index2 !== null && index2 !== void 0 && (typeof index2 !== "number" || index2 < 0 || index2 === Number.POSITIVE_INFINITY)) {
      throw new Error("Expected positive finite `index`");
    }
    if (parent !== null && parent !== void 0 && (!parent.type || !parent.children)) {
      throw new Error("Expected valid `parent`");
    }
    if ((index2 === null || index2 === void 0) !== (parent === null || parent === void 0)) {
      throw new Error("Expected both `index` and `parent`");
    }
    return looksLikeAnElement$1(element2) ? check.call(context, element2, index2, parent) : false;
  }
);
const convertElement$1 = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return element$4;
    }
    if (typeof test === "string") {
      return tagNameFactory$1(test);
    }
    if (typeof test === "object") {
      return anyFactory$4(test);
    }
    if (typeof test === "function") {
      return castFactory$4(test);
    }
    throw new Error("Expected function, string, or array as `test`");
  }
);
function anyFactory$4(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convertElement$1(tests[index2]);
  }
  return castFactory$4(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function tagNameFactory$1(check) {
  return castFactory$4(tagName);
  function tagName(element2) {
    return element2.tagName === check;
  }
}
function castFactory$4(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeAnElement$1(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function element$4(element2) {
  return Boolean(
    element2 && typeof element2 === "object" && "type" in element2 && element2.type === "element" && "tagName" in element2 && typeof element2.tagName === "string"
  );
}
function looksLikeAnElement$1(value) {
  return value !== null && typeof value === "object" && "type" in value && "tagName" in value;
}
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const WINDOWS_PATH_REGEX = /^[a-zA-Z]:\\/;
function isAbsoluteUrl(url) {
  if (typeof url !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof url}\``);
  }
  if (WINDOWS_PATH_REGEX.test(url)) {
    return false;
  }
  return ABSOLUTE_URL_REGEX.test(url);
}
const convert$2 = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok$4;
    }
    if (typeof test === "function") {
      return castFactory$3(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory$3(test) : propsFactory$2(test);
    }
    if (typeof test === "string") {
      return typeFactory$2(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory$3(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert$2(tests[index2]);
  }
  return castFactory$3(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory$2(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory$3(all2);
  function all2(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key2;
    for (key2 in check) {
      if (nodeAsRecord[key2] !== checkAsRecord[key2])
        return false;
    }
    return true;
  }
}
function typeFactory$2(check) {
  return castFactory$3(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory$3(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode$1(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok$4() {
  return true;
}
function looksLikeANode$1(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
function color$1(d3) {
  return "\x1B[33m" + d3 + "\x1B[39m";
}
const empty$2 = [];
const CONTINUE$1 = true;
const EXIT$1 = false;
const SKIP$1 = "skip";
function visitParents$1(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is2 = convert$2(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color$1(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty$2;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is2(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult$1(visitor(node2, parents));
        if (result[0] === EXIT$1) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP$1) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT$1) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult$1(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE$1, value];
  }
  return value === null || value === void 0 ? empty$2 : [value];
}
function visit$1(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents$1(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}
const defaultProtocols = ["http", "https"];
const defaultRel = ["nofollow"];
const emptyOptions$a = {};
function rehypeExternalLinks(options) {
  const settings = options || emptyOptions$a;
  const protocols = settings.protocols || defaultProtocols;
  const is2 = convertElement$1(settings.test);
  return function(tree) {
    visit$1(tree, "element", function(node2, index2, parent) {
      if (node2.tagName === "a" && typeof node2.properties.href === "string" && is2(node2, index2, parent)) {
        const url = node2.properties.href;
        if (isAbsoluteUrl(url) ? protocols.includes(url.slice(0, url.indexOf(":"))) : url.startsWith("//")) {
          const contentRaw = createIfNeeded(settings.content, node2);
          const content2 = contentRaw && !Array.isArray(contentRaw) ? [contentRaw] : contentRaw;
          const relRaw = createIfNeeded(settings.rel, node2) || defaultRel;
          const rel = typeof relRaw === "string" ? parse$1(relRaw) : relRaw;
          const target = createIfNeeded(settings.target, node2);
          const properties2 = createIfNeeded(settings.properties, node2);
          if (properties2) {
            Object.assign(node2.properties, structuredClone$1(properties2));
          }
          if (rel.length > 0) {
            node2.properties.rel = [...rel];
          }
          if (target) {
            node2.properties.target = target;
          }
          if (content2) {
            const properties3 = createIfNeeded(settings.contentProperties, node2) || {};
            node2.children.push({
              type: "element",
              tagName: "span",
              properties: structuredClone$1(properties3),
              children: structuredClone$1(content2)
            });
          }
        }
      }
    });
  };
}
function createIfNeeded(value, element2) {
  return typeof value === "function" ? value(element2) : value;
}
const embedded$1 = convertElement$1(
  /**
   * @param element
   * @returns {element is {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}}
   */
  function(element2) {
    return element2.tagName === "audio" || element2.tagName === "canvas" || element2.tagName === "embed" || element2.tagName === "iframe" || element2.tagName === "img" || element2.tagName === "math" || element2.tagName === "object" || element2.tagName === "picture" || element2.tagName === "svg" || element2.tagName === "video";
  }
);
const own$g = {}.hasOwnProperty;
function hasProperty$1(node2, name2) {
  const value = node2.type === "element" && own$g.call(node2.properties, name2) && node2.properties[name2];
  return value !== null && value !== void 0 && value !== false;
}
const list$4 = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
function isBodyOkLink(node2) {
  if (node2.type !== "element" || node2.tagName !== "link") {
    return false;
  }
  if (node2.properties.itemProp) {
    return true;
  }
  const rel = node2.properties.rel;
  let index2 = -1;
  if (!Array.isArray(rel) || rel.length === 0) {
    return false;
  }
  while (++index2 < rel.length) {
    if (!list$4.has(String(rel[index2]))) {
      return false;
    }
  }
  return true;
}
const basic = convertElement$1([
  "a",
  "abbr",
  // `area` is in fact only phrasing if it is inside a `map` element.
  // However, since `area`s are required to be inside a `map` element, and it’s
  // a rather involved check, it’s ignored here for now.
  "area",
  "b",
  "bdi",
  "bdo",
  "br",
  "button",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "i",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "map",
  "mark",
  "meter",
  "noscript",
  "output",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "template",
  "textarea",
  "time",
  "u",
  "var",
  "wbr"
]);
const meta$1 = convertElement$1("meta");
function phrasing$1(value) {
  return Boolean(
    value.type === "text" || basic(value) || embedded$1(value) || isBodyOkLink(value) || meta$1(value) && hasProperty$1(value, "itemProp")
  );
}
const re$1 = /[ \t\n\f\r]/g;
function whitespace$1(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty$1(thing.value) : false : empty$1(thing);
}
function empty$1(value) {
  return value.replace(re$1, "") === "";
}
const whitespaceSensitiveTagNames = [
  "pre",
  "script",
  "style",
  "textarea"
];
const blocks$1 = [
  "address",
  // Flow content.
  "article",
  // Sections and headings.
  "aside",
  // Sections and headings.
  "blockquote",
  // Flow content.
  "body",
  // Page.
  "br",
  // Contribute whitespace intrinsically.
  "caption",
  // Similar to block.
  "center",
  // Flow content, legacy.
  "col",
  // Similar to block.
  "colgroup",
  // Similar to block.
  "dd",
  // Lists.
  "dialog",
  // Flow content.
  "dir",
  // Lists, legacy.
  "div",
  // Flow content.
  "dl",
  // Lists.
  "dt",
  // Lists.
  "figcaption",
  // Flow content.
  "figure",
  // Flow content.
  "footer",
  // Flow content.
  "form",
  // Flow content.
  "h1",
  // Sections and headings.
  "h2",
  // Sections and headings.
  "h3",
  // Sections and headings.
  "h4",
  // Sections and headings.
  "h5",
  // Sections and headings.
  "h6",
  // Sections and headings.
  "head",
  // Page.
  "header",
  // Flow content.
  "hgroup",
  // Sections and headings.
  "hr",
  // Flow content.
  "html",
  // Page.
  "legend",
  // Flow content.
  "li",
  // Block-like.
  "li",
  // Similar to block.
  "listing",
  // Flow content, legacy
  "main",
  // Flow content.
  "menu",
  // Lists.
  "nav",
  // Sections and headings.
  "ol",
  // Lists.
  "optgroup",
  // Similar to block.
  "option",
  // Similar to block.
  "p",
  // Flow content.
  "plaintext",
  // Flow content, legacy
  "pre",
  // Flow content.
  "section",
  // Sections and headings.
  "summary",
  // Similar to block.
  "table",
  // Similar to block.
  "tbody",
  // Similar to block.
  "td",
  // Block-like.
  "td",
  // Similar to block.
  "tfoot",
  // Similar to block.
  "th",
  // Block-like.
  "th",
  // Similar to block.
  "thead",
  // Similar to block.
  "tr",
  // Similar to block.
  "ul",
  // Lists.
  "wbr",
  // Contribute whitespace intrinsically.
  "xmp"
  // Flow content, legacy
];
const content$6 = [
  // Form.
  "button",
  "input",
  "select",
  "textarea"
];
const skippable$3 = [
  "area",
  "base",
  "basefont",
  "dialog",
  "datalist",
  "head",
  "link",
  "meta",
  "noembed",
  "noframes",
  "param",
  "rp",
  "script",
  "source",
  "style",
  "template",
  "track",
  "title"
];
const emptyOptions$9 = {};
const ignorableNode$1 = convert$2(["doctype", "comment"]);
function rehypeMinifyWhitespace$1(options) {
  const settings = options || emptyOptions$9;
  const collapse = collapseFactory$1(
    settings.newlines ? replaceNewlines$1 : replaceWhitespace$1
  );
  return function(tree) {
    minify$1(tree, { collapse, whitespace: "normal" });
  };
}
function minify$1(node2, state) {
  if ("children" in node2) {
    const settings = { ...state };
    if (node2.type === "root" || blocklike$1(node2)) {
      settings.before = true;
      settings.after = true;
    }
    settings.whitespace = inferWhiteSpace$1(node2, state);
    return all$5(node2, settings);
  }
  if (node2.type === "text") {
    if (state.whitespace === "normal") {
      return minifyText$1(node2, state);
    }
    if (state.whitespace === "nowrap") {
      node2.value = state.collapse(node2.value);
    }
  }
  return { ignore: ignorableNode$1(node2), stripAtStart: false, remove: false };
}
function minifyText$1(node2, state) {
  const value = state.collapse(node2.value);
  const result = { ignore: false, stripAtStart: false, remove: false };
  let start = 0;
  let end = value.length;
  if (state.before && removable$1(value.charAt(0))) {
    start++;
  }
  if (start !== end && removable$1(value.charAt(end - 1))) {
    if (state.after) {
      end--;
    } else {
      result.stripAtStart = true;
    }
  }
  if (start === end) {
    result.remove = true;
  } else {
    node2.value = value.slice(start, end);
  }
  return result;
}
function all$5(parent, state) {
  let before = state.before;
  const after = state.after;
  const children2 = parent.children;
  let length = children2.length;
  let index2 = -1;
  while (++index2 < length) {
    const result = minify$1(children2[index2], {
      ...state,
      after: collapsableAfter$1(children2, index2, after),
      before
    });
    if (result.remove) {
      children2.splice(index2, 1);
      index2--;
      length--;
    } else if (!result.ignore) {
      before = result.stripAtStart;
    }
    if (content$5(children2[index2])) {
      before = false;
    }
  }
  return { ignore: false, stripAtStart: Boolean(before || after), remove: false };
}
function collapsableAfter$1(nodes, index2, after) {
  while (++index2 < nodes.length) {
    const node2 = nodes[index2];
    let result = inferBoundary$1(node2);
    if (result === void 0 && "children" in node2 && !skippable$2(node2)) {
      result = collapsableAfter$1(node2.children, -1);
    }
    if (typeof result === "boolean") {
      return result;
    }
  }
  return after;
}
function inferBoundary$1(node2) {
  if (node2.type === "element") {
    if (content$5(node2)) {
      return false;
    }
    if (blocklike$1(node2)) {
      return true;
    }
  } else if (node2.type === "text") {
    if (!whitespace$1(node2)) {
      return false;
    }
  } else if (!ignorableNode$1(node2)) {
    return false;
  }
}
function content$5(node2) {
  return embedded$1(node2) || isElement$1(node2, content$6);
}
function blocklike$1(node2) {
  return isElement$1(node2, blocks$1);
}
function skippable$2(node2) {
  return Boolean(node2.type === "element" && node2.properties.hidden) || ignorableNode$1(node2) || isElement$1(node2, skippable$3);
}
function removable$1(character) {
  return character === " " || character === "\n";
}
function replaceNewlines$1(value) {
  const match = /\r?\n|\r/.exec(value);
  return match ? match[0] : " ";
}
function replaceWhitespace$1() {
  return " ";
}
function collapseFactory$1(replace2) {
  return collapse;
  function collapse(value) {
    return String(value).replace(/[\t\n\v\f\r ]+/g, replace2);
  }
}
function inferWhiteSpace$1(node2, state) {
  if ("tagName" in node2 && node2.properties) {
    switch (node2.tagName) {
      case "listing":
      case "plaintext":
      case "script":
      case "style":
      case "xmp": {
        return "pre";
      }
      case "nobr": {
        return "nowrap";
      }
      case "pre": {
        return node2.properties.wrap ? "pre-wrap" : "pre";
      }
      case "td":
      case "th": {
        return node2.properties.noWrap ? "nowrap" : state.whitespace;
      }
      case "textarea": {
        return "pre-wrap";
      }
    }
  }
  return state.whitespace;
}
const emptyOptions$8 = {};
const transformWhitespace = rehypeMinifyWhitespace$1({ newlines: true });
function rehypeFormat(options) {
  const settings = options || emptyOptions$8;
  let indent2 = settings.indent || 2;
  let indentInitial = settings.indentInitial;
  if (typeof indent2 === "number") {
    indent2 = " ".repeat(indent2);
  }
  if (indentInitial === null || indentInitial === void 0) {
    indentInitial = true;
  }
  return function(tree) {
    let head2;
    transformWhitespace(tree);
    visitParents$1(tree, function(node2, parents) {
      let index2 = -1;
      if (!("children" in node2)) {
        return;
      }
      if (isElement$1(node2, "head")) {
        head2 = true;
      }
      if (head2 && isElement$1(node2, "body")) {
        head2 = void 0;
      }
      if (isElement$1(node2, whitespaceSensitiveTagNames)) {
        return SKIP$1;
      }
      const children2 = node2.children;
      let level = parents.length;
      if (children2.length === 0 || !padding(node2, head2)) {
        return;
      }
      if (!indentInitial) {
        level--;
      }
      let eol2;
      while (++index2 < children2.length) {
        const child = children2[index2];
        if (child.type === "text" || child.type === "comment") {
          if (child.value.includes("\n")) {
            eol2 = true;
          }
          child.value = child.value.replace(
            / *\n/g,
            "$&" + String(indent2).repeat(level)
          );
        }
      }
      const result = [];
      let previous2;
      index2 = -1;
      while (++index2 < children2.length) {
        const child = children2[index2];
        if (padding(child, head2) || eol2 && !index2) {
          addBreak(result, level, child);
          eol2 = true;
        }
        previous2 = child;
        result.push(child);
      }
      if (previous2 && (eol2 || padding(previous2, head2))) {
        if (whitespace$1(previous2)) {
          result.pop();
          previous2 = result[result.length - 1];
        }
        addBreak(result, level - 1);
      }
      node2.children = result;
    });
  };
  function addBreak(list2, level, next) {
    const tail = list2[list2.length - 1];
    const previous2 = tail && whitespace$1(tail) ? list2[list2.length - 2] : tail;
    const replace2 = (blank(previous2) && blank(next) ? "\n\n" : "\n") + String(indent2).repeat(Math.max(level, 0));
    if (tail && tail.type === "text") {
      tail.value = whitespace$1(tail) ? replace2 : tail.value + replace2;
    } else {
      list2.push({ type: "text", value: replace2 });
    }
  }
  function blank(node2) {
    return Boolean(
      node2 && node2.type === "element" && settings.blanks && settings.blanks.length > 0 && settings.blanks.includes(node2.tagName)
    );
  }
}
function padding(node2, head2) {
  return node2.type === "root" || (node2.type === "element" ? head2 || isElement$1(node2, "script") || embedded$1(node2) || !phrasing$1(node2) : false);
}
const findAfter = (
  // Note: overloads like this are needed to support optional generics.
  /**
   * @type {(
   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &
   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)
   * )}
   */
  /**
   * @param {UnistParent} parent
   * @param {UnistNode | number} index
   * @param {Test} [test]
   * @returns {UnistNode | undefined}
   */
  function(parent, index2, test) {
    const is2 = convert$2(test);
    if (!parent || !parent.type || !parent.children) {
      throw new Error("Expected parent node");
    }
    if (typeof index2 === "number") {
      if (index2 < 0 || index2 === Number.POSITIVE_INFINITY) {
        throw new Error("Expected positive finite number as index");
      }
    } else {
      index2 = parent.children.indexOf(index2);
      if (index2 < 0) {
        throw new Error("Expected child node or index");
      }
    }
    while (++index2 < parent.children.length) {
      if (is2(parent.children[index2], index2, parent)) {
        return parent.children[index2];
      }
    }
    return void 0;
  }
);
const searchLineFeeds = /\n/g;
const searchTabOrSpaces = /[\t ]+/g;
const br$1 = convertElement$1("br");
const cell = convertElement$1(isCell$1);
const p$7 = convertElement$1("p");
const row = convertElement$1("tr");
const notRendered = convertElement$1([
  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  hidden$1,
  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
  closedDialog$1
]);
const blockOrCaption = convertElement$1([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function toText(tree, options = {}) {
  const children2 = "children" in tree ? tree.children : [];
  const block = blockOrCaption(tree);
  const whitespace2 = inferWhitespace(tree, {
    whitespace: options.whitespace || "normal",
    breakBefore: false,
    breakAfter: false
  });
  const results = [];
  if (tree.type === "text" || tree.type === "comment") {
    results.push(
      ...collectText(tree, {
        whitespace: whitespace2,
        breakBefore: true,
        breakAfter: true
      })
    );
  }
  let index2 = -1;
  while (++index2 < children2.length) {
    results.push(
      ...renderedTextCollection(
        children2[index2],
        // @ts-expect-error: `tree` is a parent if we’re here.
        tree,
        {
          whitespace: whitespace2,
          breakBefore: index2 ? void 0 : block,
          breakAfter: index2 < children2.length - 1 ? br$1(children2[index2 + 1]) : block
        }
      )
    );
  }
  const result = [];
  let count;
  index2 = -1;
  while (++index2 < results.length) {
    const value = results[index2];
    if (typeof value === "number") {
      if (count !== void 0 && value > count)
        count = value;
    } else if (value) {
      if (count !== void 0 && count > -1) {
        result.push("\n".repeat(count) || " ");
      }
      count = -1;
      result.push(value);
    }
  }
  return result.join("");
}
function renderedTextCollection(node2, parent, info) {
  if (node2.type === "element") {
    return collectElement(node2, parent, info);
  }
  if (node2.type === "text") {
    return info.whitespace === "normal" ? collectText(node2, info) : collectPreText(node2);
  }
  return [];
}
function collectElement(node2, parent, info) {
  const whitespace2 = inferWhitespace(node2, info);
  const children2 = node2.children || [];
  let index2 = -1;
  let items = [];
  if (notRendered(node2)) {
    return items;
  }
  let prefix;
  let suffix;
  if (br$1(node2)) {
    suffix = "\n";
  } else if (row(node2) && // @ts-expect-error: something up with types of parents.
  findAfter(parent, node2, row)) {
    suffix = "\n";
  } else if (p$7(node2)) {
    prefix = 2;
    suffix = 2;
  } else if (blockOrCaption(node2)) {
    prefix = 1;
    suffix = 1;
  }
  while (++index2 < children2.length) {
    items = items.concat(
      renderedTextCollection(children2[index2], node2, {
        whitespace: whitespace2,
        breakBefore: index2 ? void 0 : prefix,
        breakAfter: index2 < children2.length - 1 ? br$1(children2[index2 + 1]) : suffix
      })
    );
  }
  if (cell(node2) && // @ts-expect-error: something up with types of parents.
  findAfter(parent, node2, cell)) {
    items.push("	");
  }
  if (prefix)
    items.unshift(prefix);
  if (suffix)
    items.push(suffix);
  return items;
}
function collectText(node2, info) {
  const value = String(node2.value);
  const lines = [];
  const result = [];
  let start = 0;
  while (start <= value.length) {
    searchLineFeeds.lastIndex = start;
    const match = searchLineFeeds.exec(value);
    const end = match && "index" in match ? match.index : value.length;
    lines.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      trimAndCollapseSpacesAndTabs(
        // […] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        value.slice(start, end).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
        start === 0 ? info.breakBefore : true,
        end === value.length ? info.breakAfter : true
      )
    );
    start = end + 1;
  }
  let index2 = -1;
  let join2;
  while (++index2 < lines.length) {
    if (lines[index2].charCodeAt(lines[index2].length - 1) === 8203 || index2 < lines.length - 1 && lines[index2 + 1].charCodeAt(0) === 8203) {
      result.push(lines[index2]);
      join2 = void 0;
    } else if (lines[index2]) {
      if (typeof join2 === "number")
        result.push(join2);
      result.push(lines[index2]);
      join2 = 0;
    } else if (index2 === 0 || index2 === lines.length - 1) {
      result.push(0);
    }
  }
  return result;
}
function collectPreText(node2) {
  return [String(node2.value)];
}
function trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {
  const result = [];
  let start = 0;
  let end;
  while (start < value.length) {
    searchTabOrSpaces.lastIndex = start;
    const match = searchTabOrSpaces.exec(value);
    end = match ? match.index : value.length;
    if (!start && !end && match && !breakBefore) {
      result.push("");
    }
    if (start !== end) {
      result.push(value.slice(start, end));
    }
    start = match ? end + match[0].length : end;
  }
  if (start !== end && !breakAfter) {
    result.push("");
  }
  return result.join(" ");
}
function inferWhitespace(node2, info) {
  if (node2.type === "element") {
    const props = node2.properties || {};
    switch (node2.tagName) {
      case "listing":
      case "plaintext":
      case "xmp": {
        return "pre";
      }
      case "nobr": {
        return "nowrap";
      }
      case "pre": {
        return props.wrap ? "pre-wrap" : "pre";
      }
      case "td":
      case "th": {
        return props.noWrap ? "nowrap" : info.whitespace;
      }
      case "textarea": {
        return "pre-wrap";
      }
    }
  }
  return info.whitespace;
}
function hidden$1(node2) {
  return Boolean((node2.properties || {}).hidden);
}
function isCell$1(node2) {
  return node2.tagName === "td" || node2.tagName === "th";
}
function closedDialog$1(node2) {
  return node2.tagName === "dialog" && !(node2.properties || {}).open;
}
function cPlusPlus(hljs) {
  const regex2 = hljs.regex;
  const C_LINE_COMMENT_MODE2 = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] });
  const DECLTYPE_AUTO_RE = "decltype\\(auto\\)";
  const NAMESPACE_RE = "[a-zA-Z_]\\w*::";
  const TEMPLATE_ARGUMENT_RE = "<[^<>]+>";
  const FUNCTION_TYPE_RE = "(?!struct)(" + DECLTYPE_AUTO_RE + "|" + regex2.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex2.optional(TEMPLATE_ARGUMENT_RE) + ")";
  const CPP_PRIMITIVE_TYPES = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  };
  const CHARACTER_ESCAPES = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)";
  const STRINGS = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [hljs.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + CHARACTER_ESCAPES + "|.)",
        end: "'",
        illegal: "."
      },
      hljs.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  };
  const NUMBERS = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  };
  const PREPROCESSOR = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      hljs.inherit(STRINGS, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      C_LINE_COMMENT_MODE2,
      hljs.C_BLOCK_COMMENT_MODE
    ]
  };
  const TITLE_MODE2 = {
    className: "title",
    begin: regex2.optional(NAMESPACE_RE) + hljs.IDENT_RE,
    relevance: 0
  };
  const FUNCTION_TITLE = regex2.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(";
  const RESERVED_KEYWORDS = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ];
  const RESERVED_TYPES = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ];
  const TYPE_HINTS = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ];
  const FUNCTION_HINTS = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ];
  const LITERALS2 = [
    "NULL",
    "false",
    "nullopt",
    "nullptr",
    "true"
  ];
  const BUILT_IN = ["_Pragma"];
  const CPP_KEYWORDS = {
    type: RESERVED_TYPES,
    keyword: RESERVED_KEYWORDS,
    literal: LITERALS2,
    built_in: BUILT_IN,
    _type_hints: TYPE_HINTS
  };
  const FUNCTION_DISPATCH = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: FUNCTION_HINTS
    },
    begin: regex2.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      hljs.IDENT_RE,
      regex2.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  };
  const EXPRESSION_CONTAINS = [
    FUNCTION_DISPATCH,
    PREPROCESSOR,
    CPP_PRIMITIVE_TYPES,
    C_LINE_COMMENT_MODE2,
    hljs.C_BLOCK_COMMENT_MODE,
    NUMBERS,
    STRINGS
  ];
  const EXPRESSION_CONTEXT = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: CPP_KEYWORDS,
    contains: EXPRESSION_CONTAINS.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: CPP_KEYWORDS,
        contains: EXPRESSION_CONTAINS.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  };
  const FUNCTION_DECLARATION = {
    className: "function",
    begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE,
    returnBegin: true,
    end: /[{;=]/,
    excludeEnd: true,
    keywords: CPP_KEYWORDS,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: DECLTYPE_AUTO_RE,
        keywords: CPP_KEYWORDS,
        relevance: 0
      },
      {
        begin: FUNCTION_TITLE,
        returnBegin: true,
        contains: [TITLE_MODE2],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: true,
        contains: [
          STRINGS,
          NUMBERS
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: CPP_KEYWORDS,
        relevance: 0,
        contains: [
          C_LINE_COMMENT_MODE2,
          hljs.C_BLOCK_COMMENT_MODE,
          STRINGS,
          NUMBERS,
          CPP_PRIMITIVE_TYPES,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: CPP_KEYWORDS,
            relevance: 0,
            contains: [
              "self",
              C_LINE_COMMENT_MODE2,
              hljs.C_BLOCK_COMMENT_MODE,
              STRINGS,
              NUMBERS,
              CPP_PRIMITIVE_TYPES
            ]
          }
        ]
      },
      CPP_PRIMITIVE_TYPES,
      C_LINE_COMMENT_MODE2,
      hljs.C_BLOCK_COMMENT_MODE,
      PREPROCESSOR
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: CPP_KEYWORDS,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      EXPRESSION_CONTEXT,
      FUNCTION_DECLARATION,
      FUNCTION_DISPATCH,
      EXPRESSION_CONTAINS,
      [
        PREPROCESSOR,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
          end: ">",
          keywords: CPP_KEYWORDS,
          contains: [
            "self",
            CPP_PRIMITIVE_TYPES
          ]
        },
        {
          begin: hljs.IDENT_RE + "::",
          keywords: CPP_KEYWORDS
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function arduino(hljs) {
  const ARDUINO_KW = {
    type: [
      "boolean",
      "byte",
      "word",
      "String"
    ],
    built_in: [
      "KeyboardController",
      "MouseController",
      "SoftwareSerial",
      "EthernetServer",
      "EthernetClient",
      "LiquidCrystal",
      "RobotControl",
      "GSMVoiceCall",
      "EthernetUDP",
      "EsploraTFT",
      "HttpClient",
      "RobotMotor",
      "WiFiClient",
      "GSMScanner",
      "FileSystem",
      "Scheduler",
      "GSMServer",
      "YunClient",
      "YunServer",
      "IPAddress",
      "GSMClient",
      "GSMModem",
      "Keyboard",
      "Ethernet",
      "Console",
      "GSMBand",
      "Esplora",
      "Stepper",
      "Process",
      "WiFiUDP",
      "GSM_SMS",
      "Mailbox",
      "USBHost",
      "Firmata",
      "PImage",
      "Client",
      "Server",
      "GSMPIN",
      "FileIO",
      "Bridge",
      "Serial",
      "EEPROM",
      "Stream",
      "Mouse",
      "Audio",
      "Servo",
      "File",
      "Task",
      "GPRS",
      "WiFi",
      "Wire",
      "TFT",
      "GSM",
      "SPI",
      "SD"
    ],
    _hints: [
      "setup",
      "loop",
      "runShellCommandAsynchronously",
      "analogWriteResolution",
      "retrieveCallingNumber",
      "printFirmwareVersion",
      "analogReadResolution",
      "sendDigitalPortPair",
      "noListenOnLocalhost",
      "readJoystickButton",
      "setFirmwareVersion",
      "readJoystickSwitch",
      "scrollDisplayRight",
      "getVoiceCallStatus",
      "scrollDisplayLeft",
      "writeMicroseconds",
      "delayMicroseconds",
      "beginTransmission",
      "getSignalStrength",
      "runAsynchronously",
      "getAsynchronously",
      "listenOnLocalhost",
      "getCurrentCarrier",
      "readAccelerometer",
      "messageAvailable",
      "sendDigitalPorts",
      "lineFollowConfig",
      "countryNameWrite",
      "runShellCommand",
      "readStringUntil",
      "rewindDirectory",
      "readTemperature",
      "setClockDivider",
      "readLightSensor",
      "endTransmission",
      "analogReference",
      "detachInterrupt",
      "countryNameRead",
      "attachInterrupt",
      "encryptionType",
      "readBytesUntil",
      "robotNameWrite",
      "readMicrophone",
      "robotNameRead",
      "cityNameWrite",
      "userNameWrite",
      "readJoystickY",
      "readJoystickX",
      "mouseReleased",
      "openNextFile",
      "scanNetworks",
      "noInterrupts",
      "digitalWrite",
      "beginSpeaker",
      "mousePressed",
      "isActionDone",
      "mouseDragged",
      "displayLogos",
      "noAutoscroll",
      "addParameter",
      "remoteNumber",
      "getModifiers",
      "keyboardRead",
      "userNameRead",
      "waitContinue",
      "processInput",
      "parseCommand",
      "printVersion",
      "readNetworks",
      "writeMessage",
      "blinkVersion",
      "cityNameRead",
      "readMessage",
      "setDataMode",
      "parsePacket",
      "isListening",
      "setBitOrder",
      "beginPacket",
      "isDirectory",
      "motorsWrite",
      "drawCompass",
      "digitalRead",
      "clearScreen",
      "serialEvent",
      "rightToLeft",
      "setTextSize",
      "leftToRight",
      "requestFrom",
      "keyReleased",
      "compassRead",
      "analogWrite",
      "interrupts",
      "WiFiServer",
      "disconnect",
      "playMelody",
      "parseFloat",
      "autoscroll",
      "getPINUsed",
      "setPINUsed",
      "setTimeout",
      "sendAnalog",
      "readSlider",
      "analogRead",
      "beginWrite",
      "createChar",
      "motorsStop",
      "keyPressed",
      "tempoWrite",
      "readButton",
      "subnetMask",
      "debugPrint",
      "macAddress",
      "writeGreen",
      "randomSeed",
      "attachGPRS",
      "readString",
      "sendString",
      "remotePort",
      "releaseAll",
      "mouseMoved",
      "background",
      "getXChange",
      "getYChange",
      "answerCall",
      "getResult",
      "voiceCall",
      "endPacket",
      "constrain",
      "getSocket",
      "writeJSON",
      "getButton",
      "available",
      "connected",
      "findUntil",
      "readBytes",
      "exitValue",
      "readGreen",
      "writeBlue",
      "startLoop",
      "IPAddress",
      "isPressed",
      "sendSysex",
      "pauseMode",
      "gatewayIP",
      "setCursor",
      "getOemKey",
      "tuneWrite",
      "noDisplay",
      "loadImage",
      "switchPIN",
      "onRequest",
      "onReceive",
      "changePIN",
      "playFile",
      "noBuffer",
      "parseInt",
      "overflow",
      "checkPIN",
      "knobRead",
      "beginTFT",
      "bitClear",
      "updateIR",
      "bitWrite",
      "position",
      "writeRGB",
      "highByte",
      "writeRed",
      "setSpeed",
      "readBlue",
      "noStroke",
      "remoteIP",
      "transfer",
      "shutdown",
      "hangCall",
      "beginSMS",
      "endWrite",
      "attached",
      "maintain",
      "noCursor",
      "checkReg",
      "checkPUK",
      "shiftOut",
      "isValid",
      "shiftIn",
      "pulseIn",
      "connect",
      "println",
      "localIP",
      "pinMode",
      "getIMEI",
      "display",
      "noBlink",
      "process",
      "getBand",
      "running",
      "beginSD",
      "drawBMP",
      "lowByte",
      "setBand",
      "release",
      "bitRead",
      "prepare",
      "pointTo",
      "readRed",
      "setMode",
      "noFill",
      "remove",
      "listen",
      "stroke",
      "detach",
      "attach",
      "noTone",
      "exists",
      "buffer",
      "height",
      "bitSet",
      "circle",
      "config",
      "cursor",
      "random",
      "IRread",
      "setDNS",
      "endSMS",
      "getKey",
      "micros",
      "millis",
      "begin",
      "print",
      "write",
      "ready",
      "flush",
      "width",
      "isPIN",
      "blink",
      "clear",
      "press",
      "mkdir",
      "rmdir",
      "close",
      "point",
      "yield",
      "image",
      "BSSID",
      "click",
      "delay",
      "read",
      "text",
      "move",
      "peek",
      "beep",
      "rect",
      "line",
      "open",
      "seek",
      "fill",
      "size",
      "turn",
      "stop",
      "home",
      "find",
      "step",
      "tone",
      "sqrt",
      "RSSI",
      "SSID",
      "end",
      "bit",
      "tan",
      "cos",
      "sin",
      "pow",
      "map",
      "abs",
      "max",
      "min",
      "get",
      "run",
      "put"
    ],
    literal: [
      "DIGITAL_MESSAGE",
      "FIRMATA_STRING",
      "ANALOG_MESSAGE",
      "REPORT_DIGITAL",
      "REPORT_ANALOG",
      "INPUT_PULLUP",
      "SET_PIN_MODE",
      "INTERNAL2V56",
      "SYSTEM_RESET",
      "LED_BUILTIN",
      "INTERNAL1V1",
      "SYSEX_START",
      "INTERNAL",
      "EXTERNAL",
      "DEFAULT",
      "OUTPUT",
      "INPUT",
      "HIGH",
      "LOW"
    ]
  };
  const ARDUINO = cPlusPlus(hljs);
  const kws = (
    /** @type {Record<string,any>} */
    ARDUINO.keywords
  );
  kws.type = [
    ...kws.type,
    ...ARDUINO_KW.type
  ];
  kws.literal = [
    ...kws.literal,
    ...ARDUINO_KW.literal
  ];
  kws.built_in = [
    ...kws.built_in,
    ...ARDUINO_KW.built_in
  ];
  kws._hints = ARDUINO_KW._hints;
  ARDUINO.name = "Arduino";
  ARDUINO.aliases = ["ino"];
  ARDUINO.supersetOf = "cpp";
  return ARDUINO;
}
function bash(hljs) {
  const regex2 = hljs.regex;
  const VAR = {};
  const BRACED_VAR = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [VAR]
      }
      // default values
    ]
  };
  Object.assign(VAR, {
    className: "variable",
    variants: [
      { begin: regex2.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        `(?![\\w\\d])(?![$])`
      ) },
      BRACED_VAR
    ]
  });
  const SUBST = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  const HERE_DOC = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      hljs.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  };
  const QUOTE_STRING = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      hljs.BACKSLASH_ESCAPE,
      VAR,
      SUBST
    ]
  };
  SUBST.contains.push(QUOTE_STRING);
  const ESCAPED_QUOTE = {
    match: /\\"/
  };
  const APOS_STRING = {
    className: "string",
    begin: /'/,
    end: /'/
  };
  const ESCAPED_APOS = {
    match: /\\'/
  };
  const ARITHMETIC = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      hljs.NUMBER_MODE,
      VAR
    ]
  };
  const SH_LIKE_SHELLS = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ];
  const KNOWN_SHEBANG = hljs.SHEBANG({
    binary: `(${SH_LIKE_SHELLS.join("|")})`,
    relevance: 10
  });
  const FUNCTION = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: true,
    contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  };
  const KEYWORDS2 = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function",
    "select"
  ];
  const LITERALS2 = [
    "true",
    "false"
  ];
  const PATH_MODE = { match: /(\/[a-z._-]+)+/ };
  const SHELL_BUILT_INS = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ];
  const BASH_BUILT_INS = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ];
  const ZSH_BUILT_INS = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ];
  const GNU_CORE_UTILS = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: KEYWORDS2,
      literal: LITERALS2,
      built_in: [
        ...SHELL_BUILT_INS,
        ...BASH_BUILT_INS,
        // Shell modifiers
        "set",
        "shopt",
        ...ZSH_BUILT_INS,
        ...GNU_CORE_UTILS
      ]
    },
    contains: [
      KNOWN_SHEBANG,
      // to catch known shells and boost relevancy
      hljs.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      FUNCTION,
      ARITHMETIC,
      hljs.HASH_COMMENT_MODE,
      HERE_DOC,
      PATH_MODE,
      QUOTE_STRING,
      ESCAPED_QUOTE,
      APOS_STRING,
      ESCAPED_APOS,
      VAR
    ]
  };
}
function c$3(hljs) {
  const regex2 = hljs.regex;
  const C_LINE_COMMENT_MODE2 = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] });
  const DECLTYPE_AUTO_RE = "decltype\\(auto\\)";
  const NAMESPACE_RE = "[a-zA-Z_]\\w*::";
  const TEMPLATE_ARGUMENT_RE = "<[^<>]+>";
  const FUNCTION_TYPE_RE = "(" + DECLTYPE_AUTO_RE + "|" + regex2.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex2.optional(TEMPLATE_ARGUMENT_RE) + ")";
  const TYPES2 = {
    className: "type",
    variants: [
      { begin: "\\b[a-z\\d_]*_t\\b" },
      { match: /\batomic_[a-z]{3,6}\b/ }
    ]
  };
  const CHARACTER_ESCAPES = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)";
  const STRINGS = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [hljs.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + CHARACTER_ESCAPES + "|.)",
        end: "'",
        illegal: "."
      },
      hljs.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  };
  const NUMBERS = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  };
  const PREPROCESSOR = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      hljs.inherit(STRINGS, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      C_LINE_COMMENT_MODE2,
      hljs.C_BLOCK_COMMENT_MODE
    ]
  };
  const TITLE_MODE2 = {
    className: "title",
    begin: regex2.optional(NAMESPACE_RE) + hljs.IDENT_RE,
    relevance: 0
  };
  const FUNCTION_TITLE = regex2.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(";
  const C_KEYWORDS = [
    "asm",
    "auto",
    "break",
    "case",
    "continue",
    "default",
    "do",
    "else",
    "enum",
    "extern",
    "for",
    "fortran",
    "goto",
    "if",
    "inline",
    "register",
    "restrict",
    "return",
    "sizeof",
    "struct",
    "switch",
    "typedef",
    "union",
    "volatile",
    "while",
    "_Alignas",
    "_Alignof",
    "_Atomic",
    "_Generic",
    "_Noreturn",
    "_Static_assert",
    "_Thread_local",
    // aliases
    "alignas",
    "alignof",
    "noreturn",
    "static_assert",
    "thread_local",
    // not a C keyword but is, for all intents and purposes, treated exactly like one.
    "_Pragma"
  ];
  const C_TYPES = [
    "float",
    "double",
    "signed",
    "unsigned",
    "int",
    "short",
    "long",
    "char",
    "void",
    "_Bool",
    "_Complex",
    "_Imaginary",
    "_Decimal32",
    "_Decimal64",
    "_Decimal128",
    // modifiers
    "const",
    "static",
    // aliases
    "complex",
    "bool",
    "imaginary"
  ];
  const KEYWORDS2 = {
    keyword: C_KEYWORDS,
    type: C_TYPES,
    literal: "true false NULL",
    // TODO: apply hinting work similar to what was done in cpp.js
    built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
  };
  const EXPRESSION_CONTAINS = [
    PREPROCESSOR,
    TYPES2,
    C_LINE_COMMENT_MODE2,
    hljs.C_BLOCK_COMMENT_MODE,
    NUMBERS,
    STRINGS
  ];
  const EXPRESSION_CONTEXT = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: KEYWORDS2,
    contains: EXPRESSION_CONTAINS.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS2,
        contains: EXPRESSION_CONTAINS.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  };
  const FUNCTION_DECLARATION = {
    begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE,
    returnBegin: true,
    end: /[{;=]/,
    excludeEnd: true,
    keywords: KEYWORDS2,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: DECLTYPE_AUTO_RE,
        keywords: KEYWORDS2,
        relevance: 0
      },
      {
        begin: FUNCTION_TITLE,
        returnBegin: true,
        contains: [hljs.inherit(TITLE_MODE2, { className: "title.function" })],
        relevance: 0
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS2,
        relevance: 0,
        contains: [
          C_LINE_COMMENT_MODE2,
          hljs.C_BLOCK_COMMENT_MODE,
          STRINGS,
          NUMBERS,
          TYPES2,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: KEYWORDS2,
            relevance: 0,
            contains: [
              "self",
              C_LINE_COMMENT_MODE2,
              hljs.C_BLOCK_COMMENT_MODE,
              STRINGS,
              NUMBERS,
              TYPES2
            ]
          }
        ]
      },
      TYPES2,
      C_LINE_COMMENT_MODE2,
      hljs.C_BLOCK_COMMENT_MODE,
      PREPROCESSOR
    ]
  };
  return {
    name: "C",
    aliases: ["h"],
    keywords: KEYWORDS2,
    // Until differentiations are added between `c` and `cpp`, `c` will
    // not be auto-detected to avoid auto-detect conflicts between C and C++
    disableAutodetect: true,
    illegal: "</",
    contains: [].concat(
      EXPRESSION_CONTEXT,
      FUNCTION_DECLARATION,
      EXPRESSION_CONTAINS,
      [
        PREPROCESSOR,
        {
          begin: hljs.IDENT_RE + "::",
          keywords: KEYWORDS2
        },
        {
          className: "class",
          beginKeywords: "enum class struct union",
          end: /[{;:<>=]/,
          contains: [
            { beginKeywords: "final class struct" },
            hljs.TITLE_MODE
          ]
        }
      ]
    ),
    exports: {
      preprocessor: PREPROCESSOR,
      strings: STRINGS,
      keywords: KEYWORDS2
    }
  };
}
function cpp(hljs) {
  const regex2 = hljs.regex;
  const C_LINE_COMMENT_MODE2 = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] });
  const DECLTYPE_AUTO_RE = "decltype\\(auto\\)";
  const NAMESPACE_RE = "[a-zA-Z_]\\w*::";
  const TEMPLATE_ARGUMENT_RE = "<[^<>]+>";
  const FUNCTION_TYPE_RE = "(?!struct)(" + DECLTYPE_AUTO_RE + "|" + regex2.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex2.optional(TEMPLATE_ARGUMENT_RE) + ")";
  const CPP_PRIMITIVE_TYPES = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  };
  const CHARACTER_ESCAPES = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)";
  const STRINGS = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [hljs.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + CHARACTER_ESCAPES + "|.)",
        end: "'",
        illegal: "."
      },
      hljs.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  };
  const NUMBERS = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  };
  const PREPROCESSOR = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      hljs.inherit(STRINGS, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      C_LINE_COMMENT_MODE2,
      hljs.C_BLOCK_COMMENT_MODE
    ]
  };
  const TITLE_MODE2 = {
    className: "title",
    begin: regex2.optional(NAMESPACE_RE) + hljs.IDENT_RE,
    relevance: 0
  };
  const FUNCTION_TITLE = regex2.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(";
  const RESERVED_KEYWORDS = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ];
  const RESERVED_TYPES = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ];
  const TYPE_HINTS = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ];
  const FUNCTION_HINTS = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ];
  const LITERALS2 = [
    "NULL",
    "false",
    "nullopt",
    "nullptr",
    "true"
  ];
  const BUILT_IN = ["_Pragma"];
  const CPP_KEYWORDS = {
    type: RESERVED_TYPES,
    keyword: RESERVED_KEYWORDS,
    literal: LITERALS2,
    built_in: BUILT_IN,
    _type_hints: TYPE_HINTS
  };
  const FUNCTION_DISPATCH = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: FUNCTION_HINTS
    },
    begin: regex2.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      hljs.IDENT_RE,
      regex2.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  };
  const EXPRESSION_CONTAINS = [
    FUNCTION_DISPATCH,
    PREPROCESSOR,
    CPP_PRIMITIVE_TYPES,
    C_LINE_COMMENT_MODE2,
    hljs.C_BLOCK_COMMENT_MODE,
    NUMBERS,
    STRINGS
  ];
  const EXPRESSION_CONTEXT = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: CPP_KEYWORDS,
    contains: EXPRESSION_CONTAINS.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: CPP_KEYWORDS,
        contains: EXPRESSION_CONTAINS.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  };
  const FUNCTION_DECLARATION = {
    className: "function",
    begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE,
    returnBegin: true,
    end: /[{;=]/,
    excludeEnd: true,
    keywords: CPP_KEYWORDS,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: DECLTYPE_AUTO_RE,
        keywords: CPP_KEYWORDS,
        relevance: 0
      },
      {
        begin: FUNCTION_TITLE,
        returnBegin: true,
        contains: [TITLE_MODE2],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: true,
        contains: [
          STRINGS,
          NUMBERS
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: CPP_KEYWORDS,
        relevance: 0,
        contains: [
          C_LINE_COMMENT_MODE2,
          hljs.C_BLOCK_COMMENT_MODE,
          STRINGS,
          NUMBERS,
          CPP_PRIMITIVE_TYPES,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: CPP_KEYWORDS,
            relevance: 0,
            contains: [
              "self",
              C_LINE_COMMENT_MODE2,
              hljs.C_BLOCK_COMMENT_MODE,
              STRINGS,
              NUMBERS,
              CPP_PRIMITIVE_TYPES
            ]
          }
        ]
      },
      CPP_PRIMITIVE_TYPES,
      C_LINE_COMMENT_MODE2,
      hljs.C_BLOCK_COMMENT_MODE,
      PREPROCESSOR
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: CPP_KEYWORDS,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      EXPRESSION_CONTEXT,
      FUNCTION_DECLARATION,
      FUNCTION_DISPATCH,
      EXPRESSION_CONTAINS,
      [
        PREPROCESSOR,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
          end: ">",
          keywords: CPP_KEYWORDS,
          contains: [
            "self",
            CPP_PRIMITIVE_TYPES
          ]
        },
        {
          begin: hljs.IDENT_RE + "::",
          keywords: CPP_KEYWORDS
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function csharp(hljs) {
  const BUILT_IN_KEYWORDS = [
    "bool",
    "byte",
    "char",
    "decimal",
    "delegate",
    "double",
    "dynamic",
    "enum",
    "float",
    "int",
    "long",
    "nint",
    "nuint",
    "object",
    "sbyte",
    "short",
    "string",
    "ulong",
    "uint",
    "ushort"
  ];
  const FUNCTION_MODIFIERS = [
    "public",
    "private",
    "protected",
    "static",
    "internal",
    "protected",
    "abstract",
    "async",
    "extern",
    "override",
    "unsafe",
    "virtual",
    "new",
    "sealed",
    "partial"
  ];
  const LITERAL_KEYWORDS = [
    "default",
    "false",
    "null",
    "true"
  ];
  const NORMAL_KEYWORDS = [
    "abstract",
    "as",
    "base",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "do",
    "else",
    "event",
    "explicit",
    "extern",
    "finally",
    "fixed",
    "for",
    "foreach",
    "goto",
    "if",
    "implicit",
    "in",
    "interface",
    "internal",
    "is",
    "lock",
    "namespace",
    "new",
    "operator",
    "out",
    "override",
    "params",
    "private",
    "protected",
    "public",
    "readonly",
    "record",
    "ref",
    "return",
    "scoped",
    "sealed",
    "sizeof",
    "stackalloc",
    "static",
    "struct",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "unchecked",
    "unsafe",
    "using",
    "virtual",
    "void",
    "volatile",
    "while"
  ];
  const CONTEXTUAL_KEYWORDS = [
    "add",
    "alias",
    "and",
    "ascending",
    "async",
    "await",
    "by",
    "descending",
    "equals",
    "from",
    "get",
    "global",
    "group",
    "init",
    "into",
    "join",
    "let",
    "nameof",
    "not",
    "notnull",
    "on",
    "or",
    "orderby",
    "partial",
    "remove",
    "select",
    "set",
    "unmanaged",
    "value|0",
    "var",
    "when",
    "where",
    "with",
    "yield"
  ];
  const KEYWORDS2 = {
    keyword: NORMAL_KEYWORDS.concat(CONTEXTUAL_KEYWORDS),
    built_in: BUILT_IN_KEYWORDS,
    literal: LITERAL_KEYWORDS
  };
  const TITLE_MODE2 = hljs.inherit(hljs.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" });
  const NUMBERS = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  };
  const VERBATIM_STRING = {
    className: "string",
    begin: '@"',
    end: '"',
    contains: [{ begin: '""' }]
  };
  const VERBATIM_STRING_NO_LF = hljs.inherit(VERBATIM_STRING, { illegal: /\n/ });
  const SUBST = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS2
  };
  const SUBST_NO_LF = hljs.inherit(SUBST, { illegal: /\n/ });
  const INTERPOLATED_STRING = {
    className: "string",
    begin: /\$"/,
    end: '"',
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      hljs.BACKSLASH_ESCAPE,
      SUBST_NO_LF
    ]
  };
  const INTERPOLATED_VERBATIM_STRING = {
    className: "string",
    begin: /\$@"/,
    end: '"',
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      SUBST
    ]
  };
  const INTERPOLATED_VERBATIM_STRING_NO_LF = hljs.inherit(INTERPOLATED_VERBATIM_STRING, {
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      SUBST_NO_LF
    ]
  });
  SUBST.contains = [
    INTERPOLATED_VERBATIM_STRING,
    INTERPOLATED_STRING,
    VERBATIM_STRING,
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    NUMBERS,
    hljs.C_BLOCK_COMMENT_MODE
  ];
  SUBST_NO_LF.contains = [
    INTERPOLATED_VERBATIM_STRING_NO_LF,
    INTERPOLATED_STRING,
    VERBATIM_STRING_NO_LF,
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    NUMBERS,
    hljs.inherit(hljs.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
  ];
  const STRING = { variants: [
    INTERPOLATED_VERBATIM_STRING,
    INTERPOLATED_STRING,
    VERBATIM_STRING,
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE
  ] };
  const GENERIC_MODIFIER = {
    begin: "<",
    end: ">",
    contains: [
      { beginKeywords: "in out" },
      TITLE_MODE2
    ]
  };
  const TYPE_IDENT_RE = hljs.IDENT_RE + "(<" + hljs.IDENT_RE + "(\\s*,\\s*" + hljs.IDENT_RE + ")*>)?(\\[\\])?";
  const AT_IDENTIFIER = {
    // prevents expressions like `@class` from incorrect flagging
    // `class` as a keyword
    begin: "@" + hljs.IDENT_RE,
    relevance: 0
  };
  return {
    name: "C#",
    aliases: [
      "cs",
      "c#"
    ],
    keywords: KEYWORDS2,
    illegal: /::/,
    contains: [
      hljs.COMMENT(
        "///",
        "$",
        {
          returnBegin: true,
          contains: [
            {
              className: "doctag",
              variants: [
                {
                  begin: "///",
                  relevance: 0
                },
                { begin: "<!--|-->" },
                {
                  begin: "</?",
                  end: ">"
                }
              ]
            }
          ]
        }
      ),
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      {
        className: "meta",
        begin: "#",
        end: "$",
        keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
      },
      STRING,
      NUMBERS,
      {
        beginKeywords: "class interface",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:,]/,
        contains: [
          { beginKeywords: "where class" },
          TITLE_MODE2,
          GENERIC_MODIFIER,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          TITLE_MODE2,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "record",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          TITLE_MODE2,
          GENERIC_MODIFIER,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // [Attributes("")]
        className: "meta",
        begin: "^\\s*\\[(?=[\\w])",
        excludeBegin: true,
        end: "\\]",
        excludeEnd: true,
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new return throw await else",
        relevance: 0
      },
      {
        className: "function",
        begin: "(" + TYPE_IDENT_RE + "\\s+)+" + hljs.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
        returnBegin: true,
        end: /\s*[{;=]/,
        excludeEnd: true,
        keywords: KEYWORDS2,
        contains: [
          // prevents these from being highlighted `title`
          {
            beginKeywords: FUNCTION_MODIFIERS.join(" "),
            relevance: 0
          },
          {
            begin: hljs.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: true,
            contains: [
              hljs.TITLE_MODE,
              GENERIC_MODIFIER
            ],
            relevance: 0
          },
          { match: /\(\)/ },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS2,
            relevance: 0,
            contains: [
              STRING,
              NUMBERS,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      AT_IDENTIFIER
    ]
  };
}
const MODES$4 = (hljs) => {
  return {
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
    },
    FUNCTION_DISPATCH: {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z_][A-Za-z0-9_-]*/
    }
  };
};
const TAGS$2 = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
];
const MEDIA_FEATURES$2 = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
const PSEUDO_CLASSES$2 = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
];
const PSEUDO_ELEMENTS$2 = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
];
const ATTRIBUTES$2 = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
function css(hljs) {
  const regex2 = hljs.regex;
  const modes = MODES$4(hljs);
  const VENDOR_PREFIX = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ };
  const AT_MODIFIERS = "and or not only";
  const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
  const IDENT_RE2 = "[a-zA-Z-][a-zA-Z0-9_-]*";
  const STRINGS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: true,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: {
      // for visual continuity with `tag {}` and because we
      // don't have a great class for this?
      keyframePosition: "selector-tag"
    },
    contains: [
      modes.BLOCK_COMMENT,
      VENDOR_PREFIX,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      modes.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + IDENT_RE2,
        relevance: 0
      },
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + PSEUDO_CLASSES$2.join("|") + ")" },
          { begin: ":(:)?(" + PSEUDO_ELEMENTS$2.join("|") + ")" }
        ]
      },
      // we may actually need this (12/2020)
      // { // pseudo-selector params
      //   begin: /\(/,
      //   end: /\)/,
      //   contains: [ hljs.CSS_NUMBER_MODE ]
      // },
      modes.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + ATTRIBUTES$2.join("|") + ")\\b"
      },
      // attribute values
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          modes.BLOCK_COMMENT,
          modes.HEXCOLOR,
          modes.IMPORTANT,
          modes.CSS_NUMBER_MODE,
          ...STRINGS,
          // needed to highlight these as strings and to avoid issues with
          // illegal characters that might be inside urls that would tigger the
          // languages illegal stack
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            // from keywords
            keywords: { built_in: "url data-uri" },
            contains: [
              ...STRINGS,
              {
                className: "string",
                // any character other than `)` as in `url()` will be the start
                // of a string, which ends with `)` (from the parent mode)
                begin: /[^)]/,
                endsWithParent: true,
                excludeEnd: true
              }
            ]
          },
          modes.FUNCTION_DISPATCH
        ]
      },
      {
        begin: regex2.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        // break on Less variables @var: ...
        contains: [
          {
            className: "keyword",
            begin: AT_PROPERTY_RE
          },
          {
            begin: /\s/,
            endsWithParent: true,
            excludeEnd: true,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: AT_MODIFIERS,
              attribute: MEDIA_FEATURES$2.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...STRINGS,
              modes.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + TAGS$2.join("|") + ")\\b"
      }
    ]
  };
}
function diff(hljs) {
  const regex2 = hljs.regex;
  return {
    name: "Diff",
    aliases: ["patch"],
    contains: [
      {
        className: "meta",
        relevance: 10,
        match: regex2.either(
          /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
          /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
          /^--- +\d+,\d+ +----$/
        )
      },
      {
        className: "comment",
        variants: [
          {
            begin: regex2.either(
              /Index: /,
              /^index/,
              /={3,}/,
              /^-{3}/,
              /^\*{3} /,
              /^\+{3}/,
              /^diff --git/
            ),
            end: /$/
          },
          { match: /^\*{15}$/ }
        ]
      },
      {
        className: "addition",
        begin: /^\+/,
        end: /$/
      },
      {
        className: "deletion",
        begin: /^-/,
        end: /$/
      },
      {
        className: "addition",
        begin: /^!/,
        end: /$/
      }
    ]
  };
}
function go$2(hljs) {
  const LITERALS2 = [
    "true",
    "false",
    "iota",
    "nil"
  ];
  const BUILT_INS2 = [
    "append",
    "cap",
    "close",
    "complex",
    "copy",
    "imag",
    "len",
    "make",
    "new",
    "panic",
    "print",
    "println",
    "real",
    "recover",
    "delete"
  ];
  const TYPES2 = [
    "bool",
    "byte",
    "complex64",
    "complex128",
    "error",
    "float32",
    "float64",
    "int8",
    "int16",
    "int32",
    "int64",
    "string",
    "uint8",
    "uint16",
    "uint32",
    "uint64",
    "int",
    "uint",
    "uintptr",
    "rune"
  ];
  const KWS = [
    "break",
    "case",
    "chan",
    "const",
    "continue",
    "default",
    "defer",
    "else",
    "fallthrough",
    "for",
    "func",
    "go",
    "goto",
    "if",
    "import",
    "interface",
    "map",
    "package",
    "range",
    "return",
    "select",
    "struct",
    "switch",
    "type",
    "var"
  ];
  const KEYWORDS2 = {
    keyword: KWS,
    type: TYPES2,
    literal: LITERALS2,
    built_in: BUILT_INS2
  };
  return {
    name: "Go",
    aliases: ["golang"],
    keywords: KEYWORDS2,
    illegal: "</",
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      {
        className: "string",
        variants: [
          hljs.QUOTE_STRING_MODE,
          hljs.APOS_STRING_MODE,
          {
            begin: "`",
            end: "`"
          }
        ]
      },
      {
        className: "number",
        variants: [
          {
            begin: hljs.C_NUMBER_RE + "[i]",
            relevance: 1
          },
          hljs.C_NUMBER_MODE
        ]
      },
      {
        begin: /:=/
        // relevance booster
      },
      {
        className: "function",
        beginKeywords: "func",
        end: "\\s*(\\{|$)",
        excludeEnd: true,
        contains: [
          hljs.TITLE_MODE,
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: true,
            keywords: KEYWORDS2,
            illegal: /["']/
          }
        ]
      }
    ]
  };
}
function graphql(hljs) {
  const regex2 = hljs.regex;
  const GQL_NAME = /[_A-Za-z][_0-9A-Za-z]*/;
  return {
    name: "GraphQL",
    aliases: ["gql"],
    case_insensitive: true,
    disableAutodetect: false,
    keywords: {
      keyword: [
        "query",
        "mutation",
        "subscription",
        "type",
        "input",
        "schema",
        "directive",
        "interface",
        "union",
        "scalar",
        "fragment",
        "enum",
        "on"
      ],
      literal: [
        "true",
        "false",
        "null"
      ]
    },
    contains: [
      hljs.HASH_COMMENT_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.NUMBER_MODE,
      {
        scope: "punctuation",
        match: /[.]{3}/,
        relevance: 0
      },
      {
        scope: "punctuation",
        begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
        relevance: 0
      },
      {
        scope: "variable",
        begin: /\$/,
        end: /\W/,
        excludeEnd: true,
        relevance: 0
      },
      {
        scope: "meta",
        match: /@\w+/,
        excludeEnd: true
      },
      {
        scope: "symbol",
        begin: regex2.concat(GQL_NAME, regex2.lookahead(/\s*:/)),
        relevance: 0
      }
    ],
    illegal: [
      /[;<']/,
      /BEGIN/
    ]
  };
}
function ini(hljs) {
  const regex2 = hljs.regex;
  const NUMBERS = {
    className: "number",
    relevance: 0,
    variants: [
      { begin: /([+-]+)?[\d]+_[\d_]+/ },
      { begin: hljs.NUMBER_RE }
    ]
  };
  const COMMENTS = hljs.COMMENT();
  COMMENTS.variants = [
    {
      begin: /;/,
      end: /$/
    },
    {
      begin: /#/,
      end: /$/
    }
  ];
  const VARIABLES = {
    className: "variable",
    variants: [
      { begin: /\$[\w\d"][\w\d_]*/ },
      { begin: /\$\{(.*?)\}/ }
    ]
  };
  const LITERALS2 = {
    className: "literal",
    begin: /\bon|off|true|false|yes|no\b/
  };
  const STRINGS = {
    className: "string",
    contains: [hljs.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: "'''",
        end: "'''",
        relevance: 10
      },
      {
        begin: '"""',
        end: '"""',
        relevance: 10
      },
      {
        begin: '"',
        end: '"'
      },
      {
        begin: "'",
        end: "'"
      }
    ]
  };
  const ARRAY2 = {
    begin: /\[/,
    end: /\]/,
    contains: [
      COMMENTS,
      LITERALS2,
      VARIABLES,
      STRINGS,
      NUMBERS,
      "self"
    ],
    relevance: 0
  };
  const BARE_KEY = /[A-Za-z0-9_-]+/;
  const QUOTED_KEY_DOUBLE_QUOTE = /"(\\"|[^"])*"/;
  const QUOTED_KEY_SINGLE_QUOTE = /'[^']*'/;
  const ANY_KEY = regex2.either(
    BARE_KEY,
    QUOTED_KEY_DOUBLE_QUOTE,
    QUOTED_KEY_SINGLE_QUOTE
  );
  const DOTTED_KEY = regex2.concat(
    ANY_KEY,
    "(\\s*\\.\\s*",
    ANY_KEY,
    ")*",
    regex2.lookahead(/\s*=\s*[^#\s]/)
  );
  return {
    name: "TOML, also INI",
    aliases: ["toml"],
    case_insensitive: true,
    illegal: /\S/,
    contains: [
      COMMENTS,
      {
        className: "section",
        begin: /\[+/,
        end: /\]+/
      },
      {
        begin: DOTTED_KEY,
        className: "attr",
        starts: {
          end: /$/,
          contains: [
            COMMENTS,
            ARRAY2,
            LITERALS2,
            VARIABLES,
            STRINGS,
            NUMBERS
          ]
        }
      }
    ]
  };
}
var decimalDigits$1 = "[0-9](_*[0-9])*";
var frac$1 = `\\.(${decimalDigits$1})`;
var hexDigits$1 = "[0-9a-fA-F](_*[0-9a-fA-F])*";
var NUMERIC$1 = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${decimalDigits$1})((${frac$1})|\\.)?|(${frac$1}))[eE][+-]?(${decimalDigits$1})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${decimalDigits$1})((${frac$1})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${frac$1})[fFdD]?\\b` },
    { begin: `\\b(${decimalDigits$1})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${hexDigits$1})\\.?|(${hexDigits$1})?\\.(${hexDigits$1}))[pP][+-]?(${decimalDigits$1})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${hexDigits$1})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function recurRegex(re2, substitution, depth) {
  if (depth === -1)
    return "";
  return re2.replace(substitution, (_10) => {
    return recurRegex(re2, substitution, depth - 1);
  });
}
function java(hljs) {
  const regex2 = hljs.regex;
  const JAVA_IDENT_RE = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*";
  const GENERIC_IDENT_RE = JAVA_IDENT_RE + recurRegex("(?:<" + JAVA_IDENT_RE + "~~~(?:\\s*,\\s*" + JAVA_IDENT_RE + "~~~)*>)?", /~~~/g, 2);
  const MAIN_KEYWORDS = [
    "synchronized",
    "abstract",
    "private",
    "var",
    "static",
    "if",
    "const ",
    "for",
    "while",
    "strictfp",
    "finally",
    "protected",
    "import",
    "native",
    "final",
    "void",
    "enum",
    "else",
    "break",
    "transient",
    "catch",
    "instanceof",
    "volatile",
    "case",
    "assert",
    "package",
    "default",
    "public",
    "try",
    "switch",
    "continue",
    "throws",
    "protected",
    "public",
    "private",
    "module",
    "requires",
    "exports",
    "do",
    "sealed",
    "yield",
    "permits"
  ];
  const BUILT_INS2 = [
    "super",
    "this"
  ];
  const LITERALS2 = [
    "false",
    "true",
    "null"
  ];
  const TYPES2 = [
    "char",
    "boolean",
    "long",
    "float",
    "int",
    "byte",
    "short",
    "double"
  ];
  const KEYWORDS2 = {
    keyword: MAIN_KEYWORDS,
    literal: LITERALS2,
    type: TYPES2,
    built_in: BUILT_INS2
  };
  const ANNOTATION = {
    className: "meta",
    begin: "@" + JAVA_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"]
        // allow nested () inside our annotation
      }
    ]
  };
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    keywords: KEYWORDS2,
    relevance: 0,
    contains: [hljs.C_BLOCK_COMMENT_MODE],
    endsParent: true
  };
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: KEYWORDS2,
    illegal: /<\/|#/,
    contains: [
      hljs.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [hljs.BACKSLASH_ESCAPE]
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          JAVA_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        // Exceptions for hyphenated keywords
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          regex2.concat(/(?!else)/, JAVA_IDENT_RE),
          /\s+/,
          JAVA_IDENT_RE,
          /\s+/,
          /=(?!=)/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          JAVA_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          PARAMS,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        begin: [
          "(?:" + GENERIC_IDENT_RE + "\\s+)",
          hljs.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: KEYWORDS2,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: KEYWORDS2,
            relevance: 0,
            contains: [
              ANNOTATION,
              hljs.APOS_STRING_MODE,
              hljs.QUOTE_STRING_MODE,
              NUMERIC$1,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      NUMERIC$1,
      ANNOTATION
    ]
  };
}
const IDENT_RE$3 = "[A-Za-z$_][0-9A-Za-z$_]*";
const KEYWORDS$1 = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
const LITERALS$1 = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];
const TYPES$1 = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
];
const ERROR_TYPES$1 = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
const BUILT_IN_GLOBALS$1 = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
const BUILT_IN_VARIABLES$1 = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
];
const BUILT_INS$1 = [].concat(
  BUILT_IN_GLOBALS$1,
  TYPES$1,
  ERROR_TYPES$1
);
function javascript$1(hljs) {
  const regex2 = hljs.regex;
  const hasClosingTag = (match, { after }) => {
    const tag = "</" + match[0].slice(1);
    const pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };
  const IDENT_RE$12 = IDENT_RE$3;
  const FRAGMENT = {
    begin: "<>",
    end: "</>"
  };
  const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (match, response) => {
      const afterMatchIndex = match[0].length + match.index;
      const nextChar = match.input[afterMatchIndex];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        nextChar === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        nextChar === ","
      ) {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      let m10;
      const afterMatch = match.input.substring(afterMatchIndex);
      if (m10 = afterMatch.match(/^\s*=/)) {
        response.ignoreMatch();
        return;
      }
      if (m10 = afterMatch.match(/^\s+extends\s+/)) {
        if (m10.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  const KEYWORDS$1$1 = {
    $pattern: IDENT_RE$3,
    keyword: KEYWORDS$1,
    literal: LITERALS$1,
    built_in: BUILT_INS$1,
    "variable.language": BUILT_IN_VARIABLES$1
  };
  const decimalDigits2 = "[0-9](_?[0-9])*";
  const frac2 = `\\.(${decimalDigits2})`;
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${decimalInteger})((${frac2})|\\.)?|(${frac2}))[eE][+-]?(${decimalDigits2})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac2})\\b|\\.)?|(${frac2})\\b` },
      // DecimalBigIntegerLiteral
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  };
  const SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$1$1,
    contains: []
    // defined later
  };
  const HTML_TEMPLATE = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "xml"
    }
  };
  const CSS_TEMPLATE = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "css"
    }
  };
  const GRAPHQL_TEMPLATE = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "graphql"
    }
  };
  const TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    "\\*/",
    {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$12 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            // eat spaces (not newlines) so we can find
            // types or variables
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT2 = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    GRAPHQL_TEMPLATE,
    TEMPLATE_STRING,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    NUMBER
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$1$1,
    contains: [
      "self"
    ].concat(SUBST_INTERNALS)
  });
  const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1$1,
    contains: PARAMS_CONTAINS
  };
  const CLASS_OR_EXTENDS = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12,
          /\s+/,
          /extends/,
          /\s+/,
          regex2.concat(IDENT_RE$12, "(", regex2.concat(/\./, IDENT_RE$12), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: regex2.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...TYPES$1,
        ...ERROR_TYPES$1
      ]
    }
  };
  const USE_STRICT = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };
  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          IDENT_RE$12,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [PARAMS],
    illegal: /%/
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function noneOf(list2) {
    return regex2.concat("(?!", list2.join("|"), ")");
  }
  const FUNCTION_CALL = {
    match: regex2.concat(
      /\b/,
      noneOf([
        ...BUILT_IN_GLOBALS$1,
        "super",
        "import"
      ]),
      IDENT_RE$12,
      regex2.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  };
  const PROPERTY_ACCESS = {
    begin: regex2.concat(/\./, regex2.lookahead(
      regex2.concat(IDENT_RE$12, /(?![0-9A-Za-z$_(])/)
    )),
    end: IDENT_RE$12,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };
  const GETTER_OR_SETTER = {
    match: [
      /get|set/,
      /\s+/,
      IDENT_RE$12,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      PARAMS
    ]
  };
  const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/,
      /\s+/,
      IDENT_RE$12,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      regex2.lookahead(FUNC_LEAD_IN_RE)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$1$1,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT2,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      NUMBER,
      CLASS_REFERENCE,
      {
        className: "attr",
        begin: IDENT_RE$12 + regex2.lookahead(":"),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      {
        // "value" container
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          COMMENT2,
          hljs.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              { match: XML_SELF_CLOSING },
              {
                begin: XML_TAG.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      FUNCTION_DEFINITION,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$12, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + IDENT_RE$12,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [PARAMS]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function json(hljs) {
  const ATTRIBUTE = {
    className: "attr",
    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
    relevance: 1.01
  };
  const PUNCTUATION = {
    match: /[{}[\],:]/,
    className: "punctuation",
    relevance: 0
  };
  const LITERALS2 = [
    "true",
    "false",
    "null"
  ];
  const LITERALS_MODE = {
    scope: "literal",
    beginKeywords: LITERALS2.join(" ")
  };
  return {
    name: "JSON",
    keywords: {
      literal: LITERALS2
    },
    contains: [
      ATTRIBUTE,
      PUNCTUATION,
      hljs.QUOTE_STRING_MODE,
      LITERALS_MODE,
      hljs.C_NUMBER_MODE,
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE
    ],
    illegal: "\\S"
  };
}
var decimalDigits = "[0-9](_*[0-9])*";
var frac = `\\.(${decimalDigits})`;
var hexDigits = "[0-9a-fA-F](_*[0-9a-fA-F])*";
var NUMERIC = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${frac})[fFdD]?\\b` },
    { begin: `\\b(${decimalDigits})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))[pP][+-]?(${decimalDigits})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function kotlin(hljs) {
  const KEYWORDS2 = {
    keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
    built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
    literal: "true false null"
  };
  const KEYWORDS_WITH_LABEL = {
    className: "keyword",
    begin: /\b(break|continue|return|this)\b/,
    starts: { contains: [
      {
        className: "symbol",
        begin: /@\w+/
      }
    ] }
  };
  const LABEL = {
    className: "symbol",
    begin: hljs.UNDERSCORE_IDENT_RE + "@"
  };
  const SUBST = {
    className: "subst",
    begin: /\$\{/,
    end: /\}/,
    contains: [hljs.C_NUMBER_MODE]
  };
  const VARIABLE = {
    className: "variable",
    begin: "\\$" + hljs.UNDERSCORE_IDENT_RE
  };
  const STRING = {
    className: "string",
    variants: [
      {
        begin: '"""',
        end: '"""(?=[^"])',
        contains: [
          VARIABLE,
          SUBST
        ]
      },
      // Can't use built-in modes easily, as we want to use STRING in the meta
      // context as 'meta-string' and there's no syntax to remove explicitly set
      // classNames in built-in modes.
      {
        begin: "'",
        end: "'",
        illegal: /\n/,
        contains: [hljs.BACKSLASH_ESCAPE]
      },
      {
        begin: '"',
        end: '"',
        illegal: /\n/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          VARIABLE,
          SUBST
        ]
      }
    ]
  };
  SUBST.contains.push(STRING);
  const ANNOTATION_USE_SITE = {
    className: "meta",
    begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + hljs.UNDERSCORE_IDENT_RE + ")?"
  };
  const ANNOTATION = {
    className: "meta",
    begin: "@" + hljs.UNDERSCORE_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          hljs.inherit(STRING, { className: "string" }),
          "self"
        ]
      }
    ]
  };
  const KOTLIN_NUMBER_MODE = NUMERIC;
  const KOTLIN_NESTED_COMMENT = hljs.COMMENT(
    "/\\*",
    "\\*/",
    { contains: [hljs.C_BLOCK_COMMENT_MODE] }
  );
  const KOTLIN_PAREN_TYPE = { variants: [
    {
      className: "type",
      begin: hljs.UNDERSCORE_IDENT_RE
    },
    {
      begin: /\(/,
      end: /\)/,
      contains: []
      // defined later
    }
  ] };
  const KOTLIN_PAREN_TYPE2 = KOTLIN_PAREN_TYPE;
  KOTLIN_PAREN_TYPE2.variants[1].contains = [KOTLIN_PAREN_TYPE];
  KOTLIN_PAREN_TYPE.variants[1].contains = [KOTLIN_PAREN_TYPE2];
  return {
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    keywords: KEYWORDS2,
    contains: [
      hljs.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      hljs.C_LINE_COMMENT_MODE,
      KOTLIN_NESTED_COMMENT,
      KEYWORDS_WITH_LABEL,
      LABEL,
      ANNOTATION_USE_SITE,
      ANNOTATION,
      {
        className: "function",
        beginKeywords: "fun",
        end: "[(]|$",
        returnBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS2,
        relevance: 5,
        contains: [
          {
            begin: hljs.UNDERSCORE_IDENT_RE + "\\s*\\(",
            returnBegin: true,
            relevance: 0,
            contains: [hljs.UNDERSCORE_TITLE_MODE]
          },
          {
            className: "type",
            begin: /</,
            end: />/,
            keywords: "reified",
            relevance: 0
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: true,
            keywords: KEYWORDS2,
            relevance: 0,
            contains: [
              {
                begin: /:/,
                end: /[=,\/]/,
                endsWithParent: true,
                contains: [
                  KOTLIN_PAREN_TYPE,
                  hljs.C_LINE_COMMENT_MODE,
                  KOTLIN_NESTED_COMMENT
                ],
                relevance: 0
              },
              hljs.C_LINE_COMMENT_MODE,
              KOTLIN_NESTED_COMMENT,
              ANNOTATION_USE_SITE,
              ANNOTATION,
              STRING,
              hljs.C_NUMBER_MODE
            ]
          },
          KOTLIN_NESTED_COMMENT
        ]
      },
      {
        begin: [
          /class|interface|trait/,
          /\s+/,
          hljs.UNDERSCORE_IDENT_RE
        ],
        beginScope: {
          3: "title.class"
        },
        keywords: "class interface trait",
        end: /[:\{(]|$/,
        excludeEnd: true,
        illegal: "extends implements",
        contains: [
          { beginKeywords: "public protected internal private constructor" },
          hljs.UNDERSCORE_TITLE_MODE,
          {
            className: "type",
            begin: /</,
            end: />/,
            excludeBegin: true,
            excludeEnd: true,
            relevance: 0
          },
          {
            className: "type",
            begin: /[,:]\s*/,
            end: /[<\(,){\s]|$/,
            excludeBegin: true,
            returnEnd: true
          },
          ANNOTATION_USE_SITE,
          ANNOTATION
        ]
      },
      STRING,
      {
        className: "meta",
        begin: "^#!/usr/bin/env",
        end: "$",
        illegal: "\n"
      },
      KOTLIN_NUMBER_MODE
    ]
  };
}
const MODES$3 = (hljs) => {
  return {
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
    },
    FUNCTION_DISPATCH: {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z_][A-Za-z0-9_-]*/
    }
  };
};
const TAGS$1 = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
];
const MEDIA_FEATURES$1 = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
const PSEUDO_CLASSES$1 = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
];
const PSEUDO_ELEMENTS$1 = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
];
const ATTRIBUTES$1 = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
const PSEUDO_SELECTORS = PSEUDO_CLASSES$1.concat(PSEUDO_ELEMENTS$1);
function less(hljs) {
  const modes = MODES$3(hljs);
  const PSEUDO_SELECTORS$1 = PSEUDO_SELECTORS;
  const AT_MODIFIERS = "and or not only";
  const IDENT_RE2 = "[\\w-]+";
  const INTERP_IDENT_RE = "(" + IDENT_RE2 + "|@\\{" + IDENT_RE2 + "\\})";
  const RULES = [];
  const VALUE_MODES = [];
  const STRING_MODE = function(c3) {
    return {
      // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
      className: "string",
      begin: "~?" + c3 + ".*?" + c3
    };
  };
  const IDENT_MODE = function(name2, begin, relevance) {
    return {
      className: name2,
      begin,
      relevance
    };
  };
  const AT_KEYWORDS = {
    $pattern: /[a-z-]+/,
    keyword: AT_MODIFIERS,
    attribute: MEDIA_FEATURES$1.join(" ")
  };
  const PARENS_MODE = {
    // used only to properly balance nested parens inside mixin call, def. arg list
    begin: "\\(",
    end: "\\)",
    contains: VALUE_MODES,
    keywords: AT_KEYWORDS,
    relevance: 0
  };
  VALUE_MODES.push(
    hljs.C_LINE_COMMENT_MODE,
    hljs.C_BLOCK_COMMENT_MODE,
    STRING_MODE("'"),
    STRING_MODE('"'),
    modes.CSS_NUMBER_MODE,
    // fixme: it does not include dot for numbers like .5em :(
    {
      begin: "(url|data-uri)\\(",
      starts: {
        className: "string",
        end: "[\\)\\n]",
        excludeEnd: true
      }
    },
    modes.HEXCOLOR,
    PARENS_MODE,
    IDENT_MODE("variable", "@@?" + IDENT_RE2, 10),
    IDENT_MODE("variable", "@\\{" + IDENT_RE2 + "\\}"),
    IDENT_MODE("built_in", "~?`[^`]*?`"),
    // inline javascript (or whatever host language) *multiline* string
    {
      // @media features (it’s here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
      className: "attribute",
      begin: IDENT_RE2 + "\\s*:",
      end: ":",
      returnBegin: true,
      excludeEnd: true
    },
    modes.IMPORTANT,
    { beginKeywords: "and not" },
    modes.FUNCTION_DISPATCH
  );
  const VALUE_WITH_RULESETS = VALUE_MODES.concat({
    begin: /\{/,
    end: /\}/,
    contains: RULES
  });
  const MIXIN_GUARD_MODE = {
    beginKeywords: "when",
    endsWithParent: true,
    contains: [{ beginKeywords: "and not" }].concat(VALUE_MODES)
    // using this form to override VALUE’s 'function' match
  };
  const RULE_MODE = {
    begin: INTERP_IDENT_RE + "\\s*:",
    returnBegin: true,
    end: /[;}]/,
    relevance: 0,
    contains: [
      { begin: /-(webkit|moz|ms|o)-/ },
      modes.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + ATTRIBUTES$1.join("|") + ")\\b",
        end: /(?=:)/,
        starts: {
          endsWithParent: true,
          illegal: "[<=$]",
          relevance: 0,
          contains: VALUE_MODES
        }
      }
    ]
  };
  const AT_RULE_MODE = {
    className: "keyword",
    begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
    starts: {
      end: "[;{}]",
      keywords: AT_KEYWORDS,
      returnEnd: true,
      contains: VALUE_MODES,
      relevance: 0
    }
  };
  const VAR_RULE_MODE = {
    className: "variable",
    variants: [
      // using more strict pattern for higher relevance to increase chances of Less detection.
      // this is *the only* Less specific statement used in most of the sources, so...
      // (we’ll still often loose to the css-parser unless there's '//' comment,
      // simply because 1 variable just can't beat 99 properties :)
      {
        begin: "@" + IDENT_RE2 + "\\s*:",
        relevance: 15
      },
      { begin: "@" + IDENT_RE2 }
    ],
    starts: {
      end: "[;}]",
      returnEnd: true,
      contains: VALUE_WITH_RULESETS
    }
  };
  const SELECTOR_MODE = {
    // first parse unambiguous selectors (i.e. those not starting with tag)
    // then fall into the scary lookahead-discriminator variant.
    // this mode also handles mixin definitions and calls
    variants: [
      {
        begin: "[\\.#:&\\[>]",
        end: "[;{}]"
        // mixin calls end with ';'
      },
      {
        begin: INTERP_IDENT_RE,
        end: /\{/
      }
    ],
    returnBegin: true,
    returnEnd: true,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      MIXIN_GUARD_MODE,
      IDENT_MODE("keyword", "all\\b"),
      IDENT_MODE("variable", "@\\{" + IDENT_RE2 + "\\}"),
      // otherwise it’s identified as tag
      {
        begin: "\\b(" + TAGS$1.join("|") + ")\\b",
        className: "selector-tag"
      },
      modes.CSS_NUMBER_MODE,
      IDENT_MODE("selector-tag", INTERP_IDENT_RE, 0),
      IDENT_MODE("selector-id", "#" + INTERP_IDENT_RE),
      IDENT_MODE("selector-class", "\\." + INTERP_IDENT_RE, 0),
      IDENT_MODE("selector-tag", "&", 0),
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        begin: ":(" + PSEUDO_CLASSES$1.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + PSEUDO_ELEMENTS$1.join("|") + ")"
      },
      {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        contains: VALUE_WITH_RULESETS
      },
      // argument list of parametric mixins
      { begin: "!important" },
      // eat !important after mixin call or it will be colored as tag
      modes.FUNCTION_DISPATCH
    ]
  };
  const PSEUDO_SELECTOR_MODE = {
    begin: IDENT_RE2 + `:(:)?(${PSEUDO_SELECTORS$1.join("|")})`,
    returnBegin: true,
    contains: [SELECTOR_MODE]
  };
  RULES.push(
    hljs.C_LINE_COMMENT_MODE,
    hljs.C_BLOCK_COMMENT_MODE,
    AT_RULE_MODE,
    VAR_RULE_MODE,
    PSEUDO_SELECTOR_MODE,
    RULE_MODE,
    SELECTOR_MODE,
    MIXIN_GUARD_MODE,
    modes.FUNCTION_DISPATCH
  );
  return {
    name: "Less",
    case_insensitive: true,
    illegal: `[=>'/<($"]`,
    contains: RULES
  };
}
function lua(hljs) {
  const OPENING_LONG_BRACKET = "\\[=*\\[";
  const CLOSING_LONG_BRACKET = "\\]=*\\]";
  const LONG_BRACKETS = {
    begin: OPENING_LONG_BRACKET,
    end: CLOSING_LONG_BRACKET,
    contains: ["self"]
  };
  const COMMENTS = [
    hljs.COMMENT("--(?!" + OPENING_LONG_BRACKET + ")", "$"),
    hljs.COMMENT(
      "--" + OPENING_LONG_BRACKET,
      CLOSING_LONG_BRACKET,
      {
        contains: [LONG_BRACKETS],
        relevance: 10
      }
    )
  ];
  return {
    name: "Lua",
    keywords: {
      $pattern: hljs.UNDERSCORE_IDENT_RE,
      literal: "true false nil",
      keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
      built_in: (
        // Metatags and globals:
        "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
      )
    },
    contains: COMMENTS.concat([
      {
        className: "function",
        beginKeywords: "function",
        end: "\\)",
        contains: [
          hljs.inherit(hljs.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
          {
            className: "params",
            begin: "\\(",
            endsWithParent: true,
            contains: COMMENTS
          }
        ].concat(COMMENTS)
      },
      hljs.C_NUMBER_MODE,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        className: "string",
        begin: OPENING_LONG_BRACKET,
        end: CLOSING_LONG_BRACKET,
        contains: [LONG_BRACKETS],
        relevance: 5
      }
    ])
  };
}
function makefile(hljs) {
  const VARIABLE = {
    className: "variable",
    variants: [
      {
        begin: "\\$\\(" + hljs.UNDERSCORE_IDENT_RE + "\\)",
        contains: [hljs.BACKSLASH_ESCAPE]
      },
      { begin: /\$[@%<?\^\+\*]/ }
    ]
  };
  const QUOTE_STRING = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      hljs.BACKSLASH_ESCAPE,
      VARIABLE
    ]
  };
  const FUNC = {
    className: "variable",
    begin: /\$\([\w-]+\s/,
    end: /\)/,
    keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
    contains: [VARIABLE]
  };
  const ASSIGNMENT = { begin: "^" + hljs.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" };
  const META = {
    className: "meta",
    begin: /^\.PHONY:/,
    end: /$/,
    keywords: {
      $pattern: /[\.\w]+/,
      keyword: ".PHONY"
    }
  };
  const TARGET = {
    className: "section",
    begin: /^[^\s]+:/,
    end: /$/,
    contains: [VARIABLE]
  };
  return {
    name: "Makefile",
    aliases: [
      "mk",
      "mak",
      "make"
    ],
    keywords: {
      $pattern: /[\w-]+/,
      keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
    },
    contains: [
      hljs.HASH_COMMENT_MODE,
      VARIABLE,
      QUOTE_STRING,
      FUNC,
      ASSIGNMENT,
      META,
      TARGET
    ]
  };
}
function markdown(hljs) {
  const regex2 = hljs.regex;
  const INLINE_HTML = {
    begin: /<\/?[A-Za-z_]/,
    end: ">",
    subLanguage: "xml",
    relevance: 0
  };
  const HORIZONTAL_RULE = {
    begin: "^[-\\*]{3,}",
    end: "$"
  };
  const CODE = {
    className: "code",
    variants: [
      // TODO: fix to allow these to work with sublanguage also
      { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
      { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
      // needed to allow markdown as a sublanguage to work
      {
        begin: "```",
        end: "```+[ ]*$"
      },
      {
        begin: "~~~",
        end: "~~~+[ ]*$"
      },
      { begin: "`.+?`" },
      {
        begin: "(?=^( {4}|\\t))",
        // use contains to gobble up multiple lines to allow the block to be whatever size
        // but only have a single open/close tag vs one per line
        contains: [
          {
            begin: "^( {4}|\\t)",
            end: "(\\n)$"
          }
        ],
        relevance: 0
      }
    ]
  };
  const LIST = {
    className: "bullet",
    begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
    end: "\\s+",
    excludeEnd: true
  };
  const LINK_REFERENCE = {
    begin: /^\[[^\n]+\]:/,
    returnBegin: true,
    contains: [
      {
        className: "symbol",
        begin: /\[/,
        end: /\]/,
        excludeBegin: true,
        excludeEnd: true
      },
      {
        className: "link",
        begin: /:\s*/,
        end: /$/,
        excludeBegin: true
      }
    ]
  };
  const URL_SCHEME = /[A-Za-z][A-Za-z0-9+.-]*/;
  const LINK = {
    variants: [
      // too much like nested array access in so many languages
      // to have any real relevance
      {
        begin: /\[.+?\]\[.*?\]/,
        relevance: 0
      },
      // popular internet URLs
      {
        begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
        relevance: 2
      },
      {
        begin: regex2.concat(/\[.+?\]\(/, URL_SCHEME, /:\/\/.*?\)/),
        relevance: 2
      },
      // relative urls
      {
        begin: /\[.+?\]\([./?&#].*?\)/,
        relevance: 1
      },
      // whatever else, lower relevance (might not be a link at all)
      {
        begin: /\[.*?\]\(.*?\)/,
        relevance: 0
      }
    ],
    returnBegin: true,
    contains: [
      {
        // empty strings for alt or link text
        match: /\[(?=\])/
      },
      {
        className: "string",
        relevance: 0,
        begin: "\\[",
        end: "\\]",
        excludeBegin: true,
        returnEnd: true
      },
      {
        className: "link",
        relevance: 0,
        begin: "\\]\\(",
        end: "\\)",
        excludeBegin: true,
        excludeEnd: true
      },
      {
        className: "symbol",
        relevance: 0,
        begin: "\\]\\[",
        end: "\\]",
        excludeBegin: true,
        excludeEnd: true
      }
    ]
  };
  const BOLD = {
    className: "strong",
    contains: [],
    // defined later
    variants: [
      {
        begin: /_{2}(?!\s)/,
        end: /_{2}/
      },
      {
        begin: /\*{2}(?!\s)/,
        end: /\*{2}/
      }
    ]
  };
  const ITALIC = {
    className: "emphasis",
    contains: [],
    // defined later
    variants: [
      {
        begin: /\*(?![*\s])/,
        end: /\*/
      },
      {
        begin: /_(?![_\s])/,
        end: /_/,
        relevance: 0
      }
    ]
  };
  const BOLD_WITHOUT_ITALIC = hljs.inherit(BOLD, { contains: [] });
  const ITALIC_WITHOUT_BOLD = hljs.inherit(ITALIC, { contains: [] });
  BOLD.contains.push(ITALIC_WITHOUT_BOLD);
  ITALIC.contains.push(BOLD_WITHOUT_ITALIC);
  let CONTAINABLE = [
    INLINE_HTML,
    LINK
  ];
  [
    BOLD,
    ITALIC,
    BOLD_WITHOUT_ITALIC,
    ITALIC_WITHOUT_BOLD
  ].forEach((m10) => {
    m10.contains = m10.contains.concat(CONTAINABLE);
  });
  CONTAINABLE = CONTAINABLE.concat(BOLD, ITALIC);
  const HEADER = {
    className: "section",
    variants: [
      {
        begin: "^#{1,6}",
        end: "$",
        contains: CONTAINABLE
      },
      {
        begin: "(?=^.+?\\n[=-]{2,}$)",
        contains: [
          { begin: "^[=-]*$" },
          {
            begin: "^",
            end: "\\n",
            contains: CONTAINABLE
          }
        ]
      }
    ]
  };
  const BLOCKQUOTE = {
    className: "quote",
    begin: "^>\\s+",
    contains: CONTAINABLE,
    end: "$"
  };
  return {
    name: "Markdown",
    aliases: [
      "md",
      "mkdown",
      "mkd"
    ],
    contains: [
      HEADER,
      INLINE_HTML,
      LIST,
      BOLD,
      ITALIC,
      BLOCKQUOTE,
      CODE,
      HORIZONTAL_RULE,
      LINK,
      LINK_REFERENCE
    ]
  };
}
function objectivec(hljs) {
  const API_CLASS = {
    className: "built_in",
    begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
  };
  const IDENTIFIER_RE = /[a-zA-Z@][a-zA-Z0-9_]*/;
  const TYPES2 = [
    "int",
    "float",
    "char",
    "unsigned",
    "signed",
    "short",
    "long",
    "double",
    "wchar_t",
    "unichar",
    "void",
    "bool",
    "BOOL",
    "id|0",
    "_Bool"
  ];
  const KWS = [
    "while",
    "export",
    "sizeof",
    "typedef",
    "const",
    "struct",
    "for",
    "union",
    "volatile",
    "static",
    "mutable",
    "if",
    "do",
    "return",
    "goto",
    "enum",
    "else",
    "break",
    "extern",
    "asm",
    "case",
    "default",
    "register",
    "explicit",
    "typename",
    "switch",
    "continue",
    "inline",
    "readonly",
    "assign",
    "readwrite",
    "self",
    "@synchronized",
    "id",
    "typeof",
    "nonatomic",
    "IBOutlet",
    "IBAction",
    "strong",
    "weak",
    "copy",
    "in",
    "out",
    "inout",
    "bycopy",
    "byref",
    "oneway",
    "__strong",
    "__weak",
    "__block",
    "__autoreleasing",
    "@private",
    "@protected",
    "@public",
    "@try",
    "@property",
    "@end",
    "@throw",
    "@catch",
    "@finally",
    "@autoreleasepool",
    "@synthesize",
    "@dynamic",
    "@selector",
    "@optional",
    "@required",
    "@encode",
    "@package",
    "@import",
    "@defs",
    "@compatibility_alias",
    "__bridge",
    "__bridge_transfer",
    "__bridge_retained",
    "__bridge_retain",
    "__covariant",
    "__contravariant",
    "__kindof",
    "_Nonnull",
    "_Nullable",
    "_Null_unspecified",
    "__FUNCTION__",
    "__PRETTY_FUNCTION__",
    "__attribute__",
    "getter",
    "setter",
    "retain",
    "unsafe_unretained",
    "nonnull",
    "nullable",
    "null_unspecified",
    "null_resettable",
    "class",
    "instancetype",
    "NS_DESIGNATED_INITIALIZER",
    "NS_UNAVAILABLE",
    "NS_REQUIRES_SUPER",
    "NS_RETURNS_INNER_POINTER",
    "NS_INLINE",
    "NS_AVAILABLE",
    "NS_DEPRECATED",
    "NS_ENUM",
    "NS_OPTIONS",
    "NS_SWIFT_UNAVAILABLE",
    "NS_ASSUME_NONNULL_BEGIN",
    "NS_ASSUME_NONNULL_END",
    "NS_REFINED_FOR_SWIFT",
    "NS_SWIFT_NAME",
    "NS_SWIFT_NOTHROW",
    "NS_DURING",
    "NS_HANDLER",
    "NS_ENDHANDLER",
    "NS_VALUERETURN",
    "NS_VOIDRETURN"
  ];
  const LITERALS2 = [
    "false",
    "true",
    "FALSE",
    "TRUE",
    "nil",
    "YES",
    "NO",
    "NULL"
  ];
  const BUILT_INS2 = [
    "dispatch_once_t",
    "dispatch_queue_t",
    "dispatch_sync",
    "dispatch_async",
    "dispatch_once"
  ];
  const KEYWORDS2 = {
    "variable.language": [
      "this",
      "super"
    ],
    $pattern: IDENTIFIER_RE,
    keyword: KWS,
    literal: LITERALS2,
    built_in: BUILT_INS2,
    type: TYPES2
  };
  const CLASS_KEYWORDS = {
    $pattern: IDENTIFIER_RE,
    keyword: [
      "@interface",
      "@class",
      "@protocol",
      "@implementation"
    ]
  };
  return {
    name: "Objective-C",
    aliases: [
      "mm",
      "objc",
      "obj-c",
      "obj-c++",
      "objective-c++"
    ],
    keywords: KEYWORDS2,
    illegal: "</",
    contains: [
      API_CLASS,
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_NUMBER_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.APOS_STRING_MODE,
      {
        className: "string",
        variants: [
          {
            begin: '@"',
            end: '"',
            illegal: "\\n",
            contains: [hljs.BACKSLASH_ESCAPE]
          }
        ]
      },
      {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/,
            end: /$/,
            illegal: "\\n"
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        className: "class",
        begin: "(" + CLASS_KEYWORDS.keyword.join("|") + ")\\b",
        end: /(\{|$)/,
        excludeEnd: true,
        keywords: CLASS_KEYWORDS,
        contains: [hljs.UNDERSCORE_TITLE_MODE]
      },
      {
        begin: "\\." + hljs.UNDERSCORE_IDENT_RE,
        relevance: 0
      }
    ]
  };
}
function perl(hljs) {
  const regex2 = hljs.regex;
  const KEYWORDS2 = [
    "abs",
    "accept",
    "alarm",
    "and",
    "atan2",
    "bind",
    "binmode",
    "bless",
    "break",
    "caller",
    "chdir",
    "chmod",
    "chomp",
    "chop",
    "chown",
    "chr",
    "chroot",
    "close",
    "closedir",
    "connect",
    "continue",
    "cos",
    "crypt",
    "dbmclose",
    "dbmopen",
    "defined",
    "delete",
    "die",
    "do",
    "dump",
    "each",
    "else",
    "elsif",
    "endgrent",
    "endhostent",
    "endnetent",
    "endprotoent",
    "endpwent",
    "endservent",
    "eof",
    "eval",
    "exec",
    "exists",
    "exit",
    "exp",
    "fcntl",
    "fileno",
    "flock",
    "for",
    "foreach",
    "fork",
    "format",
    "formline",
    "getc",
    "getgrent",
    "getgrgid",
    "getgrnam",
    "gethostbyaddr",
    "gethostbyname",
    "gethostent",
    "getlogin",
    "getnetbyaddr",
    "getnetbyname",
    "getnetent",
    "getpeername",
    "getpgrp",
    "getpriority",
    "getprotobyname",
    "getprotobynumber",
    "getprotoent",
    "getpwent",
    "getpwnam",
    "getpwuid",
    "getservbyname",
    "getservbyport",
    "getservent",
    "getsockname",
    "getsockopt",
    "given",
    "glob",
    "gmtime",
    "goto",
    "grep",
    "gt",
    "hex",
    "if",
    "index",
    "int",
    "ioctl",
    "join",
    "keys",
    "kill",
    "last",
    "lc",
    "lcfirst",
    "length",
    "link",
    "listen",
    "local",
    "localtime",
    "log",
    "lstat",
    "lt",
    "ma",
    "map",
    "mkdir",
    "msgctl",
    "msgget",
    "msgrcv",
    "msgsnd",
    "my",
    "ne",
    "next",
    "no",
    "not",
    "oct",
    "open",
    "opendir",
    "or",
    "ord",
    "our",
    "pack",
    "package",
    "pipe",
    "pop",
    "pos",
    "print",
    "printf",
    "prototype",
    "push",
    "q|0",
    "qq",
    "quotemeta",
    "qw",
    "qx",
    "rand",
    "read",
    "readdir",
    "readline",
    "readlink",
    "readpipe",
    "recv",
    "redo",
    "ref",
    "rename",
    "require",
    "reset",
    "return",
    "reverse",
    "rewinddir",
    "rindex",
    "rmdir",
    "say",
    "scalar",
    "seek",
    "seekdir",
    "select",
    "semctl",
    "semget",
    "semop",
    "send",
    "setgrent",
    "sethostent",
    "setnetent",
    "setpgrp",
    "setpriority",
    "setprotoent",
    "setpwent",
    "setservent",
    "setsockopt",
    "shift",
    "shmctl",
    "shmget",
    "shmread",
    "shmwrite",
    "shutdown",
    "sin",
    "sleep",
    "socket",
    "socketpair",
    "sort",
    "splice",
    "split",
    "sprintf",
    "sqrt",
    "srand",
    "stat",
    "state",
    "study",
    "sub",
    "substr",
    "symlink",
    "syscall",
    "sysopen",
    "sysread",
    "sysseek",
    "system",
    "syswrite",
    "tell",
    "telldir",
    "tie",
    "tied",
    "time",
    "times",
    "tr",
    "truncate",
    "uc",
    "ucfirst",
    "umask",
    "undef",
    "unless",
    "unlink",
    "unpack",
    "unshift",
    "untie",
    "until",
    "use",
    "utime",
    "values",
    "vec",
    "wait",
    "waitpid",
    "wantarray",
    "warn",
    "when",
    "while",
    "write",
    "x|0",
    "xor",
    "y|0"
  ];
  const REGEX_MODIFIERS = /[dualxmsipngr]{0,12}/;
  const PERL_KEYWORDS = {
    $pattern: /[\w.]+/,
    keyword: KEYWORDS2.join(" ")
  };
  const SUBST = {
    className: "subst",
    begin: "[$@]\\{",
    end: "\\}",
    keywords: PERL_KEYWORDS
  };
  const METHOD = {
    begin: /->\{/,
    end: /\}/
    // contains defined later
  };
  const VAR = { variants: [
    { begin: /\$\d/ },
    { begin: regex2.concat(
      /[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
      // negative look-ahead tries to avoid matching patterns that are not
      // Perl at all like $ident$, @ident@, etc.
      `(?![A-Za-z])(?![@$%])`
    ) },
    {
      begin: /[$%@][^\s\w{]/,
      relevance: 0
    }
  ] };
  const STRING_CONTAINS = [
    hljs.BACKSLASH_ESCAPE,
    SUBST,
    VAR
  ];
  const REGEX_DELIMS = [
    /!/,
    /\//,
    /\|/,
    /\?/,
    /'/,
    /"/,
    // valid but infrequent and weird
    /#/
    // valid but infrequent and weird
  ];
  const PAIRED_DOUBLE_RE = (prefix, open, close = "\\1") => {
    const middle = close === "\\1" ? close : regex2.concat(close, open);
    return regex2.concat(
      regex2.concat("(?:", prefix, ")"),
      open,
      /(?:\\.|[^\\\/])*?/,
      middle,
      /(?:\\.|[^\\\/])*?/,
      close,
      REGEX_MODIFIERS
    );
  };
  const PAIRED_RE = (prefix, open, close) => {
    return regex2.concat(
      regex2.concat("(?:", prefix, ")"),
      open,
      /(?:\\.|[^\\\/])*?/,
      close,
      REGEX_MODIFIERS
    );
  };
  const PERL_DEFAULT_CONTAINS = [
    VAR,
    hljs.HASH_COMMENT_MODE,
    hljs.COMMENT(
      /^=\w/,
      /=cut/,
      { endsWithParent: true }
    ),
    METHOD,
    {
      className: "string",
      contains: STRING_CONTAINS,
      variants: [
        {
          begin: "q[qwxr]?\\s*\\(",
          end: "\\)",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\[",
          end: "\\]",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\{",
          end: "\\}",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\|",
          end: "\\|",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*<",
          end: ">",
          relevance: 5
        },
        {
          begin: "qw\\s+q",
          end: "q",
          relevance: 5
        },
        {
          begin: "'",
          end: "'",
          contains: [hljs.BACKSLASH_ESCAPE]
        },
        {
          begin: '"',
          end: '"'
        },
        {
          begin: "`",
          end: "`",
          contains: [hljs.BACKSLASH_ESCAPE]
        },
        {
          begin: /\{\w+\}/,
          relevance: 0
        },
        {
          begin: "-?\\w+\\s*=>",
          relevance: 0
        }
      ]
    },
    {
      className: "number",
      begin: "(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",
      relevance: 0
    },
    {
      // regexp container
      begin: "(\\/\\/|" + hljs.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
      keywords: "split return print reverse grep",
      relevance: 0,
      contains: [
        hljs.HASH_COMMENT_MODE,
        {
          className: "regexp",
          variants: [
            // allow matching common delimiters
            { begin: PAIRED_DOUBLE_RE("s|tr|y", regex2.either(...REGEX_DELIMS, { capture: true })) },
            // and then paired delmis
            { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\(", "\\)") },
            { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\[", "\\]") },
            { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\{", "\\}") }
          ],
          relevance: 2
        },
        {
          className: "regexp",
          variants: [
            {
              // could be a comment in many languages so do not count
              // as relevant
              begin: /(m|qr)\/\//,
              relevance: 0
            },
            // prefix is optional with /regex/
            { begin: PAIRED_RE("(?:m|qr)?", /\//, /\//) },
            // allow matching common delimiters
            { begin: PAIRED_RE("m|qr", regex2.either(...REGEX_DELIMS, { capture: true }), /\1/) },
            // allow common paired delmins
            { begin: PAIRED_RE("m|qr", /\(/, /\)/) },
            { begin: PAIRED_RE("m|qr", /\[/, /\]/) },
            { begin: PAIRED_RE("m|qr", /\{/, /\}/) }
          ]
        }
      ]
    },
    {
      className: "function",
      beginKeywords: "sub",
      end: "(\\s*\\(.*?\\))?[;{]",
      excludeEnd: true,
      relevance: 5,
      contains: [hljs.TITLE_MODE]
    },
    {
      begin: "-\\w\\b",
      relevance: 0
    },
    {
      begin: "^__DATA__$",
      end: "^__END__$",
      subLanguage: "mojolicious",
      contains: [
        {
          begin: "^@@.*",
          end: "$",
          className: "comment"
        }
      ]
    }
  ];
  SUBST.contains = PERL_DEFAULT_CONTAINS;
  METHOD.contains = PERL_DEFAULT_CONTAINS;
  return {
    name: "Perl",
    aliases: [
      "pl",
      "pm"
    ],
    keywords: PERL_KEYWORDS,
    contains: PERL_DEFAULT_CONTAINS
  };
}
function php(hljs) {
  const regex2 = hljs.regex;
  const NOT_PERL_ETC = /(?![A-Za-z0-9])(?![$])/;
  const IDENT_RE2 = regex2.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    NOT_PERL_ETC
  );
  const PASCAL_CASE_CLASS_NAME_RE = regex2.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    NOT_PERL_ETC
  );
  const VARIABLE = {
    scope: "variable",
    match: "\\$+" + IDENT_RE2
  };
  const PREPROCESSOR = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      // boost for obvious PHP
      { begin: /<\?=/ },
      // less relevant per PSR-1 which says not to use short-tags
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
      // end php tag
    ]
  };
  const SUBST = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  };
  const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, { illegal: null });
  const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
    illegal: null,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
  });
  const HEREDOC = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
    "on:begin": (m10, resp) => {
      resp.data._beginMatch = m10[1] || m10[2];
    },
    "on:end": (m10, resp) => {
      if (resp.data._beginMatch !== m10[1])
        resp.ignoreMatch();
    }
  };
  const NOWDOC = hljs.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  });
  const WHITESPACE = "[ 	\n]";
  const STRING = {
    scope: "string",
    variants: [
      DOUBLE_QUOTED,
      SINGLE_QUOTED,
      HEREDOC,
      NOWDOC
    ]
  };
  const NUMBER = {
    scope: "number",
    variants: [
      { begin: `\\b0[bB][01]+(?:_[01]+)*\\b` },
      // Binary w/ underscore support
      { begin: `\\b0[oO][0-7]+(?:_[0-7]+)*\\b` },
      // Octals w/ underscore support
      { begin: `\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b` },
      // Hex w/ underscore support
      // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
      { begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?` }
    ],
    relevance: 0
  };
  const LITERALS2 = [
    "false",
    "null",
    "true"
  ];
  const KWS = [
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ];
  const BUILT_INS2 = [
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ];
  const dualCase = (items) => {
    const result = [];
    items.forEach((item) => {
      result.push(item);
      if (item.toLowerCase() === item) {
        result.push(item.toUpperCase());
      } else {
        result.push(item.toLowerCase());
      }
    });
    return result;
  };
  const KEYWORDS2 = {
    keyword: KWS,
    literal: dualCase(LITERALS2),
    built_in: BUILT_INS2
  };
  const normalizeKeywords = (items) => {
    return items.map((item) => {
      return item.replace(/\|\d+$/, "");
    });
  };
  const CONSTRUCTOR_CALL = { variants: [
    {
      match: [
        /new/,
        regex2.concat(WHITESPACE, "+"),
        // to prevent built ins from being confused as the class constructor call
        regex2.concat("(?!", normalizeKeywords(BUILT_INS2).join("\\b|"), "\\b)"),
        PASCAL_CASE_CLASS_NAME_RE
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] };
  const CONSTANT_REFERENCE = regex2.concat(IDENT_RE2, "\\b(?!\\()");
  const LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON = { variants: [
    {
      match: [
        regex2.concat(
          /::/,
          regex2.lookahead(/(?!class\b)/)
        ),
        CONSTANT_REFERENCE
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        regex2.concat(
          /::/,
          regex2.lookahead(/(?!class\b)/)
        ),
        CONSTANT_REFERENCE
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        regex2.concat(
          "::",
          regex2.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] };
  const NAMED_ARGUMENT = {
    scope: "attr",
    match: regex2.concat(IDENT_RE2, regex2.lookahead(":"), regex2.lookahead(/(?!::)/))
  };
  const PARAMS_MODE = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: KEYWORDS2,
    contains: [
      NAMED_ARGUMENT,
      VARIABLE,
      LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
      hljs.C_BLOCK_COMMENT_MODE,
      STRING,
      NUMBER,
      CONSTRUCTOR_CALL
    ]
  };
  const FUNCTION_INVOKE = {
    relevance: 0,
    match: [
      /\b/,
      // to prevent keywords from being confused as the function title
      regex2.concat("(?!fn\\b|function\\b|", normalizeKeywords(KWS).join("\\b|"), "|", normalizeKeywords(BUILT_INS2).join("\\b|"), "\\b)"),
      IDENT_RE2,
      regex2.concat(WHITESPACE, "*"),
      regex2.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [PARAMS_MODE]
  };
  PARAMS_MODE.contains.push(FUNCTION_INVOKE);
  const ATTRIBUTE_CONTAINS = [
    NAMED_ARGUMENT,
    LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
    hljs.C_BLOCK_COMMENT_MODE,
    STRING,
    NUMBER,
    CONSTRUCTOR_CALL
  ];
  const ATTRIBUTES2 = {
    begin: regex2.concat(/#\[\s*/, PASCAL_CASE_CLASS_NAME_RE),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: LITERALS2,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: LITERALS2,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...ATTRIBUTE_CONTAINS
        ]
      },
      ...ATTRIBUTE_CONTAINS,
      {
        scope: "meta",
        match: PASCAL_CASE_CLASS_NAME_RE
      }
    ]
  };
  return {
    case_insensitive: false,
    keywords: KEYWORDS2,
    contains: [
      ATTRIBUTES2,
      hljs.HASH_COMMENT_MODE,
      hljs.COMMENT("//", "$"),
      hljs.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: hljs.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: true
            }
          ]
        }
      },
      PREPROCESSOR,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      VARIABLE,
      FUNCTION_INVOKE,
      LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
      {
        match: [
          /const/,
          /\s/,
          IDENT_RE2
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      CONSTRUCTOR_CALL,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: true,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          hljs.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            // No markup, just a relevance booster
            endsParent: true
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS2,
            contains: [
              "self",
              VARIABLE,
              LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
              hljs.C_BLOCK_COMMENT_MODE,
              STRING,
              NUMBER
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: true,
        contains: [
          { beginKeywords: "extends implements" },
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      // both use and namespace still use "old style" rules (vs multi-match)
      // because the namespace name can include `\` and we still want each
      // element to be treated as its own *individual* title
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [hljs.inherit(hljs.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          // TODO: title.function vs title.class
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          // TODO: could be title.class or title.function
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      STRING,
      NUMBER
    ]
  };
}
function phpTemplate(hljs) {
  return {
    name: "PHP template",
    subLanguage: "xml",
    contains: [
      {
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [
          // We don't want the php closing tag ?> to close the PHP block when
          // inside any of the following blocks:
          {
            begin: "/\\*",
            end: "\\*/",
            skip: true
          },
          {
            begin: 'b"',
            end: '"',
            skip: true
          },
          {
            begin: "b'",
            end: "'",
            skip: true
          },
          hljs.inherit(hljs.APOS_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: true
          }),
          hljs.inherit(hljs.QUOTE_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: true
          })
        ]
      }
    ]
  };
}
function plaintext(hljs) {
  return {
    name: "Plain text",
    aliases: [
      "text",
      "txt"
    ],
    disableAutodetect: true
  };
}
function python(hljs) {
  const regex2 = hljs.regex;
  const IDENT_RE2 = /[\p{XID_Start}_]\p{XID_Continue}*/u;
  const RESERVED_WORDS = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ];
  const BUILT_INS2 = [
    "__import__",
    "abs",
    "all",
    "any",
    "ascii",
    "bin",
    "bool",
    "breakpoint",
    "bytearray",
    "bytes",
    "callable",
    "chr",
    "classmethod",
    "compile",
    "complex",
    "delattr",
    "dict",
    "dir",
    "divmod",
    "enumerate",
    "eval",
    "exec",
    "filter",
    "float",
    "format",
    "frozenset",
    "getattr",
    "globals",
    "hasattr",
    "hash",
    "help",
    "hex",
    "id",
    "input",
    "int",
    "isinstance",
    "issubclass",
    "iter",
    "len",
    "list",
    "locals",
    "map",
    "max",
    "memoryview",
    "min",
    "next",
    "object",
    "oct",
    "open",
    "ord",
    "pow",
    "print",
    "property",
    "range",
    "repr",
    "reversed",
    "round",
    "set",
    "setattr",
    "slice",
    "sorted",
    "staticmethod",
    "str",
    "sum",
    "super",
    "tuple",
    "type",
    "vars",
    "zip"
  ];
  const LITERALS2 = [
    "__debug__",
    "Ellipsis",
    "False",
    "None",
    "NotImplemented",
    "True"
  ];
  const TYPES2 = [
    "Any",
    "Callable",
    "Coroutine",
    "Dict",
    "List",
    "Literal",
    "Generic",
    "Optional",
    "Sequence",
    "Set",
    "Tuple",
    "Type",
    "Union"
  ];
  const KEYWORDS2 = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: RESERVED_WORDS,
    built_in: BUILT_INS2,
    literal: LITERALS2,
    type: TYPES2
  };
  const PROMPT = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  };
  const SUBST = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS2,
    illegal: /#/
  };
  const LITERAL_BRACKET = {
    begin: /\{\{/,
    relevance: 0
  };
  const STRING = {
    className: "string",
    contains: [hljs.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE
    ]
  };
  const digitpart = "[0-9](_?[0-9])*";
  const pointfloat = `(\\b(${digitpart}))?\\.(${digitpart})|\\b(${digitpart})\\.`;
  const lookahead2 = `\\b|${RESERVED_WORDS.join("|")}`;
  const NUMBER = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?(?=${lookahead2})`
      },
      {
        begin: `(${pointfloat})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${lookahead2})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${lookahead2})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${lookahead2})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${lookahead2})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${digitpart})[jJ](?=${lookahead2})`
      }
    ]
  };
  const COMMENT_TYPE = {
    className: "comment",
    begin: regex2.lookahead(/# type:/),
    end: /$/,
    keywords: KEYWORDS2,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: true
      }
    ]
  };
  const PARAMS = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: true
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS2,
        contains: [
          "self",
          PROMPT,
          NUMBER,
          STRING,
          hljs.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  SUBST.contains = [
    STRING,
    NUMBER,
    PROMPT
  ];
  return {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: true,
    keywords: KEYWORDS2,
    illegal: /(<\/|\?)|=>/,
    contains: [
      PROMPT,
      NUMBER,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      STRING,
      COMMENT_TYPE,
      hljs.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          IDENT_RE2
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [PARAMS]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              IDENT_RE2,
              /\s*/,
              /\(\s*/,
              IDENT_RE2,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              IDENT_RE2
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          NUMBER,
          PARAMS,
          STRING
        ]
      }
    ]
  };
}
function pythonRepl(hljs) {
  return {
    aliases: ["pycon"],
    contains: [
      {
        className: "meta.prompt",
        starts: {
          // a space separates the REPL prefix from the actual code
          // this is purely for cleaner HTML output
          end: / |$/,
          starts: {
            end: "$",
            subLanguage: "python"
          }
        },
        variants: [
          { begin: /^>>>(?=[ ]|$)/ },
          { begin: /^\.\.\.(?=[ ]|$)/ }
        ]
      }
    ]
  };
}
function r(hljs) {
  const regex2 = hljs.regex;
  const IDENT_RE2 = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/;
  const NUMBER_TYPES_RE = regex2.either(
    // Special case: only hexadecimal binary powers can contain fractions
    /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
    // Hexadecimal numbers without fraction and optional binary power
    /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
    // Decimal numbers
    /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
  );
  const OPERATORS_RE = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/;
  const PUNCTUATION_RE = regex2.either(
    /[()]/,
    /[{}]/,
    /\[\[/,
    /[[\]]/,
    /\\/,
    /,/
  );
  return {
    name: "R",
    keywords: {
      $pattern: IDENT_RE2,
      keyword: "function if in break next repeat else for while",
      literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
      built_in: (
        // Builtin constants
        "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
      )
    },
    contains: [
      // Roxygen comments
      hljs.COMMENT(
        /#'/,
        /$/,
        { contains: [
          {
            // Handle `@examples` separately to cause all subsequent code
            // until the next `@`-tag on its own line to be kept as-is,
            // preventing highlighting. This code is example R code, so nested
            // doctags shouldn’t be treated as such. See
            // `test/markup/r/roxygen.txt` for an example.
            scope: "doctag",
            match: /@examples/,
            starts: {
              end: regex2.lookahead(regex2.either(
                // end if another doc comment
                /\n^#'\s*(?=@[a-zA-Z]+)/,
                // or a line with no comment
                /\n^(?!#')/
              )),
              endsParent: true
            }
          },
          {
            // Handle `@param` to highlight the parameter name following
            // after.
            scope: "doctag",
            begin: "@param",
            end: /$/,
            contains: [
              {
                scope: "variable",
                variants: [
                  { match: IDENT_RE2 },
                  { match: /`(?:\\.|[^`\\])+`/ }
                ],
                endsParent: true
              }
            ]
          },
          {
            scope: "doctag",
            match: /@[a-zA-Z]+/
          },
          {
            scope: "keyword",
            match: /\\[a-zA-Z]+/
          }
        ] }
      ),
      hljs.HASH_COMMENT_MODE,
      {
        scope: "string",
        contains: [hljs.BACKSLASH_ESCAPE],
        variants: [
          hljs.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\(/,
            end: /\)(-*)"/
          }),
          hljs.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\{/,
            end: /\}(-*)"/
          }),
          hljs.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\[/,
            end: /\](-*)"/
          }),
          hljs.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\(/,
            end: /\)(-*)'/
          }),
          hljs.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\{/,
            end: /\}(-*)'/
          }),
          hljs.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\[/,
            end: /\](-*)'/
          }),
          {
            begin: '"',
            end: '"',
            relevance: 0
          },
          {
            begin: "'",
            end: "'",
            relevance: 0
          }
        ]
      },
      // Matching numbers immediately following punctuation and operators is
      // tricky since we need to look at the character ahead of a number to
      // ensure the number is not part of an identifier, and we cannot use
      // negative look-behind assertions. So instead we explicitly handle all
      // possible combinations of (operator|punctuation), number.
      // TODO: replace with negative look-behind when available
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
      // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
      {
        relevance: 0,
        variants: [
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              OPERATORS_RE,
              NUMBER_TYPES_RE
            ]
          },
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              /%[^%]*%/,
              NUMBER_TYPES_RE
            ]
          },
          {
            scope: {
              1: "punctuation",
              2: "number"
            },
            match: [
              PUNCTUATION_RE,
              NUMBER_TYPES_RE
            ]
          },
          {
            scope: { 2: "number" },
            match: [
              /[^a-zA-Z0-9._]|^/,
              // not part of an identifier, or start of document
              NUMBER_TYPES_RE
            ]
          }
        ]
      },
      // Operators/punctuation when they're not directly followed by numbers
      {
        // Relevance boost for the most common assignment form.
        scope: { 3: "operator" },
        match: [
          IDENT_RE2,
          /\s+/,
          /<-/,
          /\s+/
        ]
      },
      {
        scope: "operator",
        relevance: 0,
        variants: [
          { match: OPERATORS_RE },
          { match: /%[^%]*%/ }
        ]
      },
      {
        scope: "punctuation",
        relevance: 0,
        match: PUNCTUATION_RE
      },
      {
        // Escaped identifier
        begin: "`",
        end: "`",
        contains: [{ begin: /\\./ }]
      }
    ]
  };
}
function ruby(hljs) {
  const regex2 = hljs.regex;
  const RUBY_METHOD_RE = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)";
  const CLASS_NAME_RE = regex2.either(
    /\b([A-Z]+[a-z0-9]+)+/,
    // ends in caps
    /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
  );
  const CLASS_NAME_WITH_NAMESPACE_RE = regex2.concat(CLASS_NAME_RE, /(::\w+)*/);
  const PSEUDO_KWS = [
    "include",
    "extend",
    "prepend",
    "public",
    "private",
    "protected",
    "raise",
    "throw"
  ];
  const RUBY_KEYWORDS = {
    "variable.constant": [
      "__FILE__",
      "__LINE__",
      "__ENCODING__"
    ],
    "variable.language": [
      "self",
      "super"
    ],
    keyword: [
      "alias",
      "and",
      "begin",
      "BEGIN",
      "break",
      "case",
      "class",
      "defined",
      "do",
      "else",
      "elsif",
      "end",
      "END",
      "ensure",
      "for",
      "if",
      "in",
      "module",
      "next",
      "not",
      "or",
      "redo",
      "require",
      "rescue",
      "retry",
      "return",
      "then",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield",
      ...PSEUDO_KWS
    ],
    built_in: [
      "proc",
      "lambda",
      "attr_accessor",
      "attr_reader",
      "attr_writer",
      "define_method",
      "private_constant",
      "module_function"
    ],
    literal: [
      "true",
      "false",
      "nil"
    ]
  };
  const YARDOCTAG = {
    className: "doctag",
    begin: "@[A-Za-z]+"
  };
  const IRB_OBJECT = {
    begin: "#<",
    end: ">"
  };
  const COMMENT_MODES = [
    hljs.COMMENT(
      "#",
      "$",
      { contains: [YARDOCTAG] }
    ),
    hljs.COMMENT(
      "^=begin",
      "^=end",
      {
        contains: [YARDOCTAG],
        relevance: 10
      }
    ),
    hljs.COMMENT("^__END__", hljs.MATCH_NOTHING_RE)
  ];
  const SUBST = {
    className: "subst",
    begin: /#\{/,
    end: /\}/,
    keywords: RUBY_KEYWORDS
  };
  const STRING = {
    className: "string",
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ],
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      {
        begin: /`/,
        end: /`/
      },
      {
        begin: /%[qQwWx]?\(/,
        end: /\)/
      },
      {
        begin: /%[qQwWx]?\[/,
        end: /\]/
      },
      {
        begin: /%[qQwWx]?\{/,
        end: /\}/
      },
      {
        begin: /%[qQwWx]?</,
        end: />/
      },
      {
        begin: /%[qQwWx]?\//,
        end: /\//
      },
      {
        begin: /%[qQwWx]?%/,
        end: /%/
      },
      {
        begin: /%[qQwWx]?-/,
        end: /-/
      },
      {
        begin: /%[qQwWx]?\|/,
        end: /\|/
      },
      // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
      // where ? is the last character of a preceding identifier, as in: `func?4`
      { begin: /\B\?(\\\d{1,3})/ },
      { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
      { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
      { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
      { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
      { begin: /\B\?\\?\S/ },
      // heredocs
      {
        // this guard makes sure that we have an entire heredoc and not a false
        // positive (auto-detect, etc.)
        begin: regex2.concat(
          /<<[-~]?'?/,
          regex2.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
        ),
        contains: [
          hljs.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST
            ]
          })
        ]
      }
    ]
  };
  const decimal = "[1-9](_?[0-9])*|0";
  const digits = "[0-9](_?[0-9])*";
  const NUMBER = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal integer/float, optionally exponential or rational, optionally imaginary
      { begin: `\\b(${decimal})(\\.(${digits}))?([eE][+-]?(${digits})|r)?i?\\b` },
      // explicit decimal/binary/octal/hexadecimal integer,
      // optionally rational and/or imaginary
      { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
      // 0-prefixed implicit octal integer, optionally rational and/or imaginary
      { begin: "\\b0(_?[0-7])+r?i?\\b" }
    ]
  };
  const PARAMS = {
    variants: [
      {
        match: /\(\)/
      },
      {
        className: "params",
        begin: /\(/,
        end: /(?=\))/,
        excludeBegin: true,
        endsParent: true,
        keywords: RUBY_KEYWORDS
      }
    ]
  };
  const INCLUDE_EXTEND = {
    match: [
      /(include|extend)\s+/,
      CLASS_NAME_WITH_NAMESPACE_RE
    ],
    scope: {
      2: "title.class"
    },
    keywords: RUBY_KEYWORDS
  };
  const CLASS_DEFINITION = {
    variants: [
      {
        match: [
          /class\s+/,
          CLASS_NAME_WITH_NAMESPACE_RE,
          /\s+<\s+/,
          CLASS_NAME_WITH_NAMESPACE_RE
        ]
      },
      {
        match: [
          /\b(class|module)\s+/,
          CLASS_NAME_WITH_NAMESPACE_RE
        ]
      }
    ],
    scope: {
      2: "title.class",
      4: "title.class.inherited"
    },
    keywords: RUBY_KEYWORDS
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  const METHOD_DEFINITION = {
    match: [
      /def/,
      /\s+/,
      RUBY_METHOD_RE
    ],
    scope: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };
  const OBJECT_CREATION = {
    relevance: 0,
    match: [
      CLASS_NAME_WITH_NAMESPACE_RE,
      /\.new[. (]/
    ],
    scope: {
      1: "title.class"
    }
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: CLASS_NAME_RE,
    scope: "title.class"
  };
  const RUBY_DEFAULT_CONTAINS = [
    STRING,
    CLASS_DEFINITION,
    INCLUDE_EXTEND,
    OBJECT_CREATION,
    UPPER_CASE_CONSTANT,
    CLASS_REFERENCE,
    METHOD_DEFINITION,
    {
      // swallow namespace qualifiers before symbols
      begin: hljs.IDENT_RE + "::"
    },
    {
      className: "symbol",
      begin: hljs.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
      relevance: 0
    },
    {
      className: "symbol",
      begin: ":(?!\\s)",
      contains: [
        STRING,
        { begin: RUBY_METHOD_RE }
      ],
      relevance: 0
    },
    NUMBER,
    {
      // negative-look forward attempts to prevent false matches like:
      // @ident@ or $ident$ that might indicate this is not ruby at all
      className: "variable",
      begin: `(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])`
    },
    {
      className: "params",
      begin: /\|/,
      end: /\|/,
      excludeBegin: true,
      excludeEnd: true,
      relevance: 0,
      // this could be a lot of things (in other languages) other than params
      keywords: RUBY_KEYWORDS
    },
    {
      // regexp container
      begin: "(" + hljs.RE_STARTERS_RE + "|unless)\\s*",
      keywords: "unless",
      contains: [
        {
          className: "regexp",
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          illegal: /\n/,
          variants: [
            {
              begin: "/",
              end: "/[a-z]*"
            },
            {
              begin: /%r\{/,
              end: /\}[a-z]*/
            },
            {
              begin: "%r\\(",
              end: "\\)[a-z]*"
            },
            {
              begin: "%r!",
              end: "![a-z]*"
            },
            {
              begin: "%r\\[",
              end: "\\][a-z]*"
            }
          ]
        }
      ].concat(IRB_OBJECT, COMMENT_MODES),
      relevance: 0
    }
  ].concat(IRB_OBJECT, COMMENT_MODES);
  SUBST.contains = RUBY_DEFAULT_CONTAINS;
  PARAMS.contains = RUBY_DEFAULT_CONTAINS;
  const SIMPLE_PROMPT = "[>?]>";
  const DEFAULT_PROMPT = "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]";
  const RVM_PROMPT = "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>";
  const IRB_DEFAULT = [
    {
      begin: /^\s*=>/,
      starts: {
        end: "$",
        contains: RUBY_DEFAULT_CONTAINS
      }
    },
    {
      className: "meta.prompt",
      begin: "^(" + SIMPLE_PROMPT + "|" + DEFAULT_PROMPT + "|" + RVM_PROMPT + ")(?=[ ])",
      starts: {
        end: "$",
        keywords: RUBY_KEYWORDS,
        contains: RUBY_DEFAULT_CONTAINS
      }
    }
  ];
  COMMENT_MODES.unshift(IRB_OBJECT);
  return {
    name: "Ruby",
    aliases: [
      "rb",
      "gemspec",
      "podspec",
      "thor",
      "irb"
    ],
    keywords: RUBY_KEYWORDS,
    illegal: /\/\*/,
    contains: [hljs.SHEBANG({ binary: "ruby" })].concat(IRB_DEFAULT).concat(COMMENT_MODES).concat(RUBY_DEFAULT_CONTAINS)
  };
}
function rust(hljs) {
  const regex2 = hljs.regex;
  const FUNCTION_INVOKE = {
    className: "title.function.invoke",
    relevance: 0,
    begin: regex2.concat(
      /\b/,
      /(?!let|for|while|if|else|match\b)/,
      hljs.IDENT_RE,
      regex2.lookahead(/\s*\(/)
    )
  };
  const NUMBER_SUFFIX = "([ui](8|16|32|64|128|size)|f(32|64))?";
  const KEYWORDS2 = [
    "abstract",
    "as",
    "async",
    "await",
    "become",
    "box",
    "break",
    "const",
    "continue",
    "crate",
    "do",
    "dyn",
    "else",
    "enum",
    "extern",
    "false",
    "final",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "macro",
    "match",
    "mod",
    "move",
    "mut",
    "override",
    "priv",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "try",
    "type",
    "typeof",
    "unsafe",
    "unsized",
    "use",
    "virtual",
    "where",
    "while",
    "yield"
  ];
  const LITERALS2 = [
    "true",
    "false",
    "Some",
    "None",
    "Ok",
    "Err"
  ];
  const BUILTINS = [
    // functions
    "drop ",
    // traits
    "Copy",
    "Send",
    "Sized",
    "Sync",
    "Drop",
    "Fn",
    "FnMut",
    "FnOnce",
    "ToOwned",
    "Clone",
    "Debug",
    "PartialEq",
    "PartialOrd",
    "Eq",
    "Ord",
    "AsRef",
    "AsMut",
    "Into",
    "From",
    "Default",
    "Iterator",
    "Extend",
    "IntoIterator",
    "DoubleEndedIterator",
    "ExactSizeIterator",
    "SliceConcatExt",
    "ToString",
    // macros
    "assert!",
    "assert_eq!",
    "bitflags!",
    "bytes!",
    "cfg!",
    "col!",
    "concat!",
    "concat_idents!",
    "debug_assert!",
    "debug_assert_eq!",
    "env!",
    "eprintln!",
    "panic!",
    "file!",
    "format!",
    "format_args!",
    "include_bytes!",
    "include_str!",
    "line!",
    "local_data_key!",
    "module_path!",
    "option_env!",
    "print!",
    "println!",
    "select!",
    "stringify!",
    "try!",
    "unimplemented!",
    "unreachable!",
    "vec!",
    "write!",
    "writeln!",
    "macro_rules!",
    "assert_ne!",
    "debug_assert_ne!"
  ];
  const TYPES2 = [
    "i8",
    "i16",
    "i32",
    "i64",
    "i128",
    "isize",
    "u8",
    "u16",
    "u32",
    "u64",
    "u128",
    "usize",
    "f32",
    "f64",
    "str",
    "char",
    "bool",
    "Box",
    "Option",
    "Result",
    "String",
    "Vec"
  ];
  return {
    name: "Rust",
    aliases: ["rs"],
    keywords: {
      $pattern: hljs.IDENT_RE + "!?",
      type: TYPES2,
      keyword: KEYWORDS2,
      literal: LITERALS2,
      built_in: BUILTINS
    },
    illegal: "</",
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
      hljs.inherit(hljs.QUOTE_STRING_MODE, {
        begin: /b?"/,
        illegal: null
      }),
      {
        className: "string",
        variants: [
          { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
          { begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/ }
        ]
      },
      {
        className: "symbol",
        begin: /'[a-zA-Z_][a-zA-Z0-9_]*/
      },
      {
        className: "number",
        variants: [
          { begin: "\\b0b([01_]+)" + NUMBER_SUFFIX },
          { begin: "\\b0o([0-7_]+)" + NUMBER_SUFFIX },
          { begin: "\\b0x([A-Fa-f0-9_]+)" + NUMBER_SUFFIX },
          { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + NUMBER_SUFFIX }
        ],
        relevance: 0
      },
      {
        begin: [
          /fn/,
          /\s+/,
          hljs.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      },
      {
        className: "meta",
        begin: "#!?\\[",
        end: "\\]",
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        begin: [
          /let/,
          /\s+/,
          /(?:mut\s+)?/,
          hljs.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "keyword",
          4: "variable"
        }
      },
      // must come before impl/for rule later
      {
        begin: [
          /for/,
          /\s+/,
          hljs.UNDERSCORE_IDENT_RE,
          /\s+/,
          /in/
        ],
        className: {
          1: "keyword",
          3: "variable",
          5: "keyword"
        }
      },
      {
        begin: [
          /type/,
          /\s+/,
          hljs.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: [
          /(?:trait|enum|struct|union|impl|for)/,
          /\s+/,
          hljs.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: hljs.IDENT_RE + "::",
        keywords: {
          keyword: "Self",
          built_in: BUILTINS,
          type: TYPES2
        }
      },
      {
        className: "punctuation",
        begin: "->"
      },
      FUNCTION_INVOKE
    ]
  };
}
const MODES$2 = (hljs) => {
  return {
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
    },
    FUNCTION_DISPATCH: {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z_][A-Za-z0-9_-]*/
    }
  };
};
const TAGS = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
];
const MEDIA_FEATURES = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
const PSEUDO_CLASSES = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
];
const PSEUDO_ELEMENTS = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
];
const ATTRIBUTES = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
function scss(hljs) {
  const modes = MODES$2(hljs);
  const PSEUDO_ELEMENTS$12 = PSEUDO_ELEMENTS;
  const PSEUDO_CLASSES$12 = PSEUDO_CLASSES;
  const AT_IDENTIFIER = "@[a-z-]+";
  const AT_MODIFIERS = "and or not only";
  const IDENT_RE2 = "[a-zA-Z-][a-zA-Z0-9_-]*";
  const VARIABLE = {
    className: "variable",
    begin: "(\\$" + IDENT_RE2 + ")\\b",
    relevance: 0
  };
  return {
    name: "SCSS",
    case_insensitive: true,
    illegal: "[=/|']",
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      modes.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + TAGS.join("|") + ")\\b",
        // was there, before, but why?
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + PSEUDO_CLASSES$12.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + PSEUDO_ELEMENTS$12.join("|") + ")"
      },
      VARIABLE,
      {
        // pseudo-selector params
        begin: /\(/,
        end: /\)/,
        contains: [modes.CSS_NUMBER_MODE]
      },
      modes.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
      },
      { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          modes.BLOCK_COMMENT,
          VARIABLE,
          modes.HEXCOLOR,
          modes.CSS_NUMBER_MODE,
          hljs.QUOTE_STRING_MODE,
          hljs.APOS_STRING_MODE,
          modes.IMPORTANT,
          modes.FUNCTION_DISPATCH
        ]
      },
      // matching these here allows us to treat them more like regular CSS
      // rules so everything between the {} gets regular rule highlighting,
      // which is what we want for page and font-face
      {
        begin: "@(page|font-face)",
        keywords: {
          $pattern: AT_IDENTIFIER,
          keyword: "@page @font-face"
        }
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: true,
        keywords: {
          $pattern: /[a-z-]+/,
          keyword: AT_MODIFIERS,
          attribute: MEDIA_FEATURES.join(" ")
        },
        contains: [
          {
            begin: AT_IDENTIFIER,
            className: "keyword"
          },
          {
            begin: /[a-z-]+(?=:)/,
            className: "attribute"
          },
          VARIABLE,
          hljs.QUOTE_STRING_MODE,
          hljs.APOS_STRING_MODE,
          modes.HEXCOLOR,
          modes.CSS_NUMBER_MODE
        ]
      },
      modes.FUNCTION_DISPATCH
    ]
  };
}
function shell(hljs) {
  return {
    name: "Shell Session",
    aliases: [
      "console",
      "shellsession"
    ],
    contains: [
      {
        className: "meta.prompt",
        // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
        // echo /path/to/home > t.exe
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: {
          end: /[^\\](?=\s*$)/,
          subLanguage: "bash"
        }
      }
    ]
  };
}
function sql(hljs) {
  const regex2 = hljs.regex;
  const COMMENT_MODE = hljs.COMMENT("--", "$");
  const STRING = {
    className: "string",
    variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [{ begin: /''/ }]
      }
    ]
  };
  const QUOTED_IDENTIFIER = {
    begin: /"/,
    end: /"/,
    contains: [{ begin: /""/ }]
  };
  const LITERALS2 = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ];
  const MULTI_WORD_TYPES = [
    "double precision",
    "large object",
    "with timezone",
    "without timezone"
  ];
  const TYPES2 = [
    "bigint",
    "binary",
    "blob",
    "boolean",
    "char",
    "character",
    "clob",
    "date",
    "dec",
    "decfloat",
    "decimal",
    "float",
    "int",
    "integer",
    "interval",
    "nchar",
    "nclob",
    "national",
    "numeric",
    "real",
    "row",
    "smallint",
    "time",
    "timestamp",
    "varchar",
    "varying",
    // modifier (character varying)
    "varbinary"
  ];
  const NON_RESERVED_WORDS = [
    "add",
    "asc",
    "collation",
    "desc",
    "final",
    "first",
    "last",
    "view"
  ];
  const RESERVED_WORDS = [
    "abs",
    "acos",
    "all",
    "allocate",
    "alter",
    "and",
    "any",
    "are",
    "array",
    "array_agg",
    "array_max_cardinality",
    "as",
    "asensitive",
    "asin",
    "asymmetric",
    "at",
    "atan",
    "atomic",
    "authorization",
    "avg",
    "begin",
    "begin_frame",
    "begin_partition",
    "between",
    "bigint",
    "binary",
    "blob",
    "boolean",
    "both",
    "by",
    "call",
    "called",
    "cardinality",
    "cascaded",
    "case",
    "cast",
    "ceil",
    "ceiling",
    "char",
    "char_length",
    "character",
    "character_length",
    "check",
    "classifier",
    "clob",
    "close",
    "coalesce",
    "collate",
    "collect",
    "column",
    "commit",
    "condition",
    "connect",
    "constraint",
    "contains",
    "convert",
    "copy",
    "corr",
    "corresponding",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "create",
    "cross",
    "cube",
    "cume_dist",
    "current",
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_row",
    "current_schema",
    "current_time",
    "current_timestamp",
    "current_path",
    "current_role",
    "current_transform_group_for_type",
    "current_user",
    "cursor",
    "cycle",
    "date",
    "day",
    "deallocate",
    "dec",
    "decimal",
    "decfloat",
    "declare",
    "default",
    "define",
    "delete",
    "dense_rank",
    "deref",
    "describe",
    "deterministic",
    "disconnect",
    "distinct",
    "double",
    "drop",
    "dynamic",
    "each",
    "element",
    "else",
    "empty",
    "end",
    "end_frame",
    "end_partition",
    "end-exec",
    "equals",
    "escape",
    "every",
    "except",
    "exec",
    "execute",
    "exists",
    "exp",
    "external",
    "extract",
    "false",
    "fetch",
    "filter",
    "first_value",
    "float",
    "floor",
    "for",
    "foreign",
    "frame_row",
    "free",
    "from",
    "full",
    "function",
    "fusion",
    "get",
    "global",
    "grant",
    "group",
    "grouping",
    "groups",
    "having",
    "hold",
    "hour",
    "identity",
    "in",
    "indicator",
    "initial",
    "inner",
    "inout",
    "insensitive",
    "insert",
    "int",
    "integer",
    "intersect",
    "intersection",
    "interval",
    "into",
    "is",
    "join",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "language",
    "large",
    "last_value",
    "lateral",
    "lead",
    "leading",
    "left",
    "like",
    "like_regex",
    "listagg",
    "ln",
    "local",
    "localtime",
    "localtimestamp",
    "log",
    "log10",
    "lower",
    "match",
    "match_number",
    "match_recognize",
    "matches",
    "max",
    "member",
    "merge",
    "method",
    "min",
    "minute",
    "mod",
    "modifies",
    "module",
    "month",
    "multiset",
    "national",
    "natural",
    "nchar",
    "nclob",
    "new",
    "no",
    "none",
    "normalize",
    "not",
    "nth_value",
    "ntile",
    "null",
    "nullif",
    "numeric",
    "octet_length",
    "occurrences_regex",
    "of",
    "offset",
    "old",
    "omit",
    "on",
    "one",
    "only",
    "open",
    "or",
    "order",
    "out",
    "outer",
    "over",
    "overlaps",
    "overlay",
    "parameter",
    "partition",
    "pattern",
    "per",
    "percent",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "period",
    "portion",
    "position",
    "position_regex",
    "power",
    "precedes",
    "precision",
    "prepare",
    "primary",
    "procedure",
    "ptf",
    "range",
    "rank",
    "reads",
    "real",
    "recursive",
    "ref",
    "references",
    "referencing",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "release",
    "result",
    "return",
    "returns",
    "revoke",
    "right",
    "rollback",
    "rollup",
    "row",
    "row_number",
    "rows",
    "running",
    "savepoint",
    "scope",
    "scroll",
    "search",
    "second",
    "seek",
    "select",
    "sensitive",
    "session_user",
    "set",
    "show",
    "similar",
    "sin",
    "sinh",
    "skip",
    "smallint",
    "some",
    "specific",
    "specifictype",
    "sql",
    "sqlexception",
    "sqlstate",
    "sqlwarning",
    "sqrt",
    "start",
    "static",
    "stddev_pop",
    "stddev_samp",
    "submultiset",
    "subset",
    "substring",
    "substring_regex",
    "succeeds",
    "sum",
    "symmetric",
    "system",
    "system_time",
    "system_user",
    "table",
    "tablesample",
    "tan",
    "tanh",
    "then",
    "time",
    "timestamp",
    "timezone_hour",
    "timezone_minute",
    "to",
    "trailing",
    "translate",
    "translate_regex",
    "translation",
    "treat",
    "trigger",
    "trim",
    "trim_array",
    "true",
    "truncate",
    "uescape",
    "union",
    "unique",
    "unknown",
    "unnest",
    "update",
    "upper",
    "user",
    "using",
    "value",
    "values",
    "value_of",
    "var_pop",
    "var_samp",
    "varbinary",
    "varchar",
    "varying",
    "versioning",
    "when",
    "whenever",
    "where",
    "width_bucket",
    "window",
    "with",
    "within",
    "without",
    "year"
  ];
  const RESERVED_FUNCTIONS = [
    "abs",
    "acos",
    "array_agg",
    "asin",
    "atan",
    "avg",
    "cast",
    "ceil",
    "ceiling",
    "coalesce",
    "corr",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "cume_dist",
    "dense_rank",
    "deref",
    "element",
    "exp",
    "extract",
    "first_value",
    "floor",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "last_value",
    "lead",
    "listagg",
    "ln",
    "log",
    "log10",
    "lower",
    "max",
    "min",
    "mod",
    "nth_value",
    "ntile",
    "nullif",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "position",
    "position_regex",
    "power",
    "rank",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "row_number",
    "sin",
    "sinh",
    "sqrt",
    "stddev_pop",
    "stddev_samp",
    "substring",
    "substring_regex",
    "sum",
    "tan",
    "tanh",
    "translate",
    "translate_regex",
    "treat",
    "trim",
    "trim_array",
    "unnest",
    "upper",
    "value_of",
    "var_pop",
    "var_samp",
    "width_bucket"
  ];
  const POSSIBLE_WITHOUT_PARENS = [
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_schema",
    "current_transform_group_for_type",
    "current_user",
    "session_user",
    "system_time",
    "system_user",
    "current_time",
    "localtime",
    "current_timestamp",
    "localtimestamp"
  ];
  const COMBOS = [
    "create table",
    "insert into",
    "primary key",
    "foreign key",
    "not null",
    "alter table",
    "add constraint",
    "grouping sets",
    "on overflow",
    "character set",
    "respect nulls",
    "ignore nulls",
    "nulls first",
    "nulls last",
    "depth first",
    "breadth first"
  ];
  const FUNCTIONS = RESERVED_FUNCTIONS;
  const KEYWORDS2 = [
    ...RESERVED_WORDS,
    ...NON_RESERVED_WORDS
  ].filter((keyword2) => {
    return !RESERVED_FUNCTIONS.includes(keyword2);
  });
  const VARIABLE = {
    className: "variable",
    begin: /@[a-z0-9][a-z0-9_]*/
  };
  const OPERATOR = {
    className: "operator",
    begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0
  };
  const FUNCTION_CALL = {
    begin: regex2.concat(/\b/, regex2.either(...FUNCTIONS), /\s*\(/),
    relevance: 0,
    keywords: { built_in: FUNCTIONS }
  };
  function reduceRelevancy(list2, {
    exceptions,
    when
  } = {}) {
    const qualifyFn = when;
    exceptions = exceptions || [];
    return list2.map((item) => {
      if (item.match(/\|\d+$/) || exceptions.includes(item)) {
        return item;
      } else if (qualifyFn(item)) {
        return `${item}|0`;
      } else {
        return item;
      }
    });
  }
  return {
    name: "SQL",
    case_insensitive: true,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: reduceRelevancy(KEYWORDS2, { when: (x10) => x10.length < 3 }),
      literal: LITERALS2,
      type: TYPES2,
      built_in: POSSIBLE_WITHOUT_PARENS
    },
    contains: [
      {
        begin: regex2.either(...COMBOS),
        relevance: 0,
        keywords: {
          $pattern: /[\w\.]+/,
          keyword: KEYWORDS2.concat(COMBOS),
          literal: LITERALS2,
          type: TYPES2
        }
      },
      {
        className: "type",
        begin: regex2.either(...MULTI_WORD_TYPES)
      },
      FUNCTION_CALL,
      VARIABLE,
      STRING,
      QUOTED_IDENTIFIER,
      hljs.C_NUMBER_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      COMMENT_MODE,
      OPERATOR
    ]
  };
}
function source$3(re2) {
  if (!re2)
    return null;
  if (typeof re2 === "string")
    return re2;
  return re2.source;
}
function lookahead$2(re2) {
  return concat$3("(?=", re2, ")");
}
function concat$3(...args) {
  const joined = args.map((x10) => source$3(x10)).join("");
  return joined;
}
function stripOptionsFromArgs$3(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either$3(...args) {
  const opts = stripOptionsFromArgs$3(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x10) => source$3(x10)).join("|") + ")";
  return joined;
}
const keywordWrapper$1 = (keyword2) => concat$3(
  /\b/,
  keyword2,
  /\w$/.test(keyword2) ? /\b/ : /\B/
);
const dotKeywords = [
  "Protocol",
  // contextual
  "Type"
  // contextual
].map(keywordWrapper$1);
const optionalDotKeywords = [
  "init",
  "self"
].map(keywordWrapper$1);
const keywordTypes = [
  "Any",
  "Self"
];
const keywords = [
  // strings below will be fed into the regular `keywords` engine while regex
  // will result in additional modes being created to scan for those keywords to
  // avoid conflicts with other rules
  "actor",
  "any",
  // contextual
  "associatedtype",
  "async",
  "await",
  /as\?/,
  // operator
  /as!/,
  // operator
  "as",
  // operator
  "borrowing",
  // contextual
  "break",
  "case",
  "catch",
  "class",
  "consume",
  // contextual
  "consuming",
  // contextual
  "continue",
  "convenience",
  // contextual
  "copy",
  // contextual
  "default",
  "defer",
  "deinit",
  "didSet",
  // contextual
  "distributed",
  "do",
  "dynamic",
  // contextual
  "each",
  "else",
  "enum",
  "extension",
  "fallthrough",
  /fileprivate\(set\)/,
  "fileprivate",
  "final",
  // contextual
  "for",
  "func",
  "get",
  // contextual
  "guard",
  "if",
  "import",
  "indirect",
  // contextual
  "infix",
  // contextual
  /init\?/,
  /init!/,
  "inout",
  /internal\(set\)/,
  "internal",
  "in",
  "is",
  // operator
  "isolated",
  // contextual
  "nonisolated",
  // contextual
  "lazy",
  // contextual
  "let",
  "macro",
  "mutating",
  // contextual
  "nonmutating",
  // contextual
  /open\(set\)/,
  // contextual
  "open",
  // contextual
  "operator",
  "optional",
  // contextual
  "override",
  // contextual
  "postfix",
  // contextual
  "precedencegroup",
  "prefix",
  // contextual
  /private\(set\)/,
  "private",
  "protocol",
  /public\(set\)/,
  "public",
  "repeat",
  "required",
  // contextual
  "rethrows",
  "return",
  "set",
  // contextual
  "some",
  // contextual
  "static",
  "struct",
  "subscript",
  "super",
  "switch",
  "throws",
  "throw",
  /try\?/,
  // operator
  /try!/,
  // operator
  "try",
  // operator
  "typealias",
  /unowned\(safe\)/,
  // contextual
  /unowned\(unsafe\)/,
  // contextual
  "unowned",
  // contextual
  "var",
  "weak",
  // contextual
  "where",
  "while",
  "willSet"
  // contextual
];
const literals = [
  "false",
  "nil",
  "true"
];
const precedencegroupKeywords = [
  "assignment",
  "associativity",
  "higherThan",
  "left",
  "lowerThan",
  "none",
  "right"
];
const numberSignKeywords = [
  "#colorLiteral",
  "#column",
  "#dsohandle",
  "#else",
  "#elseif",
  "#endif",
  "#error",
  "#file",
  "#fileID",
  "#fileLiteral",
  "#filePath",
  "#function",
  "#if",
  "#imageLiteral",
  "#keyPath",
  "#line",
  "#selector",
  "#sourceLocation",
  "#warning"
];
const builtIns = [
  "abs",
  "all",
  "any",
  "assert",
  "assertionFailure",
  "debugPrint",
  "dump",
  "fatalError",
  "getVaList",
  "isKnownUniquelyReferenced",
  "max",
  "min",
  "numericCast",
  "pointwiseMax",
  "pointwiseMin",
  "precondition",
  "preconditionFailure",
  "print",
  "readLine",
  "repeatElement",
  "sequence",
  "stride",
  "swap",
  "swift_unboxFromSwiftValueWithType",
  "transcode",
  "type",
  "unsafeBitCast",
  "unsafeDowncast",
  "withExtendedLifetime",
  "withUnsafeMutablePointer",
  "withUnsafePointer",
  "withVaList",
  "withoutActuallyEscaping",
  "zip"
];
const operatorHead$1 = either$3(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
);
const operatorCharacter$1 = either$3(
  operatorHead$1,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn't supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
);
const operator$1 = concat$3(operatorHead$1, operatorCharacter$1, "*");
const identifierHead$1 = either$3(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren't supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
);
const identifierCharacter$1 = either$3(
  identifierHead$1,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
);
const identifier$1 = concat$3(identifierHead$1, identifierCharacter$1, "*");
const typeIdentifier = concat$3(/[A-Z]/, identifierCharacter$1, "*");
const keywordAttributes = [
  "attached",
  "autoclosure",
  concat$3(/convention\(/, either$3("swift", "block", "c"), /\)/),
  "discardableResult",
  "dynamicCallable",
  "dynamicMemberLookup",
  "escaping",
  "freestanding",
  "frozen",
  "GKInspectable",
  "IBAction",
  "IBDesignable",
  "IBInspectable",
  "IBOutlet",
  "IBSegueAction",
  "inlinable",
  "main",
  "nonobjc",
  "NSApplicationMain",
  "NSCopying",
  "NSManaged",
  concat$3(/objc\(/, identifier$1, /\)/),
  "objc",
  "objcMembers",
  "propertyWrapper",
  "requires_stored_property_inits",
  "resultBuilder",
  "Sendable",
  "testable",
  "UIApplicationMain",
  "unchecked",
  "unknown",
  "usableFromInline",
  "warn_unqualified_access"
];
const availabilityKeywords = [
  "iOS",
  "iOSApplicationExtension",
  "macOS",
  "macOSApplicationExtension",
  "macCatalyst",
  "macCatalystApplicationExtension",
  "watchOS",
  "watchOSApplicationExtension",
  "tvOS",
  "tvOSApplicationExtension",
  "swift"
];
function swift(hljs) {
  const WHITESPACE = {
    match: /\s+/,
    relevance: 0
  };
  const BLOCK_COMMENT = hljs.COMMENT(
    "/\\*",
    "\\*/",
    { contains: ["self"] }
  );
  const COMMENTS = [
    hljs.C_LINE_COMMENT_MODE,
    BLOCK_COMMENT
  ];
  const DOT_KEYWORD = {
    match: [
      /\./,
      either$3(...dotKeywords, ...optionalDotKeywords)
    ],
    className: { 2: "keyword" }
  };
  const KEYWORD_GUARD = {
    // Consume .keyword to prevent highlighting properties and methods as keywords.
    match: concat$3(/\./, either$3(...keywords)),
    relevance: 0
  };
  const PLAIN_KEYWORDS = keywords.filter((kw2) => typeof kw2 === "string").concat(["_|0"]);
  const REGEX_KEYWORDS = keywords.filter((kw2) => typeof kw2 !== "string").concat(keywordTypes).map(keywordWrapper$1);
  const KEYWORD = { variants: [
    {
      className: "keyword",
      match: either$3(...REGEX_KEYWORDS, ...optionalDotKeywords)
    }
  ] };
  const KEYWORDS2 = {
    $pattern: either$3(
      /\b\w+/,
      // regular keywords
      /#\w+/
      // number keywords
    ),
    keyword: PLAIN_KEYWORDS.concat(numberSignKeywords),
    literal: literals
  };
  const KEYWORD_MODES = [
    DOT_KEYWORD,
    KEYWORD_GUARD,
    KEYWORD
  ];
  const BUILT_IN_GUARD = {
    // Consume .built_in to prevent highlighting properties and methods.
    match: concat$3(/\./, either$3(...builtIns)),
    relevance: 0
  };
  const BUILT_IN = {
    className: "built_in",
    match: concat$3(/\b/, either$3(...builtIns), /(?=\()/)
  };
  const BUILT_INS2 = [
    BUILT_IN_GUARD,
    BUILT_IN
  ];
  const OPERATOR_GUARD = {
    // Prevent -> from being highlighting as an operator.
    match: /->/,
    relevance: 0
  };
  const OPERATOR = {
    className: "operator",
    relevance: 0,
    variants: [
      { match: operator$1 },
      {
        // dot-operator: only operators that start with a dot are allowed to use dots as
        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
        // characters that may also include dots.
        match: `\\.(\\.|${operatorCharacter$1})+`
      }
    ]
  };
  const OPERATORS = [
    OPERATOR_GUARD,
    OPERATOR
  ];
  const decimalDigits2 = "([0-9]_*)+";
  const hexDigits2 = "([0-9a-fA-F]_*)+";
  const NUMBER = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal floating-point-literal (subsumes decimal-literal)
      { match: `\\b(${decimalDigits2})(\\.(${decimalDigits2}))?([eE][+-]?(${decimalDigits2}))?\\b` },
      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
      { match: `\\b0x(${hexDigits2})(\\.(${hexDigits2}))?([pP][+-]?(${decimalDigits2}))?\\b` },
      // octal-literal
      { match: /\b0o([0-7]_*)+\b/ },
      // binary-literal
      { match: /\b0b([01]_*)+\b/ }
    ]
  };
  const ESCAPED_CHARACTER = (rawDelimiter = "") => ({
    className: "subst",
    variants: [
      { match: concat$3(/\\/, rawDelimiter, /[0\\tnr"']/) },
      { match: concat$3(/\\/, rawDelimiter, /u\{[0-9a-fA-F]{1,8}\}/) }
    ]
  });
  const ESCAPED_NEWLINE = (rawDelimiter = "") => ({
    className: "subst",
    match: concat$3(/\\/, rawDelimiter, /[\t ]*(?:[\r\n]|\r\n)/)
  });
  const INTERPOLATION = (rawDelimiter = "") => ({
    className: "subst",
    label: "interpol",
    begin: concat$3(/\\/, rawDelimiter, /\(/),
    end: /\)/
  });
  const MULTILINE_STRING = (rawDelimiter = "") => ({
    begin: concat$3(rawDelimiter, /"""/),
    end: concat$3(/"""/, rawDelimiter),
    contains: [
      ESCAPED_CHARACTER(rawDelimiter),
      ESCAPED_NEWLINE(rawDelimiter),
      INTERPOLATION(rawDelimiter)
    ]
  });
  const SINGLE_LINE_STRING = (rawDelimiter = "") => ({
    begin: concat$3(rawDelimiter, /"/),
    end: concat$3(/"/, rawDelimiter),
    contains: [
      ESCAPED_CHARACTER(rawDelimiter),
      INTERPOLATION(rawDelimiter)
    ]
  });
  const STRING = {
    className: "string",
    variants: [
      MULTILINE_STRING(),
      MULTILINE_STRING("#"),
      MULTILINE_STRING("##"),
      MULTILINE_STRING("###"),
      SINGLE_LINE_STRING(),
      SINGLE_LINE_STRING("#"),
      SINGLE_LINE_STRING("##"),
      SINGLE_LINE_STRING("###")
    ]
  };
  const REGEXP_CONTENTS = [
    hljs.BACKSLASH_ESCAPE,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [hljs.BACKSLASH_ESCAPE]
    }
  ];
  const BARE_REGEXP_LITERAL = {
    begin: /\/[^\s](?=[^/\n]*\/)/,
    end: /\//,
    contains: REGEXP_CONTENTS
  };
  const EXTENDED_REGEXP_LITERAL = (rawDelimiter) => {
    const begin = concat$3(rawDelimiter, /\//);
    const end = concat$3(/\//, rawDelimiter);
    return {
      begin,
      end,
      contains: [
        ...REGEXP_CONTENTS,
        {
          scope: "comment",
          begin: `#(?!.*${end})`,
          end: /$/
        }
      ]
    };
  };
  const REGEXP2 = {
    scope: "regexp",
    variants: [
      EXTENDED_REGEXP_LITERAL("###"),
      EXTENDED_REGEXP_LITERAL("##"),
      EXTENDED_REGEXP_LITERAL("#"),
      BARE_REGEXP_LITERAL
    ]
  };
  const QUOTED_IDENTIFIER = { match: concat$3(/`/, identifier$1, /`/) };
  const IMPLICIT_PARAMETER = {
    className: "variable",
    match: /\$\d+/
  };
  const PROPERTY_WRAPPER_PROJECTION = {
    className: "variable",
    match: `\\$${identifierCharacter$1}+`
  };
  const IDENTIFIERS = [
    QUOTED_IDENTIFIER,
    IMPLICIT_PARAMETER,
    PROPERTY_WRAPPER_PROJECTION
  ];
  const AVAILABLE_ATTRIBUTE = {
    match: /(@|#(un)?)available/,
    scope: "keyword",
    starts: { contains: [
      {
        begin: /\(/,
        end: /\)/,
        keywords: availabilityKeywords,
        contains: [
          ...OPERATORS,
          NUMBER,
          STRING
        ]
      }
    ] }
  };
  const KEYWORD_ATTRIBUTE = {
    scope: "keyword",
    match: concat$3(/@/, either$3(...keywordAttributes))
  };
  const USER_DEFINED_ATTRIBUTE = {
    scope: "meta",
    match: concat$3(/@/, identifier$1)
  };
  const ATTRIBUTES2 = [
    AVAILABLE_ATTRIBUTE,
    KEYWORD_ATTRIBUTE,
    USER_DEFINED_ATTRIBUTE
  ];
  const TYPE = {
    match: lookahead$2(/\b[A-Z]/),
    relevance: 0,
    contains: [
      {
        // Common Apple frameworks, for relevance boost
        className: "type",
        match: concat$3(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter$1, "+")
      },
      {
        // Type identifier
        className: "type",
        match: typeIdentifier,
        relevance: 0
      },
      {
        // Optional type
        match: /[?!]+/,
        relevance: 0
      },
      {
        // Variadic parameter
        match: /\.\.\./,
        relevance: 0
      },
      {
        // Protocol composition
        match: concat$3(/\s+&\s+/, lookahead$2(typeIdentifier)),
        relevance: 0
      }
    ]
  };
  const GENERIC_ARGUMENTS = {
    begin: /</,
    end: />/,
    keywords: KEYWORDS2,
    contains: [
      ...COMMENTS,
      ...KEYWORD_MODES,
      ...ATTRIBUTES2,
      OPERATOR_GUARD,
      TYPE
    ]
  };
  TYPE.contains.push(GENERIC_ARGUMENTS);
  const TUPLE_ELEMENT_NAME = {
    match: concat$3(identifier$1, /\s*:/),
    keywords: "_|0",
    relevance: 0
  };
  const TUPLE = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: KEYWORDS2,
    contains: [
      "self",
      TUPLE_ELEMENT_NAME,
      ...COMMENTS,
      REGEXP2,
      ...KEYWORD_MODES,
      ...BUILT_INS2,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...IDENTIFIERS,
      ...ATTRIBUTES2,
      TYPE
    ]
  };
  const GENERIC_PARAMETERS = {
    begin: /</,
    end: />/,
    keywords: "repeat each",
    contains: [
      ...COMMENTS,
      TYPE
    ]
  };
  const FUNCTION_PARAMETER_NAME = {
    begin: either$3(
      lookahead$2(concat$3(identifier$1, /\s*:/)),
      lookahead$2(concat$3(identifier$1, /\s+/, identifier$1, /\s*:/))
    ),
    end: /:/,
    relevance: 0,
    contains: [
      {
        className: "keyword",
        match: /\b_\b/
      },
      {
        className: "params",
        match: identifier$1
      }
    ]
  };
  const FUNCTION_PARAMETERS = {
    begin: /\(/,
    end: /\)/,
    keywords: KEYWORDS2,
    contains: [
      FUNCTION_PARAMETER_NAME,
      ...COMMENTS,
      ...KEYWORD_MODES,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...ATTRIBUTES2,
      TYPE,
      TUPLE
    ],
    endsParent: true,
    illegal: /["']/
  };
  const FUNCTION_OR_MACRO = {
    match: [
      /(func|macro)/,
      /\s+/,
      either$3(QUOTED_IDENTIFIER.match, identifier$1, operator$1)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      GENERIC_PARAMETERS,
      FUNCTION_PARAMETERS,
      WHITESPACE
    ],
    illegal: [
      /\[/,
      /%/
    ]
  };
  const INIT_SUBSCRIPT = {
    match: [
      /\b(?:subscript|init[?!]?)/,
      /\s*(?=[<(])/
    ],
    className: { 1: "keyword" },
    contains: [
      GENERIC_PARAMETERS,
      FUNCTION_PARAMETERS,
      WHITESPACE
    ],
    illegal: /\[|%/
  };
  const OPERATOR_DECLARATION = {
    match: [
      /operator/,
      /\s+/,
      operator$1
    ],
    className: {
      1: "keyword",
      3: "title"
    }
  };
  const PRECEDENCEGROUP = {
    begin: [
      /precedencegroup/,
      /\s+/,
      typeIdentifier
    ],
    className: {
      1: "keyword",
      3: "title"
    },
    contains: [TYPE],
    keywords: [
      ...precedencegroupKeywords,
      ...literals
    ],
    end: /}/
  };
  for (const variant of STRING.variants) {
    const interpolation = variant.contains.find((mode) => mode.label === "interpol");
    interpolation.keywords = KEYWORDS2;
    const submodes = [
      ...KEYWORD_MODES,
      ...BUILT_INS2,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...IDENTIFIERS
    ];
    interpolation.contains = [
      ...submodes,
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          "self",
          ...submodes
        ]
      }
    ];
  }
  return {
    name: "Swift",
    keywords: KEYWORDS2,
    contains: [
      ...COMMENTS,
      FUNCTION_OR_MACRO,
      INIT_SUBSCRIPT,
      {
        beginKeywords: "struct protocol class extension enum actor",
        end: "\\{",
        excludeEnd: true,
        keywords: KEYWORDS2,
        contains: [
          hljs.inherit(hljs.TITLE_MODE, {
            className: "title.class",
            begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
          }),
          ...KEYWORD_MODES
        ]
      },
      OPERATOR_DECLARATION,
      PRECEDENCEGROUP,
      {
        beginKeywords: "import",
        end: /$/,
        contains: [...COMMENTS],
        relevance: 0
      },
      REGEXP2,
      ...KEYWORD_MODES,
      ...BUILT_INS2,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...IDENTIFIERS,
      ...ATTRIBUTES2,
      TYPE,
      TUPLE
    ]
  };
}
const IDENT_RE$2 = "[A-Za-z$_][0-9A-Za-z$_]*";
const KEYWORDS = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
const LITERALS = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];
const TYPES = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
];
const ERROR_TYPES = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
const BUILT_IN_GLOBALS = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
const BUILT_IN_VARIABLES = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
];
const BUILT_INS = [].concat(
  BUILT_IN_GLOBALS,
  TYPES,
  ERROR_TYPES
);
function javascript(hljs) {
  const regex2 = hljs.regex;
  const hasClosingTag = (match, { after }) => {
    const tag = "</" + match[0].slice(1);
    const pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };
  const IDENT_RE$12 = IDENT_RE$2;
  const FRAGMENT = {
    begin: "<>",
    end: "</>"
  };
  const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (match, response) => {
      const afterMatchIndex = match[0].length + match.index;
      const nextChar = match.input[afterMatchIndex];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        nextChar === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        nextChar === ","
      ) {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      let m10;
      const afterMatch = match.input.substring(afterMatchIndex);
      if (m10 = afterMatch.match(/^\s*=/)) {
        response.ignoreMatch();
        return;
      }
      if (m10 = afterMatch.match(/^\s+extends\s+/)) {
        if (m10.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  const KEYWORDS$12 = {
    $pattern: IDENT_RE$2,
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILT_INS,
    "variable.language": BUILT_IN_VARIABLES
  };
  const decimalDigits2 = "[0-9](_?[0-9])*";
  const frac2 = `\\.(${decimalDigits2})`;
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${decimalInteger})((${frac2})|\\.)?|(${frac2}))[eE][+-]?(${decimalDigits2})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac2})\\b|\\.)?|(${frac2})\\b` },
      // DecimalBigIntegerLiteral
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  };
  const SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$12,
    contains: []
    // defined later
  };
  const HTML_TEMPLATE = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "xml"
    }
  };
  const CSS_TEMPLATE = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "css"
    }
  };
  const GRAPHQL_TEMPLATE = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "graphql"
    }
  };
  const TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    "\\*/",
    {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$12 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            // eat spaces (not newlines) so we can find
            // types or variables
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT2 = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    GRAPHQL_TEMPLATE,
    TEMPLATE_STRING,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    NUMBER
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$12,
    contains: [
      "self"
    ].concat(SUBST_INTERNALS)
  });
  const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$12,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$12,
    contains: PARAMS_CONTAINS
  };
  const CLASS_OR_EXTENDS = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12,
          /\s+/,
          /extends/,
          /\s+/,
          regex2.concat(IDENT_RE$12, "(", regex2.concat(/\./, IDENT_RE$12), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: regex2.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...TYPES,
        ...ERROR_TYPES
      ]
    }
  };
  const USE_STRICT = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };
  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          IDENT_RE$12,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [PARAMS],
    illegal: /%/
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function noneOf(list2) {
    return regex2.concat("(?!", list2.join("|"), ")");
  }
  const FUNCTION_CALL = {
    match: regex2.concat(
      /\b/,
      noneOf([
        ...BUILT_IN_GLOBALS,
        "super",
        "import"
      ]),
      IDENT_RE$12,
      regex2.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  };
  const PROPERTY_ACCESS = {
    begin: regex2.concat(/\./, regex2.lookahead(
      regex2.concat(IDENT_RE$12, /(?![0-9A-Za-z$_(])/)
    )),
    end: IDENT_RE$12,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };
  const GETTER_OR_SETTER = {
    match: [
      /get|set/,
      /\s+/,
      IDENT_RE$12,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      PARAMS
    ]
  };
  const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/,
      /\s+/,
      IDENT_RE$12,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      regex2.lookahead(FUNC_LEAD_IN_RE)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$12,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT2,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      NUMBER,
      CLASS_REFERENCE,
      {
        className: "attr",
        begin: IDENT_RE$12 + regex2.lookahead(":"),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      {
        // "value" container
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          COMMENT2,
          hljs.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$12,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              { match: XML_SELF_CLOSING },
              {
                begin: XML_TAG.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      FUNCTION_DEFINITION,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$12, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + IDENT_RE$12,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [PARAMS]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function typescript(hljs) {
  const tsLanguage = javascript(hljs);
  const IDENT_RE$12 = IDENT_RE$2;
  const TYPES2 = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ];
  const NAMESPACE = {
    beginKeywords: "namespace",
    end: /\{/,
    excludeEnd: true,
    contains: [tsLanguage.exports.CLASS_REFERENCE]
  };
  const INTERFACE = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: true,
    keywords: {
      keyword: "interface extends",
      built_in: TYPES2
    },
    contains: [tsLanguage.exports.CLASS_REFERENCE]
  };
  const USE_STRICT = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  };
  const TS_SPECIFIC_KEYWORDS = [
    "type",
    "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override"
  ];
  const KEYWORDS$12 = {
    $pattern: IDENT_RE$2,
    keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS),
    literal: LITERALS,
    built_in: BUILT_INS.concat(TYPES2),
    "variable.language": BUILT_IN_VARIABLES
  };
  const DECORATOR = {
    className: "meta",
    begin: "@" + IDENT_RE$12
  };
  const swapMode = (mode, label, replacement) => {
    const indx = mode.contains.findIndex((m10) => m10.label === label);
    if (indx === -1) {
      throw new Error("can not find mode to replace");
    }
    mode.contains.splice(indx, 1, replacement);
  };
  Object.assign(tsLanguage.keywords, KEYWORDS$12);
  tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
  tsLanguage.contains = tsLanguage.contains.concat([
    DECORATOR,
    NAMESPACE,
    INTERFACE
  ]);
  swapMode(tsLanguage, "shebang", hljs.SHEBANG());
  swapMode(tsLanguage, "use_strict", USE_STRICT);
  const functionDeclaration = tsLanguage.contains.find((m10) => m10.label === "func.def");
  functionDeclaration.relevance = 0;
  Object.assign(tsLanguage, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  });
  return tsLanguage;
}
function vbnet(hljs) {
  const regex2 = hljs.regex;
  const CHARACTER = {
    className: "string",
    begin: /"(""|[^/n])"C\b/
  };
  const STRING = {
    className: "string",
    begin: /"/,
    end: /"/,
    illegal: /\n/,
    contains: [
      {
        // double quote escape
        begin: /""/
      }
    ]
  };
  const MM_DD_YYYY = /\d{1,2}\/\d{1,2}\/\d{4}/;
  const YYYY_MM_DD = /\d{4}-\d{1,2}-\d{1,2}/;
  const TIME_12H = /(\d|1[012])(:\d+){0,2} *(AM|PM)/;
  const TIME_24H = /\d{1,2}(:\d{1,2}){1,2}/;
  const DATE2 = {
    className: "literal",
    variants: [
      {
        // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
        begin: regex2.concat(/# */, regex2.either(YYYY_MM_DD, MM_DD_YYYY), / *#/)
      },
      {
        // #H:mm[:ss]# (24h Time)
        begin: regex2.concat(/# */, TIME_24H, / *#/)
      },
      {
        // #h[:mm[:ss]] A# (12h Time)
        begin: regex2.concat(/# */, TIME_12H, / *#/)
      },
      {
        // date plus time
        begin: regex2.concat(
          /# */,
          regex2.either(YYYY_MM_DD, MM_DD_YYYY),
          / +/,
          regex2.either(TIME_12H, TIME_24H),
          / *#/
        )
      }
    ]
  };
  const NUMBER = {
    className: "number",
    relevance: 0,
    variants: [
      {
        // Float
        begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
      },
      {
        // Integer (base 10)
        begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 16)
        begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 8)
        begin: /&O[0-7_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 2)
        begin: /&B[01_]+((U?[SIL])|[%&])?/
      }
    ]
  };
  const LABEL = {
    className: "label",
    begin: /^\w+:/
  };
  const DOC_COMMENT = hljs.COMMENT(/'''/, /$/, { contains: [
    {
      className: "doctag",
      begin: /<\/?/,
      end: />/
    }
  ] });
  const COMMENT2 = hljs.COMMENT(null, /$/, { variants: [
    { begin: /'/ },
    {
      // TODO: Use multi-class for leading spaces
      begin: /([\t ]|^)REM(?=\s)/
    }
  ] });
  const DIRECTIVES = {
    className: "meta",
    // TODO: Use multi-class for indentation once available
    begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
    end: /$/,
    keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
    contains: [COMMENT2]
  };
  return {
    name: "Visual Basic .NET",
    aliases: ["vb"],
    case_insensitive: true,
    classNameAliases: { label: "symbol" },
    keywords: {
      keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
      built_in: (
        // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
        "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
      ),
      type: (
        // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
        "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
      ),
      literal: "true false nothing"
    },
    illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
    contains: [
      CHARACTER,
      STRING,
      DATE2,
      NUMBER,
      LABEL,
      DOC_COMMENT,
      COMMENT2,
      DIRECTIVES
    ]
  };
}
function wasm(hljs) {
  hljs.regex;
  const BLOCK_COMMENT = hljs.COMMENT(/\(;/, /;\)/);
  BLOCK_COMMENT.contains.push("self");
  const LINE_COMMENT = hljs.COMMENT(/;;/, /$/);
  const KWS = [
    "anyfunc",
    "block",
    "br",
    "br_if",
    "br_table",
    "call",
    "call_indirect",
    "data",
    "drop",
    "elem",
    "else",
    "end",
    "export",
    "func",
    "global.get",
    "global.set",
    "local.get",
    "local.set",
    "local.tee",
    "get_global",
    "get_local",
    "global",
    "if",
    "import",
    "local",
    "loop",
    "memory",
    "memory.grow",
    "memory.size",
    "module",
    "mut",
    "nop",
    "offset",
    "param",
    "result",
    "return",
    "select",
    "set_global",
    "set_local",
    "start",
    "table",
    "tee_local",
    "then",
    "type",
    "unreachable"
  ];
  const FUNCTION_REFERENCE = {
    begin: [
      /(?:func|call|call_indirect)/,
      /\s+/,
      /\$[^\s)]+/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    }
  };
  const ARGUMENT = {
    className: "variable",
    begin: /\$[\w_]+/
  };
  const PARENS = {
    match: /(\((?!;)|\))+/,
    className: "punctuation",
    relevance: 0
  };
  const NUMBER = {
    className: "number",
    relevance: 0,
    // borrowed from Prism, TODO: split out into variants
    match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
  };
  const TYPE = {
    // look-ahead prevents us from gobbling up opcodes
    match: /(i32|i64|f32|f64)(?!\.)/,
    className: "type"
  };
  const MATH_OPERATIONS = {
    className: "keyword",
    // borrowed from Prism, TODO: split out into variants
    match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
  };
  const OFFSET_ALIGN = {
    match: [
      /(?:offset|align)/,
      /\s*/,
      /=/
    ],
    className: {
      1: "keyword",
      3: "operator"
    }
  };
  return {
    name: "WebAssembly",
    keywords: {
      $pattern: /[\w.]+/,
      keyword: KWS
    },
    contains: [
      LINE_COMMENT,
      BLOCK_COMMENT,
      OFFSET_ALIGN,
      ARGUMENT,
      PARENS,
      FUNCTION_REFERENCE,
      hljs.QUOTE_STRING_MODE,
      TYPE,
      MATH_OPERATIONS,
      NUMBER
    ]
  };
}
function xml$1(hljs) {
  const regex2 = hljs.regex;
  const TAG_NAME_RE = regex2.concat(/[\p{L}_]/u, regex2.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u);
  const XML_IDENT_RE = /[\p{L}0-9._:-]+/u;
  const XML_ENTITIES = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  };
  const XML_META_KEYWORDS = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  };
  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
    begin: /\(/,
    end: /\)/
  });
  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: "string" });
  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" });
  const TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: XML_IDENT_RE,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: true,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [XML_ENTITIES]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [XML_ENTITIES]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: true,
    unicodeRegex: true,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          XML_META_KEYWORDS,
          QUOTE_META_STRING_MODE,
          APOS_META_STRING_MODE,
          XML_META_PAR_KEYWORDS,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  XML_META_KEYWORDS,
                  XML_META_PAR_KEYWORDS,
                  QUOTE_META_STRING_MODE,
                  APOS_META_STRING_MODE
                ]
              }
            ]
          }
        ]
      },
      hljs.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      XML_ENTITIES,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              QUOTE_META_STRING_MODE
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/style>/,
          returnEnd: true,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/script>/,
          returnEnd: true,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: regex2.concat(
          /</,
          regex2.lookahead(regex2.concat(
            TAG_NAME_RE,
            // <tag/>
            // <tag>
            // <tag ...
            regex2.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0,
            starts: TAG_INTERNALS
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: regex2.concat(
          /<\//,
          regex2.lookahead(regex2.concat(
            TAG_NAME_RE,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: true
          }
        ]
      }
    ]
  };
}
function yaml(hljs) {
  const LITERALS2 = "true false yes no null";
  const URI_CHARACTERS = "[\\w#;/?:@&=+$,.~*'()[\\]]+";
  const KEY = {
    className: "attr",
    variants: [
      { begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)" },
      {
        // double quoted keys
        begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)'
      },
      {
        // single quoted keys
        begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)"
      }
    ]
  };
  const TEMPLATE_VARIABLES = {
    className: "template-variable",
    variants: [
      {
        // jinja templates Ansible
        begin: /\{\{/,
        end: /\}\}/
      },
      {
        // Ruby i18n
        begin: /%\{/,
        end: /\}/
      }
    ]
  };
  const STRING = {
    className: "string",
    relevance: 0,
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      { begin: /\S+/ }
    ],
    contains: [
      hljs.BACKSLASH_ESCAPE,
      TEMPLATE_VARIABLES
    ]
  };
  const CONTAINER_STRING = hljs.inherit(STRING, { variants: [
    {
      begin: /'/,
      end: /'/
    },
    {
      begin: /"/,
      end: /"/
    },
    { begin: /[^\s,{}[\]]+/ }
  ] });
  const DATE_RE = "[0-9]{4}(-[0-9][0-9]){0,2}";
  const TIME_RE = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?";
  const FRACTION_RE = "(\\.[0-9]*)?";
  const ZONE_RE = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?";
  const TIMESTAMP = {
    className: "number",
    begin: "\\b" + DATE_RE + TIME_RE + FRACTION_RE + ZONE_RE + "\\b"
  };
  const VALUE_CONTAINER = {
    end: ",",
    endsWithParent: true,
    excludeEnd: true,
    keywords: LITERALS2,
    relevance: 0
  };
  const OBJECT2 = {
    begin: /\{/,
    end: /\}/,
    contains: [VALUE_CONTAINER],
    illegal: "\\n",
    relevance: 0
  };
  const ARRAY2 = {
    begin: "\\[",
    end: "\\]",
    contains: [VALUE_CONTAINER],
    illegal: "\\n",
    relevance: 0
  };
  const MODES2 = [
    KEY,
    {
      className: "meta",
      begin: "^---\\s*$",
      relevance: 10
    },
    {
      // multi line string
      // Blocks start with a | or > followed by a newline
      //
      // Indentation of subsequent lines must be the same to
      // be considered part of the block
      className: "string",
      begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
    },
    {
      // Ruby/Rails erb
      begin: "<%[%=-]?",
      end: "[%-]?%>",
      subLanguage: "ruby",
      excludeBegin: true,
      excludeEnd: true,
      relevance: 0
    },
    {
      // named tags
      className: "type",
      begin: "!\\w+!" + URI_CHARACTERS
    },
    // https://yaml.org/spec/1.2/spec.html#id2784064
    {
      // verbatim tags
      className: "type",
      begin: "!<" + URI_CHARACTERS + ">"
    },
    {
      // primary tags
      className: "type",
      begin: "!" + URI_CHARACTERS
    },
    {
      // secondary tags
      className: "type",
      begin: "!!" + URI_CHARACTERS
    },
    {
      // fragment id &ref
      className: "meta",
      begin: "&" + hljs.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // fragment reference *ref
      className: "meta",
      begin: "\\*" + hljs.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // array listing
      className: "bullet",
      // TODO: remove |$ hack when we have proper look-ahead support
      begin: "-(?=[ ]|$)",
      relevance: 0
    },
    hljs.HASH_COMMENT_MODE,
    {
      beginKeywords: LITERALS2,
      keywords: { literal: LITERALS2 }
    },
    TIMESTAMP,
    // numbers are any valid C-style number that
    // sit isolated from other words
    {
      className: "number",
      begin: hljs.C_NUMBER_RE + "\\b",
      relevance: 0
    },
    OBJECT2,
    ARRAY2,
    STRING
  ];
  const VALUE_MODES = [...MODES2];
  VALUE_MODES.pop();
  VALUE_MODES.push(CONTAINER_STRING);
  VALUE_CONTAINER.contains = VALUE_MODES;
  return {
    name: "YAML",
    case_insensitive: true,
    aliases: ["yml"],
    contains: MODES2
  };
}
const grammars = {
  arduino,
  bash,
  c: c$3,
  cpp,
  csharp,
  css,
  diff,
  go: go$2,
  graphql,
  ini,
  java,
  javascript: javascript$1,
  json,
  kotlin,
  less,
  lua,
  makefile,
  markdown,
  objectivec,
  perl,
  php,
  "php-template": phpTemplate,
  plaintext,
  python,
  "python-repl": pythonRepl,
  r,
  ruby,
  rust,
  scss,
  shell,
  sql,
  swift,
  typescript,
  vbnet,
  wasm,
  xml: xml$1,
  yaml
};
function ok$3() {
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x10) {
  return x10 && x10.__esModule && Object.prototype.hasOwnProperty.call(x10, "default") ? x10["default"] : x10;
}
function deepFreeze$1(obj) {
  if (obj instanceof Map) {
    obj.clear = obj.delete = obj.set = function() {
      throw new Error("map is read-only");
    };
  } else if (obj instanceof Set) {
    obj.add = obj.clear = obj.delete = function() {
      throw new Error("set is read-only");
    };
  }
  Object.freeze(obj);
  Object.getOwnPropertyNames(obj).forEach((name2) => {
    const prop = obj[name2];
    const type = typeof prop;
    if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
      deepFreeze$1(prop);
    }
  });
  return obj;
}
let Response$1 = class Response {
  /**
   * @param {CompiledMode} mode
   */
  constructor(mode) {
    if (mode.data === void 0)
      mode.data = {};
    this.data = mode.data;
    this.isMatchIgnored = false;
  }
  ignoreMatch() {
    this.isMatchIgnored = true;
  }
};
function escapeHTML$1(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function inherit$1$1(original, ...objects) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key2 in original) {
    result[key2] = original[key2];
  }
  objects.forEach(function(obj) {
    for (const key2 in obj) {
      result[key2] = obj[key2];
    }
  });
  return (
    /** @type {T} */
    result
  );
}
const SPAN_CLOSE$1 = "</span>";
const emitsWrappingTags$1 = (node2) => {
  return !!node2.scope;
};
const scopeToCSSClass$1 = (name2, { prefix }) => {
  if (name2.startsWith("language:")) {
    return name2.replace("language:", "language-");
  }
  if (name2.includes(".")) {
    const pieces = name2.split(".");
    return [
      `${prefix}${pieces.shift()}`,
      ...pieces.map((x10, i3) => `${x10}${"_".repeat(i3 + 1)}`)
    ].join(" ");
  }
  return `${prefix}${name2}`;
};
let HTMLRenderer$1 = class HTMLRenderer {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(text2) {
    this.buffer += escapeHTML$1(text2);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(node2) {
    if (!emitsWrappingTags$1(node2))
      return;
    const className = scopeToCSSClass$1(
      node2.scope,
      { prefix: this.classPrefix }
    );
    this.span(className);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(node2) {
    if (!emitsWrappingTags$1(node2))
      return;
    this.buffer += SPAN_CLOSE$1;
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(className) {
    this.buffer += `<span class="${className}">`;
  }
};
const newNode$1 = (opts = {}) => {
  const result = { children: [] };
  Object.assign(result, opts);
  return result;
};
let TokenTree$1 = class TokenTree {
  constructor() {
    this.rootNode = newNode$1();
    this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(node2) {
    this.top.children.push(node2);
  }
  /** @param {string} scope */
  openNode(scope) {
    const node2 = newNode$1({ scope });
    this.add(node2);
    this.stack.push(node2);
  }
  closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    return void 0;
  }
  closeAllNodes() {
    while (this.closeNode())
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(builder) {
    return this.constructor._walk(builder, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(builder, node2) {
    if (typeof node2 === "string") {
      builder.addText(node2);
    } else if (node2.children) {
      builder.openNode(node2);
      node2.children.forEach((child) => this._walk(builder, child));
      builder.closeNode(node2);
    }
    return builder;
  }
  /**
   * @param {Node} node
   */
  static _collapse(node2) {
    if (typeof node2 === "string")
      return;
    if (!node2.children)
      return;
    if (node2.children.every((el2) => typeof el2 === "string")) {
      node2.children = [node2.children.join("")];
    } else {
      node2.children.forEach((child) => {
        TokenTree._collapse(child);
      });
    }
  }
};
let TokenTreeEmitter$1 = class TokenTreeEmitter extends TokenTree$1 {
  /**
   * @param {*} options
   */
  constructor(options) {
    super();
    this.options = options;
  }
  /**
   * @param {string} text
   */
  addText(text2) {
    if (text2 === "") {
      return;
    }
    this.add(text2);
  }
  /** @param {string} scope */
  startScope(scope) {
    this.openNode(scope);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(emitter, name2) {
    const node2 = emitter.root;
    if (name2)
      node2.scope = `language:${name2}`;
    this.add(node2);
  }
  toHTML() {
    const renderer = new HTMLRenderer$1(this, this.options);
    return renderer.value();
  }
  finalize() {
    this.closeAllNodes();
    return true;
  }
};
function source$2(re2) {
  if (!re2)
    return null;
  if (typeof re2 === "string")
    return re2;
  return re2.source;
}
function lookahead$1(re2) {
  return concat$2("(?=", re2, ")");
}
function anyNumberOfTimes$1(re2) {
  return concat$2("(?:", re2, ")*");
}
function optional$1(re2) {
  return concat$2("(?:", re2, ")?");
}
function concat$2(...args) {
  const joined = args.map((x10) => source$2(x10)).join("");
  return joined;
}
function stripOptionsFromArgs$2(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either$2(...args) {
  const opts = stripOptionsFromArgs$2(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x10) => source$2(x10)).join("|") + ")";
  return joined;
}
function countMatchGroups$1(re2) {
  return new RegExp(re2.toString() + "|").exec("").length - 1;
}
function startsWith$1(re2, lexeme) {
  const match = re2 && re2.exec(lexeme);
  return match && match.index === 0;
}
const BACKREF_RE$1 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function _rewriteBackreferences$1(regexps, { joinWith }) {
  let numCaptures = 0;
  return regexps.map((regex2) => {
    numCaptures += 1;
    const offset = numCaptures;
    let re2 = source$2(regex2);
    let out = "";
    while (re2.length > 0) {
      const match = BACKREF_RE$1.exec(re2);
      if (!match) {
        out += re2;
        break;
      }
      out += re2.substring(0, match.index);
      re2 = re2.substring(match.index + match[0].length);
      if (match[0][0] === "\\" && match[1]) {
        out += "\\" + String(Number(match[1]) + offset);
      } else {
        out += match[0];
        if (match[0] === "(") {
          numCaptures++;
        }
      }
    }
    return out;
  }).map((re2) => `(${re2})`).join(joinWith);
}
const MATCH_NOTHING_RE$1 = /\b\B/;
const IDENT_RE$1 = "[a-zA-Z]\\w*";
const UNDERSCORE_IDENT_RE$1 = "[a-zA-Z_]\\w*";
const NUMBER_RE$1 = "\\b\\d+(\\.\\d+)?";
const C_NUMBER_RE$1 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
const BINARY_NUMBER_RE$1 = "\\b(0b[01]+)";
const RE_STARTERS_RE$1 = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
const SHEBANG$1 = (opts = {}) => {
  const beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat$2(
      beginShebang,
      /.*\b/,
      opts.binary,
      /\b.*/
    );
  }
  return inherit$1$1({
    scope: "meta",
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (m10, resp) => {
      if (m10.index !== 0)
        resp.ignoreMatch();
    }
  }, opts);
};
const BACKSLASH_ESCAPE$1 = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
};
const APOS_STRING_MODE$1 = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE$1]
};
const QUOTE_STRING_MODE$1 = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE$1]
};
const PHRASAL_WORDS_MODE$1 = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
const COMMENT$1 = function(begin, end, modeOptions = {}) {
  const mode = inherit$1$1(
    {
      scope: "comment",
      begin,
      end,
      contains: []
    },
    modeOptions
  );
  mode.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  const ENGLISH_WORD = either$2(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  mode.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: concat$2(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        ENGLISH_WORD,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  );
  return mode;
};
const C_LINE_COMMENT_MODE$1 = COMMENT$1("//", "$");
const C_BLOCK_COMMENT_MODE$1 = COMMENT$1("/\\*", "\\*/");
const HASH_COMMENT_MODE$1 = COMMENT$1("#", "$");
const NUMBER_MODE$1 = {
  scope: "number",
  begin: NUMBER_RE$1,
  relevance: 0
};
const C_NUMBER_MODE$1 = {
  scope: "number",
  begin: C_NUMBER_RE$1,
  relevance: 0
};
const BINARY_NUMBER_MODE$1 = {
  scope: "number",
  begin: BINARY_NUMBER_RE$1,
  relevance: 0
};
const REGEXP_MODE$1 = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    BACKSLASH_ESCAPE$1,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [BACKSLASH_ESCAPE$1]
    }
  ]
};
const TITLE_MODE$1 = {
  scope: "title",
  begin: IDENT_RE$1,
  relevance: 0
};
const UNDERSCORE_TITLE_MODE$1 = {
  scope: "title",
  begin: UNDERSCORE_IDENT_RE$1,
  relevance: 0
};
const METHOD_GUARD$1 = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + UNDERSCORE_IDENT_RE$1,
  relevance: 0
};
const END_SAME_AS_BEGIN$1 = function(mode) {
  return Object.assign(
    mode,
    {
      /** @type {ModeCallback} */
      "on:begin": (m10, resp) => {
        resp.data._beginMatch = m10[1];
      },
      /** @type {ModeCallback} */
      "on:end": (m10, resp) => {
        if (resp.data._beginMatch !== m10[1])
          resp.ignoreMatch();
      }
    }
  );
};
var MODES$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: APOS_STRING_MODE$1,
  BACKSLASH_ESCAPE: BACKSLASH_ESCAPE$1,
  BINARY_NUMBER_MODE: BINARY_NUMBER_MODE$1,
  BINARY_NUMBER_RE: BINARY_NUMBER_RE$1,
  COMMENT: COMMENT$1,
  C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE$1,
  C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE$1,
  C_NUMBER_MODE: C_NUMBER_MODE$1,
  C_NUMBER_RE: C_NUMBER_RE$1,
  END_SAME_AS_BEGIN: END_SAME_AS_BEGIN$1,
  HASH_COMMENT_MODE: HASH_COMMENT_MODE$1,
  IDENT_RE: IDENT_RE$1,
  MATCH_NOTHING_RE: MATCH_NOTHING_RE$1,
  METHOD_GUARD: METHOD_GUARD$1,
  NUMBER_MODE: NUMBER_MODE$1,
  NUMBER_RE: NUMBER_RE$1,
  PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE$1,
  QUOTE_STRING_MODE: QUOTE_STRING_MODE$1,
  REGEXP_MODE: REGEXP_MODE$1,
  RE_STARTERS_RE: RE_STARTERS_RE$1,
  SHEBANG: SHEBANG$1,
  TITLE_MODE: TITLE_MODE$1,
  UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE$1,
  UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE$1
});
function skipIfHasPrecedingDot$1(match, response) {
  const before = match.input[match.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}
function scopeClassName$1(mode, _parent) {
  if (mode.className !== void 0) {
    mode.scope = mode.className;
    delete mode.className;
  }
}
function beginKeywords$1(mode, parent) {
  if (!parent)
    return;
  if (!mode.beginKeywords)
    return;
  mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
  mode.__beforeBegin = skipIfHasPrecedingDot$1;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;
  if (mode.relevance === void 0)
    mode.relevance = 0;
}
function compileIllegal$1(mode, _parent) {
  if (!Array.isArray(mode.illegal))
    return;
  mode.illegal = either$2(...mode.illegal);
}
function compileMatch$1(mode, _parent) {
  if (!mode.match)
    return;
  if (mode.begin || mode.end)
    throw new Error("begin & end are not supported with match");
  mode.begin = mode.match;
  delete mode.match;
}
function compileRelevance$1(mode, _parent) {
  if (mode.relevance === void 0)
    mode.relevance = 1;
}
const beforeMatchExt$1 = (mode, parent) => {
  if (!mode.beforeMatch)
    return;
  if (mode.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const originalMode = Object.assign({}, mode);
  Object.keys(mode).forEach((key2) => {
    delete mode[key2];
  });
  mode.keywords = originalMode.keywords;
  mode.begin = concat$2(originalMode.beforeMatch, lookahead$1(originalMode.begin));
  mode.starts = {
    relevance: 0,
    contains: [
      Object.assign(originalMode, { endsParent: true })
    ]
  };
  mode.relevance = 0;
  delete originalMode.beforeMatch;
};
const COMMON_KEYWORDS$1 = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
];
const DEFAULT_KEYWORD_SCOPE$1 = "keyword";
function compileKeywords$1(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE$1) {
  const compiledKeywords = /* @__PURE__ */ Object.create(null);
  if (typeof rawKeywords === "string") {
    compileList(scopeName, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(scopeName, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(scopeName2) {
      Object.assign(
        compiledKeywords,
        compileKeywords$1(rawKeywords[scopeName2], caseInsensitive, scopeName2)
      );
    });
  }
  return compiledKeywords;
  function compileList(scopeName2, keywordList2) {
    if (caseInsensitive) {
      keywordList2 = keywordList2.map((x10) => x10.toLowerCase());
    }
    keywordList2.forEach(function(keyword2) {
      const pair = keyword2.split("|");
      compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword$1(pair[0], pair[1])];
    });
  }
}
function scoreForKeyword$1(keyword2, providedScore) {
  if (providedScore) {
    return Number(providedScore);
  }
  return commonKeyword$1(keyword2) ? 0 : 1;
}
function commonKeyword$1(keyword2) {
  return COMMON_KEYWORDS$1.includes(keyword2.toLowerCase());
}
const seenDeprecations$1 = {};
const error$1 = (message) => {
  console.error(message);
};
const warn$1 = (message, ...args) => {
  console.log(`WARN: ${message}`, ...args);
};
const deprecated$1 = (version2, message) => {
  if (seenDeprecations$1[`${version2}/${message}`])
    return;
  console.log(`Deprecated as of ${version2}. ${message}`);
  seenDeprecations$1[`${version2}/${message}`] = true;
};
const MultiClassError$1 = new Error();
function remapScopeNames$1(mode, regexes, { key: key2 }) {
  let offset = 0;
  const scopeNames = mode[key2];
  const emit = {};
  const positions = {};
  for (let i3 = 1; i3 <= regexes.length; i3++) {
    positions[i3 + offset] = scopeNames[i3];
    emit[i3 + offset] = true;
    offset += countMatchGroups$1(regexes[i3 - 1]);
  }
  mode[key2] = positions;
  mode[key2]._emit = emit;
  mode[key2]._multi = true;
}
function beginMultiClass$1(mode) {
  if (!Array.isArray(mode.begin))
    return;
  if (mode.skip || mode.excludeBegin || mode.returnBegin) {
    error$1("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
    throw MultiClassError$1;
  }
  if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
    error$1("beginScope must be object");
    throw MultiClassError$1;
  }
  remapScopeNames$1(mode, mode.begin, { key: "beginScope" });
  mode.begin = _rewriteBackreferences$1(mode.begin, { joinWith: "" });
}
function endMultiClass$1(mode) {
  if (!Array.isArray(mode.end))
    return;
  if (mode.skip || mode.excludeEnd || mode.returnEnd) {
    error$1("skip, excludeEnd, returnEnd not compatible with endScope: {}");
    throw MultiClassError$1;
  }
  if (typeof mode.endScope !== "object" || mode.endScope === null) {
    error$1("endScope must be object");
    throw MultiClassError$1;
  }
  remapScopeNames$1(mode, mode.end, { key: "endScope" });
  mode.end = _rewriteBackreferences$1(mode.end, { joinWith: "" });
}
function scopeSugar$1(mode) {
  if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
    mode.beginScope = mode.scope;
    delete mode.scope;
  }
}
function MultiClass$1(mode) {
  scopeSugar$1(mode);
  if (typeof mode.beginScope === "string") {
    mode.beginScope = { _wrap: mode.beginScope };
  }
  if (typeof mode.endScope === "string") {
    mode.endScope = { _wrap: mode.endScope };
  }
  beginMultiClass$1(mode);
  endMultiClass$1(mode);
}
function compileLanguage$1(language2) {
  function langRe(value, global2) {
    return new RegExp(
      source$2(value),
      "m" + (language2.case_insensitive ? "i" : "") + (language2.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
    );
  }
  class MultiRegex {
    constructor() {
      this.matchIndexes = {};
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }
    // @ts-ignore
    addRule(re2, opts) {
      opts.position = this.position++;
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re2]);
      this.matchAt += countMatchGroups$1(re2) + 1;
    }
    compile() {
      if (this.regexes.length === 0) {
        this.exec = () => null;
      }
      const terminators = this.regexes.map((el2) => el2[1]);
      this.matcherRe = langRe(_rewriteBackreferences$1(terminators, { joinWith: "|" }), true);
      this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(s3) {
      this.matcherRe.lastIndex = this.lastIndex;
      const match = this.matcherRe.exec(s3);
      if (!match) {
        return null;
      }
      const i3 = match.findIndex((el2, i10) => i10 > 0 && el2 !== void 0);
      const matchData = this.matchIndexes[i3];
      match.splice(0, i3);
      return Object.assign(match, matchData);
    }
  }
  class ResumableMultiRegex {
    constructor() {
      this.rules = [];
      this.multiRegexes = [];
      this.count = 0;
      this.lastIndex = 0;
      this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(index2) {
      if (this.multiRegexes[index2])
        return this.multiRegexes[index2];
      const matcher = new MultiRegex();
      this.rules.slice(index2).forEach(([re2, opts]) => matcher.addRule(re2, opts));
      matcher.compile();
      this.multiRegexes[index2] = matcher;
      return matcher;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(re2, opts) {
      this.rules.push([re2, opts]);
      if (opts.type === "begin")
        this.count++;
    }
    /** @param {string} s */
    exec(s3) {
      const m10 = this.getMatcher(this.regexIndex);
      m10.lastIndex = this.lastIndex;
      let result = m10.exec(s3);
      if (this.resumingScanAtSamePosition()) {
        if (result && result.index === this.lastIndex)
          ;
        else {
          const m22 = this.getMatcher(0);
          m22.lastIndex = this.lastIndex + 1;
          result = m22.exec(s3);
        }
      }
      if (result) {
        this.regexIndex += result.position + 1;
        if (this.regexIndex === this.count) {
          this.considerAll();
        }
      }
      return result;
    }
  }
  function buildModeRegex(mode) {
    const mm2 = new ResumableMultiRegex();
    mode.contains.forEach((term) => mm2.addRule(term.begin, { rule: term, type: "begin" }));
    if (mode.terminatorEnd) {
      mm2.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm2.addRule(mode.illegal, { type: "illegal" });
    }
    return mm2;
  }
  function compileMode(mode, parent) {
    const cmode = (
      /** @type CompiledMode */
      mode
    );
    if (mode.isCompiled)
      return cmode;
    [
      scopeClassName$1,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      compileMatch$1,
      MultiClass$1,
      beforeMatchExt$1
    ].forEach((ext) => ext(mode, parent));
    language2.compilerExtensions.forEach((ext) => ext(mode, parent));
    mode.__beforeBegin = null;
    [
      beginKeywords$1,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      compileIllegal$1,
      // default to 1 relevance if not specified
      compileRelevance$1
    ].forEach((ext) => ext(mode, parent));
    mode.isCompiled = true;
    let keywordPattern = null;
    if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
      mode.keywords = Object.assign({}, mode.keywords);
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }
    keywordPattern = keywordPattern || /\w+/;
    if (mode.keywords) {
      mode.keywords = compileKeywords$1(mode.keywords, language2.case_insensitive);
    }
    cmode.keywordPatternRe = langRe(keywordPattern, true);
    if (parent) {
      if (!mode.begin)
        mode.begin = /\B|\b/;
      cmode.beginRe = langRe(cmode.begin);
      if (!mode.end && !mode.endsWithParent)
        mode.end = /\B|\b/;
      if (mode.end)
        cmode.endRe = langRe(cmode.end);
      cmode.terminatorEnd = source$2(cmode.end) || "";
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
      }
    }
    if (mode.illegal)
      cmode.illegalRe = langRe(
        /** @type {RegExp | string} */
        mode.illegal
      );
    if (!mode.contains)
      mode.contains = [];
    mode.contains = [].concat(...mode.contains.map(function(c3) {
      return expandOrCloneMode$1(c3 === "self" ? mode : c3);
    }));
    mode.contains.forEach(function(c3) {
      compileMode(
        /** @type Mode */
        c3,
        cmode
      );
    });
    if (mode.starts) {
      compileMode(mode.starts, parent);
    }
    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }
  if (!language2.compilerExtensions)
    language2.compilerExtensions = [];
  if (language2.contains && language2.contains.includes("self")) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }
  language2.classNameAliases = inherit$1$1(language2.classNameAliases || {});
  return compileMode(
    /** @type Mode */
    language2
  );
}
function dependencyOnParent$1(mode) {
  if (!mode)
    return false;
  return mode.endsWithParent || dependencyOnParent$1(mode.starts);
}
function expandOrCloneMode$1(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit$1$1(mode, { variants: null }, variant);
    });
  }
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }
  if (dependencyOnParent$1(mode)) {
    return inherit$1$1(mode, { starts: mode.starts ? inherit$1$1(mode.starts) : null });
  }
  if (Object.isFrozen(mode)) {
    return inherit$1$1(mode);
  }
  return mode;
}
var version$1 = "11.9.0";
let HTMLInjectionError$1 = class HTMLInjectionError extends Error {
  constructor(reason, html2) {
    super(reason);
    this.name = "HTMLInjectionError";
    this.html = html2;
  }
};
const escape$2 = escapeHTML$1;
const inherit$2 = inherit$1$1;
const NO_MATCH$1 = Symbol("nomatch");
const MAX_KEYWORD_HITS$1 = 7;
const HLJS$1 = function(hljs) {
  const languages = /* @__PURE__ */ Object.create(null);
  const aliases = /* @__PURE__ */ Object.create(null);
  const plugins = [];
  let SAFE_MODE = true;
  const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
  let options = {
    ignoreUnescapedHTML: false,
    throwUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: TokenTreeEmitter$1
  };
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }
  function blockLanguage(block) {
    let classes = block.className + " ";
    classes += block.parentNode ? block.parentNode.className : "";
    const match = options.languageDetectRe.exec(classes);
    if (match) {
      const language2 = getLanguage(match[1]);
      if (!language2) {
        warn$1(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
        warn$1("Falling back to no-highlight mode for this block.", block);
      }
      return language2 ? match[1] : "no-highlight";
    }
    return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
  }
  function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
    let code = "";
    let languageName = "";
    if (typeof optionsOrCode === "object") {
      code = codeOrLanguageName;
      ignoreIllegals = optionsOrCode.ignoreIllegals;
      languageName = optionsOrCode.language;
    } else {
      deprecated$1("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
      deprecated$1("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
      languageName = codeOrLanguageName;
      code = optionsOrCode;
    }
    if (ignoreIllegals === void 0) {
      ignoreIllegals = true;
    }
    const context = {
      code,
      language: languageName
    };
    fire("before:highlight", context);
    const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
    result.code = context.code;
    fire("after:highlight", result);
    return result;
  }
  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
    const keywordHits = /* @__PURE__ */ Object.create(null);
    function keywordData(mode, matchText) {
      return mode.keywords[matchText];
    }
    function processKeywords() {
      if (!top2.keywords) {
        emitter.addText(modeBuffer);
        return;
      }
      let lastIndex = 0;
      top2.keywordPatternRe.lastIndex = 0;
      let match = top2.keywordPatternRe.exec(modeBuffer);
      let buf = "";
      while (match) {
        buf += modeBuffer.substring(lastIndex, match.index);
        const word = language2.case_insensitive ? match[0].toLowerCase() : match[0];
        const data = keywordData(top2, word);
        if (data) {
          const [kind, keywordRelevance] = data;
          emitter.addText(buf);
          buf = "";
          keywordHits[word] = (keywordHits[word] || 0) + 1;
          if (keywordHits[word] <= MAX_KEYWORD_HITS$1)
            relevance += keywordRelevance;
          if (kind.startsWith("_")) {
            buf += match[0];
          } else {
            const cssClass = language2.classNameAliases[kind] || kind;
            emitKeyword(match[0], cssClass);
          }
        } else {
          buf += match[0];
        }
        lastIndex = top2.keywordPatternRe.lastIndex;
        match = top2.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substring(lastIndex);
      emitter.addText(buf);
    }
    function processSubLanguage() {
      if (modeBuffer === "")
        return;
      let result2 = null;
      if (typeof top2.subLanguage === "string") {
        if (!languages[top2.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result2 = _highlight(top2.subLanguage, modeBuffer, true, continuations[top2.subLanguage]);
        continuations[top2.subLanguage] = /** @type {CompiledMode} */
        result2._top;
      } else {
        result2 = highlightAuto(modeBuffer, top2.subLanguage.length ? top2.subLanguage : null);
      }
      if (top2.relevance > 0) {
        relevance += result2.relevance;
      }
      emitter.__addSublanguage(result2._emitter, result2.language);
    }
    function processBuffer() {
      if (top2.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = "";
    }
    function emitKeyword(keyword2, scope) {
      if (keyword2 === "")
        return;
      emitter.startScope(scope);
      emitter.addText(keyword2);
      emitter.endScope();
    }
    function emitMultiClass(scope, match) {
      let i3 = 1;
      const max2 = match.length - 1;
      while (i3 <= max2) {
        if (!scope._emit[i3]) {
          i3++;
          continue;
        }
        const klass = language2.classNameAliases[scope[i3]] || scope[i3];
        const text2 = match[i3];
        if (klass) {
          emitKeyword(text2, klass);
        } else {
          modeBuffer = text2;
          processKeywords();
          modeBuffer = "";
        }
        i3++;
      }
    }
    function startNewMode(mode, match) {
      if (mode.scope && typeof mode.scope === "string") {
        emitter.openNode(language2.classNameAliases[mode.scope] || mode.scope);
      }
      if (mode.beginScope) {
        if (mode.beginScope._wrap) {
          emitKeyword(modeBuffer, language2.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
          modeBuffer = "";
        } else if (mode.beginScope._multi) {
          emitMultiClass(mode.beginScope, match);
          modeBuffer = "";
        }
      }
      top2 = Object.create(mode, { parent: { value: top2 } });
      return top2;
    }
    function endOfMode(mode, match, matchPlusRemainder) {
      let matched = startsWith$1(mode.endRe, matchPlusRemainder);
      if (matched) {
        if (mode["on:end"]) {
          const resp = new Response$1(mode);
          mode["on:end"](match, resp);
          if (resp.isMatchIgnored)
            matched = false;
        }
        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match, matchPlusRemainder);
      }
    }
    function doIgnore(lexeme) {
      if (top2.matcher.regexIndex === 0) {
        modeBuffer += lexeme[0];
        return 1;
      } else {
        resumeScanAtSamePosition = true;
        return 0;
      }
    }
    function doBeginMatch(match) {
      const lexeme = match[0];
      const newMode = match.rule;
      const resp = new Response$1(newMode);
      const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
      for (const cb of beforeCallbacks) {
        if (!cb)
          continue;
        cb(match, resp);
        if (resp.isMatchIgnored)
          return doIgnore(lexeme);
      }
      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode, match);
      return newMode.returnBegin ? 0 : lexeme.length;
    }
    function doEndMatch(match) {
      const lexeme = match[0];
      const matchPlusRemainder = codeToHighlight.substring(match.index);
      const endMode = endOfMode(top2, match, matchPlusRemainder);
      if (!endMode) {
        return NO_MATCH$1;
      }
      const origin = top2;
      if (top2.endScope && top2.endScope._wrap) {
        processBuffer();
        emitKeyword(lexeme, top2.endScope._wrap);
      } else if (top2.endScope && top2.endScope._multi) {
        processBuffer();
        emitMultiClass(top2.endScope, match);
      } else if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top2.scope) {
          emitter.closeNode();
        }
        if (!top2.skip && !top2.subLanguage) {
          relevance += top2.relevance;
        }
        top2 = top2.parent;
      } while (top2 !== endMode.parent);
      if (endMode.starts) {
        startNewMode(endMode.starts, match);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }
    function processContinuations() {
      const list2 = [];
      for (let current = top2; current !== language2; current = current.parent) {
        if (current.scope) {
          list2.unshift(current.scope);
        }
      }
      list2.forEach((item) => emitter.openNode(item));
    }
    let lastMatch = {};
    function processLexeme(textBeforeMatch, match) {
      const lexeme = match && match[0];
      modeBuffer += textBeforeMatch;
      if (lexeme == null) {
        processBuffer();
        return 0;
      }
      if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
        if (!SAFE_MODE) {
          const err = new Error(`0 width match regex (${languageName})`);
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match;
      if (match.type === "begin") {
        return doBeginMatch(match);
      } else if (match.type === "illegal" && !ignoreIllegals) {
        const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top2.scope || "<unnamed>") + '"');
        err.mode = top2;
        throw err;
      } else if (match.type === "end") {
        const processed = doEndMatch(match);
        if (processed !== NO_MATCH$1) {
          return processed;
        }
      }
      if (match.type === "illegal" && lexeme === "") {
        return 1;
      }
      if (iterations > 1e5 && iterations > match.index * 3) {
        const err = new Error("potential infinite loop, way more iterations than matches");
        throw err;
      }
      modeBuffer += lexeme;
      return lexeme.length;
    }
    const language2 = getLanguage(languageName);
    if (!language2) {
      error$1(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }
    const md = compileLanguage$1(language2);
    let result = "";
    let top2 = continuation || md;
    const continuations = {};
    const emitter = new options.__emitter(options);
    processContinuations();
    let modeBuffer = "";
    let relevance = 0;
    let index2 = 0;
    let iterations = 0;
    let resumeScanAtSamePosition = false;
    try {
      if (!language2.__emitTokens) {
        top2.matcher.considerAll();
        for (; ; ) {
          iterations++;
          if (resumeScanAtSamePosition) {
            resumeScanAtSamePosition = false;
          } else {
            top2.matcher.considerAll();
          }
          top2.matcher.lastIndex = index2;
          const match = top2.matcher.exec(codeToHighlight);
          if (!match)
            break;
          const beforeMatch = codeToHighlight.substring(index2, match.index);
          const processedCount = processLexeme(beforeMatch, match);
          index2 = match.index + processedCount;
        }
        processLexeme(codeToHighlight.substring(index2));
      } else {
        language2.__emitTokens(codeToHighlight, emitter);
      }
      emitter.finalize();
      result = emitter.toHTML();
      return {
        language: languageName,
        value: result,
        relevance,
        illegal: false,
        _emitter: emitter,
        _top: top2
      };
    } catch (err) {
      if (err.message && err.message.includes("Illegal")) {
        return {
          language: languageName,
          value: escape$2(codeToHighlight),
          illegal: true,
          relevance: 0,
          _illegalBy: {
            message: err.message,
            index: index2,
            context: codeToHighlight.slice(index2 - 100, index2 + 100),
            mode: err.mode,
            resultSoFar: result
          },
          _emitter: emitter
        };
      } else if (SAFE_MODE) {
        return {
          language: languageName,
          value: escape$2(codeToHighlight),
          illegal: false,
          relevance: 0,
          errorRaised: err,
          _emitter: emitter,
          _top: top2
        };
      } else {
        throw err;
      }
    }
  }
  function justTextHighlightResult(code) {
    const result = {
      value: escape$2(code),
      illegal: false,
      relevance: 0,
      _top: PLAINTEXT_LANGUAGE,
      _emitter: new options.__emitter(options)
    };
    result._emitter.addText(code);
    return result;
  }
  function highlightAuto(code, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages);
    const plaintext2 = justTextHighlightResult(code);
    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
      (name2) => _highlight(name2, code, false)
    );
    results.unshift(plaintext2);
    const sorted = results.sort((a3, b10) => {
      if (a3.relevance !== b10.relevance)
        return b10.relevance - a3.relevance;
      if (a3.language && b10.language) {
        if (getLanguage(a3.language).supersetOf === b10.language) {
          return 1;
        } else if (getLanguage(b10.language).supersetOf === a3.language) {
          return -1;
        }
      }
      return 0;
    });
    const [best, secondBest] = sorted;
    const result = best;
    result.secondBest = secondBest;
    return result;
  }
  function updateClassName(element2, currentLang, resultLang) {
    const language2 = currentLang && aliases[currentLang] || resultLang;
    element2.classList.add("hljs");
    element2.classList.add(`language-${language2}`);
  }
  function highlightElement(element2) {
    let node2 = null;
    const language2 = blockLanguage(element2);
    if (shouldNotHighlight(language2))
      return;
    fire(
      "before:highlightElement",
      { el: element2, language: language2 }
    );
    if (element2.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", element2);
      return;
    }
    if (element2.children.length > 0) {
      if (!options.ignoreUnescapedHTML) {
        console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
        console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
        console.warn("The element with unescaped HTML:");
        console.warn(element2);
      }
      if (options.throwUnescapedHTML) {
        const err = new HTMLInjectionError$1(
          "One of your code blocks includes unescaped HTML.",
          element2.innerHTML
        );
        throw err;
      }
    }
    node2 = element2;
    const text2 = node2.textContent;
    const result = language2 ? highlight2(text2, { language: language2, ignoreIllegals: true }) : highlightAuto(text2);
    element2.innerHTML = result.value;
    element2.dataset.highlighted = "yes";
    updateClassName(element2, language2, result.language);
    element2.result = {
      language: result.language,
      // TODO: remove with version 11.0
      re: result.relevance,
      relevance: result.relevance
    };
    if (result.secondBest) {
      element2.secondBest = {
        language: result.secondBest.language,
        relevance: result.secondBest.relevance
      };
    }
    fire("after:highlightElement", { el: element2, result, text: text2 });
  }
  function configure2(userOptions) {
    options = inherit$2(options, userOptions);
  }
  const initHighlighting = () => {
    highlightAll();
    deprecated$1("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function initHighlightingOnLoad() {
    highlightAll();
    deprecated$1("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let wantsHighlight = false;
  function highlightAll() {
    if (document.readyState === "loading") {
      wantsHighlight = true;
      return;
    }
    const blocks2 = document.querySelectorAll(options.cssSelector);
    blocks2.forEach(highlightElement);
  }
  function boot() {
    if (wantsHighlight)
      highlightAll();
  }
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("DOMContentLoaded", boot, false);
  }
  function registerLanguage(languageName, languageDefinition) {
    let lang = null;
    try {
      lang = languageDefinition(hljs);
    } catch (error$1$1) {
      error$1("Language definition for '{}' could not be registered.".replace("{}", languageName));
      if (!SAFE_MODE) {
        throw error$1$1;
      } else {
        error$1(error$1$1);
      }
      lang = PLAINTEXT_LANGUAGE;
    }
    if (!lang.name)
      lang.name = languageName;
    languages[languageName] = lang;
    lang.rawDefinition = languageDefinition.bind(null, hljs);
    if (lang.aliases) {
      registerAliases(lang.aliases, { languageName });
    }
  }
  function unregisterLanguage(languageName) {
    delete languages[languageName];
    for (const alias of Object.keys(aliases)) {
      if (aliases[alias] === languageName) {
        delete aliases[alias];
      }
    }
  }
  function listLanguages() {
    return Object.keys(languages);
  }
  function getLanguage(name2) {
    name2 = (name2 || "").toLowerCase();
    return languages[name2] || languages[aliases[name2]];
  }
  function registerAliases(aliasList, { languageName }) {
    if (typeof aliasList === "string") {
      aliasList = [aliasList];
    }
    aliasList.forEach((alias) => {
      aliases[alias.toLowerCase()] = languageName;
    });
  }
  function autoDetection(name2) {
    const lang = getLanguage(name2);
    return lang && !lang.disableAutodetect;
  }
  function upgradePluginAPI(plugin) {
    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
      plugin["before:highlightElement"] = (data) => {
        plugin["before:highlightBlock"](
          Object.assign({ block: data.el }, data)
        );
      };
    }
    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
      plugin["after:highlightElement"] = (data) => {
        plugin["after:highlightBlock"](
          Object.assign({ block: data.el }, data)
        );
      };
    }
  }
  function addPlugin(plugin) {
    upgradePluginAPI(plugin);
    plugins.push(plugin);
  }
  function removePlugin(plugin) {
    const index2 = plugins.indexOf(plugin);
    if (index2 !== -1) {
      plugins.splice(index2, 1);
    }
  }
  function fire(event, args) {
    const cb = event;
    plugins.forEach(function(plugin) {
      if (plugin[cb]) {
        plugin[cb](args);
      }
    });
  }
  function deprecateHighlightBlock(el2) {
    deprecated$1("10.7.0", "highlightBlock will be removed entirely in v12.0");
    deprecated$1("10.7.0", "Please use highlightElement now.");
    return highlightElement(el2);
  }
  Object.assign(hljs, {
    highlight: highlight2,
    highlightAuto,
    highlightAll,
    highlightElement,
    // TODO: Remove with v12 API
    highlightBlock: deprecateHighlightBlock,
    configure: configure2,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage,
    unregisterLanguage,
    listLanguages,
    getLanguage,
    registerAliases,
    autoDetection,
    inherit: inherit$2,
    addPlugin,
    removePlugin
  });
  hljs.debugMode = function() {
    SAFE_MODE = false;
  };
  hljs.safeMode = function() {
    SAFE_MODE = true;
  };
  hljs.versionString = version$1;
  hljs.regex = {
    concat: concat$2,
    lookahead: lookahead$1,
    either: either$2,
    optional: optional$1,
    anyNumberOfTimes: anyNumberOfTimes$1
  };
  for (const key2 in MODES$1) {
    if (typeof MODES$1[key2] === "object") {
      deepFreeze$1(MODES$1[key2]);
    }
  }
  Object.assign(hljs, MODES$1);
  return hljs;
};
const highlight$1 = HLJS$1({});
highlight$1.newInstance = () => HLJS$1({});
var core$2 = highlight$1;
highlight$1.HighlightJS = highlight$1;
highlight$1.default = highlight$1;
const HighlightJS = /* @__PURE__ */ getDefaultExportFromCjs$1(core$2);
const emptyOptions$6 = {};
const defaultPrefix = "hljs-";
function createLowlight(grammars2) {
  const high = HighlightJS.newInstance();
  if (grammars2) {
    register(grammars2);
  }
  return {
    highlight: highlight2,
    highlightAuto,
    listLanguages,
    register,
    registerAlias,
    registered
  };
  function highlight2(language2, value, options) {
    const settings = options || emptyOptions$6;
    const prefix = typeof settings.prefix === "string" ? settings.prefix : defaultPrefix;
    if (!high.getLanguage(language2)) {
      throw new Error("Unknown language: `" + language2 + "` is not registered");
    }
    high.configure({ __emitter: HastEmitter, classPrefix: prefix });
    const result = (
      /** @type {HighlightResult & {_emitter: HastEmitter}} */
      high.highlight(value, { ignoreIllegals: true, language: language2 })
    );
    if (result.errorRaised) {
      throw new Error("Could not highlight with `Highlight.js`", {
        cause: result.errorRaised
      });
    }
    const root2 = result._emitter.root;
    const data = (
      /** @type {RootData} */
      root2.data
    );
    data.language = result.language;
    data.relevance = result.relevance;
    return root2;
  }
  function highlightAuto(value, options) {
    const settings = options || emptyOptions$6;
    const subset = settings.subset || listLanguages();
    let index2 = -1;
    let relevance = 0;
    let result;
    while (++index2 < subset.length) {
      const name2 = subset[index2];
      if (!high.getLanguage(name2))
        continue;
      const current = highlight2(name2, value, options);
      if (current.data && current.data.relevance !== void 0 && current.data.relevance > relevance) {
        relevance = current.data.relevance;
        result = current;
      }
    }
    return result || {
      type: "root",
      children: [],
      data: { language: void 0, relevance }
    };
  }
  function listLanguages() {
    return high.listLanguages();
  }
  function register(grammarsOrName, grammar) {
    if (typeof grammarsOrName === "string") {
      high.registerLanguage(grammarsOrName, grammar);
    } else {
      let name2;
      for (name2 in grammarsOrName) {
        if (Object.hasOwn(grammarsOrName, name2)) {
          high.registerLanguage(name2, grammarsOrName[name2]);
        }
      }
    }
  }
  function registerAlias(aliasesOrName, alias) {
    if (typeof aliasesOrName === "string") {
      high.registerAliases(
        // Note: copy needed because hljs doesn’t accept readonly arrays yet.
        typeof alias === "string" ? alias : [...alias],
        { languageName: aliasesOrName }
      );
    } else {
      let key2;
      for (key2 in aliasesOrName) {
        if (Object.hasOwn(aliasesOrName, key2)) {
          const aliases = aliasesOrName[key2];
          high.registerAliases(
            // Note: copy needed because hljs doesn’t accept readonly arrays yet.
            typeof aliases === "string" ? aliases : [...aliases],
            { languageName: key2 }
          );
        }
      }
    }
  }
  function registered(aliasOrName) {
    return Boolean(high.getLanguage(aliasOrName));
  }
}
class HastEmitter {
  /**
   * @param {Readonly<HljsOptions>} options
   *   Configuration.
   * @returns
   *   Instance.
   */
  constructor(options) {
    this.options = options;
    this.root = {
      type: "root",
      children: [],
      data: { language: void 0, relevance: 0 }
    };
    this.stack = [this.root];
  }
  /**
   * @param {string} value
   *   Text to add.
   * @returns {undefined}
   *   Nothing.
   *
   */
  addText(value) {
    if (value === "")
      return;
    const current = this.stack[this.stack.length - 1];
    const tail = current.children[current.children.length - 1];
    if (tail && tail.type === "text") {
      tail.value += value;
    } else {
      current.children.push({ type: "text", value });
    }
  }
  /**
   *
   * @param {unknown} rawName
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  startScope(rawName) {
    this.openNode(String(rawName));
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  endScope() {
    this.closeNode();
  }
  /**
   * @param {HastEmitter} other
   *   Other emitter.
   * @param {string} name
   *   Name of the sublanguage.
   * @returns {undefined}
   *   Nothing.
   */
  __addSublanguage(other, name2) {
    const current = this.stack[this.stack.length - 1];
    const results = (
      /** @type {Array<ElementContent>} */
      other.root.children
    );
    if (name2) {
      current.children.push({
        type: "element",
        tagName: "span",
        properties: { className: [name2] },
        children: results
      });
    } else {
      current.children.push(...results);
    }
  }
  /**
   * @param {string} name
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  openNode(name2) {
    const self2 = this;
    const className = name2.split(".").map(function(d3, i3) {
      return i3 ? d3 + "_".repeat(i3) : self2.options.classPrefix + d3;
    });
    const current = this.stack[this.stack.length - 1];
    const child = {
      type: "element",
      tagName: "span",
      properties: { className },
      children: []
    };
    current.children.push(child);
    this.stack.push(child);
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  closeNode() {
    this.stack.pop();
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  finalize() {
  }
  /**
   * @returns {string}
   *   Nothing.
   */
  toHTML() {
    return "";
  }
}
const emptyOptions$5 = {};
function rehypeHighlight(options) {
  const settings = options || emptyOptions$5;
  const aliases = settings.aliases;
  const detect = settings.detect || false;
  const languages = settings.languages || grammars;
  const plainText = settings.plainText;
  const prefix = settings.prefix;
  const subset = settings.subset;
  let name2 = "hljs";
  const lowlight = createLowlight(languages);
  if (aliases) {
    lowlight.registerAlias(aliases);
  }
  if (prefix) {
    const pos = prefix.indexOf("-");
    name2 = pos > -1 ? prefix.slice(0, pos) : prefix;
  }
  return function(tree, file) {
    visit$1(tree, "element", function(node2, _10, parent) {
      if (node2.tagName !== "code" || !parent || parent.type !== "element" || parent.tagName !== "pre") {
        return;
      }
      const lang = language$1(node2);
      if (lang === false || !lang && !detect || lang && plainText && plainText.includes(lang)) {
        return;
      }
      if (!Array.isArray(node2.properties.className)) {
        node2.properties.className = [];
      }
      if (!node2.properties.className.includes(name2)) {
        node2.properties.className.unshift(name2);
      }
      let result;
      try {
        result = lang ? lowlight.highlight(lang, toText(parent), { prefix }) : lowlight.highlightAuto(toText(parent), { prefix, subset });
      } catch (error2) {
        const cause = (
          /** @type {Error} */
          error2
        );
        if (lang && /Unknown language/.test(cause.message)) {
          file.message(
            "Cannot highlight as `" + lang + "`, it’s not registered",
            {
              ancestors: [parent, node2],
              cause,
              place: node2.position,
              ruleId: "missing-language",
              source: "rehype-highlight"
            }
          );
          return;
        }
        throw cause;
      }
      if (!lang && result.data && result.data.language) {
        node2.properties.className.push("language-" + result.data.language);
      }
      if (result.children.length > 0) {
        node2.children = /** @type {Array<ElementContent>} */
        result.children;
      }
    });
  };
}
function language$1(node2) {
  const className = node2.properties.className;
  let index2 = -1;
  if (!Array.isArray(className)) {
    return;
  }
  while (++index2 < className.length) {
    const value = String(className[index2]);
    if (value === "no-highlight" || value === "nohighlight") {
      return false;
    }
    if (value.slice(0, 5) === "lang-") {
      return value.slice(5);
    }
    if (value.slice(0, 9) === "language-") {
      return value.slice(9);
    }
  }
}
const pointEnd = point$3("end");
const pointStart = point$3("start");
function point$3(type) {
  return point2;
  function point2(node2) {
    const point3 = node2 && node2.position && node2.position[type] || {};
    if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
      return {
        line: point3.line,
        column: point3.column,
        offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
      };
    }
  }
}
function position$2(node2) {
  const start = pointStart(node2);
  const end = pointEnd(node2);
  if (start && end) {
    return { start, end };
  }
}
const aria$1 = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"];
const defaultSchema = {
  ancestors: {
    tbody: ["table"],
    td: ["table"],
    th: ["table"],
    thead: ["table"],
    tfoot: ["table"],
    tr: ["table"]
  },
  attributes: {
    a: [
      ...aria$1,
      // Note: these 3 are used by GFM footnotes, they do work on all links.
      "dataFootnoteBackref",
      "dataFootnoteRef",
      ["className", "data-footnote-backref"],
      "href"
    ],
    blockquote: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `code` as HTML in markdown, they adds it some other way.
    // We can’t do that, so we have to allow it.
    code: [["className", /^language-./]],
    del: ["cite"],
    div: ["itemScope", "itemType"],
    dl: [...aria$1],
    // Note: these 2 are used by GFM footnotes, they *sometimes* work.
    h2: [
      ["id", "footnote-label"],
      ["className", "sr-only"]
    ],
    img: [...aria$1, "longDesc", "src"],
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We can’t do that, so we have to allow it.
    input: [
      ["disabled", true],
      ["type", "checkbox"]
    ],
    ins: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `li` as HTML in markdown, they adds it some other way.
    // We can’t do that, so we have to allow it.
    li: [["className", "task-list-item"]],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We can’t do that, so we have to allow it.
    ol: [...aria$1, ["className", "contains-task-list"]],
    q: ["cite"],
    section: ["dataFootnotes", ["className", "footnotes"]],
    source: ["srcSet"],
    summary: [...aria$1],
    table: [...aria$1],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We can’t do that, so we have to allow it.
    ul: [...aria$1, ["className", "contains-task-list"]],
    "*": [
      "abbr",
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "align",
      "alt",
      "axis",
      "border",
      "cellPadding",
      "cellSpacing",
      "char",
      "charOff",
      "charSet",
      "checked",
      "clear",
      "colSpan",
      "color",
      "cols",
      "compact",
      "coords",
      "dateTime",
      "dir",
      "disabled",
      "encType",
      "frame",
      "hSpace",
      "headers",
      "height",
      "hrefLang",
      "htmlFor",
      "id",
      "isMap",
      "itemProp",
      "label",
      "lang",
      "maxLength",
      "media",
      "method",
      "multiple",
      "name",
      "noHref",
      "noShade",
      "noWrap",
      "open",
      "prompt",
      "readOnly",
      "rel",
      "rev",
      "rowSpan",
      "rows",
      "rules",
      "scope",
      "selected",
      "shape",
      "size",
      "span",
      "start",
      "summary",
      "tabIndex",
      "target",
      "title",
      "useMap",
      "vAlign",
      "value",
      "width"
    ]
  },
  clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
  clobberPrefix: "user-content-",
  protocols: {
    cite: ["http", "https"],
    href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
    longDesc: ["http", "https"],
    src: ["http", "https"]
  },
  required: {
    input: { disabled: true, type: "checkbox" }
  },
  strip: ["script"],
  tagNames: [
    "a",
    "b",
    "blockquote",
    "br",
    "code",
    "dd",
    "del",
    "details",
    "div",
    "dl",
    "dt",
    "em",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We can’t do that, so we have to allow it.
    "input",
    "ins",
    "kbd",
    "li",
    "ol",
    "p",
    "picture",
    "pre",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "source",
    "span",
    "strike",
    "strong",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr",
    "tt",
    "ul",
    "var"
  ]
};
const own$f = {}.hasOwnProperty;
function sanitize(node2, options) {
  let ctx = { type: "root", children: [] };
  const state = {
    schema: options ? { ...defaultSchema, ...options } : defaultSchema,
    stack: []
  };
  const replace2 = transform(state, node2);
  if (replace2) {
    if (Array.isArray(replace2)) {
      if (replace2.length === 1) {
        ctx = replace2[0];
      } else {
        ctx.children = replace2;
      }
    } else {
      ctx = replace2;
    }
  }
  return ctx;
}
function transform(state, node2) {
  if (node2 && typeof node2 === "object") {
    const unsafe2 = (
      /** @type {Record<string, Readonly<unknown>>} */
      node2
    );
    const type = typeof unsafe2.type === "string" ? unsafe2.type : "";
    switch (type) {
      case "comment": {
        return comment$3(state, unsafe2);
      }
      case "doctype": {
        return doctype$2(state, unsafe2);
      }
      case "element": {
        return element$2(state, unsafe2);
      }
      case "root": {
        return root$6(state, unsafe2);
      }
      case "text": {
        return text$8(state, unsafe2);
      }
    }
  }
}
function comment$3(state, unsafe2) {
  if (state.schema.allowComments) {
    const result = typeof unsafe2.value === "string" ? unsafe2.value : "";
    const index2 = result.indexOf("-->");
    const value = index2 < 0 ? result : result.slice(0, index2);
    const node2 = { type: "comment", value };
    patch$1(node2, unsafe2);
    return node2;
  }
}
function doctype$2(state, unsafe2) {
  if (state.schema.allowDoctypes) {
    const node2 = { type: "doctype" };
    patch$1(node2, unsafe2);
    return node2;
  }
}
function element$2(state, unsafe2) {
  const name2 = typeof unsafe2.tagName === "string" ? unsafe2.tagName : "";
  state.stack.push(name2);
  const content2 = (
    /** @type {Array<ElementContent>} */
    children(state, unsafe2.children)
  );
  const props = properties(state, unsafe2.properties);
  state.stack.pop();
  let safeElement = false;
  if (name2.length > 0 && name2 !== "*" && (!state.schema.tagNames || state.schema.tagNames.includes(name2))) {
    safeElement = true;
    if (state.schema.ancestors && own$f.call(state.schema.ancestors, name2)) {
      const ancestors = state.schema.ancestors[name2];
      let index2 = -1;
      safeElement = false;
      while (++index2 < ancestors.length) {
        if (state.stack.includes(ancestors[index2])) {
          safeElement = true;
        }
      }
    }
  }
  if (!safeElement) {
    return state.schema.strip && !state.schema.strip.includes(name2) ? content2 : void 0;
  }
  const node2 = {
    type: "element",
    tagName: name2,
    properties: props,
    children: content2
  };
  patch$1(node2, unsafe2);
  return node2;
}
function root$6(state, unsafe2) {
  const content2 = (
    /** @type {Array<RootContent>} */
    children(state, unsafe2.children)
  );
  const node2 = { type: "root", children: content2 };
  patch$1(node2, unsafe2);
  return node2;
}
function text$8(_10, unsafe2) {
  const value = typeof unsafe2.value === "string" ? unsafe2.value : "";
  const node2 = { type: "text", value };
  patch$1(node2, unsafe2);
  return node2;
}
function children(state, children2) {
  const results = [];
  if (Array.isArray(children2)) {
    const childrenUnknown = (
      /** @type {Array<Readonly<unknown>>} */
      children2
    );
    let index2 = -1;
    while (++index2 < childrenUnknown.length) {
      const value = transform(state, childrenUnknown[index2]);
      if (value) {
        if (Array.isArray(value)) {
          results.push(...value);
        } else {
          results.push(value);
        }
      }
    }
  }
  return results;
}
function properties(state, properties2) {
  const tagName = state.stack[state.stack.length - 1];
  const attributes = state.schema.attributes;
  const required = state.schema.required;
  const specific = attributes && own$f.call(attributes, tagName) ? attributes[tagName] : void 0;
  const defaults = attributes && own$f.call(attributes, "*") ? attributes["*"] : void 0;
  const props = (
    /** @type {Readonly<Record<string, Readonly<unknown>>>} */
    properties2 && typeof properties2 === "object" ? properties2 : {}
  );
  const result = {};
  let key2;
  for (key2 in props) {
    if (own$f.call(props, key2)) {
      let definition2;
      if (specific)
        definition2 = findDefinition(specific, key2);
      if (!definition2 && defaults)
        definition2 = findDefinition(defaults, key2);
      if (definition2) {
        const unsafe2 = props[key2];
        const safe2 = Array.isArray(unsafe2) ? propertyValues(state, definition2, key2, unsafe2) : propertyValue(state, definition2, key2, unsafe2);
        if (safe2 !== null && safe2 !== void 0) {
          result[key2] = safe2;
        }
      }
    }
  }
  if (required && own$f.call(required, tagName)) {
    const properties3 = required[tagName];
    for (key2 in properties3) {
      if (own$f.call(properties3, key2) && !own$f.call(result, key2)) {
        result[key2] = properties3[key2];
      }
    }
  }
  return result;
}
function propertyValues(state, definition2, key2, values) {
  let index2 = -1;
  const result = [];
  while (++index2 < values.length) {
    const value = propertyValue(state, definition2, key2, values[index2]);
    if (typeof value === "number" || typeof value === "string") {
      result.push(value);
    }
  }
  return result;
}
function propertyValue(state, definition2, key2, value) {
  if (typeof value !== "boolean" && typeof value !== "number" && typeof value !== "string") {
    return;
  }
  if (!safeProtocol(state, key2, value)) {
    return;
  }
  if (typeof definition2 === "object" && definition2.length > 1) {
    let ok2 = false;
    let index2 = 0;
    while (++index2 < definition2.length) {
      const allowed = definition2[index2];
      if (allowed && typeof allowed === "object" && "flags" in allowed) {
        if (allowed.test(String(value))) {
          ok2 = true;
          break;
        }
      } else if (allowed === value) {
        ok2 = true;
        break;
      }
    }
    if (!ok2)
      return;
  }
  return state.schema.clobber && state.schema.clobberPrefix && state.schema.clobber.includes(key2) ? state.schema.clobberPrefix + value : value;
}
function safeProtocol(state, key2, value) {
  const protocols = state.schema.protocols && own$f.call(state.schema.protocols, key2) ? state.schema.protocols[key2] : void 0;
  if (!protocols || protocols.length === 0) {
    return true;
  }
  const url = String(value);
  const colon = url.indexOf(":");
  const questionMark = url.indexOf("?");
  const numberSign = url.indexOf("#");
  const slash = url.indexOf("/");
  if (colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {
    return true;
  }
  let index2 = -1;
  while (++index2 < protocols.length) {
    const protocol = protocols[index2];
    if (colon === protocol.length && url.slice(0, protocol.length) === protocol) {
      return true;
    }
  }
  return false;
}
function patch$1(node2, unsafe2) {
  const cleanPosition = position$2(
    // @ts-expect-error: looks like a node.
    unsafe2
  );
  if (unsafe2.data) {
    node2.data = structuredClone$1(unsafe2.data);
  }
  if (cleanPosition)
    node2.position = cleanPosition;
}
function findDefinition(definitions, key2) {
  let dataDefault;
  let index2 = -1;
  while (++index2 < definitions.length) {
    const entry = definitions[index2];
    const name2 = typeof entry === "string" ? entry : entry[0];
    if (name2 === key2) {
      return entry;
    }
    if (name2 === "data*")
      dataDefault = entry;
  }
  if (key2.length > 4 && key2.slice(0, 4).toLowerCase() === "data") {
    return dataDefault;
  }
}
function rehypeSanitize(options) {
  return function(tree) {
    const result = (
      /** @type {Root} */
      sanitize(tree, options)
    );
    return result;
  };
}
var regex$1 = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g;
const regex = regex$1;
var githubSlugger = BananaSlug;
const own$e = Object.hasOwnProperty;
function BananaSlug() {
  const self2 = this;
  if (!(self2 instanceof BananaSlug))
    return new BananaSlug();
  self2.reset();
}
BananaSlug.prototype.slug = function(value, maintainCase) {
  const self2 = this;
  let slug = slugger(value, maintainCase === true);
  const originalSlug = slug;
  while (own$e.call(self2.occurrences, slug)) {
    self2.occurrences[originalSlug]++;
    slug = originalSlug + "-" + self2.occurrences[originalSlug];
  }
  self2.occurrences[slug] = 0;
  return slug;
};
BananaSlug.prototype.reset = function() {
  this.occurrences = /* @__PURE__ */ Object.create(null);
};
function slugger(string2, maintainCase) {
  if (typeof string2 !== "string")
    return "";
  if (!maintainCase)
    string2 = string2.toLowerCase();
  return string2.replace(regex, "").replace(/ /g, "-");
}
BananaSlug.slug = slugger;
const Slugger = /* @__PURE__ */ getDefaultExportFromCjs$1(githubSlugger);
const own$d = {}.hasOwnProperty;
function hasProperty(node2, field) {
  const value = typeof field === "string" && isNode$2(node2) && node2.type === "element" && node2.properties && own$d.call(node2.properties, field) && node2.properties[field];
  return value !== null && value !== void 0 && value !== false;
}
function isNode$2(value) {
  return Boolean(value && typeof value === "object" && "type" in value);
}
function headingRank(node2) {
  const name2 = node2 && node2.type === "element" && node2.tagName.toLowerCase() || "";
  const code = name2.length === 2 && name2.charCodeAt(0) === 104 ? name2.charCodeAt(1) : 0;
  return code > 48 && code < 55 ? code - 48 : null;
}
function toString$4(node2) {
  if ("children" in node2) {
    return all$4(node2);
  }
  return "value" in node2 ? node2.value : "";
}
function one$4(node2) {
  if (node2.type === "text") {
    return node2.value;
  }
  return "children" in node2 ? all$4(node2) : "";
}
function all$4(node2) {
  let index2 = -1;
  const result = [];
  while (++index2 < node2.children.length) {
    result[index2] = one$4(node2.children[index2]);
  }
  return result.join("");
}
const convert$1 = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return ok$2;
    }
    if (typeof test === "string") {
      return typeFactory$1(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory$2(test) : propsFactory$1(test);
    }
    if (typeof test === "function") {
      return castFactory$2(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory$2(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert$1(tests[index2]);
  }
  return castFactory$2(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory$1(check) {
  return castFactory$2(all2);
  function all2(node2) {
    let key2;
    for (key2 in check) {
      if (node2[key2] !== check[key2])
        return false;
    }
    return true;
  }
}
function typeFactory$1(check) {
  return castFactory$2(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory$2(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function ok$2() {
  return true;
}
function color(d3) {
  return "\x1B[33m" + d3 + "\x1B[39m";
}
const CONTINUE = true;
const EXIT = false;
const SKIP = "skip";
const visitParents = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    const is2 = convert$1(test);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node2, index2, parents) {
      const value = node2 && typeof node2 === "object" ? node2 : {};
      if (typeof value.type === "string") {
        const name2 = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = [];
        let subresult;
        let offset;
        let grandparents;
        if (!test || is2(node2, index2, parents[parents.length - 1] || null)) {
          result = toResult(visitor(node2, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if (node2.children && result[0] !== SKIP) {
          offset = (reverse ? node2.children.length : -1) + step;
          grandparents = parents.concat(node2);
          while (offset > -1 && offset < node2.children.length) {
            subresult = factory(node2.children[offset], offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
        return result;
      }
    }
  }
);
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}
const visit = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      return visitor(
        node2,
        parent ? parent.children.indexOf(node2) : null,
        parent
      );
    }
  }
);
function basePropertyOf$1(object) {
  return function(key2) {
    return object == null ? void 0 : object[key2];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  // Latin-1 Supplement block.
  "À": "A",
  "Á": "A",
  "Â": "A",
  "Ã": "A",
  "Ä": "A",
  "Å": "A",
  "à": "a",
  "á": "a",
  "â": "a",
  "ã": "a",
  "ä": "a",
  "å": "a",
  "Ç": "C",
  "ç": "c",
  "Ð": "D",
  "ð": "d",
  "È": "E",
  "É": "E",
  "Ê": "E",
  "Ë": "E",
  "è": "e",
  "é": "e",
  "ê": "e",
  "ë": "e",
  "Ì": "I",
  "Í": "I",
  "Î": "I",
  "Ï": "I",
  "ì": "i",
  "í": "i",
  "î": "i",
  "ï": "i",
  "Ñ": "N",
  "ñ": "n",
  "Ò": "O",
  "Ó": "O",
  "Ô": "O",
  "Õ": "O",
  "Ö": "O",
  "Ø": "O",
  "ò": "o",
  "ó": "o",
  "ô": "o",
  "õ": "o",
  "ö": "o",
  "ø": "o",
  "Ù": "U",
  "Ú": "U",
  "Û": "U",
  "Ü": "U",
  "ù": "u",
  "ú": "u",
  "û": "u",
  "ü": "u",
  "Ý": "Y",
  "ý": "y",
  "ÿ": "y",
  "Æ": "Ae",
  "æ": "ae",
  "Þ": "Th",
  "þ": "th",
  "ß": "ss",
  // Latin Extended-A block.
  "Ā": "A",
  "Ă": "A",
  "Ą": "A",
  "ā": "a",
  "ă": "a",
  "ą": "a",
  "Ć": "C",
  "Ĉ": "C",
  "Ċ": "C",
  "Č": "C",
  "ć": "c",
  "ĉ": "c",
  "ċ": "c",
  "č": "c",
  "Ď": "D",
  "Đ": "D",
  "ď": "d",
  "đ": "d",
  "Ē": "E",
  "Ĕ": "E",
  "Ė": "E",
  "Ę": "E",
  "Ě": "E",
  "ē": "e",
  "ĕ": "e",
  "ė": "e",
  "ę": "e",
  "ě": "e",
  "Ĝ": "G",
  "Ğ": "G",
  "Ġ": "G",
  "Ģ": "G",
  "ĝ": "g",
  "ğ": "g",
  "ġ": "g",
  "ģ": "g",
  "Ĥ": "H",
  "Ħ": "H",
  "ĥ": "h",
  "ħ": "h",
  "Ĩ": "I",
  "Ī": "I",
  "Ĭ": "I",
  "Į": "I",
  "İ": "I",
  "ĩ": "i",
  "ī": "i",
  "ĭ": "i",
  "į": "i",
  "ı": "i",
  "Ĵ": "J",
  "ĵ": "j",
  "Ķ": "K",
  "ķ": "k",
  "ĸ": "k",
  "Ĺ": "L",
  "Ļ": "L",
  "Ľ": "L",
  "Ŀ": "L",
  "Ł": "L",
  "ĺ": "l",
  "ļ": "l",
  "ľ": "l",
  "ŀ": "l",
  "ł": "l",
  "Ń": "N",
  "Ņ": "N",
  "Ň": "N",
  "Ŋ": "N",
  "ń": "n",
  "ņ": "n",
  "ň": "n",
  "ŋ": "n",
  "Ō": "O",
  "Ŏ": "O",
  "Ő": "O",
  "ō": "o",
  "ŏ": "o",
  "ő": "o",
  "Ŕ": "R",
  "Ŗ": "R",
  "Ř": "R",
  "ŕ": "r",
  "ŗ": "r",
  "ř": "r",
  "Ś": "S",
  "Ŝ": "S",
  "Ş": "S",
  "Š": "S",
  "ś": "s",
  "ŝ": "s",
  "ş": "s",
  "š": "s",
  "Ţ": "T",
  "Ť": "T",
  "Ŧ": "T",
  "ţ": "t",
  "ť": "t",
  "ŧ": "t",
  "Ũ": "U",
  "Ū": "U",
  "Ŭ": "U",
  "Ů": "U",
  "Ű": "U",
  "Ų": "U",
  "ũ": "u",
  "ū": "u",
  "ŭ": "u",
  "ů": "u",
  "ű": "u",
  "ų": "u",
  "Ŵ": "W",
  "ŵ": "w",
  "Ŷ": "Y",
  "ŷ": "y",
  "Ÿ": "Y",
  "Ź": "Z",
  "Ż": "Z",
  "Ž": "Z",
  "ź": "z",
  "ż": "z",
  "ž": "z",
  "Ĳ": "IJ",
  "ĳ": "ij",
  "Œ": "Oe",
  "œ": "oe",
  "ŉ": "'n",
  "ſ": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$5 = freeGlobal || freeSelf || Function("return this")();
var _root = root$5;
var root$4 = _root;
var Symbol$4 = root$4.Symbol;
var _Symbol = Symbol$4;
function arrayMap$1(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var _arrayMap = arrayMap$1;
var isArray$3 = Array.isArray;
var isArray_1 = isArray$3;
var Symbol$3 = _Symbol;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
var nativeObjectToString$1 = objectProto$1.toString;
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$1.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto = Object.prototype;
var nativeObjectToString = objectProto.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$1(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$1;
function isObjectLike$1(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$1;
var baseGetTag = _baseGetTag, isObjectLike = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
var isSymbol_1 = isSymbol$1;
var Symbol$1 = _Symbol, arrayMap = _arrayMap, isArray$2 = isArray_1, isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$2(value)) {
    return arrayMap(value, baseToString$1) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$3(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$3;
var deburrLetter = _deburrLetter, toString$2 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsCombo = "[" + rsComboRange + "]";
var reComboMark = RegExp(rsCombo, "g");
function deburr(string2) {
  string2 = toString$2(string2);
  return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr;
const deburr$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(deburr_1);
const slugs = new Slugger();
function getHeaderNodeId(node2, props = {}) {
  const {
    enableCustomId = false,
    maintainCase = false,
    removeAccents = false
  } = props;
  const headerNode = node2;
  let id2;
  let isCustomId = false;
  if (enableCustomId && headerNode.children.length > 0) {
    const last = headerNode.children[headerNode.children.length - 1];
    const match = /^(.*?)\s*{#([\w-]+)}$/.exec(toString$4(last));
    if (match && (match[1] || headerNode.children.length > 1)) {
      id2 = match[2];
      if (match[1]) {
        last.value = match[1];
      } else {
        isCustomId = true;
      }
    }
  }
  if (!id2) {
    const slug = slugs.slug(toString$4(headerNode), maintainCase);
    id2 = removeAccents ? deburr$1(slug) : slug;
  }
  return { id: id2, isCustomId };
}
function rehypeSlug(props = {}) {
  return (tree) => {
    slugs.reset();
    visit(tree, "element", (node2) => {
      if (headingRank(node2) && node2.properties && !hasProperty(node2, "id")) {
        const { id: id2, isCustomId } = getHeaderNodeId(node2, props);
        if (isCustomId)
          node2.children.pop();
        node2.properties.id = id2;
      }
    });
  };
}
const htmlVoidElements = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
const own$c = {}.hasOwnProperty;
function zwitch$1(key2, options) {
  const settings = options || {};
  function one2(value, ...parameters) {
    let fn2 = one2.invalid;
    const handlers2 = one2.handlers;
    if (value && own$c.call(value, key2)) {
      const id2 = String(value[key2]);
      fn2 = own$c.call(handlers2, id2) ? handlers2[id2] : one2.unknown;
    }
    if (fn2) {
      return fn2.call(this, value, ...parameters);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}
function core$1(value, options) {
  value = value.replace(
    options.subset ? charactersToExpression$1(options.subset) : /["&'<>`]/g,
    basic2
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    basic2
  );
  function surrogate(pair, index2, all2) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all2.charCodeAt(index2 + 2),
      options
    );
  }
  function basic2(character, index2, all2) {
    return options.format(
      character.charCodeAt(0),
      all2.charCodeAt(index2 + 1),
      options
    );
  }
}
function charactersToExpression$1(subset) {
  const groups = [];
  let index2 = -1;
  while (++index2 < subset.length) {
    groups.push(subset[index2].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}
function toHexadecimal$1(code, next, omit) {
  const value = "&#x" + code.toString(16).toUpperCase();
  return omit && next && !/[\dA-Fa-f]/.test(String.fromCharCode(next)) ? value : value + ";";
}
function toDecimal$1(code, next, omit) {
  const value = "&#" + String(code);
  return omit && next && !/\d/.test(String.fromCharCode(next)) ? value : value + ";";
}
const characterEntitiesLegacy$1 = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];
const characterEntitiesHtml4$1 = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
};
const dangerous$1 = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];
const own$b = {}.hasOwnProperty;
const characters$1 = {};
let key$1;
for (key$1 in characterEntitiesHtml4$1) {
  if (own$b.call(characterEntitiesHtml4$1, key$1)) {
    characters$1[characterEntitiesHtml4$1[key$1]] = key$1;
  }
}
function toNamed$1(code, next, omit, attribute) {
  const character = String.fromCharCode(code);
  if (own$b.call(characters$1, character)) {
    const name2 = characters$1[character];
    const value = "&" + name2;
    if (omit && characterEntitiesLegacy$1.includes(name2) && !dangerous$1.includes(name2) && (!attribute || next && next !== 61 && /[^\da-z]/i.test(String.fromCharCode(next)))) {
      return value;
    }
    return value + ";";
  }
  return "";
}
function formatSmart$1(code, next, options) {
  let numeric = toHexadecimal$1(code, next, options.omitOptionalSemicolons);
  let named;
  if (options.useNamedReferences || options.useShortestReferences) {
    named = toNamed$1(
      code,
      next,
      options.omitOptionalSemicolons,
      options.attribute
    );
  }
  if ((options.useShortestReferences || !named) && options.useShortestReferences) {
    const decimal = toDecimal$1(code, next, options.omitOptionalSemicolons);
    if (decimal.length < numeric.length) {
      numeric = decimal;
    }
  }
  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;
}
function stringifyEntities$1(value, options) {
  return core$1(value, Object.assign({ format: formatSmart$1 }, options));
}
function comment$2(node2, _12, _22, state) {
  return state.settings.bogusComments ? "<?" + stringifyEntities$1(
    node2.value,
    Object.assign({}, state.settings.characterReferences, { subset: [">"] })
  ) + ">" : "<!--" + node2.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, encode) + "-->";
  function encode($02) {
    return stringifyEntities$1(
      $02,
      Object.assign({}, state.settings.characterReferences, {
        subset: ["<", ">"]
      })
    );
  }
}
function doctype$1(_12, _22, _32, state) {
  return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
}
function ccount$1(value, character) {
  const source2 = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source2.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source2.indexOf(character, index2 + character.length);
  }
  return count;
}
const siblingAfter$1 = siblings$1(1);
const siblingBefore$1 = siblings$1(-1);
const emptyChildren$2 = [];
function siblings$1(increment2) {
  return sibling;
  function sibling(parent, index2, includeWhitespace) {
    const siblings2 = parent ? parent.children : emptyChildren$2;
    let offset = (index2 || 0) + increment2;
    let next = siblings2[offset];
    if (!includeWhitespace) {
      while (next && whitespace$1(next)) {
        offset += increment2;
        next = siblings2[offset];
      }
    }
    return next;
  }
}
const own$a = {}.hasOwnProperty;
function omission$1(handlers2) {
  return omit;
  function omit(node2, index2, parent) {
    return own$a.call(handlers2, node2.tagName) && handlers2[node2.tagName](node2, index2, parent);
  }
}
const closing$1 = omission$1({
  body: body$3,
  caption: headOrColgroupOrCaption$1,
  colgroup: headOrColgroupOrCaption$1,
  dd: dd$2,
  dt: dt$2,
  head: headOrColgroupOrCaption$1,
  html: html$6,
  li: li$2,
  optgroup: optgroup$1,
  option: option$1,
  p: p$6,
  rp: rubyElement$1,
  rt: rubyElement$1,
  tbody: tbody$3,
  td: cells$1,
  tfoot: tfoot$1,
  th: cells$1,
  thead: thead$1,
  tr: tr$3
});
function headOrColgroupOrCaption$1(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2, true);
  return !next || next.type !== "comment" && !(next.type === "text" && whitespace$1(next.value.charAt(0)));
}
function html$6(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return !next || next.type !== "comment";
}
function body$3(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return !next || next.type !== "comment";
}
function p$6(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
  !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
}
function li$2(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return !next || next.type === "element" && next.tagName === "li";
}
function dt$2(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd")
  );
}
function dd$2(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
}
function rubyElement$1(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
}
function optgroup$1(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return !next || next.type === "element" && next.tagName === "optgroup";
}
function option$1(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
}
function thead$1(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot")
  );
}
function tbody$3(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
}
function tfoot$1(_10, index2, parent) {
  return !siblingAfter$1(parent, index2);
}
function tr$3(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return !next || next.type === "element" && next.tagName === "tr";
}
function cells$1(_10, index2, parent) {
  const next = siblingAfter$1(parent, index2);
  return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
}
const opening$1 = omission$1({
  body: body$2,
  colgroup: colgroup$1,
  head: head$1,
  html: html$4,
  tbody: tbody$2
});
function html$4(node2) {
  const head2 = siblingAfter$1(node2, -1);
  return !head2 || head2.type !== "comment";
}
function head$1(node2) {
  const children2 = node2.children;
  const seen = [];
  let index2 = -1;
  while (++index2 < children2.length) {
    const child = children2[index2];
    if (child.type === "element" && (child.tagName === "title" || child.tagName === "base")) {
      if (seen.includes(child.tagName))
        return false;
      seen.push(child.tagName);
    }
  }
  return children2.length > 0;
}
function body$2(node2) {
  const head2 = siblingAfter$1(node2, -1, true);
  return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace$1(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
}
function colgroup$1(node2, index2, parent) {
  const previous2 = siblingBefore$1(parent, index2);
  const head2 = siblingAfter$1(node2, -1, true);
  if (parent && previous2 && previous2.type === "element" && previous2.tagName === "colgroup" && closing$1(previous2, parent.children.indexOf(previous2), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "col");
}
function tbody$2(node2, index2, parent) {
  const previous2 = siblingBefore$1(parent, index2);
  const head2 = siblingAfter$1(node2, -1);
  if (parent && previous2 && previous2.type === "element" && (previous2.tagName === "thead" || previous2.tagName === "tbody") && closing$1(previous2, parent.children.indexOf(previous2), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "tr");
}
const constants$1 = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
    [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
    ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function element(node2, index2, parent, state) {
  const schema = state.schema;
  const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
  let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node2.tagName.toLowerCase());
  const parts = [];
  let last;
  if (schema.space === "html" && node2.tagName === "svg") {
    state.schema = svg$2;
  }
  const attrs = serializeAttributes$1(state, node2.properties);
  const content2 = state.all(
    schema.space === "html" && node2.tagName === "template" ? node2.content : node2
  );
  state.schema = schema;
  if (content2)
    selfClosing = false;
  if (attrs || !omit || !opening$1(node2, index2, parent)) {
    parts.push("<", node2.tagName, attrs ? " " + attrs : "");
    if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
      last = attrs.charAt(attrs.length - 1);
      if (!state.settings.tightSelfClosing || last === "/" || last && last !== '"' && last !== "'") {
        parts.push(" ");
      }
      parts.push("/");
    }
    parts.push(">");
  }
  parts.push(content2);
  if (!selfClosing && (!omit || !closing$1(node2, index2, parent))) {
    parts.push("</" + node2.tagName + ">");
  }
  return parts.join("");
}
function serializeAttributes$1(state, props) {
  const values = [];
  let index2 = -1;
  let key2;
  if (props) {
    for (key2 in props) {
      if (props[key2] !== null && props[key2] !== void 0) {
        const value = serializeAttribute$1(state, key2, props[key2]);
        if (value)
          values.push(value);
      }
    }
  }
  while (++index2 < values.length) {
    const last = state.settings.tightAttributes ? values[index2].charAt(values[index2].length - 1) : void 0;
    if (index2 !== values.length - 1 && last !== '"' && last !== "'") {
      values[index2] += " ";
    }
  }
  return values.join("");
}
function serializeAttribute$1(state, key2, value) {
  const info = find$2(state.schema, key2);
  const x10 = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
  const y10 = state.settings.allowDangerousCharacters ? 0 : 1;
  let quote = state.quote;
  let result;
  if (info.overloadedBoolean && (value === info.attribute || value === "")) {
    value = true;
  } else if (info.boolean || info.overloadedBoolean && typeof value !== "string") {
    value = Boolean(value);
  }
  if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
    return "";
  }
  const name2 = stringifyEntities$1(
    info.attribute,
    Object.assign({}, state.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: constants$1.name[x10][y10]
    })
  );
  if (value === true)
    return name2;
  value = Array.isArray(value) ? (info.commaSeparated ? stringify$3 : stringify$2)(value, {
    padLeft: !state.settings.tightCommaSeparatedLists
  }) : String(value);
  if (state.settings.collapseEmptyAttributes && !value)
    return name2;
  if (state.settings.preferUnquoted) {
    result = stringifyEntities$1(
      value,
      Object.assign({}, state.settings.characterReferences, {
        attribute: true,
        subset: constants$1.unquoted[x10][y10]
      })
    );
  }
  if (result !== value) {
    if (state.settings.quoteSmart && ccount$1(value, quote) > ccount$1(value, state.alternative)) {
      quote = state.alternative;
    }
    result = quote + stringifyEntities$1(
      value,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: (quote === "'" ? constants$1.single : constants$1.double)[x10][y10],
        attribute: true
      })
    ) + quote;
  }
  return name2 + (result ? "=" + result : result);
}
function text$7(node2, _10, parent, state) {
  return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node2.value : stringifyEntities$1(
    node2.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: ["<", "&"]
    })
  );
}
function raw$1(node2, index2, parent, state) {
  return state.settings.allowDangerousHtml ? node2.value : text$7(node2, index2, parent, state);
}
function root$3(node2, _12, _22, state) {
  return state.all(node2);
}
const handle$1 = zwitch$1("type", {
  invalid: invalid$2,
  unknown: unknown$2,
  handlers: { comment: comment$2, doctype: doctype$1, element, raw: raw$1, root: root$3, text: text$7 }
});
function invalid$2(node2) {
  throw new Error("Expected node, not `" + node2 + "`");
}
function unknown$2(node_) {
  const node2 = (
    /** @type {Nodes} */
    node_
  );
  throw new Error("Cannot compile unknown node `" + node2.type + "`");
}
const emptyOptions$4 = {};
const emptyCharacterReferences = {};
const emptyChildren = [];
function toHtml(tree, options) {
  const options_ = options || emptyOptions$4;
  const quote = options_.quote || '"';
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
  }
  const state = {
    one: one$3,
    all: all$3,
    settings: {
      omitOptionalTags: options_.omitOptionalTags || false,
      allowParseErrors: options_.allowParseErrors || false,
      allowDangerousCharacters: options_.allowDangerousCharacters || false,
      quoteSmart: options_.quoteSmart || false,
      preferUnquoted: options_.preferUnquoted || false,
      tightAttributes: options_.tightAttributes || false,
      upperDoctype: options_.upperDoctype || false,
      tightDoctype: options_.tightDoctype || false,
      bogusComments: options_.bogusComments || false,
      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
      tightSelfClosing: options_.tightSelfClosing || false,
      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
      allowDangerousHtml: options_.allowDangerousHtml || false,
      voids: options_.voids || htmlVoidElements,
      characterReferences: options_.characterReferences || emptyCharacterReferences,
      closeSelfClosing: options_.closeSelfClosing || false,
      closeEmptyElements: options_.closeEmptyElements || false
    },
    schema: options_.space === "svg" ? svg$2 : html$7,
    quote,
    alternative
  };
  return state.one(
    Array.isArray(tree) ? { type: "root", children: tree } : tree,
    void 0,
    void 0
  );
}
function one$3(node2, index2, parent) {
  return handle$1(node2, index2, parent, this);
}
function all$3(parent) {
  const results = [];
  const children2 = parent && parent.children || emptyChildren;
  let index2 = -1;
  while (++index2 < children2.length) {
    results[index2] = this.one(children2[index2], index2, parent);
  }
  return results.join("");
}
function rehypeStringify(options) {
  const self2 = this;
  const settings = { ...self2.data("settings"), ...options };
  self2.compiler = compiler2;
  function compiler2(tree) {
    return toHtml(tree, settings);
  }
}
const unicodePunctuationInternal$1 = regexCheck$1(/\p{P}/u);
const asciiAlpha$1 = regexCheck$1(/[A-Za-z]/);
const asciiAlphanumeric$1 = regexCheck$1(/[\dA-Za-z]/);
const asciiAtext = regexCheck$1(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl$1(code) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code !== null && (code < 32 || code === 127)
  );
}
const asciiDigit = regexCheck$1(/\d/);
const asciiHexDigit = regexCheck$1(/[\dA-Fa-f]/);
const asciiPunctuation$1 = regexCheck$1(/[!-/:-@[-`{-~]/);
function markdownLineEnding$1(code) {
  return code !== null && code < -2;
}
function markdownLineEndingOrSpace$1(code) {
  return code !== null && (code < 0 || code === 32);
}
function markdownSpace$1(code) {
  return code === -2 || code === -1 || code === 32;
}
function unicodePunctuation$1(code) {
  return asciiPunctuation$1(code) || unicodePunctuationInternal$1(code);
}
const unicodeWhitespace$1 = regexCheck$1(/\s/);
function regexCheck$1(regex2) {
  return check;
  function check(code) {
    return code !== null && code > -1 && regex2.test(String.fromCharCode(code));
  }
}
function escapeStringRegexp(string2) {
  if (typeof string2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function findAndReplace(tree, list2, options) {
  const settings = options || {};
  const ignored = convert$2(settings.ignore || []);
  const pairs = toPairs(list2);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents$1(tree, "text", visitor);
  }
  function visitor(node2, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      const siblings2 = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings2 ? siblings2.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace2 = pairs[pairIndex][1];
    let start = 0;
    const siblings2 = parent.children;
    const index2 = siblings2.indexOf(node2);
    let change = false;
    let nodes = [];
    find2.lastIndex = 0;
    let match = find2.exec(node2.value);
    while (match) {
      const position2 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node2]
      };
      let value = replace2(...match, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find2.lastIndex = position2 + 1;
      } else {
        if (start !== position2) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start, position2)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start = position2 + match[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match = find2.exec(node2.value);
    }
    if (change) {
      if (start < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index2 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index2 = -1;
  while (++index2 < list2.length) {
    const tuple = list2[index2];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find2) {
  return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : function() {
    return replace2;
  };
}
const inConstruct = "phrasing";
const notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node2 = this.stack[this.stack.length - 1];
  ok$3(node2.type === "link");
  node2.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_10, protocol, domain2, path2, match) {
  let prefix = "";
  if (!previous$1(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path2);
  if (!parts[0])
    return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_10, atext, label, match) {
  if (
    // Not an expected previous character.
    !previous$1(match, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount$1(url, "(");
  let closingParens = ccount$1(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous$1(match, email) {
  const code = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace$1(code) || unicodePunctuation$1(code)) && (!email || code !== 47);
}
function normalizeIdentifier$1(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
footnoteReference$1.peek = footnoteReferencePeek;
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
}
function gfmFootnoteToMarkdown() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition, footnoteReference: footnoteReference$1 }
  };
}
function enterFootnoteDefinition(token) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token
  );
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function exitFootnoteDefinitionLabelString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok$3(node2.type === "footnoteDefinition");
  node2.label = label;
  node2.identifier = normalizeIdentifier$1(
    this.sliceSerialize(token)
  ).toLowerCase();
}
function exitFootnoteDefinition(token) {
  this.exit(token);
}
function enterFootnoteCall(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteCallString() {
  this.buffer();
}
function exitFootnoteCallString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok$3(node2.type === "footnoteReference");
  node2.label = label;
  node2.identifier = normalizeIdentifier$1(
    this.sliceSerialize(token)
  ).toLowerCase();
}
function exitFootnoteCall(token) {
  this.exit(token);
}
function footnoteReference$1(node2, _10, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit2 = state.enter("footnoteReference");
  const subexit = state.enter("reference");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  exit2();
  value += tracker.move("]");
  return value;
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteDefinition(node2, _10, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit2 = state.enter("footnoteDefinition");
  const subexit = state.enter("label");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  value += tracker.move(
    "]:" + (node2.children && node2.children.length > 0 ? " " : "")
  );
  tracker.shift(4);
  value += tracker.move(
    state.indentLines(state.containerFlow(node2, tracker.current()), map$3)
  );
  exit2();
  return value;
}
function map$3(line, index2, blank) {
  if (index2 === 0) {
    return line;
  }
  return (blank ? "" : "    ") + line;
}
const constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node2, _10, state, info) {
  const tracker = state.createTracker(info);
  const exit2 = state.enter("strikethrough");
  let value = tracker.move("~~");
  value += state.containerPhrasing(node2, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit2();
  return value;
}
function peekDelete() {
  return "~";
}
function markdownTable(table2, options = {}) {
  const align = (options.align || []).concat();
  const stringLength = options.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table2.length) {
    const row3 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table2[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table2[rowIndex].length;
    }
    while (++columnIndex2 < table2[rowIndex].length) {
      const cell2 = serialize(table2[rowIndex][columnIndex2]);
      if (options.alignDelimiters !== false) {
        const size = stringLength(cell2);
        sizes2[columnIndex2] = size;
        if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size;
        }
      }
      row3.push(cell2);
    }
    cellMatrix[rowIndex] = row3;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code;
    }
  }
  columnIndex = -1;
  const row2 = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code = alignments[columnIndex];
    let before = "";
    let after = "";
    if (code === 99) {
      before = ":";
      after = ":";
    } else if (code === 108) {
      before = ":";
    } else if (code === 114) {
      after = ":";
    }
    let size = options.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell2 = before + "-".repeat(size) + after;
    if (options.alignDelimiters !== false) {
      size = before.length + size + after.length;
      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }
      sizes[columnIndex] = size;
    }
    row2[columnIndex] = cell2;
  }
  cellMatrix.splice(1, 0, row2);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row3 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell2 = row3[columnIndex] || "";
      let before = "";
      let after = "";
      if (options.alignDelimiters !== false) {
        const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code = alignments[columnIndex];
        if (code === 114) {
          before = " ".repeat(size);
        } else if (code === 99) {
          if (size % 2) {
            before = " ".repeat(size / 2 + 0.5);
            after = " ".repeat(size / 2 - 0.5);
          } else {
            before = " ".repeat(size / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size);
        }
      }
      if (options.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (options.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(options.alignDelimiters === false && cell2 === "") && (options.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (options.alignDelimiters !== false) {
        line.push(before);
      }
      line.push(cell2);
      if (options.alignDelimiters !== false) {
        line.push(after);
      }
      if (options.padding !== false) {
        line.push(" ");
      }
      if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(
      options.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
    );
  }
  return lines.join("\n");
}
function serialize(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function defaultStringLength(value) {
  return value.length;
}
function toAlignment(value) {
  const code = typeof value === "string" ? value.codePointAt(0) : 0;
  return code === 67 || code === 99 ? 99 : code === 76 || code === 108 ? 108 : code === 82 || code === 114 ? 114 : 0;
}
const own$9 = {}.hasOwnProperty;
function configure$1(base2, extension2) {
  let index2 = -1;
  let key2;
  if (extension2.extensions) {
    while (++index2 < extension2.extensions.length) {
      configure$1(base2, extension2.extensions[index2]);
    }
  }
  for (key2 in extension2) {
    if (own$9.call(extension2, key2)) {
      switch (key2) {
        case "extensions": {
          break;
        }
        case "unsafe": {
          list$3(base2[key2], extension2[key2]);
          break;
        }
        case "join": {
          list$3(base2[key2], extension2[key2]);
          break;
        }
        case "handlers": {
          map$2(base2[key2], extension2[key2]);
          break;
        }
        default: {
          base2.options[key2] = extension2[key2];
        }
      }
    }
  }
  return base2;
}
function list$3(left, right) {
  if (right) {
    left.push(...right);
  }
}
function map$2(left, right) {
  if (right) {
    Object.assign(left, right);
  }
}
function blockquote$1(node2, _10, state, info) {
  const exit2 = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map$1
  );
  exit2();
  return value;
}
function map$1(line, _10, blank) {
  return ">" + (blank ? "" : " ") + line;
}
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list2, none2) {
  if (typeof list2 === "string") {
    list2 = [list2];
  }
  if (!list2 || list2.length === 0) {
    return none2;
  }
  let index2 = -1;
  while (++index2 < list2.length) {
    if (stack.includes(list2[index2])) {
      return true;
    }
  }
  return false;
}
function hardBreak$1(_10, _12, state, info) {
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}
function longestStreak(value, substring) {
  const source2 = String(value);
  let index2 = source2.indexOf(substring);
  let expected = index2;
  let count = 0;
  let max2 = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index2 !== -1) {
    if (index2 === expected) {
      if (++count > max2) {
        max2 = count;
      }
    } else {
      count = 1;
    }
    expected = index2 + substring.length;
    index2 = source2.indexOf(substring, expected);
  }
  return max2;
}
function formatCodeAsIndented(node2, state) {
  return Boolean(
    state.options.fences === false && node2.value && // If there’s no info…
    !node2.lang && // And there’s a non-whitespace character…
    /[^ \r\n]/.test(node2.value) && // And the value doesn’t start or end in a blank…
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
  );
}
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}
function code$4(node2, _10, state, info) {
  const marker = checkFence(state);
  const raw2 = node2.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit3 = state.enter("codeIndented");
    const value2 = state.indentLines(raw2, map);
    exit3();
    return value2;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
  const exit2 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node2.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node2.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw2) {
    value += tracker.move(raw2 + "\n");
  }
  value += tracker.move(sequence);
  exit2();
  return value;
}
function map(line, _10, blank) {
  return (blank ? "" : "    ") + line;
}
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}
function definition$1(node2, _10, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If there’s no url, or…
    !node2.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit2();
  return value;
}
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}
emphasis$1.peek = emphasisPeek;
function emphasis$1(node2, _10, state, info) {
  const marker = checkEmphasis(state);
  const exit2 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker);
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker);
  exit2();
  return value;
}
function emphasisPeek(_10, _12, state) {
  return state.options.emphasis || "*";
}
const emptyOptions$3 = {};
function toString$1(value, options) {
  const settings = options || emptyOptions$3;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one$2(value, includeImageAlt, includeHtml);
}
function one$2(value, includeImageAlt, includeHtml) {
  if (node$1(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all$1(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all$1(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all$1(values, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one$2(values[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node$1(value) {
  return Boolean(value && typeof value === "object");
}
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit$1(node2, function(node3) {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT$1;
    }
  });
  return Boolean(
    (!node2.depth || node2.depth < 3) && toString$1(node2) && (state.options.setext || literalWithBreak)
  );
}
function heading$2(node2, _10, state, info) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node2, state)) {
    const exit3 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit3();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size…
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit2 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node2, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit2();
  return value;
}
html$1.peek = htmlPeek;
function html$1(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}
image$1.peek = imagePeek;
function image$1(node2, _10, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function imagePeek() {
  return "!";
}
imageReference$1.peek = imageReferencePeek;
function imageReference$1(node2, _10, state, info) {
  const type = node2.referenceType;
  const exit2 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}
inlineCode$1.peek = inlineCodePeek;
function inlineCode$1(node2, _10, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    const expression = state.compilePattern(pattern);
    let match;
    if (!pattern.atBreak)
      continue;
    while (match = expression.exec(value)) {
      let position2 = match.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}
function formatLinkAsAutolink(node2, state) {
  const raw2 = toString$1(node2);
  return Boolean(
    !state.options.resourceLink && // If there’s a url…
    node2.url && // And there’s a no title…
    !node2.title && // And the content of `node` is a single text node…
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content…
    (raw2 === node2.url || "mailto:" + raw2 === node2.url) && // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work), space, or angle brackets…
    !/[\0- <>\u007F]/.test(node2.url)
  );
}
link$1.peek = linkPeek;
function link$1(node2, _10, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit2;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit2 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit2();
    state.stack = stack;
    return value2;
  }
  exit2 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function linkPeek(node2, _10, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}
linkReference$1.peek = linkReferencePeek;
function linkReference$1(node2, _10, state, info) {
  const type = node2.referenceType;
  const exit2 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text2 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text2 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type === "full" || !text2 || text2 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}
function list$2(node2, parent, state, info) {
  const exit2 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index2 = -1;
      while (++index2 < node2.children.length) {
        const item = node2.children[index2];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node2, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit2();
  return value;
}
function checkListItemIndent(state) {
  const style2 = state.options.listItemIndent || "one";
  if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style2;
}
function listItem$1(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size - bullet.length));
  tracker.shift(size);
  const exit2 = state.enter("listItem");
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map2
  );
  exit2();
  return value;
  function map2(line, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
  }
}
function paragraph$1(node2, _10, state, info) {
  const exit2 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node2, info);
  subexit();
  exit2();
  return value;
}
const phrasing = (
  /** @type {(node?: unknown) => node is PhrasingContent} */
  convert$2([
    "break",
    "delete",
    "emphasis",
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    "link",
    "linkReference",
    "strong",
    "text"
  ])
);
function root$1(node2, _10, state, info) {
  const hasPhrasing = node2.children.some(function(d3) {
    return phrasing(d3);
  });
  const fn2 = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return fn2.call(state, node2, info);
}
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}
strong$1.peek = strongPeek;
function strong$1(node2, _10, state, info) {
  const marker = checkStrong(state);
  const exit2 = state.enter("strong");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker + marker);
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker + marker);
  exit2();
  return value;
}
function strongPeek(_10, _12, state) {
  return state.options.strong || "*";
}
function text$6(node2, _10, state, info) {
  return state.safe(node2.value, info);
}
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}
function thematicBreak$2(_10, _12, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}
const handle = {
  blockquote: blockquote$1,
  break: hardBreak$1,
  code: code$4,
  definition: definition$1,
  emphasis: emphasis$1,
  hardBreak: hardBreak$1,
  heading: heading$2,
  html: html$1,
  image: image$1,
  imageReference: imageReference$1,
  inlineCode: inlineCode$1,
  link: link$1,
  linkReference: linkReference$1,
  list: list$2,
  listItem: listItem$1,
  paragraph: paragraph$1,
  root: root$1,
  strong: strong$1,
  text: text$6,
  thematicBreak: thematicBreak$2
};
const join$1 = [joinDefaults];
function joinDefaults(left, right, parent, state) {
  if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
    return false;
  }
  if ("spread" in parent && typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && // Two paragraphs.
    (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
    right.type === "heading" && formatHeadingAsSetext(right, state))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}
const fullPhrasingSpans = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
const unsafe = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
  { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A plus sign could start a list item.
  { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
  // A dot could start a list item.
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: true, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: true, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: true, character: "~" }
];
const characterEntities = {
  AElig: "Æ",
  AMP: "&",
  Aacute: "Á",
  Abreve: "Ă",
  Acirc: "Â",
  Acy: "А",
  Afr: "𝔄",
  Agrave: "À",
  Alpha: "Α",
  Amacr: "Ā",
  And: "⩓",
  Aogon: "Ą",
  Aopf: "𝔸",
  ApplyFunction: "⁡",
  Aring: "Å",
  Ascr: "𝒜",
  Assign: "≔",
  Atilde: "Ã",
  Auml: "Ä",
  Backslash: "∖",
  Barv: "⫧",
  Barwed: "⌆",
  Bcy: "Б",
  Because: "∵",
  Bernoullis: "ℬ",
  Beta: "Β",
  Bfr: "𝔅",
  Bopf: "𝔹",
  Breve: "˘",
  Bscr: "ℬ",
  Bumpeq: "≎",
  CHcy: "Ч",
  COPY: "©",
  Cacute: "Ć",
  Cap: "⋒",
  CapitalDifferentialD: "ⅅ",
  Cayleys: "ℭ",
  Ccaron: "Č",
  Ccedil: "Ç",
  Ccirc: "Ĉ",
  Cconint: "∰",
  Cdot: "Ċ",
  Cedilla: "¸",
  CenterDot: "·",
  Cfr: "ℭ",
  Chi: "Χ",
  CircleDot: "⊙",
  CircleMinus: "⊖",
  CirclePlus: "⊕",
  CircleTimes: "⊗",
  ClockwiseContourIntegral: "∲",
  CloseCurlyDoubleQuote: "”",
  CloseCurlyQuote: "’",
  Colon: "∷",
  Colone: "⩴",
  Congruent: "≡",
  Conint: "∯",
  ContourIntegral: "∮",
  Copf: "ℂ",
  Coproduct: "∐",
  CounterClockwiseContourIntegral: "∳",
  Cross: "⨯",
  Cscr: "𝒞",
  Cup: "⋓",
  CupCap: "≍",
  DD: "ⅅ",
  DDotrahd: "⤑",
  DJcy: "Ђ",
  DScy: "Ѕ",
  DZcy: "Џ",
  Dagger: "‡",
  Darr: "↡",
  Dashv: "⫤",
  Dcaron: "Ď",
  Dcy: "Д",
  Del: "∇",
  Delta: "Δ",
  Dfr: "𝔇",
  DiacriticalAcute: "´",
  DiacriticalDot: "˙",
  DiacriticalDoubleAcute: "˝",
  DiacriticalGrave: "`",
  DiacriticalTilde: "˜",
  Diamond: "⋄",
  DifferentialD: "ⅆ",
  Dopf: "𝔻",
  Dot: "¨",
  DotDot: "⃜",
  DotEqual: "≐",
  DoubleContourIntegral: "∯",
  DoubleDot: "¨",
  DoubleDownArrow: "⇓",
  DoubleLeftArrow: "⇐",
  DoubleLeftRightArrow: "⇔",
  DoubleLeftTee: "⫤",
  DoubleLongLeftArrow: "⟸",
  DoubleLongLeftRightArrow: "⟺",
  DoubleLongRightArrow: "⟹",
  DoubleRightArrow: "⇒",
  DoubleRightTee: "⊨",
  DoubleUpArrow: "⇑",
  DoubleUpDownArrow: "⇕",
  DoubleVerticalBar: "∥",
  DownArrow: "↓",
  DownArrowBar: "⤓",
  DownArrowUpArrow: "⇵",
  DownBreve: "̑",
  DownLeftRightVector: "⥐",
  DownLeftTeeVector: "⥞",
  DownLeftVector: "↽",
  DownLeftVectorBar: "⥖",
  DownRightTeeVector: "⥟",
  DownRightVector: "⇁",
  DownRightVectorBar: "⥗",
  DownTee: "⊤",
  DownTeeArrow: "↧",
  Downarrow: "⇓",
  Dscr: "𝒟",
  Dstrok: "Đ",
  ENG: "Ŋ",
  ETH: "Ð",
  Eacute: "É",
  Ecaron: "Ě",
  Ecirc: "Ê",
  Ecy: "Э",
  Edot: "Ė",
  Efr: "𝔈",
  Egrave: "È",
  Element: "∈",
  Emacr: "Ē",
  EmptySmallSquare: "◻",
  EmptyVerySmallSquare: "▫",
  Eogon: "Ę",
  Eopf: "𝔼",
  Epsilon: "Ε",
  Equal: "⩵",
  EqualTilde: "≂",
  Equilibrium: "⇌",
  Escr: "ℰ",
  Esim: "⩳",
  Eta: "Η",
  Euml: "Ë",
  Exists: "∃",
  ExponentialE: "ⅇ",
  Fcy: "Ф",
  Ffr: "𝔉",
  FilledSmallSquare: "◼",
  FilledVerySmallSquare: "▪",
  Fopf: "𝔽",
  ForAll: "∀",
  Fouriertrf: "ℱ",
  Fscr: "ℱ",
  GJcy: "Ѓ",
  GT: ">",
  Gamma: "Γ",
  Gammad: "Ϝ",
  Gbreve: "Ğ",
  Gcedil: "Ģ",
  Gcirc: "Ĝ",
  Gcy: "Г",
  Gdot: "Ġ",
  Gfr: "𝔊",
  Gg: "⋙",
  Gopf: "𝔾",
  GreaterEqual: "≥",
  GreaterEqualLess: "⋛",
  GreaterFullEqual: "≧",
  GreaterGreater: "⪢",
  GreaterLess: "≷",
  GreaterSlantEqual: "⩾",
  GreaterTilde: "≳",
  Gscr: "𝒢",
  Gt: "≫",
  HARDcy: "Ъ",
  Hacek: "ˇ",
  Hat: "^",
  Hcirc: "Ĥ",
  Hfr: "ℌ",
  HilbertSpace: "ℋ",
  Hopf: "ℍ",
  HorizontalLine: "─",
  Hscr: "ℋ",
  Hstrok: "Ħ",
  HumpDownHump: "≎",
  HumpEqual: "≏",
  IEcy: "Е",
  IJlig: "Ĳ",
  IOcy: "Ё",
  Iacute: "Í",
  Icirc: "Î",
  Icy: "И",
  Idot: "İ",
  Ifr: "ℑ",
  Igrave: "Ì",
  Im: "ℑ",
  Imacr: "Ī",
  ImaginaryI: "ⅈ",
  Implies: "⇒",
  Int: "∬",
  Integral: "∫",
  Intersection: "⋂",
  InvisibleComma: "⁣",
  InvisibleTimes: "⁢",
  Iogon: "Į",
  Iopf: "𝕀",
  Iota: "Ι",
  Iscr: "ℐ",
  Itilde: "Ĩ",
  Iukcy: "І",
  Iuml: "Ï",
  Jcirc: "Ĵ",
  Jcy: "Й",
  Jfr: "𝔍",
  Jopf: "𝕁",
  Jscr: "𝒥",
  Jsercy: "Ј",
  Jukcy: "Є",
  KHcy: "Х",
  KJcy: "Ќ",
  Kappa: "Κ",
  Kcedil: "Ķ",
  Kcy: "К",
  Kfr: "𝔎",
  Kopf: "𝕂",
  Kscr: "𝒦",
  LJcy: "Љ",
  LT: "<",
  Lacute: "Ĺ",
  Lambda: "Λ",
  Lang: "⟪",
  Laplacetrf: "ℒ",
  Larr: "↞",
  Lcaron: "Ľ",
  Lcedil: "Ļ",
  Lcy: "Л",
  LeftAngleBracket: "⟨",
  LeftArrow: "←",
  LeftArrowBar: "⇤",
  LeftArrowRightArrow: "⇆",
  LeftCeiling: "⌈",
  LeftDoubleBracket: "⟦",
  LeftDownTeeVector: "⥡",
  LeftDownVector: "⇃",
  LeftDownVectorBar: "⥙",
  LeftFloor: "⌊",
  LeftRightArrow: "↔",
  LeftRightVector: "⥎",
  LeftTee: "⊣",
  LeftTeeArrow: "↤",
  LeftTeeVector: "⥚",
  LeftTriangle: "⊲",
  LeftTriangleBar: "⧏",
  LeftTriangleEqual: "⊴",
  LeftUpDownVector: "⥑",
  LeftUpTeeVector: "⥠",
  LeftUpVector: "↿",
  LeftUpVectorBar: "⥘",
  LeftVector: "↼",
  LeftVectorBar: "⥒",
  Leftarrow: "⇐",
  Leftrightarrow: "⇔",
  LessEqualGreater: "⋚",
  LessFullEqual: "≦",
  LessGreater: "≶",
  LessLess: "⪡",
  LessSlantEqual: "⩽",
  LessTilde: "≲",
  Lfr: "𝔏",
  Ll: "⋘",
  Lleftarrow: "⇚",
  Lmidot: "Ŀ",
  LongLeftArrow: "⟵",
  LongLeftRightArrow: "⟷",
  LongRightArrow: "⟶",
  Longleftarrow: "⟸",
  Longleftrightarrow: "⟺",
  Longrightarrow: "⟹",
  Lopf: "𝕃",
  LowerLeftArrow: "↙",
  LowerRightArrow: "↘",
  Lscr: "ℒ",
  Lsh: "↰",
  Lstrok: "Ł",
  Lt: "≪",
  Map: "⤅",
  Mcy: "М",
  MediumSpace: " ",
  Mellintrf: "ℳ",
  Mfr: "𝔐",
  MinusPlus: "∓",
  Mopf: "𝕄",
  Mscr: "ℳ",
  Mu: "Μ",
  NJcy: "Њ",
  Nacute: "Ń",
  Ncaron: "Ň",
  Ncedil: "Ņ",
  Ncy: "Н",
  NegativeMediumSpace: "​",
  NegativeThickSpace: "​",
  NegativeThinSpace: "​",
  NegativeVeryThinSpace: "​",
  NestedGreaterGreater: "≫",
  NestedLessLess: "≪",
  NewLine: "\n",
  Nfr: "𝔑",
  NoBreak: "⁠",
  NonBreakingSpace: " ",
  Nopf: "ℕ",
  Not: "⫬",
  NotCongruent: "≢",
  NotCupCap: "≭",
  NotDoubleVerticalBar: "∦",
  NotElement: "∉",
  NotEqual: "≠",
  NotEqualTilde: "≂̸",
  NotExists: "∄",
  NotGreater: "≯",
  NotGreaterEqual: "≱",
  NotGreaterFullEqual: "≧̸",
  NotGreaterGreater: "≫̸",
  NotGreaterLess: "≹",
  NotGreaterSlantEqual: "⩾̸",
  NotGreaterTilde: "≵",
  NotHumpDownHump: "≎̸",
  NotHumpEqual: "≏̸",
  NotLeftTriangle: "⋪",
  NotLeftTriangleBar: "⧏̸",
  NotLeftTriangleEqual: "⋬",
  NotLess: "≮",
  NotLessEqual: "≰",
  NotLessGreater: "≸",
  NotLessLess: "≪̸",
  NotLessSlantEqual: "⩽̸",
  NotLessTilde: "≴",
  NotNestedGreaterGreater: "⪢̸",
  NotNestedLessLess: "⪡̸",
  NotPrecedes: "⊀",
  NotPrecedesEqual: "⪯̸",
  NotPrecedesSlantEqual: "⋠",
  NotReverseElement: "∌",
  NotRightTriangle: "⋫",
  NotRightTriangleBar: "⧐̸",
  NotRightTriangleEqual: "⋭",
  NotSquareSubset: "⊏̸",
  NotSquareSubsetEqual: "⋢",
  NotSquareSuperset: "⊐̸",
  NotSquareSupersetEqual: "⋣",
  NotSubset: "⊂⃒",
  NotSubsetEqual: "⊈",
  NotSucceeds: "⊁",
  NotSucceedsEqual: "⪰̸",
  NotSucceedsSlantEqual: "⋡",
  NotSucceedsTilde: "≿̸",
  NotSuperset: "⊃⃒",
  NotSupersetEqual: "⊉",
  NotTilde: "≁",
  NotTildeEqual: "≄",
  NotTildeFullEqual: "≇",
  NotTildeTilde: "≉",
  NotVerticalBar: "∤",
  Nscr: "𝒩",
  Ntilde: "Ñ",
  Nu: "Ν",
  OElig: "Œ",
  Oacute: "Ó",
  Ocirc: "Ô",
  Ocy: "О",
  Odblac: "Ő",
  Ofr: "𝔒",
  Ograve: "Ò",
  Omacr: "Ō",
  Omega: "Ω",
  Omicron: "Ο",
  Oopf: "𝕆",
  OpenCurlyDoubleQuote: "“",
  OpenCurlyQuote: "‘",
  Or: "⩔",
  Oscr: "𝒪",
  Oslash: "Ø",
  Otilde: "Õ",
  Otimes: "⨷",
  Ouml: "Ö",
  OverBar: "‾",
  OverBrace: "⏞",
  OverBracket: "⎴",
  OverParenthesis: "⏜",
  PartialD: "∂",
  Pcy: "П",
  Pfr: "𝔓",
  Phi: "Φ",
  Pi: "Π",
  PlusMinus: "±",
  Poincareplane: "ℌ",
  Popf: "ℙ",
  Pr: "⪻",
  Precedes: "≺",
  PrecedesEqual: "⪯",
  PrecedesSlantEqual: "≼",
  PrecedesTilde: "≾",
  Prime: "″",
  Product: "∏",
  Proportion: "∷",
  Proportional: "∝",
  Pscr: "𝒫",
  Psi: "Ψ",
  QUOT: '"',
  Qfr: "𝔔",
  Qopf: "ℚ",
  Qscr: "𝒬",
  RBarr: "⤐",
  REG: "®",
  Racute: "Ŕ",
  Rang: "⟫",
  Rarr: "↠",
  Rarrtl: "⤖",
  Rcaron: "Ř",
  Rcedil: "Ŗ",
  Rcy: "Р",
  Re: "ℜ",
  ReverseElement: "∋",
  ReverseEquilibrium: "⇋",
  ReverseUpEquilibrium: "⥯",
  Rfr: "ℜ",
  Rho: "Ρ",
  RightAngleBracket: "⟩",
  RightArrow: "→",
  RightArrowBar: "⇥",
  RightArrowLeftArrow: "⇄",
  RightCeiling: "⌉",
  RightDoubleBracket: "⟧",
  RightDownTeeVector: "⥝",
  RightDownVector: "⇂",
  RightDownVectorBar: "⥕",
  RightFloor: "⌋",
  RightTee: "⊢",
  RightTeeArrow: "↦",
  RightTeeVector: "⥛",
  RightTriangle: "⊳",
  RightTriangleBar: "⧐",
  RightTriangleEqual: "⊵",
  RightUpDownVector: "⥏",
  RightUpTeeVector: "⥜",
  RightUpVector: "↾",
  RightUpVectorBar: "⥔",
  RightVector: "⇀",
  RightVectorBar: "⥓",
  Rightarrow: "⇒",
  Ropf: "ℝ",
  RoundImplies: "⥰",
  Rrightarrow: "⇛",
  Rscr: "ℛ",
  Rsh: "↱",
  RuleDelayed: "⧴",
  SHCHcy: "Щ",
  SHcy: "Ш",
  SOFTcy: "Ь",
  Sacute: "Ś",
  Sc: "⪼",
  Scaron: "Š",
  Scedil: "Ş",
  Scirc: "Ŝ",
  Scy: "С",
  Sfr: "𝔖",
  ShortDownArrow: "↓",
  ShortLeftArrow: "←",
  ShortRightArrow: "→",
  ShortUpArrow: "↑",
  Sigma: "Σ",
  SmallCircle: "∘",
  Sopf: "𝕊",
  Sqrt: "√",
  Square: "□",
  SquareIntersection: "⊓",
  SquareSubset: "⊏",
  SquareSubsetEqual: "⊑",
  SquareSuperset: "⊐",
  SquareSupersetEqual: "⊒",
  SquareUnion: "⊔",
  Sscr: "𝒮",
  Star: "⋆",
  Sub: "⋐",
  Subset: "⋐",
  SubsetEqual: "⊆",
  Succeeds: "≻",
  SucceedsEqual: "⪰",
  SucceedsSlantEqual: "≽",
  SucceedsTilde: "≿",
  SuchThat: "∋",
  Sum: "∑",
  Sup: "⋑",
  Superset: "⊃",
  SupersetEqual: "⊇",
  Supset: "⋑",
  THORN: "Þ",
  TRADE: "™",
  TSHcy: "Ћ",
  TScy: "Ц",
  Tab: "	",
  Tau: "Τ",
  Tcaron: "Ť",
  Tcedil: "Ţ",
  Tcy: "Т",
  Tfr: "𝔗",
  Therefore: "∴",
  Theta: "Θ",
  ThickSpace: "  ",
  ThinSpace: " ",
  Tilde: "∼",
  TildeEqual: "≃",
  TildeFullEqual: "≅",
  TildeTilde: "≈",
  Topf: "𝕋",
  TripleDot: "⃛",
  Tscr: "𝒯",
  Tstrok: "Ŧ",
  Uacute: "Ú",
  Uarr: "↟",
  Uarrocir: "⥉",
  Ubrcy: "Ў",
  Ubreve: "Ŭ",
  Ucirc: "Û",
  Ucy: "У",
  Udblac: "Ű",
  Ufr: "𝔘",
  Ugrave: "Ù",
  Umacr: "Ū",
  UnderBar: "_",
  UnderBrace: "⏟",
  UnderBracket: "⎵",
  UnderParenthesis: "⏝",
  Union: "⋃",
  UnionPlus: "⊎",
  Uogon: "Ų",
  Uopf: "𝕌",
  UpArrow: "↑",
  UpArrowBar: "⤒",
  UpArrowDownArrow: "⇅",
  UpDownArrow: "↕",
  UpEquilibrium: "⥮",
  UpTee: "⊥",
  UpTeeArrow: "↥",
  Uparrow: "⇑",
  Updownarrow: "⇕",
  UpperLeftArrow: "↖",
  UpperRightArrow: "↗",
  Upsi: "ϒ",
  Upsilon: "Υ",
  Uring: "Ů",
  Uscr: "𝒰",
  Utilde: "Ũ",
  Uuml: "Ü",
  VDash: "⊫",
  Vbar: "⫫",
  Vcy: "В",
  Vdash: "⊩",
  Vdashl: "⫦",
  Vee: "⋁",
  Verbar: "‖",
  Vert: "‖",
  VerticalBar: "∣",
  VerticalLine: "|",
  VerticalSeparator: "❘",
  VerticalTilde: "≀",
  VeryThinSpace: " ",
  Vfr: "𝔙",
  Vopf: "𝕍",
  Vscr: "𝒱",
  Vvdash: "⊪",
  Wcirc: "Ŵ",
  Wedge: "⋀",
  Wfr: "𝔚",
  Wopf: "𝕎",
  Wscr: "𝒲",
  Xfr: "𝔛",
  Xi: "Ξ",
  Xopf: "𝕏",
  Xscr: "𝒳",
  YAcy: "Я",
  YIcy: "Ї",
  YUcy: "Ю",
  Yacute: "Ý",
  Ycirc: "Ŷ",
  Ycy: "Ы",
  Yfr: "𝔜",
  Yopf: "𝕐",
  Yscr: "𝒴",
  Yuml: "Ÿ",
  ZHcy: "Ж",
  Zacute: "Ź",
  Zcaron: "Ž",
  Zcy: "З",
  Zdot: "Ż",
  ZeroWidthSpace: "​",
  Zeta: "Ζ",
  Zfr: "ℨ",
  Zopf: "ℤ",
  Zscr: "𝒵",
  aacute: "á",
  abreve: "ă",
  ac: "∾",
  acE: "∾̳",
  acd: "∿",
  acirc: "â",
  acute: "´",
  acy: "а",
  aelig: "æ",
  af: "⁡",
  afr: "𝔞",
  agrave: "à",
  alefsym: "ℵ",
  aleph: "ℵ",
  alpha: "α",
  amacr: "ā",
  amalg: "⨿",
  amp: "&",
  and: "∧",
  andand: "⩕",
  andd: "⩜",
  andslope: "⩘",
  andv: "⩚",
  ang: "∠",
  ange: "⦤",
  angle: "∠",
  angmsd: "∡",
  angmsdaa: "⦨",
  angmsdab: "⦩",
  angmsdac: "⦪",
  angmsdad: "⦫",
  angmsdae: "⦬",
  angmsdaf: "⦭",
  angmsdag: "⦮",
  angmsdah: "⦯",
  angrt: "∟",
  angrtvb: "⊾",
  angrtvbd: "⦝",
  angsph: "∢",
  angst: "Å",
  angzarr: "⍼",
  aogon: "ą",
  aopf: "𝕒",
  ap: "≈",
  apE: "⩰",
  apacir: "⩯",
  ape: "≊",
  apid: "≋",
  apos: "'",
  approx: "≈",
  approxeq: "≊",
  aring: "å",
  ascr: "𝒶",
  ast: "*",
  asymp: "≈",
  asympeq: "≍",
  atilde: "ã",
  auml: "ä",
  awconint: "∳",
  awint: "⨑",
  bNot: "⫭",
  backcong: "≌",
  backepsilon: "϶",
  backprime: "‵",
  backsim: "∽",
  backsimeq: "⋍",
  barvee: "⊽",
  barwed: "⌅",
  barwedge: "⌅",
  bbrk: "⎵",
  bbrktbrk: "⎶",
  bcong: "≌",
  bcy: "б",
  bdquo: "„",
  becaus: "∵",
  because: "∵",
  bemptyv: "⦰",
  bepsi: "϶",
  bernou: "ℬ",
  beta: "β",
  beth: "ℶ",
  between: "≬",
  bfr: "𝔟",
  bigcap: "⋂",
  bigcirc: "◯",
  bigcup: "⋃",
  bigodot: "⨀",
  bigoplus: "⨁",
  bigotimes: "⨂",
  bigsqcup: "⨆",
  bigstar: "★",
  bigtriangledown: "▽",
  bigtriangleup: "△",
  biguplus: "⨄",
  bigvee: "⋁",
  bigwedge: "⋀",
  bkarow: "⤍",
  blacklozenge: "⧫",
  blacksquare: "▪",
  blacktriangle: "▴",
  blacktriangledown: "▾",
  blacktriangleleft: "◂",
  blacktriangleright: "▸",
  blank: "␣",
  blk12: "▒",
  blk14: "░",
  blk34: "▓",
  block: "█",
  bne: "=⃥",
  bnequiv: "≡⃥",
  bnot: "⌐",
  bopf: "𝕓",
  bot: "⊥",
  bottom: "⊥",
  bowtie: "⋈",
  boxDL: "╗",
  boxDR: "╔",
  boxDl: "╖",
  boxDr: "╓",
  boxH: "═",
  boxHD: "╦",
  boxHU: "╩",
  boxHd: "╤",
  boxHu: "╧",
  boxUL: "╝",
  boxUR: "╚",
  boxUl: "╜",
  boxUr: "╙",
  boxV: "║",
  boxVH: "╬",
  boxVL: "╣",
  boxVR: "╠",
  boxVh: "╫",
  boxVl: "╢",
  boxVr: "╟",
  boxbox: "⧉",
  boxdL: "╕",
  boxdR: "╒",
  boxdl: "┐",
  boxdr: "┌",
  boxh: "─",
  boxhD: "╥",
  boxhU: "╨",
  boxhd: "┬",
  boxhu: "┴",
  boxminus: "⊟",
  boxplus: "⊞",
  boxtimes: "⊠",
  boxuL: "╛",
  boxuR: "╘",
  boxul: "┘",
  boxur: "└",
  boxv: "│",
  boxvH: "╪",
  boxvL: "╡",
  boxvR: "╞",
  boxvh: "┼",
  boxvl: "┤",
  boxvr: "├",
  bprime: "‵",
  breve: "˘",
  brvbar: "¦",
  bscr: "𝒷",
  bsemi: "⁏",
  bsim: "∽",
  bsime: "⋍",
  bsol: "\\",
  bsolb: "⧅",
  bsolhsub: "⟈",
  bull: "•",
  bullet: "•",
  bump: "≎",
  bumpE: "⪮",
  bumpe: "≏",
  bumpeq: "≏",
  cacute: "ć",
  cap: "∩",
  capand: "⩄",
  capbrcup: "⩉",
  capcap: "⩋",
  capcup: "⩇",
  capdot: "⩀",
  caps: "∩︀",
  caret: "⁁",
  caron: "ˇ",
  ccaps: "⩍",
  ccaron: "č",
  ccedil: "ç",
  ccirc: "ĉ",
  ccups: "⩌",
  ccupssm: "⩐",
  cdot: "ċ",
  cedil: "¸",
  cemptyv: "⦲",
  cent: "¢",
  centerdot: "·",
  cfr: "𝔠",
  chcy: "ч",
  check: "✓",
  checkmark: "✓",
  chi: "χ",
  cir: "○",
  cirE: "⧃",
  circ: "ˆ",
  circeq: "≗",
  circlearrowleft: "↺",
  circlearrowright: "↻",
  circledR: "®",
  circledS: "Ⓢ",
  circledast: "⊛",
  circledcirc: "⊚",
  circleddash: "⊝",
  cire: "≗",
  cirfnint: "⨐",
  cirmid: "⫯",
  cirscir: "⧂",
  clubs: "♣",
  clubsuit: "♣",
  colon: ":",
  colone: "≔",
  coloneq: "≔",
  comma: ",",
  commat: "@",
  comp: "∁",
  compfn: "∘",
  complement: "∁",
  complexes: "ℂ",
  cong: "≅",
  congdot: "⩭",
  conint: "∮",
  copf: "𝕔",
  coprod: "∐",
  copy: "©",
  copysr: "℗",
  crarr: "↵",
  cross: "✗",
  cscr: "𝒸",
  csub: "⫏",
  csube: "⫑",
  csup: "⫐",
  csupe: "⫒",
  ctdot: "⋯",
  cudarrl: "⤸",
  cudarrr: "⤵",
  cuepr: "⋞",
  cuesc: "⋟",
  cularr: "↶",
  cularrp: "⤽",
  cup: "∪",
  cupbrcap: "⩈",
  cupcap: "⩆",
  cupcup: "⩊",
  cupdot: "⊍",
  cupor: "⩅",
  cups: "∪︀",
  curarr: "↷",
  curarrm: "⤼",
  curlyeqprec: "⋞",
  curlyeqsucc: "⋟",
  curlyvee: "⋎",
  curlywedge: "⋏",
  curren: "¤",
  curvearrowleft: "↶",
  curvearrowright: "↷",
  cuvee: "⋎",
  cuwed: "⋏",
  cwconint: "∲",
  cwint: "∱",
  cylcty: "⌭",
  dArr: "⇓",
  dHar: "⥥",
  dagger: "†",
  daleth: "ℸ",
  darr: "↓",
  dash: "‐",
  dashv: "⊣",
  dbkarow: "⤏",
  dblac: "˝",
  dcaron: "ď",
  dcy: "д",
  dd: "ⅆ",
  ddagger: "‡",
  ddarr: "⇊",
  ddotseq: "⩷",
  deg: "°",
  delta: "δ",
  demptyv: "⦱",
  dfisht: "⥿",
  dfr: "𝔡",
  dharl: "⇃",
  dharr: "⇂",
  diam: "⋄",
  diamond: "⋄",
  diamondsuit: "♦",
  diams: "♦",
  die: "¨",
  digamma: "ϝ",
  disin: "⋲",
  div: "÷",
  divide: "÷",
  divideontimes: "⋇",
  divonx: "⋇",
  djcy: "ђ",
  dlcorn: "⌞",
  dlcrop: "⌍",
  dollar: "$",
  dopf: "𝕕",
  dot: "˙",
  doteq: "≐",
  doteqdot: "≑",
  dotminus: "∸",
  dotplus: "∔",
  dotsquare: "⊡",
  doublebarwedge: "⌆",
  downarrow: "↓",
  downdownarrows: "⇊",
  downharpoonleft: "⇃",
  downharpoonright: "⇂",
  drbkarow: "⤐",
  drcorn: "⌟",
  drcrop: "⌌",
  dscr: "𝒹",
  dscy: "ѕ",
  dsol: "⧶",
  dstrok: "đ",
  dtdot: "⋱",
  dtri: "▿",
  dtrif: "▾",
  duarr: "⇵",
  duhar: "⥯",
  dwangle: "⦦",
  dzcy: "џ",
  dzigrarr: "⟿",
  eDDot: "⩷",
  eDot: "≑",
  eacute: "é",
  easter: "⩮",
  ecaron: "ě",
  ecir: "≖",
  ecirc: "ê",
  ecolon: "≕",
  ecy: "э",
  edot: "ė",
  ee: "ⅇ",
  efDot: "≒",
  efr: "𝔢",
  eg: "⪚",
  egrave: "è",
  egs: "⪖",
  egsdot: "⪘",
  el: "⪙",
  elinters: "⏧",
  ell: "ℓ",
  els: "⪕",
  elsdot: "⪗",
  emacr: "ē",
  empty: "∅",
  emptyset: "∅",
  emptyv: "∅",
  emsp13: " ",
  emsp14: " ",
  emsp: " ",
  eng: "ŋ",
  ensp: " ",
  eogon: "ę",
  eopf: "𝕖",
  epar: "⋕",
  eparsl: "⧣",
  eplus: "⩱",
  epsi: "ε",
  epsilon: "ε",
  epsiv: "ϵ",
  eqcirc: "≖",
  eqcolon: "≕",
  eqsim: "≂",
  eqslantgtr: "⪖",
  eqslantless: "⪕",
  equals: "=",
  equest: "≟",
  equiv: "≡",
  equivDD: "⩸",
  eqvparsl: "⧥",
  erDot: "≓",
  erarr: "⥱",
  escr: "ℯ",
  esdot: "≐",
  esim: "≂",
  eta: "η",
  eth: "ð",
  euml: "ë",
  euro: "€",
  excl: "!",
  exist: "∃",
  expectation: "ℰ",
  exponentiale: "ⅇ",
  fallingdotseq: "≒",
  fcy: "ф",
  female: "♀",
  ffilig: "ﬃ",
  fflig: "ﬀ",
  ffllig: "ﬄ",
  ffr: "𝔣",
  filig: "ﬁ",
  fjlig: "fj",
  flat: "♭",
  fllig: "ﬂ",
  fltns: "▱",
  fnof: "ƒ",
  fopf: "𝕗",
  forall: "∀",
  fork: "⋔",
  forkv: "⫙",
  fpartint: "⨍",
  frac12: "½",
  frac13: "⅓",
  frac14: "¼",
  frac15: "⅕",
  frac16: "⅙",
  frac18: "⅛",
  frac23: "⅔",
  frac25: "⅖",
  frac34: "¾",
  frac35: "⅗",
  frac38: "⅜",
  frac45: "⅘",
  frac56: "⅚",
  frac58: "⅝",
  frac78: "⅞",
  frasl: "⁄",
  frown: "⌢",
  fscr: "𝒻",
  gE: "≧",
  gEl: "⪌",
  gacute: "ǵ",
  gamma: "γ",
  gammad: "ϝ",
  gap: "⪆",
  gbreve: "ğ",
  gcirc: "ĝ",
  gcy: "г",
  gdot: "ġ",
  ge: "≥",
  gel: "⋛",
  geq: "≥",
  geqq: "≧",
  geqslant: "⩾",
  ges: "⩾",
  gescc: "⪩",
  gesdot: "⪀",
  gesdoto: "⪂",
  gesdotol: "⪄",
  gesl: "⋛︀",
  gesles: "⪔",
  gfr: "𝔤",
  gg: "≫",
  ggg: "⋙",
  gimel: "ℷ",
  gjcy: "ѓ",
  gl: "≷",
  glE: "⪒",
  gla: "⪥",
  glj: "⪤",
  gnE: "≩",
  gnap: "⪊",
  gnapprox: "⪊",
  gne: "⪈",
  gneq: "⪈",
  gneqq: "≩",
  gnsim: "⋧",
  gopf: "𝕘",
  grave: "`",
  gscr: "ℊ",
  gsim: "≳",
  gsime: "⪎",
  gsiml: "⪐",
  gt: ">",
  gtcc: "⪧",
  gtcir: "⩺",
  gtdot: "⋗",
  gtlPar: "⦕",
  gtquest: "⩼",
  gtrapprox: "⪆",
  gtrarr: "⥸",
  gtrdot: "⋗",
  gtreqless: "⋛",
  gtreqqless: "⪌",
  gtrless: "≷",
  gtrsim: "≳",
  gvertneqq: "≩︀",
  gvnE: "≩︀",
  hArr: "⇔",
  hairsp: " ",
  half: "½",
  hamilt: "ℋ",
  hardcy: "ъ",
  harr: "↔",
  harrcir: "⥈",
  harrw: "↭",
  hbar: "ℏ",
  hcirc: "ĥ",
  hearts: "♥",
  heartsuit: "♥",
  hellip: "…",
  hercon: "⊹",
  hfr: "𝔥",
  hksearow: "⤥",
  hkswarow: "⤦",
  hoarr: "⇿",
  homtht: "∻",
  hookleftarrow: "↩",
  hookrightarrow: "↪",
  hopf: "𝕙",
  horbar: "―",
  hscr: "𝒽",
  hslash: "ℏ",
  hstrok: "ħ",
  hybull: "⁃",
  hyphen: "‐",
  iacute: "í",
  ic: "⁣",
  icirc: "î",
  icy: "и",
  iecy: "е",
  iexcl: "¡",
  iff: "⇔",
  ifr: "𝔦",
  igrave: "ì",
  ii: "ⅈ",
  iiiint: "⨌",
  iiint: "∭",
  iinfin: "⧜",
  iiota: "℩",
  ijlig: "ĳ",
  imacr: "ī",
  image: "ℑ",
  imagline: "ℐ",
  imagpart: "ℑ",
  imath: "ı",
  imof: "⊷",
  imped: "Ƶ",
  in: "∈",
  incare: "℅",
  infin: "∞",
  infintie: "⧝",
  inodot: "ı",
  int: "∫",
  intcal: "⊺",
  integers: "ℤ",
  intercal: "⊺",
  intlarhk: "⨗",
  intprod: "⨼",
  iocy: "ё",
  iogon: "į",
  iopf: "𝕚",
  iota: "ι",
  iprod: "⨼",
  iquest: "¿",
  iscr: "𝒾",
  isin: "∈",
  isinE: "⋹",
  isindot: "⋵",
  isins: "⋴",
  isinsv: "⋳",
  isinv: "∈",
  it: "⁢",
  itilde: "ĩ",
  iukcy: "і",
  iuml: "ï",
  jcirc: "ĵ",
  jcy: "й",
  jfr: "𝔧",
  jmath: "ȷ",
  jopf: "𝕛",
  jscr: "𝒿",
  jsercy: "ј",
  jukcy: "є",
  kappa: "κ",
  kappav: "ϰ",
  kcedil: "ķ",
  kcy: "к",
  kfr: "𝔨",
  kgreen: "ĸ",
  khcy: "х",
  kjcy: "ќ",
  kopf: "𝕜",
  kscr: "𝓀",
  lAarr: "⇚",
  lArr: "⇐",
  lAtail: "⤛",
  lBarr: "⤎",
  lE: "≦",
  lEg: "⪋",
  lHar: "⥢",
  lacute: "ĺ",
  laemptyv: "⦴",
  lagran: "ℒ",
  lambda: "λ",
  lang: "⟨",
  langd: "⦑",
  langle: "⟨",
  lap: "⪅",
  laquo: "«",
  larr: "←",
  larrb: "⇤",
  larrbfs: "⤟",
  larrfs: "⤝",
  larrhk: "↩",
  larrlp: "↫",
  larrpl: "⤹",
  larrsim: "⥳",
  larrtl: "↢",
  lat: "⪫",
  latail: "⤙",
  late: "⪭",
  lates: "⪭︀",
  lbarr: "⤌",
  lbbrk: "❲",
  lbrace: "{",
  lbrack: "[",
  lbrke: "⦋",
  lbrksld: "⦏",
  lbrkslu: "⦍",
  lcaron: "ľ",
  lcedil: "ļ",
  lceil: "⌈",
  lcub: "{",
  lcy: "л",
  ldca: "⤶",
  ldquo: "“",
  ldquor: "„",
  ldrdhar: "⥧",
  ldrushar: "⥋",
  ldsh: "↲",
  le: "≤",
  leftarrow: "←",
  leftarrowtail: "↢",
  leftharpoondown: "↽",
  leftharpoonup: "↼",
  leftleftarrows: "⇇",
  leftrightarrow: "↔",
  leftrightarrows: "⇆",
  leftrightharpoons: "⇋",
  leftrightsquigarrow: "↭",
  leftthreetimes: "⋋",
  leg: "⋚",
  leq: "≤",
  leqq: "≦",
  leqslant: "⩽",
  les: "⩽",
  lescc: "⪨",
  lesdot: "⩿",
  lesdoto: "⪁",
  lesdotor: "⪃",
  lesg: "⋚︀",
  lesges: "⪓",
  lessapprox: "⪅",
  lessdot: "⋖",
  lesseqgtr: "⋚",
  lesseqqgtr: "⪋",
  lessgtr: "≶",
  lesssim: "≲",
  lfisht: "⥼",
  lfloor: "⌊",
  lfr: "𝔩",
  lg: "≶",
  lgE: "⪑",
  lhard: "↽",
  lharu: "↼",
  lharul: "⥪",
  lhblk: "▄",
  ljcy: "љ",
  ll: "≪",
  llarr: "⇇",
  llcorner: "⌞",
  llhard: "⥫",
  lltri: "◺",
  lmidot: "ŀ",
  lmoust: "⎰",
  lmoustache: "⎰",
  lnE: "≨",
  lnap: "⪉",
  lnapprox: "⪉",
  lne: "⪇",
  lneq: "⪇",
  lneqq: "≨",
  lnsim: "⋦",
  loang: "⟬",
  loarr: "⇽",
  lobrk: "⟦",
  longleftarrow: "⟵",
  longleftrightarrow: "⟷",
  longmapsto: "⟼",
  longrightarrow: "⟶",
  looparrowleft: "↫",
  looparrowright: "↬",
  lopar: "⦅",
  lopf: "𝕝",
  loplus: "⨭",
  lotimes: "⨴",
  lowast: "∗",
  lowbar: "_",
  loz: "◊",
  lozenge: "◊",
  lozf: "⧫",
  lpar: "(",
  lparlt: "⦓",
  lrarr: "⇆",
  lrcorner: "⌟",
  lrhar: "⇋",
  lrhard: "⥭",
  lrm: "‎",
  lrtri: "⊿",
  lsaquo: "‹",
  lscr: "𝓁",
  lsh: "↰",
  lsim: "≲",
  lsime: "⪍",
  lsimg: "⪏",
  lsqb: "[",
  lsquo: "‘",
  lsquor: "‚",
  lstrok: "ł",
  lt: "<",
  ltcc: "⪦",
  ltcir: "⩹",
  ltdot: "⋖",
  lthree: "⋋",
  ltimes: "⋉",
  ltlarr: "⥶",
  ltquest: "⩻",
  ltrPar: "⦖",
  ltri: "◃",
  ltrie: "⊴",
  ltrif: "◂",
  lurdshar: "⥊",
  luruhar: "⥦",
  lvertneqq: "≨︀",
  lvnE: "≨︀",
  mDDot: "∺",
  macr: "¯",
  male: "♂",
  malt: "✠",
  maltese: "✠",
  map: "↦",
  mapsto: "↦",
  mapstodown: "↧",
  mapstoleft: "↤",
  mapstoup: "↥",
  marker: "▮",
  mcomma: "⨩",
  mcy: "м",
  mdash: "—",
  measuredangle: "∡",
  mfr: "𝔪",
  mho: "℧",
  micro: "µ",
  mid: "∣",
  midast: "*",
  midcir: "⫰",
  middot: "·",
  minus: "−",
  minusb: "⊟",
  minusd: "∸",
  minusdu: "⨪",
  mlcp: "⫛",
  mldr: "…",
  mnplus: "∓",
  models: "⊧",
  mopf: "𝕞",
  mp: "∓",
  mscr: "𝓂",
  mstpos: "∾",
  mu: "μ",
  multimap: "⊸",
  mumap: "⊸",
  nGg: "⋙̸",
  nGt: "≫⃒",
  nGtv: "≫̸",
  nLeftarrow: "⇍",
  nLeftrightarrow: "⇎",
  nLl: "⋘̸",
  nLt: "≪⃒",
  nLtv: "≪̸",
  nRightarrow: "⇏",
  nVDash: "⊯",
  nVdash: "⊮",
  nabla: "∇",
  nacute: "ń",
  nang: "∠⃒",
  nap: "≉",
  napE: "⩰̸",
  napid: "≋̸",
  napos: "ŉ",
  napprox: "≉",
  natur: "♮",
  natural: "♮",
  naturals: "ℕ",
  nbsp: " ",
  nbump: "≎̸",
  nbumpe: "≏̸",
  ncap: "⩃",
  ncaron: "ň",
  ncedil: "ņ",
  ncong: "≇",
  ncongdot: "⩭̸",
  ncup: "⩂",
  ncy: "н",
  ndash: "–",
  ne: "≠",
  neArr: "⇗",
  nearhk: "⤤",
  nearr: "↗",
  nearrow: "↗",
  nedot: "≐̸",
  nequiv: "≢",
  nesear: "⤨",
  nesim: "≂̸",
  nexist: "∄",
  nexists: "∄",
  nfr: "𝔫",
  ngE: "≧̸",
  nge: "≱",
  ngeq: "≱",
  ngeqq: "≧̸",
  ngeqslant: "⩾̸",
  nges: "⩾̸",
  ngsim: "≵",
  ngt: "≯",
  ngtr: "≯",
  nhArr: "⇎",
  nharr: "↮",
  nhpar: "⫲",
  ni: "∋",
  nis: "⋼",
  nisd: "⋺",
  niv: "∋",
  njcy: "њ",
  nlArr: "⇍",
  nlE: "≦̸",
  nlarr: "↚",
  nldr: "‥",
  nle: "≰",
  nleftarrow: "↚",
  nleftrightarrow: "↮",
  nleq: "≰",
  nleqq: "≦̸",
  nleqslant: "⩽̸",
  nles: "⩽̸",
  nless: "≮",
  nlsim: "≴",
  nlt: "≮",
  nltri: "⋪",
  nltrie: "⋬",
  nmid: "∤",
  nopf: "𝕟",
  not: "¬",
  notin: "∉",
  notinE: "⋹̸",
  notindot: "⋵̸",
  notinva: "∉",
  notinvb: "⋷",
  notinvc: "⋶",
  notni: "∌",
  notniva: "∌",
  notnivb: "⋾",
  notnivc: "⋽",
  npar: "∦",
  nparallel: "∦",
  nparsl: "⫽⃥",
  npart: "∂̸",
  npolint: "⨔",
  npr: "⊀",
  nprcue: "⋠",
  npre: "⪯̸",
  nprec: "⊀",
  npreceq: "⪯̸",
  nrArr: "⇏",
  nrarr: "↛",
  nrarrc: "⤳̸",
  nrarrw: "↝̸",
  nrightarrow: "↛",
  nrtri: "⋫",
  nrtrie: "⋭",
  nsc: "⊁",
  nsccue: "⋡",
  nsce: "⪰̸",
  nscr: "𝓃",
  nshortmid: "∤",
  nshortparallel: "∦",
  nsim: "≁",
  nsime: "≄",
  nsimeq: "≄",
  nsmid: "∤",
  nspar: "∦",
  nsqsube: "⋢",
  nsqsupe: "⋣",
  nsub: "⊄",
  nsubE: "⫅̸",
  nsube: "⊈",
  nsubset: "⊂⃒",
  nsubseteq: "⊈",
  nsubseteqq: "⫅̸",
  nsucc: "⊁",
  nsucceq: "⪰̸",
  nsup: "⊅",
  nsupE: "⫆̸",
  nsupe: "⊉",
  nsupset: "⊃⃒",
  nsupseteq: "⊉",
  nsupseteqq: "⫆̸",
  ntgl: "≹",
  ntilde: "ñ",
  ntlg: "≸",
  ntriangleleft: "⋪",
  ntrianglelefteq: "⋬",
  ntriangleright: "⋫",
  ntrianglerighteq: "⋭",
  nu: "ν",
  num: "#",
  numero: "№",
  numsp: " ",
  nvDash: "⊭",
  nvHarr: "⤄",
  nvap: "≍⃒",
  nvdash: "⊬",
  nvge: "≥⃒",
  nvgt: ">⃒",
  nvinfin: "⧞",
  nvlArr: "⤂",
  nvle: "≤⃒",
  nvlt: "<⃒",
  nvltrie: "⊴⃒",
  nvrArr: "⤃",
  nvrtrie: "⊵⃒",
  nvsim: "∼⃒",
  nwArr: "⇖",
  nwarhk: "⤣",
  nwarr: "↖",
  nwarrow: "↖",
  nwnear: "⤧",
  oS: "Ⓢ",
  oacute: "ó",
  oast: "⊛",
  ocir: "⊚",
  ocirc: "ô",
  ocy: "о",
  odash: "⊝",
  odblac: "ő",
  odiv: "⨸",
  odot: "⊙",
  odsold: "⦼",
  oelig: "œ",
  ofcir: "⦿",
  ofr: "𝔬",
  ogon: "˛",
  ograve: "ò",
  ogt: "⧁",
  ohbar: "⦵",
  ohm: "Ω",
  oint: "∮",
  olarr: "↺",
  olcir: "⦾",
  olcross: "⦻",
  oline: "‾",
  olt: "⧀",
  omacr: "ō",
  omega: "ω",
  omicron: "ο",
  omid: "⦶",
  ominus: "⊖",
  oopf: "𝕠",
  opar: "⦷",
  operp: "⦹",
  oplus: "⊕",
  or: "∨",
  orarr: "↻",
  ord: "⩝",
  order: "ℴ",
  orderof: "ℴ",
  ordf: "ª",
  ordm: "º",
  origof: "⊶",
  oror: "⩖",
  orslope: "⩗",
  orv: "⩛",
  oscr: "ℴ",
  oslash: "ø",
  osol: "⊘",
  otilde: "õ",
  otimes: "⊗",
  otimesas: "⨶",
  ouml: "ö",
  ovbar: "⌽",
  par: "∥",
  para: "¶",
  parallel: "∥",
  parsim: "⫳",
  parsl: "⫽",
  part: "∂",
  pcy: "п",
  percnt: "%",
  period: ".",
  permil: "‰",
  perp: "⊥",
  pertenk: "‱",
  pfr: "𝔭",
  phi: "φ",
  phiv: "ϕ",
  phmmat: "ℳ",
  phone: "☎",
  pi: "π",
  pitchfork: "⋔",
  piv: "ϖ",
  planck: "ℏ",
  planckh: "ℎ",
  plankv: "ℏ",
  plus: "+",
  plusacir: "⨣",
  plusb: "⊞",
  pluscir: "⨢",
  plusdo: "∔",
  plusdu: "⨥",
  pluse: "⩲",
  plusmn: "±",
  plussim: "⨦",
  plustwo: "⨧",
  pm: "±",
  pointint: "⨕",
  popf: "𝕡",
  pound: "£",
  pr: "≺",
  prE: "⪳",
  prap: "⪷",
  prcue: "≼",
  pre: "⪯",
  prec: "≺",
  precapprox: "⪷",
  preccurlyeq: "≼",
  preceq: "⪯",
  precnapprox: "⪹",
  precneqq: "⪵",
  precnsim: "⋨",
  precsim: "≾",
  prime: "′",
  primes: "ℙ",
  prnE: "⪵",
  prnap: "⪹",
  prnsim: "⋨",
  prod: "∏",
  profalar: "⌮",
  profline: "⌒",
  profsurf: "⌓",
  prop: "∝",
  propto: "∝",
  prsim: "≾",
  prurel: "⊰",
  pscr: "𝓅",
  psi: "ψ",
  puncsp: " ",
  qfr: "𝔮",
  qint: "⨌",
  qopf: "𝕢",
  qprime: "⁗",
  qscr: "𝓆",
  quaternions: "ℍ",
  quatint: "⨖",
  quest: "?",
  questeq: "≟",
  quot: '"',
  rAarr: "⇛",
  rArr: "⇒",
  rAtail: "⤜",
  rBarr: "⤏",
  rHar: "⥤",
  race: "∽̱",
  racute: "ŕ",
  radic: "√",
  raemptyv: "⦳",
  rang: "⟩",
  rangd: "⦒",
  range: "⦥",
  rangle: "⟩",
  raquo: "»",
  rarr: "→",
  rarrap: "⥵",
  rarrb: "⇥",
  rarrbfs: "⤠",
  rarrc: "⤳",
  rarrfs: "⤞",
  rarrhk: "↪",
  rarrlp: "↬",
  rarrpl: "⥅",
  rarrsim: "⥴",
  rarrtl: "↣",
  rarrw: "↝",
  ratail: "⤚",
  ratio: "∶",
  rationals: "ℚ",
  rbarr: "⤍",
  rbbrk: "❳",
  rbrace: "}",
  rbrack: "]",
  rbrke: "⦌",
  rbrksld: "⦎",
  rbrkslu: "⦐",
  rcaron: "ř",
  rcedil: "ŗ",
  rceil: "⌉",
  rcub: "}",
  rcy: "р",
  rdca: "⤷",
  rdldhar: "⥩",
  rdquo: "”",
  rdquor: "”",
  rdsh: "↳",
  real: "ℜ",
  realine: "ℛ",
  realpart: "ℜ",
  reals: "ℝ",
  rect: "▭",
  reg: "®",
  rfisht: "⥽",
  rfloor: "⌋",
  rfr: "𝔯",
  rhard: "⇁",
  rharu: "⇀",
  rharul: "⥬",
  rho: "ρ",
  rhov: "ϱ",
  rightarrow: "→",
  rightarrowtail: "↣",
  rightharpoondown: "⇁",
  rightharpoonup: "⇀",
  rightleftarrows: "⇄",
  rightleftharpoons: "⇌",
  rightrightarrows: "⇉",
  rightsquigarrow: "↝",
  rightthreetimes: "⋌",
  ring: "˚",
  risingdotseq: "≓",
  rlarr: "⇄",
  rlhar: "⇌",
  rlm: "‏",
  rmoust: "⎱",
  rmoustache: "⎱",
  rnmid: "⫮",
  roang: "⟭",
  roarr: "⇾",
  robrk: "⟧",
  ropar: "⦆",
  ropf: "𝕣",
  roplus: "⨮",
  rotimes: "⨵",
  rpar: ")",
  rpargt: "⦔",
  rppolint: "⨒",
  rrarr: "⇉",
  rsaquo: "›",
  rscr: "𝓇",
  rsh: "↱",
  rsqb: "]",
  rsquo: "’",
  rsquor: "’",
  rthree: "⋌",
  rtimes: "⋊",
  rtri: "▹",
  rtrie: "⊵",
  rtrif: "▸",
  rtriltri: "⧎",
  ruluhar: "⥨",
  rx: "℞",
  sacute: "ś",
  sbquo: "‚",
  sc: "≻",
  scE: "⪴",
  scap: "⪸",
  scaron: "š",
  sccue: "≽",
  sce: "⪰",
  scedil: "ş",
  scirc: "ŝ",
  scnE: "⪶",
  scnap: "⪺",
  scnsim: "⋩",
  scpolint: "⨓",
  scsim: "≿",
  scy: "с",
  sdot: "⋅",
  sdotb: "⊡",
  sdote: "⩦",
  seArr: "⇘",
  searhk: "⤥",
  searr: "↘",
  searrow: "↘",
  sect: "§",
  semi: ";",
  seswar: "⤩",
  setminus: "∖",
  setmn: "∖",
  sext: "✶",
  sfr: "𝔰",
  sfrown: "⌢",
  sharp: "♯",
  shchcy: "щ",
  shcy: "ш",
  shortmid: "∣",
  shortparallel: "∥",
  shy: "­",
  sigma: "σ",
  sigmaf: "ς",
  sigmav: "ς",
  sim: "∼",
  simdot: "⩪",
  sime: "≃",
  simeq: "≃",
  simg: "⪞",
  simgE: "⪠",
  siml: "⪝",
  simlE: "⪟",
  simne: "≆",
  simplus: "⨤",
  simrarr: "⥲",
  slarr: "←",
  smallsetminus: "∖",
  smashp: "⨳",
  smeparsl: "⧤",
  smid: "∣",
  smile: "⌣",
  smt: "⪪",
  smte: "⪬",
  smtes: "⪬︀",
  softcy: "ь",
  sol: "/",
  solb: "⧄",
  solbar: "⌿",
  sopf: "𝕤",
  spades: "♠",
  spadesuit: "♠",
  spar: "∥",
  sqcap: "⊓",
  sqcaps: "⊓︀",
  sqcup: "⊔",
  sqcups: "⊔︀",
  sqsub: "⊏",
  sqsube: "⊑",
  sqsubset: "⊏",
  sqsubseteq: "⊑",
  sqsup: "⊐",
  sqsupe: "⊒",
  sqsupset: "⊐",
  sqsupseteq: "⊒",
  squ: "□",
  square: "□",
  squarf: "▪",
  squf: "▪",
  srarr: "→",
  sscr: "𝓈",
  ssetmn: "∖",
  ssmile: "⌣",
  sstarf: "⋆",
  star: "☆",
  starf: "★",
  straightepsilon: "ϵ",
  straightphi: "ϕ",
  strns: "¯",
  sub: "⊂",
  subE: "⫅",
  subdot: "⪽",
  sube: "⊆",
  subedot: "⫃",
  submult: "⫁",
  subnE: "⫋",
  subne: "⊊",
  subplus: "⪿",
  subrarr: "⥹",
  subset: "⊂",
  subseteq: "⊆",
  subseteqq: "⫅",
  subsetneq: "⊊",
  subsetneqq: "⫋",
  subsim: "⫇",
  subsub: "⫕",
  subsup: "⫓",
  succ: "≻",
  succapprox: "⪸",
  succcurlyeq: "≽",
  succeq: "⪰",
  succnapprox: "⪺",
  succneqq: "⪶",
  succnsim: "⋩",
  succsim: "≿",
  sum: "∑",
  sung: "♪",
  sup1: "¹",
  sup2: "²",
  sup3: "³",
  sup: "⊃",
  supE: "⫆",
  supdot: "⪾",
  supdsub: "⫘",
  supe: "⊇",
  supedot: "⫄",
  suphsol: "⟉",
  suphsub: "⫗",
  suplarr: "⥻",
  supmult: "⫂",
  supnE: "⫌",
  supne: "⊋",
  supplus: "⫀",
  supset: "⊃",
  supseteq: "⊇",
  supseteqq: "⫆",
  supsetneq: "⊋",
  supsetneqq: "⫌",
  supsim: "⫈",
  supsub: "⫔",
  supsup: "⫖",
  swArr: "⇙",
  swarhk: "⤦",
  swarr: "↙",
  swarrow: "↙",
  swnwar: "⤪",
  szlig: "ß",
  target: "⌖",
  tau: "τ",
  tbrk: "⎴",
  tcaron: "ť",
  tcedil: "ţ",
  tcy: "т",
  tdot: "⃛",
  telrec: "⌕",
  tfr: "𝔱",
  there4: "∴",
  therefore: "∴",
  theta: "θ",
  thetasym: "ϑ",
  thetav: "ϑ",
  thickapprox: "≈",
  thicksim: "∼",
  thinsp: " ",
  thkap: "≈",
  thksim: "∼",
  thorn: "þ",
  tilde: "˜",
  times: "×",
  timesb: "⊠",
  timesbar: "⨱",
  timesd: "⨰",
  tint: "∭",
  toea: "⤨",
  top: "⊤",
  topbot: "⌶",
  topcir: "⫱",
  topf: "𝕥",
  topfork: "⫚",
  tosa: "⤩",
  tprime: "‴",
  trade: "™",
  triangle: "▵",
  triangledown: "▿",
  triangleleft: "◃",
  trianglelefteq: "⊴",
  triangleq: "≜",
  triangleright: "▹",
  trianglerighteq: "⊵",
  tridot: "◬",
  trie: "≜",
  triminus: "⨺",
  triplus: "⨹",
  trisb: "⧍",
  tritime: "⨻",
  trpezium: "⏢",
  tscr: "𝓉",
  tscy: "ц",
  tshcy: "ћ",
  tstrok: "ŧ",
  twixt: "≬",
  twoheadleftarrow: "↞",
  twoheadrightarrow: "↠",
  uArr: "⇑",
  uHar: "⥣",
  uacute: "ú",
  uarr: "↑",
  ubrcy: "ў",
  ubreve: "ŭ",
  ucirc: "û",
  ucy: "у",
  udarr: "⇅",
  udblac: "ű",
  udhar: "⥮",
  ufisht: "⥾",
  ufr: "𝔲",
  ugrave: "ù",
  uharl: "↿",
  uharr: "↾",
  uhblk: "▀",
  ulcorn: "⌜",
  ulcorner: "⌜",
  ulcrop: "⌏",
  ultri: "◸",
  umacr: "ū",
  uml: "¨",
  uogon: "ų",
  uopf: "𝕦",
  uparrow: "↑",
  updownarrow: "↕",
  upharpoonleft: "↿",
  upharpoonright: "↾",
  uplus: "⊎",
  upsi: "υ",
  upsih: "ϒ",
  upsilon: "υ",
  upuparrows: "⇈",
  urcorn: "⌝",
  urcorner: "⌝",
  urcrop: "⌎",
  uring: "ů",
  urtri: "◹",
  uscr: "𝓊",
  utdot: "⋰",
  utilde: "ũ",
  utri: "▵",
  utrif: "▴",
  uuarr: "⇈",
  uuml: "ü",
  uwangle: "⦧",
  vArr: "⇕",
  vBar: "⫨",
  vBarv: "⫩",
  vDash: "⊨",
  vangrt: "⦜",
  varepsilon: "ϵ",
  varkappa: "ϰ",
  varnothing: "∅",
  varphi: "ϕ",
  varpi: "ϖ",
  varpropto: "∝",
  varr: "↕",
  varrho: "ϱ",
  varsigma: "ς",
  varsubsetneq: "⊊︀",
  varsubsetneqq: "⫋︀",
  varsupsetneq: "⊋︀",
  varsupsetneqq: "⫌︀",
  vartheta: "ϑ",
  vartriangleleft: "⊲",
  vartriangleright: "⊳",
  vcy: "в",
  vdash: "⊢",
  vee: "∨",
  veebar: "⊻",
  veeeq: "≚",
  vellip: "⋮",
  verbar: "|",
  vert: "|",
  vfr: "𝔳",
  vltri: "⊲",
  vnsub: "⊂⃒",
  vnsup: "⊃⃒",
  vopf: "𝕧",
  vprop: "∝",
  vrtri: "⊳",
  vscr: "𝓋",
  vsubnE: "⫋︀",
  vsubne: "⊊︀",
  vsupnE: "⫌︀",
  vsupne: "⊋︀",
  vzigzag: "⦚",
  wcirc: "ŵ",
  wedbar: "⩟",
  wedge: "∧",
  wedgeq: "≙",
  weierp: "℘",
  wfr: "𝔴",
  wopf: "𝕨",
  wp: "℘",
  wr: "≀",
  wreath: "≀",
  wscr: "𝓌",
  xcap: "⋂",
  xcirc: "◯",
  xcup: "⋃",
  xdtri: "▽",
  xfr: "𝔵",
  xhArr: "⟺",
  xharr: "⟷",
  xi: "ξ",
  xlArr: "⟸",
  xlarr: "⟵",
  xmap: "⟼",
  xnis: "⋻",
  xodot: "⨀",
  xopf: "𝕩",
  xoplus: "⨁",
  xotime: "⨂",
  xrArr: "⟹",
  xrarr: "⟶",
  xscr: "𝓍",
  xsqcup: "⨆",
  xuplus: "⨄",
  xutri: "△",
  xvee: "⋁",
  xwedge: "⋀",
  yacute: "ý",
  yacy: "я",
  ycirc: "ŷ",
  ycy: "ы",
  yen: "¥",
  yfr: "𝔶",
  yicy: "ї",
  yopf: "𝕪",
  yscr: "𝓎",
  yucy: "ю",
  yuml: "ÿ",
  zacute: "ź",
  zcaron: "ž",
  zcy: "з",
  zdot: "ż",
  zeetrf: "ℨ",
  zeta: "ζ",
  zfr: "𝔷",
  zhcy: "ж",
  zigrarr: "⇝",
  zopf: "𝕫",
  zscr: "𝓏",
  zwj: "‍",
  zwnj: "‌"
};
const own$8 = {}.hasOwnProperty;
function decodeNamedCharacterReference(value) {
  return own$8.call(characterEntities, value) ? characterEntities[value] : false;
}
function decodeNumericCharacterReference(value, base2) {
  const code = Number.parseInt(value, base2);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code < 9 || code === 11 || code > 13 && code < 32 || // Control character (DEL) of C0, and C1 controls.
    code > 126 && code < 160 || // Lone high surrogates and low surrogates.
    code > 55295 && code < 57344 || // Noncharacters.
    code > 64975 && code < 65008 || (code & 65535) === 65535 || (code & 65535) === 65534 || // Out of range
    code > 1114111
  ) {
    return "�";
  }
  return String.fromCharCode(code);
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($02, $12, $22) {
  if ($12) {
    return $12;
  }
  const head2 = $22.charCodeAt(0);
  if (head2 === 35) {
    const head3 = $22.charCodeAt(1);
    const hex = head3 === 120 || head3 === 88;
    return decodeNumericCharacterReference($22.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($22) || $02;
}
function association(node2) {
  if (node2.label || !node2.identifier) {
    return node2.label || "";
  }
  return decodeString(node2.identifier);
}
function compilePattern(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp(
      (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
      "g"
    );
  }
  return pattern._compiled;
}
function containerPhrasing(parent, state, info) {
  const indexStack = state.indexStack;
  const children2 = parent.children || [];
  const results = [];
  let index2 = -1;
  let before = info.before;
  indexStack.push(-1);
  let tracker = state.createTracker(info);
  while (++index2 < children2.length) {
    const child = children2[index2];
    let after;
    indexStack[indexStack.length - 1] = index2;
    if (index2 + 1 < children2.length) {
      let handle2 = state.handle.handlers[children2[index2 + 1].type];
      if (handle2 && handle2.peek)
        handle2 = handle2.peek;
      after = handle2 ? handle2(children2[index2 + 1], parent, state, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after = info.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        " "
      );
      before = " ";
      tracker = state.createTracker(info);
      tracker.move(results.join(""));
    }
    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          ...tracker.current(),
          before,
          after
        })
      )
    );
    before = results[results.length - 1].slice(-1);
  }
  indexStack.pop();
  return results.join("");
}
function containerFlow(parent, state, info) {
  const indexStack = state.indexStack;
  const children2 = parent.children || [];
  const tracker = state.createTracker(info);
  const results = [];
  let index2 = -1;
  indexStack.push(-1);
  while (++index2 < children2.length) {
    const child = children2[index2];
    indexStack[indexStack.length - 1] = index2;
    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          before: "\n",
          after: "\n",
          ...tracker.current()
        })
      )
    );
    if (child.type !== "list") {
      state.bulletLastUsed = void 0;
    }
    if (index2 < children2.length - 1) {
      results.push(
        tracker.move(between(child, children2[index2 + 1], parent, state))
      );
    }
  }
  indexStack.pop();
  return results.join("");
}
function between(left, right, parent, state) {
  let index2 = state.join.length;
  while (index2--) {
    const result = state.join[index2](left, right, parent, state);
    if (result === true || result === 1) {
      break;
    }
    if (typeof result === "number") {
      return "\n".repeat(1 + result);
    }
    if (result === false) {
      return "\n\n<!---->\n\n";
    }
  }
  return "\n\n";
}
const eol = /\r?\n|\r/g;
function indentLines(value, map2) {
  const result = [];
  let start = 0;
  let line = 0;
  let match;
  while (match = eol.exec(value)) {
    one2(value.slice(start, match.index));
    result.push(match[0]);
    start = match.index + match[0].length;
    line++;
  }
  one2(value.slice(start));
  return result.join("");
  function one2(value2) {
    result.push(map2(value2, line, !value2));
  }
}
function safe(state, input, config) {
  const value = (config.before || "") + (input || "") + (config.after || "");
  const positions = [];
  const result = [];
  const infos = {};
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    if (!patternInScope(state.stack, pattern)) {
      continue;
    }
    const expression = state.compilePattern(pattern);
    let match;
    while (match = expression.exec(value)) {
      const before = "before" in pattern || Boolean(pattern.atBreak);
      const after = "after" in pattern;
      const position2 = match.index + (before ? match[1].length : 0);
      if (positions.includes(position2)) {
        if (infos[position2].before && !before) {
          infos[position2].before = false;
        }
        if (infos[position2].after && !after) {
          infos[position2].after = false;
        }
      } else {
        positions.push(position2);
        infos[position2] = { before, after };
      }
    }
  }
  positions.sort(numerical);
  let start = config.before ? config.before.length : 0;
  const end = value.length - (config.after ? config.after.length : 0);
  index2 = -1;
  while (++index2 < positions.length) {
    const position2 = positions[index2];
    if (position2 < start || position2 >= end) {
      continue;
    }
    if (position2 + 1 < end && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index2 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
      continue;
    }
    if (start !== position2) {
      result.push(escapeBackslashes(value.slice(start, position2), "\\"));
    }
    start = position2;
    if (/[!-/:-@[-`{-~]/.test(value.charAt(position2)) && (!config.encode || !config.encode.includes(value.charAt(position2)))) {
      result.push("\\");
    } else {
      result.push(
        "&#x" + value.charCodeAt(position2).toString(16).toUpperCase() + ";"
      );
      start++;
    }
  }
  result.push(escapeBackslashes(value.slice(start, end), config.after));
  return result.join("");
}
function numerical(a3, b10) {
  return a3 - b10;
}
function escapeBackslashes(value, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value + after;
  let index2 = -1;
  let start = 0;
  let match;
  while (match = expression.exec(whole)) {
    positions.push(match.index);
  }
  while (++index2 < positions.length) {
    if (start !== positions[index2]) {
      results.push(value.slice(start, positions[index2]));
    }
    results.push("\\");
    start = positions[index2];
  }
  results.push(value.slice(start));
  return results.join("");
}
function track(config) {
  const options = config || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;
  return { move, current, shift: shift2 };
  function current() {
    return { now: { line, column }, lineShift };
  }
  function shift2(value) {
    lineShift += value;
  }
  function move(input) {
    const value = input || "";
    const chunks = value.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value;
  }
}
function toMarkdown(tree, options = {}) {
  const state = {
    enter,
    indentLines,
    associationId: association,
    containerPhrasing: containerPhrasingBound,
    containerFlow: containerFlowBound,
    createTracker: track,
    compilePattern,
    safe: safeBound,
    stack: [],
    unsafe: [...unsafe],
    join: [...join$1],
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...handle },
    options: {},
    indexStack: [],
    // @ts-expect-error: add `handle` in a second.
    handle: void 0
  };
  configure$1(state, options);
  if (state.options.tightDefinitions) {
    state.join.push(joinDefinition);
  }
  state.handle = zwitch$1("type", {
    invalid: invalid$1,
    unknown: unknown$1,
    handlers: state.handlers
  });
  let result = state.handle(tree, void 0, state, {
    before: "\n",
    after: "\n",
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
    result += "\n";
  }
  return result;
  function enter(name2) {
    state.stack.push(name2);
    return exit2;
    function exit2() {
      state.stack.pop();
    }
  }
}
function invalid$1(value) {
  throw new Error("Cannot handle value `" + value + "`, expected node");
}
function unknown$1(value) {
  const node2 = (
    /** @type {Nodes} */
    value
  );
  throw new Error("Cannot handle unknown node `" + node2.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}
function containerPhrasingBound(parent, info) {
  return containerPhrasing(parent, this, info);
}
function containerFlowBound(parent, info) {
  return containerFlow(parent, this, info);
}
function safeBound(value, config) {
  return safe(this, value, config);
}
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit$1,
      tableHeader: exit$1,
      tableRow: exit$1
    }
  };
}
function enterTable(token) {
  const align = token._align;
  this.enter(
    {
      type: "table",
      align: align.map(function(d3) {
        return d3 === "none" ? null : d3;
      }),
      children: []
    },
    token
  );
  this.data.inTable = true;
}
function exitTable(token) {
  this.exit(token);
  this.data.inTable = void 0;
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit$1(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace);
  }
  const node2 = this.stack[this.stack.length - 1];
  ok$3(node2.type === "inlineCode");
  node2.value = value;
  this.exit(token);
}
function replace($02, $12) {
  return $12 === "|" ? $12 : $02;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding2 = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding2 ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node2, _10, state, info) {
    return serializeData(handleTableAsData(node2, state, info), node2.align);
  }
  function handleTableRow(node2, _10, state, info) {
    const row2 = handleTableRowAsData(node2, state, info);
    const value = serializeData([row2]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node2, _10, state, info) {
    const exit2 = state.enter("tableCell");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, {
      ...info,
      before: around,
      after: around
    });
    subexit();
    exit2();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: padding2,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node2, state, info) {
    const children2 = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("table");
    while (++index2 < children2.length) {
      result[index2] = handleTableRowAsData(children2[index2], state, info);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, state, info) {
    const children2 = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("tableRow");
    while (++index2 < children2.length) {
      result[index2] = handleTableCell(children2[index2], node2, state, info);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, state) {
    let value = handle.inlineCode(node2, parent, state);
    if (state.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token) {
  const node2 = this.stack[this.stack.length - 2];
  ok$3(node2.type === "listItem");
  node2.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    ok$3(node2.type === "paragraph");
    const head2 = node2.children[0];
    if (head2 && head2.type === "text") {
      const siblings2 = parent.children;
      let index2 = -1;
      let firstParaghraph;
      while (++index2 < siblings2.length) {
        const sibling = siblings2[index2];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head2.value = head2.value.slice(1);
        if (head2.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head2.position && typeof head2.position.start.offset === "number") {
          head2.position.start.column++;
          head2.position.start.offset++;
          node2.position.start = Object.assign({}, head2.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node2, parent, state, info) {
  const head2 = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head2 && head2.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = state.createTracker(info);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = handle.listItem(node2, parent, state, {
    ...info,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($02) {
    return $02 + checkbox;
  }
}
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown()
    ]
  };
}
function splice$1(list2, start, remove2, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove2 = remove2 > 0 ? remove2 : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove2);
    list2.splice(...parameters);
  } else {
    if (remove2)
      list2.splice(start, remove2);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list2.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push$1(list2, items) {
  if (list2.length > 0) {
    splice$1(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code;
    if (right) {
      for (code in right) {
        if (!hasOwnProperty.call(left, code))
          left[code] = [];
        const value = right[code];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice$1(existing, 0, 0, before);
}
const wwwPrefix$1 = {
  tokenize: tokenizeWwwPrefix$1,
  partial: true
};
const domain$1 = {
  tokenize: tokenizeDomain$1,
  partial: true
};
const path$2 = {
  tokenize: tokenizePath$1,
  partial: true
};
const trail$1 = {
  tokenize: tokenizeTrail$1,
  partial: true
};
const emailDomainDotTrail$1 = {
  tokenize: tokenizeEmailDomainDotTrail$1,
  partial: true
};
const wwwAutolink$1 = {
  tokenize: tokenizeWwwAutolink$1,
  previous: previousWww$1
};
const protocolAutolink$1 = {
  tokenize: tokenizeProtocolAutolink$1,
  previous: previousProtocol$1
};
const emailAutolink$1 = {
  tokenize: tokenizeEmailAutolink$1,
  previous: previousEmail$1
};
const text$4 = {};
function gfmAutolinkLiteral() {
  return {
    text: text$4
  };
}
let code$3 = 48;
while (code$3 < 123) {
  text$4[code$3] = emailAutolink$1;
  code$3++;
  if (code$3 === 58)
    code$3 = 65;
  else if (code$3 === 91)
    code$3 = 97;
}
text$4[43] = emailAutolink$1;
text$4[45] = emailAutolink$1;
text$4[46] = emailAutolink$1;
text$4[95] = emailAutolink$1;
text$4[72] = [emailAutolink$1, protocolAutolink$1];
text$4[104] = [emailAutolink$1, protocolAutolink$1];
text$4[87] = [emailAutolink$1, wwwAutolink$1];
text$4[119] = [emailAutolink$1, wwwAutolink$1];
function tokenizeEmailAutolink$1(effects, ok2, nok) {
  const self2 = this;
  let dot;
  let data;
  return start;
  function start(code) {
    if (!gfmAtext$1(code) || !previousEmail$1.call(self2, self2.previous) || previousUnbalanced$1(self2.events)) {
      return nok(code);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code);
  }
  function atext(code) {
    if (gfmAtext$1(code)) {
      effects.consume(code);
      return atext;
    }
    if (code === 64) {
      effects.consume(code);
      return emailDomain;
    }
    return nok(code);
  }
  function emailDomain(code) {
    if (code === 46) {
      return effects.check(
        emailDomainDotTrail$1,
        emailDomainAfter,
        emailDomainDot
      )(code);
    }
    if (code === 45 || code === 95 || asciiAlphanumeric$1(code)) {
      data = true;
      effects.consume(code);
      return emailDomain;
    }
    return emailDomainAfter(code);
  }
  function emailDomainDot(code) {
    effects.consume(code);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code) {
    if (data && dot && asciiAlpha$1(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok2(code);
    }
    return nok(code);
  }
}
function tokenizeWwwAutolink$1(effects, ok2, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code) {
    if (code !== 87 && code !== 119 || !previousWww$1.call(self2, self2.previous) || previousUnbalanced$1(self2.events)) {
      return nok(code);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(
      wwwPrefix$1,
      effects.attempt(domain$1, effects.attempt(path$2, wwwAfter), nok),
      nok
    )(code);
  }
  function wwwAfter(code) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok2(code);
  }
}
function tokenizeProtocolAutolink$1(effects, ok2, nok) {
  const self2 = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code) {
    if ((code === 72 || code === 104) && previousProtocol$1.call(self2, self2.previous) && !previousUnbalanced$1(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code);
      effects.consume(code);
      return protocolPrefixInside;
    }
    return nok(code);
  }
  function protocolPrefixInside(code) {
    if (asciiAlpha$1(code) && buffer.length < 5) {
      buffer += String.fromCodePoint(code);
      effects.consume(code);
      return protocolPrefixInside;
    }
    if (code === 58) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code);
        return protocolSlashesInside;
      }
    }
    return nok(code);
  }
  function protocolSlashesInside(code) {
    if (code === 47) {
      effects.consume(code);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code);
  }
  function afterProtocol(code) {
    return code === null || asciiControl$1(code) || markdownLineEndingOrSpace$1(code) || unicodeWhitespace$1(code) || unicodePunctuation$1(code) ? nok(code) : effects.attempt(domain$1, effects.attempt(path$2, protocolAfter), nok)(code);
  }
  function protocolAfter(code) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok2(code);
  }
}
function tokenizeWwwPrefix$1(effects, ok2, nok) {
  let size = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code) {
    if ((code === 87 || code === 119) && size < 3) {
      size++;
      effects.consume(code);
      return wwwPrefixInside;
    }
    if (code === 46 && size === 3) {
      effects.consume(code);
      return wwwPrefixAfter;
    }
    return nok(code);
  }
  function wwwPrefixAfter(code) {
    return code === null ? nok(code) : ok2(code);
  }
}
function tokenizeDomain$1(effects, ok2, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code) {
    if (code === 46 || code === 95) {
      return effects.check(trail$1, domainAfter, domainAtPunctuation)(code);
    }
    if (code === null || markdownLineEndingOrSpace$1(code) || unicodeWhitespace$1(code) || code !== 45 && unicodePunctuation$1(code)) {
      return domainAfter(code);
    }
    seen = true;
    effects.consume(code);
    return domainInside;
  }
  function domainAtPunctuation(code) {
    if (code === 95) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code);
    return domainInside;
  }
  function domainAfter(code) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code);
    }
    return ok2(code);
  }
}
function tokenizePath$1(effects, ok2) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code) {
    if (code === 40) {
      sizeOpen++;
      effects.consume(code);
      return pathInside;
    }
    if (code === 41 && sizeClose < sizeOpen) {
      return pathAtPunctuation(code);
    }
    if (code === 33 || code === 34 || code === 38 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 93 || code === 95 || code === 126) {
      return effects.check(trail$1, ok2, pathAtPunctuation)(code);
    }
    if (code === null || markdownLineEndingOrSpace$1(code) || unicodeWhitespace$1(code)) {
      return ok2(code);
    }
    effects.consume(code);
    return pathInside;
  }
  function pathAtPunctuation(code) {
    if (code === 41) {
      sizeClose++;
    }
    effects.consume(code);
    return pathInside;
  }
}
function tokenizeTrail$1(effects, ok2, nok) {
  return trail2;
  function trail2(code) {
    if (code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 63 || code === 95 || code === 126) {
      effects.consume(code);
      return trail2;
    }
    if (code === 38) {
      effects.consume(code);
      return trailCharRefStart;
    }
    if (code === 93) {
      effects.consume(code);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code === 60 || // So is whitespace.
      code === null || markdownLineEndingOrSpace$1(code) || unicodeWhitespace$1(code)
    ) {
      return ok2(code);
    }
    return nok(code);
  }
  function trailBracketAfter(code) {
    if (code === null || code === 40 || code === 91 || markdownLineEndingOrSpace$1(code) || unicodeWhitespace$1(code)) {
      return ok2(code);
    }
    return trail2(code);
  }
  function trailCharRefStart(code) {
    return asciiAlpha$1(code) ? trailCharRefInside(code) : nok(code);
  }
  function trailCharRefInside(code) {
    if (code === 59) {
      effects.consume(code);
      return trail2;
    }
    if (asciiAlpha$1(code)) {
      effects.consume(code);
      return trailCharRefInside;
    }
    return nok(code);
  }
}
function tokenizeEmailDomainDotTrail$1(effects, ok2, nok) {
  return start;
  function start(code) {
    effects.consume(code);
    return after;
  }
  function after(code) {
    return asciiAlphanumeric$1(code) ? nok(code) : ok2(code);
  }
}
function previousWww$1(code) {
  return code === null || code === 40 || code === 42 || code === 95 || code === 91 || code === 93 || code === 126 || markdownLineEndingOrSpace$1(code);
}
function previousProtocol$1(code) {
  return !asciiAlpha$1(code);
}
function previousEmail$1(code) {
  return !(code === 47 || gfmAtext$1(code));
}
function gfmAtext$1(code) {
  return code === 43 || code === 45 || code === 46 || code === 95 || asciiAlphanumeric$1(code);
}
function previousUnbalanced$1(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token = events[index2][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code = value.charCodeAt(index2);
    let replace2 = "";
    if (code === 37 && asciiAlphanumeric$1(value.charCodeAt(index2 + 1)) && asciiAlphanumeric$1(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {
        replace2 = String.fromCharCode(code);
      }
    } else if (code > 55295 && code < 57344) {
      const next = value.charCodeAt(index2 + 1);
      if (code < 56320 && next > 56319 && next < 57344) {
        replace2 = String.fromCharCode(code, next);
        skip = 1;
      } else {
        replace2 = "�";
      }
    } else {
      replace2 = String.fromCharCode(code);
    }
    if (replace2) {
      result.push(value.slice(start, index2), encodeURIComponent(replace2));
      start = index2 + skip + 1;
      replace2 = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start);
}
function classifyCharacter(code) {
  if (code === null || markdownLineEndingOrSpace$1(code) || unicodeWhitespace$1(code)) {
    return 1;
  }
  if (unicodePunctuation$1(code)) {
    return 2;
  }
}
function resolveAll$1(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}
const attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text2;
  let openingSequence;
  let closingSequence;
  let use2;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use2 = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start, -use2);
          movePoint(end, use2);
          openingSequence = {
            type: use2 > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use2 > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text2 = {
            type: use2 > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use2 > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push$1(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push$1(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text2, context]
          ]);
          nextEvents = push$1(
            nextEvents,
            resolveAll$1(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context
            )
          );
          nextEvents = push$1(nextEvents, [
            ["exit", text2, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push$1(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice$1(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start;
  function start(code) {
    marker = code;
    effects.enter("attentionSequence");
    return inside2(code);
  }
  function inside2(code) {
    if (code === marker) {
      effects.consume(code);
      return inside2;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
    token._open = Boolean(marker === 42 ? open : open && (before || !close));
    token._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok2(code);
  }
}
function movePoint(point2, offset) {
  point2.column += offset;
  point2.offset += offset;
  point2._bufferIndex += offset;
}
const autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code) {
    if (asciiAlpha$1(code)) {
      effects.consume(code);
      return schemeOrEmailAtext;
    }
    return emailAtext(code);
  }
  function schemeOrEmailAtext(code) {
    if (code === 43 || code === 45 || code === 46 || asciiAlphanumeric$1(code)) {
      size = 1;
      return schemeInsideOrEmailAtext(code);
    }
    return emailAtext(code);
  }
  function schemeInsideOrEmailAtext(code) {
    if (code === 58) {
      effects.consume(code);
      size = 0;
      return urlInside;
    }
    if ((code === 43 || code === 45 || code === 46 || asciiAlphanumeric$1(code)) && size++ < 32) {
      effects.consume(code);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code);
  }
  function urlInside(code) {
    if (code === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    if (code === null || code === 32 || code === 60 || asciiControl$1(code)) {
      return nok(code);
    }
    effects.consume(code);
    return urlInside;
  }
  function emailAtext(code) {
    if (code === 64) {
      effects.consume(code);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code)) {
      effects.consume(code);
      return emailAtext;
    }
    return nok(code);
  }
  function emailAtSignOrDot(code) {
    return asciiAlphanumeric$1(code) ? emailLabel(code) : nok(code);
  }
  function emailLabel(code) {
    if (code === 46) {
      effects.consume(code);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    return emailValue(code);
  }
  function emailValue(code) {
    if ((code === 45 || asciiAlphanumeric$1(code)) && size++ < 63) {
      const next = code === 45 ? emailValue : emailLabel;
      effects.consume(code);
      return next;
    }
    return nok(code);
  }
}
function factorySpace$1(effects, ok2, type, max2) {
  const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code) {
    if (markdownSpace$1(code)) {
      effects.enter(type);
      return prefix(code);
    }
    return ok2(code);
  }
  function prefix(code) {
    if (markdownSpace$1(code) && size++ < limit) {
      effects.consume(code);
      return prefix;
    }
    effects.exit(type);
    return ok2(code);
  }
}
const blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return start;
  function start(code) {
    return markdownSpace$1(code) ? factorySpace$1(effects, after, "linePrefix")(code) : after(code);
  }
  function after(code) {
    return code === null || markdownLineEnding$1(code) ? ok2(code) : nok(code);
  }
}
const blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    if (code === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code);
  }
  function after(code) {
    if (markdownSpace$1(code)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  const self2 = this;
  return contStart;
  function contStart(code) {
    if (markdownSpace$1(code)) {
      return factorySpace$1(
        effects,
        contBefore,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code);
    }
    return contBefore(code);
  }
  function contBefore(code) {
    return effects.attempt(blockQuote, ok2, nok)(code);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code);
    effects.exit("escapeMarker");
    return inside2;
  }
  function inside2(code) {
    if (asciiPunctuation$1(code)) {
      effects.enter("characterEscapeValue");
      effects.consume(code);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code);
  }
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let max2;
  let test;
  return start;
  function start(code) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code) {
    if (code === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max2 = 31;
    test = asciiAlphanumeric$1;
    return value(code);
  }
  function numeric(code) {
    if (code === 88 || code === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max2 = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max2 = 7;
    test = asciiDigit;
    return value(code);
  }
  function value(code) {
    if (code === 59 && size) {
      const token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric$1 && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code) && size++ < max2) {
      effects.consume(code);
      return value;
    }
    return nok(code);
  }
}
const nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
const codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this;
  const closeStart = {
    tokenize: tokenizeCloseStart,
    partial: true
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code) {
    return beforeSequenceOpen(code);
  }
  function beforeSequenceOpen(code) {
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === marker) {
      sizeOpen++;
      effects.consume(code);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace$1(code) ? factorySpace$1(effects, infoBefore, "whitespace")(code) : infoBefore(code);
  }
  function infoBefore(code) {
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("codeFencedFence");
      return self2.interrupt ? ok2(code) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code);
  }
  function info(code) {
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code);
    }
    if (markdownSpace$1(code)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace$1(effects, metaBefore, "whitespace")(code);
    }
    if (code === 96 && code === marker) {
      return nok(code);
    }
    effects.consume(code);
    return info;
  }
  function metaBefore(code) {
    if (code === null || markdownLineEnding$1(code)) {
      return infoBefore(code);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta2(code);
  }
  function meta2(code) {
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code);
    }
    if (code === 96 && code === marker) {
      return nok(code);
    }
    effects.consume(code);
    return meta2;
  }
  function atNonLazyBreak(code) {
    return effects.attempt(closeStart, after, contentBefore)(code);
  }
  function contentBefore(code) {
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code) {
    return initialPrefix > 0 && markdownSpace$1(code) ? factorySpace$1(
      effects,
      beforeContentChunk,
      "linePrefix",
      initialPrefix + 1
    )(code) : beforeContentChunk(code);
  }
  function beforeContentChunk(code) {
    if (code === null || markdownLineEnding$1(code)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code);
  }
  function contentChunk(code) {
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code);
    }
    effects.consume(code);
    return contentChunk;
  }
  function after(code) {
    effects.exit("codeFenced");
    return ok2(code);
  }
  function tokenizeCloseStart(effects2, ok3, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code) {
      effects2.enter("lineEnding");
      effects2.consume(code);
      effects2.exit("lineEnding");
      return start2;
    }
    function start2(code) {
      effects2.enter("codeFencedFence");
      return markdownSpace$1(code) ? factorySpace$1(
        effects2,
        beforeSequenceClose,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code) : beforeSequenceClose(code);
    }
    function beforeSequenceClose(code) {
      if (code === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code);
      }
      return nok2(code);
    }
    function sequenceClose(code) {
      if (code === marker) {
        size++;
        effects2.consume(code);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace$1(code) ? factorySpace$1(effects2, sequenceCloseAfter, "whitespace")(code) : sequenceCloseAfter(code);
      }
      return nok2(code);
    }
    function sequenceCloseAfter(code) {
      if (code === null || markdownLineEnding$1(code)) {
        effects2.exit("codeFencedFence");
        return ok3(code);
      }
      return nok2(code);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    if (code === null) {
      return nok(code);
    }
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code) {
    return self2.parser.lazy[self2.now().line] ? nok(code) : ok2(code);
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
const furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    effects.enter("codeIndented");
    return factorySpace$1(effects, afterPrefix, "linePrefix", 4 + 1)(code);
  }
  function afterPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code) : nok(code);
  }
  function atBreak(code) {
    if (code === null) {
      return after(code);
    }
    if (markdownLineEnding$1(code)) {
      return effects.attempt(furtherStart, atBreak, after)(code);
    }
    effects.enter("codeFlowValue");
    return inside2(code);
  }
  function inside2(code) {
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("codeFlowValue");
      return atBreak(code);
    }
    effects.consume(code);
    return inside2;
  }
  function after(code) {
    effects.exit("codeIndented");
    return ok2(code);
  }
}
function tokenizeFurtherStart(effects, ok2, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code);
    }
    if (markdownLineEnding$1(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace$1(effects, afterPrefix, "linePrefix", 4 + 1)(code);
  }
  function afterPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code) : markdownLineEnding$1(code) ? furtherStart2(code) : nok(code);
  }
}
const codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code) {
  return code !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === 96) {
      effects.consume(code);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between2(code);
  }
  function between2(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 32) {
      effects.enter("space");
      effects.consume(code);
      effects.exit("space");
      return between2;
    }
    if (code === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return sequenceClose(code);
    }
    if (markdownLineEnding$1(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return between2;
    }
    effects.enter("codeTextData");
    return data(code);
  }
  function data(code) {
    if (code === null || code === 32 || code === 96 || markdownLineEnding$1(code)) {
      effects.exit("codeTextData");
      return between2(code);
    }
    effects.consume(code);
    return data;
  }
  function sequenceClose(code) {
    if (code === 96) {
      effects.consume(code);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code);
    }
    token.type = "codeTextData";
    return data(code);
  }
}
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice$1(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.unshift([start2, start2 + slice.length - 1]);
    splice$1(events, start2, 2, slice);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}
const content$4 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
const continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return chunkStart;
  function chunkStart(code) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code);
  }
  function chunkInside(code) {
    if (code === null) {
      return contentEnd(code);
    }
    if (markdownLineEnding$1(code)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code);
    }
    effects.consume(code);
    return chunkInside;
  }
  function contentEnd(code) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code);
  }
  function contentContinue(code) {
    effects.consume(code);
    effects.exit("chunkContent");
    previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace$1(effects, prefixed, "linePrefix");
  }
  function prefixed(code) {
    if (code === null || markdownLineEnding$1(code)) {
      return nok(code);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code);
  }
}
function factoryDestination$1(effects, ok2, nok, type, literalType2, literalMarkerType, rawType, stringType2, max2) {
  const limit = max2 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code) {
    if (code === 60) {
      effects.enter(type);
      effects.enter(literalType2);
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code === null || code === 32 || code === 41 || asciiControl$1(code)) {
      return nok(code);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType2);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw2(code);
  }
  function enclosedBefore(code) {
    if (code === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      effects.exit(literalType2);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType2);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code);
  }
  function enclosed(code) {
    if (code === 62) {
      effects.exit("chunkString");
      effects.exit(stringType2);
      return enclosedBefore(code);
    }
    if (code === null || code === 60 || markdownLineEnding$1(code)) {
      return nok(code);
    }
    effects.consume(code);
    return code === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code) {
    if (code === 60 || code === 62 || code === 92) {
      effects.consume(code);
      return enclosed;
    }
    return enclosed(code);
  }
  function raw2(code) {
    if (!balance && (code === null || code === 41 || markdownLineEndingOrSpace$1(code))) {
      effects.exit("chunkString");
      effects.exit(stringType2);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code);
    }
    if (balance < limit && code === 40) {
      effects.consume(code);
      balance++;
      return raw2;
    }
    if (code === 41) {
      effects.consume(code);
      balance--;
      return raw2;
    }
    if (code === null || code === 32 || code === 40 || asciiControl$1(code)) {
      return nok(code);
    }
    effects.consume(code);
    return code === 92 ? rawEscape : raw2;
  }
  function rawEscape(code) {
    if (code === 40 || code === 41 || code === 92) {
      effects.consume(code);
      return raw2;
    }
    return raw2(code);
  }
}
function factoryLabel$1(effects, ok2, nok, type, markerType, stringType2) {
  const self2 = this;
  let size = 0;
  let seen;
  return start;
  function start(code) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    effects.enter(stringType2);
    return atBreak;
  }
  function atBreak(code) {
    if (size > 999 || code === null || code === 91 || code === 93 && !seen || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code);
    }
    if (code === 93) {
      effects.exit(stringType2);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding$1(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code);
  }
  function labelInside(code) {
    if (code === null || code === 91 || code === 93 || markdownLineEnding$1(code) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code);
    }
    effects.consume(code);
    if (!seen)
      seen = !markdownSpace$1(code);
    return code === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size++;
      return labelInside;
    }
    return labelInside(code);
  }
}
function factoryTitle$1(effects, ok2, nok, type, markerType, stringType2) {
  let marker;
  return start;
  function start(code) {
    if (code === 34 || code === 39 || code === 40) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      marker = code === 40 ? 41 : code;
      return begin;
    }
    return nok(code);
  }
  function begin(code) {
    if (code === marker) {
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType2);
    return atBreak(code);
  }
  function atBreak(code) {
    if (code === marker) {
      effects.exit(stringType2);
      return begin(marker);
    }
    if (code === null) {
      return nok(code);
    }
    if (markdownLineEnding$1(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return factorySpace$1(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside2(code);
  }
  function inside2(code) {
    if (code === marker || code === null || markdownLineEnding$1(code)) {
      effects.exit("chunkString");
      return atBreak(code);
    }
    effects.consume(code);
    return code === 92 ? escape2 : inside2;
  }
  function escape2(code) {
    if (code === marker || code === 92) {
      effects.consume(code);
      return inside2;
    }
    return inside2(code);
  }
}
function factoryWhitespace$1(effects, ok2) {
  let seen;
  return start;
  function start(code) {
    if (markdownLineEnding$1(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace$1(code)) {
      return factorySpace$1(
        effects,
        start,
        seen ? "linePrefix" : "lineSuffix"
      )(code);
    }
    return ok2(code);
  }
}
const definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
const titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier2;
  return start;
  function start(code) {
    effects.enter("definition");
    return before(code);
  }
  function before(code) {
    return factoryLabel$1.call(
      self2,
      effects,
      labelAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code);
  }
  function labelAfter(code) {
    identifier2 = normalizeIdentifier$1(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code === 58) {
      effects.enter("definitionMarker");
      effects.consume(code);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code);
  }
  function markerAfter(code) {
    return markdownLineEndingOrSpace$1(code) ? factoryWhitespace$1(effects, destinationBefore)(code) : destinationBefore(code);
  }
  function destinationBefore(code) {
    return factoryDestination$1(
      effects,
      destinationAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(code);
  }
  function destinationAfter(code) {
    return effects.attempt(titleBefore, after, after)(code);
  }
  function after(code) {
    return markdownSpace$1(code) ? factorySpace$1(effects, afterWhitespace, "whitespace")(code) : afterWhitespace(code);
  }
  function afterWhitespace(code) {
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("definition");
      self2.parser.defined.push(identifier2);
      return ok2(code);
    }
    return nok(code);
  }
}
function tokenizeTitleBefore(effects, ok2, nok) {
  return titleBefore2;
  function titleBefore2(code) {
    return markdownLineEndingOrSpace$1(code) ? factoryWhitespace$1(effects, beforeMarker)(code) : nok(code);
  }
  function beforeMarker(code) {
    return factoryTitle$1(
      effects,
      titleAfter,
      nok,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(code);
  }
  function titleAfter(code) {
    return markdownSpace$1(code) ? factorySpace$1(effects, titleAfterOptionalWhitespace, "whitespace")(code) : titleAfterOptionalWhitespace(code);
  }
  function titleAfterOptionalWhitespace(code) {
    return code === null || markdownLineEnding$1(code) ? ok2(code) : nok(code);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code) {
    effects.enter("hardBreakEscape");
    effects.consume(code);
    return after;
  }
  function after(code) {
    if (markdownLineEnding$1(code)) {
      effects.exit("hardBreakEscape");
      return ok2(code);
    }
    return nok(code);
  }
}
const headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content2;
  let text2;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content2 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text2 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice$1(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content2, context],
      ["enter", text2, context],
      ["exit", text2, context],
      ["exit", content2, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code) {
    effects.enter("atxHeading");
    return before(code);
  }
  function before(code) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === 35 && size++ < 6) {
      effects.consume(code);
      return sequenceOpen;
    }
    if (code === null || markdownLineEndingOrSpace$1(code)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code);
    }
    return nok(code);
  }
  function atBreak(code) {
    if (code === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code);
    }
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("atxHeading");
      return ok2(code);
    }
    if (markdownSpace$1(code)) {
      return factorySpace$1(effects, atBreak, "whitespace")(code);
    }
    effects.enter("atxHeadingText");
    return data(code);
  }
  function sequenceFurther(code) {
    if (code === 35) {
      effects.consume(code);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code);
  }
  function data(code) {
    if (code === null || code === 35 || markdownLineEndingOrSpace$1(code)) {
      effects.exit("atxHeadingText");
      return atBreak(code);
    }
    effects.consume(code);
    return data;
  }
}
const htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
const htmlRawNames = ["pre", "script", "style", "textarea"];
const htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
const blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: true
};
const nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index2;
  let markerB;
  return start;
  function start(code) {
    return before(code);
  }
  function before(code) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code);
    return open;
  }
  function open(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationOpen;
    }
    if (code === 47) {
      effects.consume(code);
      closingTag = true;
      return tagCloseStart;
    }
    if (code === 63) {
      effects.consume(code);
      marker = 3;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha$1(code)) {
      effects.consume(code);
      buffer = String.fromCharCode(code);
      return tagName;
    }
    return nok(code);
  }
  function declarationOpen(code) {
    if (code === 45) {
      effects.consume(code);
      marker = 2;
      return commentOpenInside;
    }
    if (code === 91) {
      effects.consume(code);
      marker = 5;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha$1(code)) {
      effects.consume(code);
      marker = 4;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code);
  }
  function commentOpenInside(code) {
    if (code === 45) {
      effects.consume(code);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code);
  }
  function cdataOpenInside(code) {
    const value = "CDATA[";
    if (code === value.charCodeAt(index2++)) {
      effects.consume(code);
      if (index2 === value.length) {
        return self2.interrupt ? ok2 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code);
  }
  function tagCloseStart(code) {
    if (asciiAlpha$1(code)) {
      effects.consume(code);
      buffer = String.fromCharCode(code);
      return tagName;
    }
    return nok(code);
  }
  function tagName(code) {
    if (code === null || code === 47 || code === 62 || markdownLineEndingOrSpace$1(code)) {
      const slash = code === 47;
      const name2 = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = 1;
        return self2.interrupt ? ok2(code) : continuation(code);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code) : continuation(code);
      }
      marker = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code) : closingTag ? completeClosingTagAfter(code) : completeAttributeNameBefore(code);
    }
    if (code === 45 || asciiAlphanumeric$1(code)) {
      effects.consume(code);
      buffer += String.fromCharCode(code);
      return tagName;
    }
    return nok(code);
  }
  function basicSelfClosing(code) {
    if (code === 62) {
      effects.consume(code);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code);
  }
  function completeClosingTagAfter(code) {
    if (markdownSpace$1(code)) {
      effects.consume(code);
      return completeClosingTagAfter;
    }
    return completeEnd(code);
  }
  function completeAttributeNameBefore(code) {
    if (code === 47) {
      effects.consume(code);
      return completeEnd;
    }
    if (code === 58 || code === 95 || asciiAlpha$1(code)) {
      effects.consume(code);
      return completeAttributeName;
    }
    if (markdownSpace$1(code)) {
      effects.consume(code);
      return completeAttributeNameBefore;
    }
    return completeEnd(code);
  }
  function completeAttributeName(code) {
    if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric$1(code)) {
      effects.consume(code);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code);
  }
  function completeAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return completeAttributeValueBefore;
    }
    if (markdownSpace$1(code)) {
      effects.consume(code);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code);
  }
  function completeAttributeValueBefore(code) {
    if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
      return nok(code);
    }
    if (code === 34 || code === 39) {
      effects.consume(code);
      markerB = code;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace$1(code)) {
      effects.consume(code);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code);
  }
  function completeAttributeValueQuoted(code) {
    if (code === markerB) {
      effects.consume(code);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code === null || markdownLineEnding$1(code)) {
      return nok(code);
    }
    effects.consume(code);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code) {
    if (code === null || code === 34 || code === 39 || code === 47 || code === 60 || code === 61 || code === 62 || code === 96 || markdownLineEndingOrSpace$1(code)) {
      return completeAttributeNameAfter(code);
    }
    effects.consume(code);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code) {
    if (code === 47 || code === 62 || markdownSpace$1(code)) {
      return completeAttributeNameBefore(code);
    }
    return nok(code);
  }
  function completeEnd(code) {
    if (code === 62) {
      effects.consume(code);
      return completeAfter;
    }
    return nok(code);
  }
  function completeAfter(code) {
    if (code === null || markdownLineEnding$1(code)) {
      return continuation(code);
    }
    if (markdownSpace$1(code)) {
      effects.consume(code);
      return completeAfter;
    }
    return nok(code);
  }
  function continuation(code) {
    if (code === 45 && marker === 2) {
      effects.consume(code);
      return continuationCommentInside;
    }
    if (code === 60 && marker === 1) {
      effects.consume(code);
      return continuationRawTagOpen;
    }
    if (code === 62 && marker === 4) {
      effects.consume(code);
      return continuationClose;
    }
    if (code === 63 && marker === 3) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    if (code === 93 && marker === 5) {
      effects.consume(code);
      return continuationCdataInside;
    }
    if (markdownLineEnding$1(code) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code);
    }
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("htmlFlowData");
      return continuationStart(code);
    }
    effects.consume(code);
    return continuation;
  }
  function continuationStart(code) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code);
  }
  function continuationStartNonLazy(code) {
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code) {
    if (code === null || markdownLineEnding$1(code)) {
      return continuationStart(code);
    }
    effects.enter("htmlFlowData");
    return continuation(code);
  }
  function continuationCommentInside(code) {
    if (code === 45) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationRawTagOpen(code) {
    if (code === 47) {
      effects.consume(code);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code);
  }
  function continuationRawEndTag(code) {
    if (code === 62) {
      const name2 = buffer.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code);
        return continuationClose;
      }
      return continuation(code);
    }
    if (asciiAlpha$1(code) && buffer.length < 8) {
      effects.consume(code);
      buffer += String.fromCharCode(code);
      return continuationRawEndTag;
    }
    return continuation(code);
  }
  function continuationCdataInside(code) {
    if (code === 93) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationDeclarationInside(code) {
    if (code === 62) {
      effects.consume(code);
      return continuationClose;
    }
    if (code === 45 && marker === 2) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationClose(code) {
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code);
    }
    effects.consume(code);
    return continuationClose;
  }
  function continuationAfter(code) {
    effects.exit("htmlFlow");
    return ok2(code);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    if (markdownLineEnding$1(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code);
  }
  function after(code) {
    return self2.parser.lazy[self2.now().line] ? nok(code) : ok2(code);
  }
}
function tokenizeBlankLineBefore(effects, ok2, nok) {
  return start;
  function start(code) {
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return effects.attempt(blankLine, ok2, nok);
  }
}
const htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start;
  function start(code) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code);
    return open;
  }
  function open(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationOpen;
    }
    if (code === 47) {
      effects.consume(code);
      return tagCloseStart;
    }
    if (code === 63) {
      effects.consume(code);
      return instruction;
    }
    if (asciiAlpha$1(code)) {
      effects.consume(code);
      return tagOpen;
    }
    return nok(code);
  }
  function declarationOpen(code) {
    if (code === 45) {
      effects.consume(code);
      return commentOpenInside;
    }
    if (code === 91) {
      effects.consume(code);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha$1(code)) {
      effects.consume(code);
      return declaration;
    }
    return nok(code);
  }
  function commentOpenInside(code) {
    if (code === 45) {
      effects.consume(code);
      return commentEnd;
    }
    return nok(code);
  }
  function comment2(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 45) {
      effects.consume(code);
      return commentClose;
    }
    if (markdownLineEnding$1(code)) {
      returnState = comment2;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return comment2;
  }
  function commentClose(code) {
    if (code === 45) {
      effects.consume(code);
      return commentEnd;
    }
    return comment2(code);
  }
  function commentEnd(code) {
    return code === 62 ? end(code) : code === 45 ? commentClose(code) : comment2(code);
  }
  function cdataOpenInside(code) {
    const value = "CDATA[";
    if (code === value.charCodeAt(index2++)) {
      effects.consume(code);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code);
  }
  function cdata(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 93) {
      effects.consume(code);
      return cdataClose;
    }
    if (markdownLineEnding$1(code)) {
      returnState = cdata;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return cdata;
  }
  function cdataClose(code) {
    if (code === 93) {
      effects.consume(code);
      return cdataEnd;
    }
    return cdata(code);
  }
  function cdataEnd(code) {
    if (code === 62) {
      return end(code);
    }
    if (code === 93) {
      effects.consume(code);
      return cdataEnd;
    }
    return cdata(code);
  }
  function declaration(code) {
    if (code === null || code === 62) {
      return end(code);
    }
    if (markdownLineEnding$1(code)) {
      returnState = declaration;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return declaration;
  }
  function instruction(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 63) {
      effects.consume(code);
      return instructionClose;
    }
    if (markdownLineEnding$1(code)) {
      returnState = instruction;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return instruction;
  }
  function instructionClose(code) {
    return code === 62 ? end(code) : instruction(code);
  }
  function tagCloseStart(code) {
    if (asciiAlpha$1(code)) {
      effects.consume(code);
      return tagClose;
    }
    return nok(code);
  }
  function tagClose(code) {
    if (code === 45 || asciiAlphanumeric$1(code)) {
      effects.consume(code);
      return tagClose;
    }
    return tagCloseBetween(code);
  }
  function tagCloseBetween(code) {
    if (markdownLineEnding$1(code)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code);
    }
    if (markdownSpace$1(code)) {
      effects.consume(code);
      return tagCloseBetween;
    }
    return end(code);
  }
  function tagOpen(code) {
    if (code === 45 || asciiAlphanumeric$1(code)) {
      effects.consume(code);
      return tagOpen;
    }
    if (code === 47 || code === 62 || markdownLineEndingOrSpace$1(code)) {
      return tagOpenBetween(code);
    }
    return nok(code);
  }
  function tagOpenBetween(code) {
    if (code === 47) {
      effects.consume(code);
      return end;
    }
    if (code === 58 || code === 95 || asciiAlpha$1(code)) {
      effects.consume(code);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding$1(code)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code);
    }
    if (markdownSpace$1(code)) {
      effects.consume(code);
      return tagOpenBetween;
    }
    return end(code);
  }
  function tagOpenAttributeName(code) {
    if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric$1(code)) {
      effects.consume(code);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code);
  }
  function tagOpenAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding$1(code)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code);
    }
    if (markdownSpace$1(code)) {
      effects.consume(code);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code);
  }
  function tagOpenAttributeValueBefore(code) {
    if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
      return nok(code);
    }
    if (code === 34 || code === 39) {
      effects.consume(code);
      marker = code;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding$1(code)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code);
    }
    if (markdownSpace$1(code)) {
      effects.consume(code);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code === null) {
      return nok(code);
    }
    if (markdownLineEnding$1(code)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code) {
    if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 96) {
      return nok(code);
    }
    if (code === 47 || code === 62 || markdownLineEndingOrSpace$1(code)) {
      return tagOpenBetween(code);
    }
    effects.consume(code);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code) {
    if (code === 47 || code === 62 || markdownLineEndingOrSpace$1(code)) {
      return tagOpenBetween(code);
    }
    return nok(code);
  }
  function end(code) {
    if (code === 62) {
      effects.consume(code);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code);
  }
  function lineEndingBefore(code) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code) {
    return markdownSpace$1(code) ? factorySpace$1(
      effects,
      lineEndingAfterPrefix,
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code) : lineEndingAfterPrefix(code);
  }
  function lineEndingAfterPrefix(code) {
    effects.enter("htmlTextData");
    return returnState(code);
  }
}
const labelEnd$1 = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd$1,
  resolveTo: resolveToLabelEnd$1,
  resolveAll: resolveAllLabelEnd$1
};
const resourceConstruct$1 = {
  tokenize: tokenizeResource$1
};
const referenceFullConstruct$1 = {
  tokenize: tokenizeReferenceFull$1
};
const referenceCollapsedConstruct$1 = {
  tokenize: tokenizeReferenceCollapsed$1
};
function resolveAllLabelEnd$1(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd$1(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text2 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push$1(media, events.slice(open + 1, open + offset + 3));
  media = push$1(media, [["enter", text2, context]]);
  media = push$1(
    media,
    resolveAll$1(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  );
  media = push$1(media, [
    ["exit", text2, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push$1(media, events.slice(close + 1));
  media = push$1(media, [["exit", group, context]]);
  splice$1(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd$1(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code) {
    if (!labelStart) {
      return nok(code);
    }
    if (labelStart._inactive) {
      return labelEndNok(code);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier$1(
        self2.sliceSerialize({
          start: labelStart.end,
          end: self2.now()
        })
      )
    );
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code) {
    if (code === 40) {
      return effects.attempt(
        resourceConstruct$1,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code);
    }
    if (code === 91) {
      return effects.attempt(
        referenceFullConstruct$1,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code);
    }
    return defined ? labelEndOk(code) : labelEndNok(code);
  }
  function referenceNotFull(code) {
    return effects.attempt(
      referenceCollapsedConstruct$1,
      labelEndOk,
      labelEndNok
    )(code);
  }
  function labelEndOk(code) {
    return ok2(code);
  }
  function labelEndNok(code) {
    labelStart._balanced = true;
    return nok(code);
  }
}
function tokenizeResource$1(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code) {
    return markdownLineEndingOrSpace$1(code) ? factoryWhitespace$1(effects, resourceOpen)(code) : resourceOpen(code);
  }
  function resourceOpen(code) {
    if (code === 41) {
      return resourceEnd(code);
    }
    return factoryDestination$1(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(code);
  }
  function resourceDestinationAfter(code) {
    return markdownLineEndingOrSpace$1(code) ? factoryWhitespace$1(effects, resourceBetween)(code) : resourceEnd(code);
  }
  function resourceDestinationMissing(code) {
    return nok(code);
  }
  function resourceBetween(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle$1(
        effects,
        resourceTitleAfter,
        nok,
        "resourceTitle",
        "resourceTitleMarker",
        "resourceTitleString"
      )(code);
    }
    return resourceEnd(code);
  }
  function resourceTitleAfter(code) {
    return markdownLineEndingOrSpace$1(code) ? factoryWhitespace$1(effects, resourceEnd)(code) : resourceEnd(code);
  }
  function resourceEnd(code) {
    if (code === 41) {
      effects.enter("resourceMarker");
      effects.consume(code);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code);
  }
}
function tokenizeReferenceFull$1(effects, ok2, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code) {
    return factoryLabel$1.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      "reference",
      "referenceMarker",
      "referenceString"
    )(code);
  }
  function referenceFullAfter(code) {
    return self2.parser.defined.includes(
      normalizeIdentifier$1(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok2(code) : nok(code);
  }
  function referenceFullMissing(code) {
    return nok(code);
  }
}
function tokenizeReferenceCollapsed$1(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code) {
    if (code === 93) {
      effects.enter("referenceMarker");
      effects.consume(code);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage$1,
  resolveAll: labelEnd$1.resolveAll
};
function tokenizeLabelStartImage$1(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code) {
    if (code === 91) {
      effects.enter("labelMarker");
      effects.consume(code);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code);
  }
  function after(code) {
    return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok2(code);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink$1,
  resolveAll: labelEnd$1.resolveAll
};
function tokenizeLabelStartLink$1(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code) {
    return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok2(code);
  }
}
const lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code) {
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace$1(effects, ok2, "linePrefix");
  }
}
const thematicBreak$1 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code) {
    effects.enter("thematicBreak");
    return before(code);
  }
  function before(code) {
    marker = code;
    return atBreak(code);
  }
  function atBreak(code) {
    if (code === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code);
    }
    if (size >= 3 && (code === null || markdownLineEnding$1(code))) {
      effects.exit("thematicBreak");
      return ok2(code);
    }
    return nok(code);
  }
  function sequence(code) {
    if (code === marker) {
      effects.consume(code);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace$1(code) ? factorySpace$1(effects, atBreak, "whitespace")(code) : atBreak(code);
  }
}
const list$1 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
const listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
const indentConstruct = {
  tokenize: tokenizeIndent$1,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code) {
    const kind = self2.containerState.type || (code === 42 || code === 43 || code === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code === self2.containerState.marker : asciiDigit(code)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code === 42 || code === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code) : atMarker(code);
      }
      if (!self2.interrupt || code === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside2(code);
      }
    }
    return nok(code);
  }
  function inside2(code) {
    if (asciiDigit(code) && ++size < 10) {
      effects.consume(code);
      return inside2;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code === self2.containerState.marker : code === 41 || code === 46)) {
      effects.exit("listItemValue");
      return atMarker(code);
    }
    return nok(code);
  }
  function atMarker(code) {
    effects.enter("listItemMarker");
    effects.consume(code);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code;
    return effects.check(
      blankLine,
      // Can’t be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code);
  }
  function otherPrefix(code) {
    if (markdownSpace$1(code)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code);
  }
  function endOfPrefix(code) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace$1(
      effects,
      ok2,
      "listItemIndent",
      self2.containerState.size + 1
    )(code);
  }
  function notBlank(code) {
    if (self2.containerState.furtherBlankLines || !markdownSpace$1(code)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code);
  }
  function notInCurrentItem(code) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace$1(
      effects,
      effects.attempt(list$1, ok2, nok),
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code);
  }
}
function tokenizeIndent$1(effects, ok2, nok) {
  const self2 = this;
  return factorySpace$1(
    effects,
    afterPrefix,
    "listItemIndent",
    self2.containerState.size + 1
  );
  function afterPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code) : nok(code);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  return factorySpace$1(
    effects,
    afterPrefix,
    "listItemPrefixWhitespace",
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function afterPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace$1(code) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code) : nok(code);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content2;
  let text2;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content2 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text2 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading2 = {
    type: "setextHeading",
    start: Object.assign({}, events[text2][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text2][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text2, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
    events[content2][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content2][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let marker;
  return start;
  function start(code) {
    let index2 = self2.events.length;
    let paragraph2;
    while (index2--) {
      if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
        paragraph2 = self2.events[index2][1].type === "paragraph";
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      marker = code;
      return before(code);
    }
    return nok(code);
  }
  function before(code) {
    effects.enter("setextHeadingLineSequence");
    return inside2(code);
  }
  function inside2(code) {
    if (code === marker) {
      effects.consume(code);
      return inside2;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace$1(code) ? factorySpace$1(effects, after, "lineSuffix")(code) : after(code);
  }
  function after(code) {
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("setextHeadingLine");
      return ok2(code);
    }
    return nok(code);
  }
}
const indent = {
  tokenize: tokenizeIndent,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token = self2.events[index2][1];
    if (token.type === "labelImage") {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
      break;
    }
  }
  return start;
  function start(code) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code);
    }
    const id2 = normalizeIdentifier$1(
      self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      })
    );
    if (id2.codePointAt(0) !== 94 || !defined.includes(id2.slice(1))) {
      return nok(code);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok2(code);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
      events[index2][1];
      break;
    }
  }
  events[index2 + 1][1].type = "data";
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string2 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string2.start),
    end: Object.assign({}, string2.end)
  };
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call, context],
    // The `[`
    events[index2 + 3],
    events[index2 + 4],
    // The `^`.
    ["enter", marker, context],
    ["exit", marker, context],
    // Everything in between.
    ["enter", string2, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string2, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok2, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size = 0;
  let data;
  return start;
  function start(code) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code) {
    if (code !== 94)
      return nok(code);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code === null || code === 91 || markdownLineEndingOrSpace$1(code)
    ) {
      return nok(code);
    }
    if (code === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier$1(self2.sliceSerialize(token)))) {
        return nok(code);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok2;
    }
    if (!markdownLineEndingOrSpace$1(code)) {
      data = true;
    }
    size++;
    effects.consume(code);
    return code === 92 ? callEscape : callData;
  }
  function callEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size++;
      return callData;
    }
    return callData(code);
  }
}
function tokenizeDefinitionStart(effects, ok2, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier2;
  let size = 0;
  let data;
  return start;
  function start(code) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code) {
    if (code === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code);
  }
  function labelInside(code) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code === null || code === 91 || markdownLineEndingOrSpace$1(code)
    ) {
      return nok(code);
    }
    if (code === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier2 = normalizeIdentifier$1(self2.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace$1(code)) {
      data = true;
    }
    size++;
    effects.consume(code);
    return code === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size++;
      return labelInside;
    }
    return labelInside(code);
  }
  function labelAfter(code) {
    if (code === 58) {
      effects.enter("definitionMarker");
      effects.consume(code);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier2)) {
        defined.push(identifier2);
      }
      return factorySpace$1(
        effects,
        whitespaceAfter,
        "gfmFootnoteDefinitionWhitespace"
      );
    }
    return nok(code);
  }
  function whitespaceAfter(code) {
    return ok2(code);
  }
}
function tokenizeDefinitionContinuation(effects, ok2, nok) {
  return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  return factorySpace$1(
    effects,
    afterPrefix,
    "gfmFootnoteDefinitionIndent",
    4 + 1
  );
  function afterPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code) : nok(code);
  }
}
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
          events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough2 = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text2 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough2, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text2, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice$1(
                nextEvents,
                nextEvents.length,
                0,
                resolveAll$1(insideSpan2, events.slice(open + 1, index2), context)
              );
            }
            splice$1(nextEvents, nextEvents.length, 0, [
              ["exit", text2, context],
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context],
              ["exit", strikethrough2, context]
            ]);
            splice$1(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok2, nok) {
    const previous2 = this.previous;
    const events = this.events;
    let size = 0;
    return start;
    function start(code) {
      if (previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code);
    }
    function more(code) {
      const before = classifyCharacter(previous2);
      if (code === 126) {
        if (size > 1)
          return nok(code);
        effects.consume(code);
        size++;
        return more;
      }
      if (size < 2 && !single)
        return nok(code);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code);
      token._open = !after || after === 2 && Boolean(before);
      token._close = !before || before === 2 && Boolean(after);
      return ok2(code);
    }
  }
}
class EditMap {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(index2, remove2, add) {
    addImpl(this, index2, remove2, add);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(events) {
    this.map.sort(function(a3, b10) {
      return a3[0] - b10[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index2 = this.map.length;
    const vecs = [];
    while (index2 > 0) {
      index2 -= 1;
      vecs.push(
        events.slice(this.map[index2][0] + this.map[index2][1]),
        this.map[index2][2]
      );
      events.length = this.map[index2][0];
    }
    vecs.push([...events]);
    events.length = 0;
    let slice = vecs.pop();
    while (slice) {
      events.push(...slice);
      slice = vecs.pop();
    }
    this.map.length = 0;
  }
}
function addImpl(editMap, at, remove2, add) {
  let index2 = 0;
  if (remove2 === 0 && add.length === 0) {
    return;
  }
  while (index2 < editMap.map.length) {
    if (editMap.map[index2][0] === at) {
      editMap.map[index2][1] += remove2;
      editMap.map[index2][2].push(...add);
      return;
    }
    index2 += 1;
  }
  editMap.map.push([at, remove2, add]);
}
function gfmTableAlign(events, index2) {
  let inDelimiterRow = false;
  const align = [];
  while (index2 < events.length) {
    const event = events[index2];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(
            events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
          );
        }
      } else if (event[1].type === "tableContent") {
        if (events[index2 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index2 += 1;
  }
  return align;
}
function gfmTable() {
  return {
    flow: {
      null: {
        tokenize: tokenizeTable,
        resolveAll: resolveTable
      }
    }
  };
}
function tokenizeTable(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let sizeB = 0;
  let seen;
  return start;
  function start(code) {
    let index2 = self2.events.length - 1;
    while (index2 > -1) {
      const type = self2.events[index2][1].type;
      if (type === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type === "linePrefix")
        index2--;
      else
        break;
    }
    const tail = index2 > -1 ? self2.events[index2][1].type : null;
    const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code);
    }
    return next(code);
  }
  function headRowBefore(code) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code);
  }
  function headRowStart(code) {
    if (code === 124) {
      return headRowBreak(code);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code);
  }
  function headRowBreak(code) {
    if (code === null) {
      return nok(code);
    }
    if (markdownLineEnding$1(code)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return headDelimiterStart;
      }
      return nok(code);
    }
    if (markdownSpace$1(code)) {
      return factorySpace$1(effects, headRowBreak, "whitespace")(code);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size += 1;
    }
    if (code === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter("data");
    return headRowData(code);
  }
  function headRowData(code) {
    if (code === null || code === 124 || markdownLineEndingOrSpace$1(code)) {
      effects.exit("data");
      return headRowBreak(code);
    }
    effects.consume(code);
    return code === 92 ? headRowEscape : headRowData;
  }
  function headRowEscape(code) {
    if (code === 92 || code === 124) {
      effects.consume(code);
      return headRowData;
    }
    return headRowData(code);
  }
  function headDelimiterStart(code) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace$1(code)) {
      return factorySpace$1(
        effects,
        headDelimiterBefore,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code);
    }
    return headDelimiterBefore(code);
  }
  function headDelimiterBefore(code) {
    if (code === 45 || code === 58) {
      return headDelimiterValueBefore(code);
    }
    if (code === 124) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code);
  }
  function headDelimiterCellBefore(code) {
    if (markdownSpace$1(code)) {
      return factorySpace$1(effects, headDelimiterValueBefore, "whitespace")(code);
    }
    return headDelimiterValueBefore(code);
  }
  function headDelimiterValueBefore(code) {
    if (code === 58) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code === 45) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code);
    }
    if (code === null || markdownLineEnding$1(code)) {
      return headDelimiterCellAfter(code);
    }
    return headDelimiterNok(code);
  }
  function headDelimiterLeftAlignmentAfter(code) {
    if (code === 45) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code);
    }
    return headDelimiterNok(code);
  }
  function headDelimiterFiller(code) {
    if (code === 45) {
      effects.consume(code);
      return headDelimiterFiller;
    }
    if (code === 58) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code);
  }
  function headDelimiterRightAlignmentAfter(code) {
    if (markdownSpace$1(code)) {
      return factorySpace$1(effects, headDelimiterCellAfter, "whitespace")(code);
    }
    return headDelimiterCellAfter(code);
  }
  function headDelimiterCellAfter(code) {
    if (code === 124) {
      return headDelimiterBefore(code);
    }
    if (code === null || markdownLineEnding$1(code)) {
      if (!seen || size !== sizeB) {
        return headDelimiterNok(code);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok2(code);
    }
    return headDelimiterNok(code);
  }
  function headDelimiterNok(code) {
    return nok(code);
  }
  function bodyRowStart(code) {
    effects.enter("tableRow");
    return bodyRowBreak(code);
  }
  function bodyRowBreak(code) {
    if (code === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("tableRow");
      return ok2(code);
    }
    if (markdownSpace$1(code)) {
      return factorySpace$1(effects, bodyRowBreak, "whitespace")(code);
    }
    effects.enter("data");
    return bodyRowData(code);
  }
  function bodyRowData(code) {
    if (code === null || code === 124 || markdownLineEndingOrSpace$1(code)) {
      effects.exit("data");
      return bodyRowBreak(code);
    }
    effects.consume(code);
    return code === 92 ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code) {
    if (code === 92 || code === 124) {
      effects.consume(code);
      return bodyRowData;
    }
    return bodyRowData(code);
  }
}
function resolveTable(events, context) {
  let index2 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell2 = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map2 = new EditMap();
  while (++index2 < events.length) {
    const event = events[index2];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          // Note: correct end is set later.
          end: Object.assign({}, token.end)
        };
        map2.add(index2, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell2 = [0, index2 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map2.add(index2, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell2[2] === 0) {
          if (lastCell[1] !== 0) {
            cell2[0] = cell2[1];
            currentCell = flushCell(
              map2,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
            lastCell = [0, 0, 0, 0];
          }
          cell2[2] = index2;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell2[0] = cell2[1];
            currentCell = flushCell(
              map2,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
          }
          lastCell = cell2;
          cell2 = [lastCell[1], index2, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index2;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index2;
      if (lastCell[1] !== 0) {
        cell2[0] = cell2[1];
        currentCell = flushCell(
          map2,
          context,
          lastCell,
          rowKind,
          index2,
          currentCell
        );
      } else if (cell2[1] !== 0) {
        currentCell = flushCell(map2, context, cell2, rowKind, index2, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell2[3] = index2;
    }
  }
  if (lastTableEnd !== 0) {
    flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
  }
  map2.consume(context.events);
  index2 = -1;
  while (++index2 < context.events.length) {
    const event = context.events[index2];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index2);
    }
  }
  return events;
}
function flushCell(map2, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map2.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    // Note: correct end is set later.
    end: Object.assign({}, now)
  };
  map2.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map2.add(range[2], 0, [["enter", valueToken, context]]);
    if (rowKind !== 2) {
      const start = context.events[range[2]];
      const end = context.events[range[3]];
      start[1].end = Object.assign({}, end[1].end);
      start[1].type = "chunkText";
      start[1].contentType = "text";
      if (range[3] > range[2] + 1) {
        const a3 = range[2] + 1;
        const b10 = range[3] - range[2] - 1;
        map2.add(a3, b10, []);
      }
    }
    map2.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map2.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map2, context, index2, table2, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index2);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table2.end = Object.assign({}, related);
  exits.push(["exit", table2, context]);
  map2.add(index2 + 1, 0, exits);
}
function getPoint(events, index2) {
  const event = events[index2];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}
const tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};
function gfmTaskListItem() {
  return {
    text: {
      [91]: tasklistCheck
    }
  };
}
function tokenizeTasklistCheck(effects, ok2, nok) {
  const self2 = this;
  return open;
  function open(code) {
    if (
      // Exit if there’s stuff before.
      self2.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code);
    effects.exit("taskListCheckMarker");
    return inside2;
  }
  function inside2(code) {
    if (markdownLineEndingOrSpace$1(code)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code);
      effects.exit("taskListCheckValueUnchecked");
      return close;
    }
    if (code === 88 || code === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code);
      effects.exit("taskListCheckValueChecked");
      return close;
    }
    return nok(code);
  }
  function close(code) {
    if (code === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code);
  }
  function after(code) {
    if (markdownLineEnding$1(code)) {
      return ok2(code);
    }
    if (markdownSpace$1(code)) {
      return effects.check(
        {
          tokenize: spaceThenNonSpace
        },
        ok2,
        nok
      )(code);
    }
    return nok(code);
  }
}
function spaceThenNonSpace(effects, ok2, nok) {
  return factorySpace$1(effects, after, "whitespace");
  function after(code) {
    return code === null ? nok(code) : ok2(code);
  }
}
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable(),
    gfmTaskListItem()
  ]);
}
const emptyOptions$2 = {};
function remarkGfm(options) {
  const self2 = (
    /** @type {Processor} */
    this
  );
  const settings = options || emptyOptions$2;
  const data = self2.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(gfm(settings));
  fromMarkdownExtensions.push(gfmFromMarkdown());
  toMarkdownExtensions.push(gfmToMarkdown(settings));
}
const content$1 = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace$1(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code) {
    effects.enter("paragraph");
    return lineStart(code);
  }
  function lineStart(code) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data(code);
  }
  function data(code) {
    if (code === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code);
      return;
    }
    if (markdownLineEnding$1(code)) {
      effects.consume(code);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code);
    return data;
  }
}
const document$2 = {
  tokenize: initializeDocument
};
const containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code);
    }
    return checkNewContainers(code);
  }
  function documentContinue(code) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice$1(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code);
    }
    return start(code);
  }
  function checkNewContainers(code) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code);
  }
  function thereIsANewContainer(code) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code);
  }
  function thereIsNoNewContainer(code) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code);
  }
  function documentContinued(code) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code);
  }
  function containerContinue(code) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code);
  }
  function flowStart(code) {
    if (code === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code);
  }
  function flowContinue(code) {
    if (code === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code);
      return;
    }
    if (markdownLineEnding$1(code)) {
      effects.consume(code);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self2.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index2][1].start.offset < lineStartOffset && // …and either is not ended yet…
          (!childFlow.events[index2][1].end || // …or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice$1(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace$1(
    effects,
    effects.attempt(this.parser.constructs.document, ok2, nok),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
const flow$1 = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace$1(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content$4, afterConstruct)
        ),
        "linePrefix"
      )
    )
  );
  return initial;
  function atBlankEnding(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}
const resolver = {
  resolveAll: createResolver()
};
const string$2 = initializeFactory("string");
const text$2 = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text2 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code) {
      return atBreak(code) ? text2(code) : notText(code);
    }
    function notText(code) {
      if (code === null) {
        effects.consume(code);
        return;
      }
      effects.enter("data");
      effects.consume(code);
      return data;
    }
    function data(code) {
      if (atBreak(code)) {
        effects.exit("data");
        return text2(code);
      }
      effects.consume(code);
      return data;
    }
    function atBreak(code) {
      if (code === null) {
        return true;
      }
      const list2 = constructs2[code];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1)
          ;
        else {
          index2++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}
function createTokenizer(parser, initialize, from) {
  let point2 = Object.assign(
    from ? Object.assign({}, from) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write: write2
  };
  let state = initialize.tokenize.call(context, effects);
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write2(slice) {
    chunks = push$1(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll$1(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { line, column, offset, _index, _bufferIndex } = point2;
    return {
      line,
      column,
      offset,
      _index,
      _bufferIndex
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go2(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go2(chunk);
      }
    }
  }
  function go2(code) {
    state = state(code);
  }
  function consume(code) {
    if (markdownLineEnding$1(code)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_10, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? (
        // @ts-expect-error Looks like a construct.
        handleListOfConstructs([constructs2])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map2) {
        return start;
        function start(code) {
          const def = code !== null && map2[code];
          const all2 = code !== null && map2.null;
          const list2 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok();
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok2,
            nok
          )(code);
        }
      }
      function ok2(code) {
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code) {
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice$1(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head2 = view[0];
      if (typeof head2 === "string") {
        view[0] = head2.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}
const document$1 = {
  [42]: list$1,
  [43]: list$1,
  [45]: list$1,
  [48]: list$1,
  [49]: list$1,
  [50]: list$1,
  [51]: list$1,
  [52]: list$1,
  [53]: list$1,
  [54]: list$1,
  [55]: list$1,
  [56]: list$1,
  [57]: list$1,
  [62]: blockQuote
};
const contentInitial = {
  [91]: definition
};
const flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
const flow = {
  [35]: headingAtx,
  [42]: thematicBreak$1,
  [45]: [setextUnderline, thematicBreak$1],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak$1,
  [96]: codeFenced,
  [126]: codeFenced
};
const string$1 = {
  [38]: characterReference,
  [92]: characterEscape
};
const text$1 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd$1,
  [95]: attention,
  [96]: codeText
};
const insideSpan = {
  null: [attention, resolver]
};
const attentionMarkers = {
  null: [42, 95]
};
const disable = {
  null: []
};
const defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers,
  contentInitial,
  disable,
  document: document$1,
  flow,
  flowInitial,
  insideSpan,
  string: string$1,
  text: text$1
}, Symbol.toStringTag, { value: "Module" }));
function parse(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([defaultConstructs, ...settings.extensions || []])
  );
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content$1),
    document: create2(document$2),
    flow: create2(flow$1),
    string: create2(string$2),
    text: create2(text$2)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}
const search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer)
        chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}
function stringifyPosition$1(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position$1(value.position);
  }
  if ("start" in value || "end" in value) {
    return position$1(value);
  }
  if ("line" in value || "column" in value) {
    return point$2(value);
  }
  return "";
}
function point$2(point2) {
  return index$1(point2 && point2.line) + ":" + index$1(point2 && point2.column);
}
function position$1(pos) {
  return point$2(pos && pos.start) + "-" + point$2(pos && pos.end);
}
function index$1(value) {
  return value && typeof value === "number" ? value : 1;
}
const own$7 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse(options).document().write(preprocess()(value, encoding, true))
    )
  );
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own$7.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            {
              sliceSerialize: events[index2][2].sliceSerialize
            },
            context
          ),
          events[index2][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point(
        events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: point(
        events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      switch (event[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case "lineEndingBlank": {
          if (event[0] === "enter") {
            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace": {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
              ;
            else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          listItem3 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function opener(create2, and) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    const siblings2 = parent.children;
    siblings2.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler]);
    node2.position = {
      start: point(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and)
        and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition$1({
          start: token.start,
          end: token.end
        }) + "): it’s not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node2.position.end = point(token.end);
  }
  function resume() {
    return toString$1(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside)
      return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier$1(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    const siblings2 = node2.children;
    let tail = siblings2[siblings2.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text2();
      tail.position = {
        start: point(token.start),
        // @ts-expect-error: we’ll add `end` later.
        end: void 0
      };
      siblings2.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string2 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string2);
    ancestor.identifier = normalizeIdentifier$1(string2).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    this.data.inReference = true;
    if (node2.type === "link") {
      const children2 = fragment.children;
      node2.children = children2;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier$1(
      this.sliceSerialize(token)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data2,
        type === "characterReferenceMarkerNumeric" ? 10 : 16
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      value = result;
    }
    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text2() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function point(d3) {
  return {
    line: d3.line,
    column: d3.column,
    offset: d3.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key2;
  for (key2 in extension2) {
    if (own$7.call(extension2, key2)) {
      switch (key2) {
        case "canContainEols": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key2];
          if (right) {
            Object.assign(combined[key2], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition$1({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition$1({
        start: right.start,
        end: right.end
      }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition$1({
        start: right.start,
        end: right.end
      }) + ") is still open"
    );
  }
}
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc2) {
    return fromMarkdown(doc2, {
      ...self2.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}
function code$2(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const properties2 = {};
  if (node2.lang) {
    properties2.className = ["language-" + node2.lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties: properties2,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function footnoteReference(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id2 = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id2.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id2);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id2);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id2);
    counter = state.footnoteOrder.length;
  } else {
    counter = index2 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id2, reuseCounter);
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}
function heading$1(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function html(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return void 0;
}
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  }
  const contents = state.all(node2);
  const head2 = contents[0];
  if (head2 && head2.type === "text") {
    head2.value = "[" + head2.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}
function imageReference(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const def = state.definitionById.get(id2);
  if (!def) {
    return revert(state, node2);
  }
  const properties2 = { src: normalizeUri(def.url || ""), alt: node2.alt };
  if (def.title !== null && def.title !== void 0) {
    properties2.title = def.title;
  }
  const result = { type: "element", tagName: "img", properties: properties2, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function image(state, node2) {
  const properties2 = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties2.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties2.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties: properties2, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function inlineCode(state, node2) {
  const text2 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text2);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text2]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function linkReference(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const def = state.definitionById.get(id2);
  if (!def) {
    return revert(state, node2);
  }
  const properties2 = { href: normalizeUri(def.url || "") };
  if (def.title !== null && def.title !== void 0) {
    properties2.title = def.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties: properties2,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function link(state, node2) {
  const properties2 = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties2.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties: properties2,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listItem(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties2 = {};
  const children2 = [];
  if (typeof node2.checked === "boolean") {
    const head2 = results[0];
    let paragraph2;
    if (head2 && head2.type === "element" && head2.tagName === "p") {
      paragraph2 = head2;
    } else {
      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift({ type: "text", value: " " });
    }
    paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties2.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child = results[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children2.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children2.push(...child.children);
    } else {
      children2.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children2.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties: properties2, children: children2 };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children2 = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children2.length) {
      loose = listItemLoose(children2[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
}
function list(state, node2) {
  const properties2 = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties2.start = node2.start;
  }
  while (++index2 < results.length) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties2.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties: properties2,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function root(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head2 = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head2);
    tableContent.push(head2);
  }
  if (rows.length > 0) {
    const body2 = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start && end)
      body2.position = { start, end };
    tableContent.push(body2);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableRow(state, node2, parent) {
  const siblings2 = parent ? parent.children : void 0;
  const rowIndex = siblings2 ? siblings2.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells2 = [];
  while (++cellIndex < length) {
    const cell2 = node2.children[cellIndex];
    const properties2 = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties2.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties: properties2, children: [] };
    if (cell2) {
      result2.children = state.all(cell2);
      state.patch(cell2, result2);
      result2 = state.applyData(cell2, result2);
    }
    cells2.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells2, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const tab = 9;
const space = 32;
function trimLines(value) {
  const source2 = String(value);
  const search2 = /\r?\n|\r/g;
  let match = search2.exec(source2);
  let last = 0;
  const lines = [];
  while (match) {
    lines.push(
      trimLine(source2.slice(last, match.index), last > 0, true),
      match[0]
    );
    last = match.index + match[0].length;
    match = search2.exec(source2);
  }
  lines.push(trimLine(source2.slice(last), last > 0, false));
  return lines.join("");
}
function trimLine(value, start, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start) {
    let code = value.codePointAt(startIndex);
    while (code === tab || code === space) {
      startIndex++;
      code = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code = value.codePointAt(endIndex - 1);
    while (code === tab || code === space) {
      endIndex--;
      code = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}
function text(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function thematicBreak(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const handlers$1 = {
  blockquote,
  break: hardBreak,
  code: code$2,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  heading: heading$1,
  html,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list,
  paragraph,
  // @ts-expect-error: root is different, but hard to type.
  root,
  strong,
  table,
  tableCell,
  tableRow,
  text,
  thematicBreak,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return void 0;
}
function defaultFootnoteBackContent(_10, rereferenceIndex) {
  const result = [{ type: "text", value: "↩" }];
  if (rereferenceIndex > 1) {
    result.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const def = state.footnoteById.get(state.footnoteOrder[referenceIndex]);
    if (!def) {
      continue;
    }
    const content2 = state.all(def);
    const id2 = String(def.identifier).toUpperCase();
    const safeId = normalizeUri(id2.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id2);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children2 = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children2 === "string") {
        children2 = { type: "text", value: children2 };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children2) ? children2 : [children2]
      });
    }
    const tail = content2[content2.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content2.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content2, true)
    };
    state.patch(def, listItem2);
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...structuredClone$1(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}
const own$2 = {}.hasOwnProperty;
const emptyOptions$1 = {};
function createState(tree, options) {
  const settings = options || emptyOptions$1;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers2 = { ...handlers$1, ...settings.handlers };
  const state = {
    all: all2,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers2,
    one: one2,
    options: settings,
    patch,
    wrap: wrap$2
  };
  visit$1(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map2 = node2.type === "definition" ? definitionById : footnoteById;
      const id2 = String(node2.identifier).toUpperCase();
      if (!map2.has(id2)) {
        map2.set(id2, node2);
      }
    }
  });
  return state;
  function one2(node2, parent) {
    const type = node2.type;
    const handle2 = state.handlers[type];
    if (own$2.call(state.handlers, type) && handle2) {
      return handle2(state, node2, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node2) {
        const { children: children2, ...shallow } = node2;
        const result = structuredClone$1(shallow);
        result.children = state.all(node2);
        return result;
      }
      return structuredClone$1(node2);
    }
    const unknown2 = state.options.unknownHandler || defaultUnknownHandler;
    return unknown2(state, node2, parent);
  }
  function all2(parent) {
    const values = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index2 = -1;
      while (++index2 < nodes.length) {
        const result = state.one(nodes[index2], parent);
        if (result) {
          if (index2 && nodes[index2 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = trimMarkdownSpaceStart(result.value);
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head2 = result.children[0];
              if (head2 && head2.type === "text") {
                head2.value = trimMarkdownSpaceStart(head2.value);
              }
            }
          }
          if (Array.isArray(result)) {
            values.push(...result);
          } else {
            values.push(result);
          }
        }
      }
    }
    return values;
  }
}
function patch(from, to2) {
  if (from.position)
    to2.position = position$2(from);
}
function applyData(from, to2) {
  let result = to2;
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        const children2 = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children: children2 };
      }
    }
    if (result.type === "element" && hProperties) {
      Object.assign(result.properties, structuredClone$1(hProperties));
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own$2.call(data, "hProperties") || own$2.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap$2(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2)
      result.push({ type: "text", value: "\n" });
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function trimMarkdownSpaceStart(value) {
  let index2 = 0;
  let code = value.charCodeAt(index2);
  while (code === 9 || code === 32) {
    index2++;
    code = value.charCodeAt(index2);
  }
  return value.slice(index2);
}
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, void 0);
  const foot = footer(state);
  const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  if (foot) {
    result.children.push({ type: "text", value: "\n" }, foot);
  }
  return result;
}
function remarkRehype(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const hastTree = (
        /** @type {HastRoot} */
        toHast(tree, options)
      );
      await destination.run(hastTree, file);
    };
  }
  return function(tree) {
    return (
      /** @type {HastRoot} */
      toHast(tree, options || destination)
    );
  };
}
function bail$1(error2) {
  if (error2) {
    throw error2;
  }
}
var hasOwn = Object.prototype.hasOwnProperty;
var toStr$1 = Object.prototype.toString;
var defineProperty$1 = Object.defineProperty;
var gOPD$1 = Object.getOwnPropertyDescriptor;
var isArray$1 = function isArray(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr$1.call(arr) === "[object Array]";
};
var isPlainObject$2 = function isPlainObject(obj) {
  if (!obj || toStr$1.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key2;
  for (key2 in obj) {
  }
  return typeof key2 === "undefined" || hasOwn.call(obj, key2);
};
var setProperty$1 = function setProperty(target, options) {
  if (defineProperty$1 && options.name === "__proto__") {
    defineProperty$1(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty$1 = function getProperty(obj, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn.call(obj, name2)) {
      return void 0;
    } else if (gOPD$1) {
      return gOPD$1(obj, name2).value;
    }
  }
  return obj[name2];
};
var extend$3 = function extend() {
  var options, name2, src, copy, copyIsArray, clone;
  var target = arguments[0];
  var i3 = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i3 = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i3 < length; ++i3) {
    options = arguments[i3];
    if (options != null) {
      for (name2 in options) {
        src = getProperty$1(target, name2);
        copy = getProperty$1(options, name2);
        if (target !== copy) {
          if (deep && copy && (isPlainObject$2(copy) || (copyIsArray = isArray$1(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray$1(src) ? src : [];
            } else {
              clone = src && isPlainObject$2(src) ? src : {};
            }
            setProperty$1(target, { name: name2, newValue: extend(deep, clone, copy) });
          } else if (typeof copy !== "undefined") {
            setProperty$1(target, { name: name2, newValue: copy });
          }
        }
      }
    }
  }
  return target;
};
const extend$4 = /* @__PURE__ */ getDefaultExportFromCjs$1(extend$3);
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough$1() {
  const fns = [];
  const pipeline = { run, use: use2 };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error2, ...output) {
      const fn2 = fns[++middlewareIndex];
      let index2 = -1;
      if (error2) {
        callback(error2);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn2) {
        wrap$1(fn2, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use2(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap$1(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error2) {
      const exception = (
        /** @type {Error} */
        error2
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result instanceof Promise) {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error2, ...output) {
    if (!called) {
      called = true;
      callback(error2, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
let VFileMessage$1 = class VFileMessage extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index2);
        options.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start ? start.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start ? start.line : void 0;
    this.name = stringifyPosition$1(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
};
VFileMessage$1.prototype.file = "";
VFileMessage$1.prototype.name = "";
VFileMessage$1.prototype.reason = "";
VFileMessage$1.prototype.message = "";
VFileMessage$1.prototype.stack = "";
VFileMessage$1.prototype.column = void 0;
VFileMessage$1.prototype.line = void 0;
VFileMessage$1.prototype.ancestors = void 0;
VFileMessage$1.prototype.cause = void 0;
VFileMessage$1.prototype.fatal = void 0;
VFileMessage$1.prototype.place = void 0;
VFileMessage$1.prototype.ruleId = void 0;
VFileMessage$1.prototype.source = void 0;
function isUrl$1(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}
const order$1 = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
let VFile$1 = class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl$1(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array$3(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = proc$1.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order$1.length) {
      const prop2 = order$1[index2];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order$1.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? path$3.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty$1(basename2, "basename");
    assertPart$1(basename2, "basename");
    this.path = path$3.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? path$3.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath$2(this.basename, "dirname");
    this.path = path$3.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? path$3.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart$1(extname2, "extname");
    assertPath$2(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path$3.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path2) {
    if (isUrl$1(path2)) {
      path2 = fileURLToPath(path2);
    }
    assertNonEmpty$1(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? path$3.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty$1(stem, "stem");
    assertPart$1(stem, "stem");
    this.path = path$3.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage$1(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
};
function assertPart$1(part, name2) {
  if (part && part.includes(path$3.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + path$3.sep + "`"
    );
  }
}
function assertNonEmpty$1(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath$2(path2, name2) {
  if (!path2) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function isUint8Array$3(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const CallableInstance$1 = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property) {
    const self2 = this;
    const constr = self2.constructor;
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const func = proto[property];
    const apply = function() {
      return func.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto);
    const names = Object.getOwnPropertyNames(func);
    for (const p10 of names) {
      const descriptor = Object.getOwnPropertyDescriptor(func, p10);
      if (descriptor)
        Object.defineProperty(apply, p10, descriptor);
    }
    return apply;
  }
);
const own$1 = {}.hasOwnProperty;
let Processor$1 = class Processor extends CallableInstance$1 {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough$1();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data(extend$4(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > 👉 **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > 👉 **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen$1("data", this.frozen);
        this.namespace[key2] = value;
        return this;
      }
      return own$1.call(this.namespace, key2) && this.namespace[key2] || void 0;
    }
    if (key2) {
      assertUnfrozen$1("data", this.frozen);
      this.namespace = key2;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > 👉 **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile$1(file);
    const parser = this.parser || this.Parser;
    assertParser$1("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > 👉 **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser$1("process", this.parser || this.Parser);
    assertCompiler$1("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile$1(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error2, tree, file2) {
        if (error2 || !tree || !file2) {
          return realDone(error2);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue$1(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error2,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error2, file2) {
        if (error2 || !file2) {
          reject(error2);
        } else if (resolve) {
          resolve(file2);
        } else {
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > 👉 **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser$1("processSync", this.parser || this.Parser);
    assertCompiler$1("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone$1("processSync", "process", complete);
    return result;
    function realDone(error2, file2) {
      complete = true;
      bail$1(error2);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > 👉 **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode$1(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile$1(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error2, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error2) {
          reject(error2);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > 👉 **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone$1("runSync", "run", complete);
    return result;
    function realDone(error2, tree2) {
      bail$1(error2);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > 👉 **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile$1(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler$1("stringify", compiler2);
    assertNode$1(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > 👉 **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen$1("use", this.frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = extend$4(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0)
        ;
      else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject2(currentPrimary) && isPlainObject2(primary)) {
          primary = extend$4(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
};
const unified = new Processor$1().freeze();
function assertParser$1(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `parser`");
  }
}
function assertCompiler$1(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `compiler`");
  }
}
function assertUnfrozen$1(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode$1(node2) {
  if (!isPlainObject2(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone$1(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile$1(value) {
  return looksLikeAVFile$1(value) ? value : new VFile$1(value);
}
function looksLikeAVFile$1(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue$1(value) {
  return typeof value === "string" || isUint8Array$2(value);
}
function isUint8Array$2(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const emptyOptions = {};
function toString(value, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one$1(value, includeImageAlt, includeHtml);
}
function one$1(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one$1(values[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}
const headings = (root2) => {
  const headingList = [];
  visit(root2, "heading", (node2) => {
    const heading2 = {
      depth: node2.depth,
      value: toString(node2, { includeImageAlt: false })
    };
    const data = node2 == null ? void 0 : node2.data;
    if (data) {
      heading2.data = data;
    }
    headingList.push(heading2);
  });
  return headingList;
};
function remarkHeadings() {
  return (node2, file) => {
    file.data.headings = headings(node2);
  };
}
function remarkStringify(options) {
  const self2 = this;
  self2.compiler = compiler2;
  function compiler2(tree) {
    return toMarkdown(tree, {
      ...self2.data("settings"),
      ...options,
      // Note: this option is not in the readme.
      // The goal is for it to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("toMarkdownExtensions") || []
    });
  }
}
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x2) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k10) => typeof obj[obj[k10]] !== "number");
    const filtered = {};
    for (const k10 of validKeys) {
      filtered[k10] = obj[k10];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e3) {
      return obj[e3];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = [];
    for (const key2 in object) {
      if (Object.prototype.hasOwnProperty.call(object, key2)) {
        keys2.push(key2);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_10, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t10 = typeof data;
  switch (t10) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error2) => {
      for (const issue of error2.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i3 = 0;
          while (i3 < issue.path.length) {
            const el2 = issue.path[i3];
            const terminal = i3 === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i3++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error2 = new ZodError(issues);
  return error2;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params2) => {
  const { data, path: path2, errorMaps, issueData } = params2;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m10) => !!m10).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x10) => !!x10)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s3 of results) {
      if (s3.status === "aborted")
        return INVALID;
      if (s3.status === "dirty")
        status.dirty();
      arrayValue.push(s3.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key2, value } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key2.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK$1 = (value) => ({ status: "valid", value });
const isAborted = (x10) => x10.status === "aborted";
const isDirty = (x10) => x10.status === "dirty";
const isValid = (x10) => x10.status === "valid";
const isAsync = (x10) => typeof Promise !== "undefined" && x10 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path2, key2) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key2;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error2 = new ZodError(ctx.common.issues);
        this._error = error2;
        return this._error;
      }
    };
  }
};
function processCreateParams(params2) {
  if (!params2)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params2) {
    const result = this.safeParse(data, params2);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params2) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap
      },
      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params2) {
    const result = await this.safeParseAsync(data, params2);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params2) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,
        async: true
      },
      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option2) {
    return ZodUnion.create([this, option2], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip2, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip2)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip2)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex2 = datetimeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data) => regex2.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get minLength() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params2) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params2)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      } else if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params2) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    ...processCreateParams(params2)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params2) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params2)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK$1(input.data);
  }
}
ZodBoolean.create = (params2) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    ...processCreateParams(params2)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params2) => {
  return new ZodDate({
    checks: [],
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params2)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK$1(input.data);
  }
}
ZodSymbol.create = (params2) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params2)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK$1(input.data);
  }
}
ZodUndefined.create = (params2) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params2)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK$1(input.data);
  }
}
ZodNull.create = (params2) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params2)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK$1(input.data);
  }
}
ZodAny.create = (params2) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params2)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK$1(input.data);
  }
}
ZodUnknown.create = (params2) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params2)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params2) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params2)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK$1(input.data);
  }
}
ZodVoid.create = (params2) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params2)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i3) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i3) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params2) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params2)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key2 in ctx.data) {
        if (!shapeKeys.includes(key2)) {
          extraKeys.push(key2);
        }
      }
    }
    const pairs = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape[key2];
      const value = ctx.data[key2];
      pairs.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key2)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          syncPairs.push({
            key: key2,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b2, _c2, _d2;
          const defaultError = (_c2 = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d2 = errorUtil.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key2) => {
      if (mask[key2] && this.shape[key2]) {
        shape[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key2) => {
      if (!mask[key2]) {
        shape[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key2) => {
      const fieldSchema = this.shape[key2];
      if (mask && !mask[key2]) {
        newShape[key2] = fieldSchema;
      } else {
        newShape[key2] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key2) => {
      if (mask && !mask[key2]) {
        newShape[key2] = this.shape[key2];
      } else {
        const fieldSchema = this.shape[key2];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key2] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params2) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
ZodObject.strictCreate = (shape, params2) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
ZodObject.lazycreate = (shape, params2) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option2) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option2._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option2 of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option2._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params2) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params2)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option2 = this.optionsMap.get(discriminatorValue);
    if (!option2) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option2._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option2._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params2) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params2)
    });
  }
}
function mergeValues(a3, b10) {
  const aType = getParsedType(a3);
  const bType = getParsedType(b10);
  if (a3 === b10) {
    return { valid: true, data: a3 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b10);
    const sharedKeys = util.objectKeys(a3).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a3, ...b10 };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a3[key2], b10[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a3.length !== b10.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a3.length; index2++) {
      const itemA = a3[index2];
      const itemB = b10[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a3 === +b10) {
    return { valid: true, data: a3 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params2) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params2)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x10) => !!x10);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params2) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params2)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key2, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key2 = pair.key;
        const value = pair.value;
        if (key2.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params2) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params2)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element2 of elements2) {
        if (element2.status === "aborted")
          return INVALID;
        if (element2.status === "dirty")
          status.dirty();
        parsedSet.add(element2.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params2) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params2)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x10) => !!x10),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x10) => !!x10),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    const params2 = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK$1(async function(...args) {
        const error2 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params2).catch((e3) => {
          error2.addIssue(makeArgsIssue(args, e3));
          throw error2;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params2).catch((e3) => {
          error2.addIssue(makeReturnsIssue(result, e3));
          throw error2;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK$1(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params2);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params2);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params2) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params2)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params2) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params2)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params2) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params2)
  });
};
function createZodEnum(values, params2) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params2)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK$1(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK$1(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params2) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params2)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK$1(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params2) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params2)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base2 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base2))
          return base2;
        const result = effect.transform(base2.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
          if (!isValid(base2))
            return base2;
          return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params2) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params2)
  });
};
ZodEffects.createWithPreprocess = (preprocess2, schema, params2) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess2 },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params2)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK$1(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params2) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params2)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK$1(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params2) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params2)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params2) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default,
    ...processCreateParams(params2)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params2) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch,
    ...processCreateParams(params2)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params2) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params2)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a3, b10) {
    return new ZodPipeline({
      in: a3,
      out: b10,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params2) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params2)
  });
};
const custom = (check, params2 = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a2, _b2;
      if (!check(data)) {
        const p10 = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
        const _fatal = (_b2 = (_a2 = p10.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
        const p22 = typeof p10 === "string" ? { message: p10 } : p10;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params2 = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params2);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK: OK$1,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
function L$2(t10) {
  var e3;
  return unified().use(remarkParse).use(remarkGfm).use(remarkRehype).use(rehypeSlug).use(rehypeDocument).use(rehypeFormat).use(rehypeSanitize, {
    ...defaultSchema,
    tagNames: (e3 = defaultSchema.tagNames) == null ? void 0 : e3.filter(
      (r3) => !["img"].includes(r3)
    )
  }).use(rehypeHighlight, {
    detect: true
  }).use(rehypeExternalLinks, { target: "_blank" }).use(rehypeStringify).process(t10);
}
const k = z$1.object({
  depth: z$1.number(),
  value: z$1.string(),
  slug: z$1.string().optional()
}), S$3 = unified().use(remarkParse).use(remarkStringify).use(remarkHeadings), M$3 = async (t10) => {
  const { headings: e3 } = (await S$3.process(t10)).data, r3 = k.array().safeParse(e3);
  return r3.success || console.error("Invalid headings from the markdown"), r3.success ? r3.data : [];
};
(function() {
  try {
    if (typeof document < "u") {
      var e3 = document.createElement("style");
      e3.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Inter:wght@100..900";@import"https://fonts.googleapis.com/css?family=JetBrains%20Mono";:root{--default-theme-border-width: 1px;--default-theme-radius: 3px;--default-theme-radius-lg: 6px;--default-theme-radius-xl: 8px;--default-theme-header-height: 50px;--default-theme-sidebar-width: 250px;--default-theme-toc-width: 250px;--default-theme-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;--default-theme-font-code: "JetBrains Mono";--default-theme-heading-1: 40px;--default-theme-page-description: 24px;--default-theme-heading-2: 24px;--default-theme-heading-3: 20px;--default-theme-heading-4: 16px;--default-theme-heading-5: 16px;--default-theme-heading-6: 16px;--default-theme-paragraph: 16px;--default-theme-small: 14px;--default-theme-mini: 13px;--default-theme-micro: 12px;--default-theme-bold: 600;--default-theme-semibold: 500;--default-theme-regular: 400;--default-theme-font-size-1: 24px;--default-theme-font-size-2: 16px;--default-theme-font-size-3: 14px;--default-theme-font-size-4: 13px;--default-theme-font-size-5: 12px;--default-theme-line-height-1: 32px;--default-theme-line-height-2: 24px;--default-theme-line-height-3: 20px;--default-theme-line-height-4: 18px;--default-theme-line-height-5: 16px;--default-theme-font-medium: 500;--default-theme-font-bold: 700}@media (max-width: 460px){:root{--default-theme-font-size-1: 22px;--default-theme-font-size-2: 14px;--default-theme-font-size-3: 12px}}@media (max-width: 720px){:root{--default-theme-heading-1: 24px;--default-theme-page-description: 20px}}.cm-scroller,.custom-scroll{overflow-y:scroll;scrollbar-color:transparent transparent;scrollbar-width:thin;-webkit-overflow-scrolling:touch}.custom-scroll-self-contain-overflow{overscroll-behavior:contain}.custom-scroll-extra-padding-right{padding-right:12px!important}@supports (-moz-appearance: none){.cm-scroller,.custom-scroll{padding-right:12px}.custom-scroll-extra-padding-right{padding-right:24px!important}}.cm-scroller:hover,.custom-scroll:hover{scrollbar-color:var( --theme-scrollbar-color, var(--default-theme-scrollbar-color) ) transparent}.cm-scroller:hover::-webkit-scrollbar-thumb,.custom-scroll:hover::-webkit-scrollbar-thumb{background:var( --theme-scrollbar-color, var(--default-theme-scrollbar-color) );background-clip:content-box;border:3px solid transparent}.cm-scroller::-webkit-scrollbar-thumb:active,.custom-scroll::-webkit-scrollbar-thumb:active{background:var( --theme-scrollbar-color-active, var(--default-theme-scrollbar-color-active) );background-clip:content-box;border:3px solid transparent}.cm-scroller::-webkit-scrollbar-corner,.custom-scroll::-webkit-scrollbar-corner{background:transparent}.cm-scroller::-webkit-scrollbar,.custom-scroll::-webkit-scrollbar{height:12px;width:12px}.cm-scroller::-webkit-scrollbar-track,.custom-scroll::-webkit-scrollbar-track{background:transparent}.cm-scroller::-webkit-scrollbar-thumb,.custom-scroll::-webkit-scrollbar-thumb{border-radius:20px;background:transparent;background-clip:content-box;border:3px solid transparent}@media (pointer: coarse){.cm-scroller,.custom-scroll{padding-right:12px}.custom-scroll-extra-padding-right{padding-right:24px!important}}')), document.head.appendChild(e3);
    }
  } catch (t10) {
    console.error("vite-plugin-css-injected-by-js", t10);
  }
})();
const $ = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
process.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
const Nt$1 = () => {
}, xr = /^on[^a-z]/, wr$1 = (e3) => xr.test(e3), C$2 = Object.assign, p$5 = Array.isArray, v$2 = (e3) => typeof e3 == "function", V$1 = (e3) => typeof e3 == "string", ze = (e3) => typeof e3 == "symbol", x$1 = (e3) => e3 !== null && typeof e3 == "object";
let rt;
const Ce$1 = () => rt || (rt = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function He(e3) {
  if (p$5(e3)) {
    const t10 = {};
    for (let r3 = 0; r3 < e3.length; r3++) {
      const n3 = e3[r3], o3 = V$1(n3) ? Ir(n3) : He(n3);
      if (o3)
        for (const a3 in o3)
          t10[a3] = o3[a3];
    }
    return t10;
  } else {
    if (V$1(e3))
      return e3;
    if (x$1(e3))
      return e3;
  }
}
const Vr = /;(?![^(]*\))/g, Cr$1 = /:([^]+)/, yr$1 = /\/\*[^]*?\*\//g;
function Ir(e3) {
  const t10 = {};
  return e3.replace(yr$1, "").split(Vr).forEach((r3) => {
    if (r3) {
      const n3 = r3.split(Cr$1);
      n3.length > 1 && (t10[n3[0].trim()] = n3[1].trim());
    }
  }), t10;
}
function Ue(e3) {
  let t10 = "";
  if (V$1(e3))
    t10 = e3;
  else if (p$5(e3))
    for (let r3 = 0; r3 < e3.length; r3++) {
      const n3 = Ue(e3[r3]);
      n3 && (t10 += n3 + " ");
    }
  else if (x$1(e3))
    for (const r3 in e3)
      e3[r3] && (t10 += r3 + " ");
  return t10.trim();
}
Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e3) => e3 !== "arguments" && e3 !== "caller").map((e3) => Symbol[e3]).filter(ze)
);
function W(e3) {
  return q(e3) ? W(e3.__v_raw) : !!(e3 && e3.__v_isReactive);
}
function q(e3) {
  return !!(e3 && e3.__v_isReadonly);
}
function $e$1(e3) {
  return W(e3) || q(e3);
}
function f$2(e3) {
  const t10 = e3 && e3.__v_raw;
  return t10 ? f$2(t10) : e3;
}
function N$3(e3) {
  return !!(e3 && e3.__v_isRef === true);
}
const B$1 = [];
function fo$1(e3) {
  B$1.push(e3);
}
function ho$1() {
  B$1.pop();
}
function _$1(e3, ...t10) {
  if (process.env.NODE_ENV === "production")
    return;
  const r3 = B$1.length ? B$1[B$1.length - 1].component : null, n3 = r3 && r3.appContext.config.warnHandler, o3 = po();
  if (n3)
    J$1(
      n3,
      r3,
      11,
      [
        e3 + t10.join(""),
        r3 && r3.proxy,
        o3.map(
          ({ vnode: a3 }) => `at <${ur$1(r3, a3.type)}>`
        ).join(`
`),
        o3
      ]
    );
  else {
    const a3 = [`[Vue warn]: ${e3}`, ...t10];
    o3.length && a3.push(`
`, ...bo$1(o3)), console.warn(...a3);
  }
}
function po() {
  let e3 = B$1[B$1.length - 1];
  if (!e3)
    return [];
  const t10 = [];
  for (; e3; ) {
    const r3 = t10[0];
    r3 && r3.vnode === e3 ? r3.recurseCount++ : t10.push({
      vnode: e3,
      recurseCount: 0
    });
    const n3 = e3.component && e3.component.parent;
    e3 = n3 && n3.vnode;
  }
  return t10;
}
function bo$1(e3) {
  const t10 = [];
  return e3.forEach((r3, n3) => {
    t10.push(...n3 === 0 ? [] : [`
`], ...mo$1(r3));
  }), t10;
}
function mo$1({ vnode: e3, recurseCount: t10 }) {
  const r3 = t10 > 0 ? `... (${t10} recursive calls)` : "", n3 = e3.component ? e3.component.parent == null : false, o3 = ` at <${ur$1(
    e3.component,
    e3.type,
    n3
  )}`, a3 = ">" + r3;
  return e3.props ? [o3, ...go$1(e3.props), a3] : [o3 + a3];
}
function go$1(e3) {
  const t10 = [], r3 = Object.keys(e3);
  return r3.slice(0, 3).forEach((n3) => {
    t10.push(...Bt$1(n3, e3[n3]));
  }), r3.length > 3 && t10.push(" ..."), t10;
}
function Bt$1(e3, t10, r3) {
  return V$1(t10) ? (t10 = JSON.stringify(t10), r3 ? t10 : [`${e3}=${t10}`]) : typeof t10 == "number" || typeof t10 == "boolean" || t10 == null ? r3 ? t10 : [`${e3}=${t10}`] : N$3(t10) ? (t10 = Bt$1(e3, f$2(t10.value), true), r3 ? t10 : [`${e3}=Ref<`, t10, ">"]) : v$2(t10) ? [`${e3}=fn${t10.name ? `<${t10.name}>` : ""}`] : (t10 = f$2(t10), r3 ? t10 : [`${e3}=`, t10]);
}
const Jt = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function J$1(e3, t10, r3, n3) {
  let o3;
  try {
    o3 = n3 ? e3(...n3) : e3();
  } catch (a3) {
    qt(a3, t10, r3);
  }
  return o3;
}
function qt(e3, t10, r3, n3 = true) {
  const o3 = t10 ? t10.vnode : null;
  if (t10) {
    let a3 = t10.parent;
    const l3 = t10.proxy, c3 = process.env.NODE_ENV !== "production" ? Jt[r3] : r3;
    for (; a3; ) {
      const i3 = a3.ec;
      if (i3) {
        for (let h10 = 0; h10 < i3.length; h10++)
          if (i3[h10](e3, l3, c3) === false)
            return;
      }
      a3 = a3.parent;
    }
    const u3 = t10.appContext.config.errorHandler;
    if (u3) {
      J$1(
        u3,
        null,
        10,
        [e3, l3, c3]
      );
      return;
    }
  }
  _o$1(e3, r3, o3, n3);
}
function _o$1(e3, t10, r3, n3 = true) {
  if (process.env.NODE_ENV !== "production") {
    const o3 = Jt[t10];
    if (r3 && fo$1(r3), _$1(`Unhandled error${o3 ? ` during execution of ${o3}` : ""}`), r3 && ho$1(), n3)
      throw e3;
    console.error(e3);
  } else
    console.error(e3);
}
let ve = false, Me$1 = false;
const T$2 = [];
let F$2 = 0;
const Q$1 = [];
let R$1 = null, M$2 = 0;
const Gt$1 = /* @__PURE__ */ Promise.resolve();
const vo$1 = 100;
function wo$1(e3) {
  let t10 = F$2 + 1, r3 = T$2.length;
  for (; t10 < r3; ) {
    const n3 = t10 + r3 >>> 1;
    oe(T$2[n3]) < e3 ? t10 = n3 + 1 : r3 = n3;
  }
  return t10;
}
function Qe$1(e3) {
  (!T$2.length || !T$2.includes(
    e3,
    ve && e3.allowRecurse ? F$2 + 1 : F$2
  )) && (e3.id == null ? T$2.push(e3) : T$2.splice(wo$1(e3.id), 0, e3), Lt$1());
}
function Lt$1() {
  !ve && !Me$1 && (Me$1 = true, Gt$1.then(Qt$1));
}
function Yt(e3) {
  p$5(e3) ? Q$1.push(...e3) : (!R$1 || !R$1.includes(
    e3,
    e3.allowRecurse ? M$2 + 1 : M$2
  )) && Q$1.push(e3), Lt$1();
}
function Eo$1(e3) {
  if (Q$1.length) {
    const t10 = [...new Set(Q$1)];
    if (Q$1.length = 0, R$1) {
      R$1.push(...t10);
      return;
    }
    for (R$1 = t10, process.env.NODE_ENV !== "production" && (e3 = e3 || /* @__PURE__ */ new Map()), R$1.sort((r3, n3) => oe(r3) - oe(n3)), M$2 = 0; M$2 < R$1.length; M$2++)
      process.env.NODE_ENV !== "production" && Xt(e3, R$1[M$2]) || R$1[M$2]();
    R$1 = null, M$2 = 0;
  }
}
const oe = (e3) => e3.id == null ? 1 / 0 : e3.id, No$1 = (e3, t10) => {
  const r3 = oe(e3) - oe(t10);
  if (r3 === 0) {
    if (e3.pre && !t10.pre)
      return -1;
    if (t10.pre && !e3.pre)
      return 1;
  }
  return r3;
};
function Qt$1(e3) {
  Me$1 = false, ve = true, process.env.NODE_ENV !== "production" && (e3 = e3 || /* @__PURE__ */ new Map()), T$2.sort(No$1);
  const t10 = process.env.NODE_ENV !== "production" ? (r3) => Xt(e3, r3) : Nt$1;
  try {
    for (F$2 = 0; F$2 < T$2.length; F$2++) {
      const r3 = T$2[F$2];
      if (r3 && r3.active !== false) {
        if (process.env.NODE_ENV !== "production" && t10(r3))
          continue;
        J$1(r3, null, 14);
      }
    }
  } finally {
    F$2 = 0, T$2.length = 0, Eo$1(e3), ve = false, (T$2.length || Q$1.length) && Qt$1(e3);
  }
}
function Xt(e3, t10) {
  if (!e3.has(t10))
    e3.set(t10, 1);
  else {
    const r3 = e3.get(t10);
    if (r3 > vo$1) {
      const n3 = t10.ownerInstance, o3 = n3 && tt$1(n3.type);
      return _$1(
        `Maximum recursive updates exceeded${o3 ? ` in component <${o3}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`
      ), true;
    } else
      e3.set(t10, r3 + 1);
  }
}
const X = /* @__PURE__ */ new Set();
process.env.NODE_ENV !== "production" && (Ce$1().__VUE_HMR_RUNTIME__ = {
  createRecord: ke$1(Oo),
  rerender: ke$1(ko$1),
  reload: ke$1(So$1)
});
const xe = /* @__PURE__ */ new Map();
function Oo(e3, t10) {
  return xe.has(e3) ? false : (xe.set(e3, {
    initialDef: te(t10),
    instances: /* @__PURE__ */ new Set()
  }), true);
}
function te(e3) {
  return ir$1(e3) ? e3.__vccOpts : e3;
}
function ko$1(e3, t10) {
  const r3 = xe.get(e3);
  r3 && (r3.initialDef.render = t10, [...r3.instances].forEach((n3) => {
    t10 && (n3.render = t10, te(n3.type).render = t10), n3.renderCache = [], n3.update();
  }));
}
function So$1(e3, t10) {
  const r3 = xe.get(e3);
  if (!r3)
    return;
  t10 = te(t10), dt$1(r3.initialDef, t10);
  const n3 = [...r3.instances];
  for (const o3 of n3) {
    const a3 = te(o3.type);
    X.has(a3) || (a3 !== r3.initialDef && dt$1(a3, t10), X.add(a3)), o3.appContext.propsCache.delete(o3.type), o3.appContext.emitsCache.delete(o3.type), o3.appContext.optionsCache.delete(o3.type), o3.ceReload ? (X.add(a3), o3.ceReload(t10.styles), X.delete(a3)) : o3.parent ? Qe$1(o3.parent.update) : o3.appContext.reload ? o3.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    );
  }
  Yt(() => {
    for (const o3 of n3)
      X.delete(
        te(o3.type)
      );
  });
}
function dt$1(e3, t10) {
  C$2(e3, t10);
  for (const r3 in e3)
    r3 !== "__file" && !(r3 in t10) && delete e3[r3];
}
function ke$1(e3) {
  return (t10, r3) => {
    try {
      return e3(t10, r3);
    } catch (n3) {
      console.error(n3), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let I$1 = null, Zt$1 = null;
const To = (e3) => e3.__isSuspense;
const er$1 = Symbol.for("v-ndc");
process.env.NODE_ENV !== "production" && ((e3) => (_$1(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(e3)));
const Bo$1 = (e3) => e3.__isTeleport, tr$2 = Symbol.for("v-fgt"), Jo$1 = Symbol.for("v-txt"), je = Symbol.for("v-cmt");
let D = null;
function Lo$1(e3) {
  return e3 ? e3.__v_isVNode === true : false;
}
const Yo$1 = (...e3) => lr$1(
  ...e3
), nr$1 = "__vInternal", ar$1 = ({ key: e3 }) => e3 ?? null, be = ({
  ref: e3,
  ref_key: t10,
  ref_for: r3
}) => (typeof e3 == "number" && (e3 = "" + e3), e3 != null ? V$1(e3) || N$3(e3) || v$2(e3) ? { i: I$1, r: e3, k: t10, f: !!r3 } : e3 : null);
function Qo(e3, t10 = null, r3 = null, n3 = 0, o3 = null, a3 = e3 === tr$2 ? 0 : 1, l3 = false, c3 = false) {
  const u3 = {
    __v_isVNode: true,
    __v_skip: true,
    type: e3,
    props: t10,
    key: t10 && ar$1(t10),
    ref: t10 && be(t10),
    scopeId: Zt$1,
    slotScopeIds: null,
    children: r3,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: a3,
    patchFlag: n3,
    dynamicProps: o3,
    dynamicChildren: null,
    appContext: null,
    ctx: I$1
  };
  return c3 ? (Ze(u3, r3), a3 & 128 && e3.normalize(u3)) : r3 && (u3.shapeFlag |= V$1(r3) ? 8 : 16), process.env.NODE_ENV !== "production" && u3.key !== u3.key && _$1("VNode created with invalid key (NaN). VNode type:", u3.type), // avoid a block node from tracking itself
  !l3 && // has current parent block
  D && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (u3.patchFlag > 0 || a3 & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  u3.patchFlag !== 32 && D.push(u3), u3;
}
const Xe = process.env.NODE_ENV !== "production" ? Yo$1 : lr$1;
function lr$1(e3, t10 = null, r3 = null, n3 = 0, o3 = null, a3 = false) {
  if ((!e3 || e3 === er$1) && (process.env.NODE_ENV !== "production" && !e3 && _$1(`Invalid vnode type when creating vnode: ${e3}.`), e3 = je), Lo$1(e3)) {
    const c3 = Ee(
      e3,
      t10,
      true
      /* mergeRef: true */
    );
    return r3 && Ze(c3, r3), !a3 && D && (c3.shapeFlag & 6 ? D[D.indexOf(e3)] = c3 : D.push(c3)), c3.patchFlag |= -2, c3;
  }
  if (ir$1(e3) && (e3 = e3.__vccOpts), t10) {
    t10 = Xo$1(t10);
    let { class: c3, style: u3 } = t10;
    c3 && !V$1(c3) && (t10.class = Ue(c3)), x$1(u3) && ($e$1(u3) && !p$5(u3) && (u3 = C$2({}, u3)), t10.style = He(u3));
  }
  const l3 = V$1(e3) ? 1 : To(e3) ? 128 : Bo$1(e3) ? 64 : x$1(e3) ? 4 : v$2(e3) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && l3 & 4 && $e$1(e3) && (e3 = f$2(e3), _$1(
    "Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    e3
  )), Qo(
    e3,
    t10,
    r3,
    n3,
    o3,
    l3,
    a3,
    true
  );
}
function Xo$1(e3) {
  return e3 ? $e$1(e3) || nr$1 in e3 ? C$2({}, e3) : e3 : null;
}
function Ee(e3, t10, r3 = false) {
  const { props: n3, ref: o3, patchFlag: a3, children: l3 } = e3, c3 = t10 ? en(n3 || {}, t10) : n3;
  return {
    __v_isVNode: true,
    __v_skip: true,
    type: e3.type,
    props: c3,
    key: c3 && ar$1(c3),
    ref: t10 && t10.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      r3 && o3 ? p$5(o3) ? o3.concat(be(t10)) : [o3, be(t10)] : be(t10)
    ) : o3,
    scopeId: e3.scopeId,
    slotScopeIds: e3.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && a3 === -1 && p$5(l3) ? l3.map(cr$1) : l3,
    target: e3.target,
    targetAnchor: e3.targetAnchor,
    staticCount: e3.staticCount,
    shapeFlag: e3.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t10 && e3.type !== tr$2 ? a3 === -1 ? 16 : a3 | 16 : a3,
    dynamicProps: e3.dynamicProps,
    dynamicChildren: e3.dynamicChildren,
    appContext: e3.appContext,
    dirs: e3.dirs,
    transition: e3.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e3.component,
    suspense: e3.suspense,
    ssContent: e3.ssContent && Ee(e3.ssContent),
    ssFallback: e3.ssFallback && Ee(e3.ssFallback),
    el: e3.el,
    anchor: e3.anchor,
    ctx: e3.ctx,
    ce: e3.ce
  };
}
function cr$1(e3) {
  const t10 = Ee(e3);
  return p$5(e3.children) && (t10.children = e3.children.map(cr$1)), t10;
}
function sr$1(e3 = " ", t10 = 0) {
  return Xe(Jo$1, null, e3, t10);
}
function Ze(e3, t10) {
  let r3 = 0;
  const { shapeFlag: n3 } = e3;
  if (t10 == null)
    t10 = null;
  else if (p$5(t10))
    r3 = 16;
  else if (typeof t10 == "object")
    if (n3 & 65) {
      const o3 = t10.default;
      o3 && (o3._c && (o3._d = false), Ze(e3, o3()), o3._c && (o3._d = true));
      return;
    } else {
      r3 = 32;
      const o3 = t10._;
      !o3 && !(nr$1 in t10) ? t10._ctx = I$1 : o3 === 3 && I$1 && (I$1.slots._ === 1 ? t10._ = 1 : (t10._ = 2, e3.patchFlag |= 1024));
    }
  else
    v$2(t10) ? (t10 = { default: t10, _ctx: I$1 }, r3 = 32) : (t10 = String(t10), n3 & 64 ? (r3 = 16, t10 = [sr$1(t10)]) : r3 = 8);
  e3.children = t10, e3.shapeFlag |= r3;
}
function en(...e3) {
  const t10 = {};
  for (let r3 = 0; r3 < e3.length; r3++) {
    const n3 = e3[r3];
    for (const o3 in n3)
      if (o3 === "class")
        t10.class !== n3.class && (t10.class = Ue([t10.class, n3.class]));
      else if (o3 === "style")
        t10.style = He([t10.style, n3.style]);
      else if (wr$1(o3)) {
        const a3 = t10[o3], l3 = n3[o3];
        l3 && a3 !== l3 && !(p$5(a3) && a3.includes(l3)) && (t10[o3] = a3 ? [].concat(a3, l3) : l3);
      } else
        o3 !== "" && (t10[o3] = n3[o3]);
  }
  return t10;
}
let L$1, xt$1 = "__VUE_INSTANCE_SETTERS__";
(L$1 = Ce$1()[xt$1]) || (L$1 = Ce$1()[xt$1] = []), L$1.push((e3) => e3);
const nn$1 = /(?:^|[-_])(\w)/g, an$1 = (e3) => e3.replace(nn$1, (t10) => t10.toUpperCase()).replace(/[-_]/g, "");
function tt$1(e3, t10 = true) {
  return v$2(e3) ? e3.displayName || e3.name : e3.name || t10 && e3.__name;
}
function ur$1(e3, t10, r3 = false) {
  let n3 = tt$1(t10);
  if (!n3 && t10.__file) {
    const o3 = t10.__file.match(/([^/\\]+)\.\w+$/);
    o3 && (n3 = o3[1]);
  }
  if (!n3 && e3 && e3.parent) {
    const o3 = (a3) => {
      for (const l3 in a3)
        if (a3[l3] === t10)
          return l3;
    };
    n3 = o3(
      e3.components || e3.parent.type.components
    ) || o3(e3.appContext.components);
  }
  return n3 ? an$1(n3) : r3 ? "App" : "Anonymous";
}
function ir$1(e3) {
  return v$2(e3) && "__vccOpts" in e3;
}
function Ve(e3) {
  return !!(e3 && e3.__v_isShallow);
}
function ln$1() {
  if (process.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const e3 = { style: "color:#3ba776" }, t10 = { style: "color:#0b1bc9" }, r3 = { style: "color:#b62e24" }, n3 = { style: "color:#9d288c" }, o3 = {
    header(s3) {
      return x$1(s3) ? s3.__isVue ? ["div", e3, "VueInstance"] : N$3(s3) ? [
        "div",
        {},
        ["span", e3, h10(s3)],
        "<",
        c3(s3.value),
        ">"
      ] : W(s3) ? [
        "div",
        {},
        ["span", e3, Ve(s3) ? "ShallowReactive" : "Reactive"],
        "<",
        c3(s3),
        `>${q(s3) ? " (readonly)" : ""}`
      ] : q(s3) ? [
        "div",
        {},
        ["span", e3, Ve(s3) ? "ShallowReadonly" : "Readonly"],
        "<",
        c3(s3),
        ">"
      ] : null : null;
    },
    hasBody(s3) {
      return s3 && s3.__isVue;
    },
    body(s3) {
      if (s3 && s3.__isVue)
        return [
          "div",
          {},
          ...a3(s3.$)
        ];
    }
  };
  function a3(s3) {
    const d3 = [];
    s3.type.props && s3.props && d3.push(l3("props", f$2(s3.props))), s3.setupState !== $ && d3.push(l3("setup", s3.setupState)), s3.data !== $ && d3.push(l3("data", f$2(s3.data)));
    const b10 = u3(s3, "computed");
    b10 && d3.push(l3("computed", b10));
    const k10 = u3(s3, "inject");
    return k10 && d3.push(l3("injected", k10)), d3.push([
      "div",
      {},
      [
        "span",
        {
          style: n3.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: s3 }]
    ]), d3;
  }
  function l3(s3, d3) {
    return d3 = C$2({}, d3), Object.keys(d3).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        s3
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(d3).map((b10) => [
          "div",
          {},
          ["span", n3, b10 + ": "],
          c3(d3[b10], false)
        ])
      ]
    ] : ["span", {}];
  }
  function c3(s3, d3 = true) {
    return typeof s3 == "number" ? ["span", t10, s3] : typeof s3 == "string" ? ["span", r3, JSON.stringify(s3)] : typeof s3 == "boolean" ? ["span", n3, s3] : x$1(s3) ? ["object", { object: d3 ? f$2(s3) : s3 }] : ["span", r3, String(s3)];
  }
  function u3(s3, d3) {
    const b10 = s3.type;
    if (v$2(b10))
      return;
    const k10 = {};
    for (const S10 in s3.ctx)
      i3(b10, S10, d3) && (k10[S10] = s3.ctx[S10]);
    return k10;
  }
  function i3(s3, d3, b10) {
    const k10 = s3[b10];
    if (p$5(k10) && k10.includes(d3) || x$1(k10) && d3 in k10 || s3.extends && i3(s3.extends, d3, b10) || s3.mixins && s3.mixins.some((S10) => i3(S10, d3, b10)))
      return true;
  }
  function h10(s3) {
    return Ve(s3) ? "ShallowRef" : s3.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(o3) : window.devtoolsFormatters = [o3];
}
function cn$1() {
  ln$1();
}
process.env.NODE_ENV !== "production" && cn$1();
const toLowerCase$1 = (s3) => s3.toLowerCase();
const trimLeftRegex$1 = /^\s*/g;
const trimLeft$1 = (s3) => s3.replace(trimLeftRegex$1, "");
const fromCamelCaseRegex$1 = /([A-Z])/g;
const fromCamelCase$1 = (s3, separator) => trimLeft$1(s3.replace(fromCamelCaseRegex$1, (match) => `${separator}${toLowerCase$1(match)}`));
const _encodeUtf8Polyfill$1 = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i3 = 0; i3 < len; i3++) {
    buf[i3] = /** @type {number} */
    encodedString.codePointAt(i3);
  }
  return buf;
};
const utf8TextEncoder$1 = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
const _encodeUtf8Native$1 = (str) => utf8TextEncoder$1.encode(str);
const encodeUtf8$1 = utf8TextEncoder$1 ? _encodeUtf8Native$1 : _encodeUtf8Polyfill$1;
let utf8TextDecoder$1 = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder$1 && utf8TextDecoder$1.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder$1 = null;
}
const create$1 = () => /* @__PURE__ */ new Map();
const undefinedToNull$1 = (v10) => v10 === void 0 ? null : v10;
let VarStoragePolyfill$1 = class VarStoragePolyfill {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key2, newValue) {
    this.map.set(key2, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key2) {
    return this.map.get(key2);
  }
};
let _localStorage$1 = new VarStoragePolyfill$1();
let usePolyfill$1 = true;
try {
  if (typeof localStorage !== "undefined") {
    _localStorage$1 = localStorage;
    usePolyfill$1 = false;
  }
} catch (e3) {
}
const varStorage$1 = _localStorage$1;
const isOneOf$1 = (value, options) => options.includes(value);
const isNode$1 = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name);
let params$1;
const computeParams$1 = () => {
  if (params$1 === void 0) {
    if (isNode$1) {
      params$1 = create$1();
      const pargs = process.argv;
      let currParamName = null;
      for (let i3 = 0; i3 < pargs.length; i3++) {
        const parg = pargs[i3];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params$1.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params$1.set(currParamName, parg);
            currParamName = null;
          }
        }
      }
      if (currParamName !== null) {
        params$1.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params$1 = create$1();
      (location.search || "?").slice(1).split("&").forEach((kv2) => {
        if (kv2.length !== 0) {
          const [key2, value] = kv2.split("=");
          params$1.set(`--${fromCamelCase$1(key2, "-")}`, value);
          params$1.set(`-${fromCamelCase$1(key2, "-")}`, value);
        }
      });
    } else {
      params$1 = create$1();
    }
  }
  return params$1;
};
const hasParam$1 = (name2) => computeParams$1().has(name2);
const getVariable$1 = (name2) => isNode$1 ? undefinedToNull$1(process.env[name2.toUpperCase()]) : undefinedToNull$1(varStorage$1.getItem(name2));
const hasConf$1 = (name2) => hasParam$1("--" + name2) || getVariable$1(name2) !== null;
hasConf$1("production");
const forceColor$1 = isNode$1 && isOneOf$1(process.env.FORCE_COLOR, ["true", "1", "2"]);
!hasParam$1("no-colors") && (!isNode$1 || process.stdout.isTTY || forceColor$1) && (!isNode$1 || hasParam$1("color") || forceColor$1 || getVariable$1("COLORTERM") !== null || (getVariable$1("TERM") || "").includes("color"));
const BIT8$1 = 128;
const BITS7$1 = 127;
const floor$1 = Math.floor;
const min$1 = (a3, b10) => a3 < b10 ? a3 : b10;
const max$1 = (a3, b10) => a3 > b10 ? a3 : b10;
const write$1 = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
const writeVarUint$1 = (encoder, num) => {
  while (num > BITS7$1) {
    write$1(encoder, BIT8$1 | BITS7$1 & num);
    num = floor$1(num / 128);
  }
  write$1(encoder, BITS7$1 & num);
};
const _strBuffer$1 = new Uint8Array(3e4);
const _maxStrBSize$1 = _strBuffer$1.length / 3;
const _writeVarStringNative$1 = (encoder, str) => {
  if (str.length < _maxStrBSize$1) {
    const written = utf8TextEncoder$1.encodeInto(str, _strBuffer$1).written || 0;
    writeVarUint$1(encoder, written);
    for (let i3 = 0; i3 < written; i3++) {
      write$1(encoder, _strBuffer$1[i3]);
    }
  } else {
    writeVarUint8Array$1(encoder, encodeUtf8$1(str));
  }
};
const _writeVarStringPolyfill$1 = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint$1(encoder, len);
  for (let i3 = 0; i3 < len; i3++) {
    write$1(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i3)
    );
  }
};
utf8TextEncoder$1 && /** @type {any} */
utf8TextEncoder$1.encodeInto ? _writeVarStringNative$1 : _writeVarStringPolyfill$1;
const writeUint8Array$1 = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min$1(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max$1(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
const writeVarUint8Array$1 = (encoder, uint8Array) => {
  writeVarUint$1(encoder, uint8Array.byteLength);
  writeUint8Array$1(encoder, uint8Array);
};
var AuthMessageType;
(function(AuthMessageType2) {
  AuthMessageType2[AuthMessageType2["Token"] = 0] = "Token";
  AuthMessageType2[AuthMessageType2["PermissionDenied"] = 1] = "PermissionDenied";
  AuthMessageType2[AuthMessageType2["Authenticated"] = 2] = "Authenticated";
})(AuthMessageType || (AuthMessageType = {}));
var WsReadyStates;
(function(WsReadyStates2) {
  WsReadyStates2[WsReadyStates2["Connecting"] = 0] = "Connecting";
  WsReadyStates2[WsReadyStates2["Open"] = 1] = "Open";
  WsReadyStates2[WsReadyStates2["Closing"] = 2] = "Closing";
  WsReadyStates2[WsReadyStates2["Closed"] = 3] = "Closed";
})(WsReadyStates || (WsReadyStates = {}));
const create$2 = () => /* @__PURE__ */ new Map();
const toLowerCase = (s3) => s3.toLowerCase();
const trimLeftRegex = /^\s*/g;
const trimLeft = (s3) => s3.replace(trimLeftRegex, "");
const fromCamelCaseRegex = /([A-Z])/g;
const fromCamelCase = (s3, separator) => trimLeft(s3.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
const _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i3 = 0; i3 < len; i3++) {
    buf[i3] = /** @type {number} */
    encodedString.codePointAt(i3);
  }
  return buf;
};
const utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
const _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
let utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}
const undefinedToNull = (v10) => v10 === void 0 ? null : v10;
class VarStoragePolyfill2 {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key2, newValue) {
    this.map.set(key2, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key2) {
    return this.map.get(key2);
  }
}
let _localStorage = new VarStoragePolyfill2();
let usePolyfill = true;
try {
  if (typeof localStorage !== "undefined") {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e3) {
}
const varStorage = _localStorage;
const isOneOf = (value, options) => options.includes(value);
const isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name);
let params;
const computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create$2();
      const pargs = process.argv;
      let currParamName = null;
      for (let i3 = 0; i3 < pargs.length; i3++) {
        const parg = pargs[i3];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create$2();
      (location.search || "?").slice(1).split("&").forEach((kv2) => {
        if (kv2.length !== 0) {
          const [key2, value] = kv2.split("=");
          params.set(`--${fromCamelCase(key2, "-")}`, value);
          params.set(`-${fromCamelCase(key2, "-")}`, value);
        }
      });
    } else {
      params = create$2();
    }
  }
  return params;
};
const hasParam = (name2) => computeParams().has(name2);
const getVariable = (name2) => isNode ? undefinedToNull(process.env[name2.toUpperCase()]) : undefinedToNull(varStorage.getItem(name2));
const hasConf = (name2) => hasParam("--" + name2) || getVariable(name2) !== null;
hasConf("production");
const forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
!hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));
const floor = Math.floor;
const min = (a3, b10) => a3 < b10 ? a3 : b10;
const max = (a3, b10) => a3 > b10 ? a3 : b10;
const BIT8 = 128;
const BITS7 = 127;
const write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
const writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
const _strBuffer = new Uint8Array(3e4);
const _maxStrBSize = _strBuffer.length / 3;
const _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i3 = 0; i3 < written; i3++) {
      write(encoder, _strBuffer[i3]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
const _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i3 = 0; i3 < len; i3++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i3)
    );
  }
};
utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
const writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
const writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var MessageType;
(function(MessageType2) {
  MessageType2[MessageType2["Sync"] = 0] = "Sync";
  MessageType2[MessageType2["Awareness"] = 1] = "Awareness";
  MessageType2[MessageType2["Auth"] = 2] = "Auth";
  MessageType2[MessageType2["QueryAwareness"] = 3] = "QueryAwareness";
  MessageType2[MessageType2["Stateless"] = 5] = "Stateless";
  MessageType2[MessageType2["CLOSE"] = 7] = "CLOSE";
  MessageType2[MessageType2["SyncStatus"] = 8] = "SyncStatus";
})(MessageType || (MessageType = {}));
var WebSocketStatus;
(function(WebSocketStatus2) {
  WebSocketStatus2["Connecting"] = "connecting";
  WebSocketStatus2["Connected"] = "connected";
  WebSocketStatus2["Disconnected"] = "disconnected";
})(WebSocketStatus || (WebSocketStatus = {}));
const DefaultBufferLength = 1024;
let nextPropID = 0;
let Range$1 = class Range {
  constructor(from, to2) {
    this.from = from;
    this.to = to2;
  }
};
class NodeProp {
  /**
  Create a new node prop type.
  */
  constructor(config = {}) {
    this.id = nextPropID++;
    this.perNode = !!config.perNode;
    this.deserialize = config.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
}
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
class MountedTree {
  constructor(tree, overlay, parser) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
}
const noProps = /* @__PURE__ */ Object.create(null);
class NodeType {
  /**
  @internal
  */
  constructor(name2, props, id2, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map2) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map2)
      for (let name2 of prop.split(" "))
        direct[name2] = map2[prop];
    return (node2) => {
      for (let groups = node2.prop(NodeProp.group), i3 = -1; i3 < (groups ? groups.length : 0); i3++) {
        let found = direct[i3 < 0 ? node2.name : groups[i3]];
        if (found)
          return found;
      }
    };
  }
}
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
const CachedNode = /* @__PURE__ */ new WeakMap(), CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
class Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children2, positions, length, props) {
    this.type = type;
    this.children = children2;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children2 = "";
    for (let ch2 of this.children) {
      let str = ch2.toString();
      if (str) {
        if (children2)
          children2 += ",";
        children2 += str;
      }
    }
    return !this.type.name ? children2 : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children2.length ? "(" + children2 + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node2 = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node2);
    return node2;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node2 = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node2);
    return node2;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from = 0, to: to2 = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c3 = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c3.from <= to2 && c3.to >= from && (!anon && c3.type.isAnonymous || enter(c3) !== false)) {
        if (c3.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c3.type.isAnonymous))
          leave(c3);
        if (c3.nextSibling())
          break;
        if (!c3.parent())
          return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children2, positions, length) => new Tree(this.type, children2, positions, length, this.propValues), config.makeTree || ((children2, positions, length) => new Tree(NodeType.none, children2, positions, length)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data) {
    return buildTree(data);
  }
}
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
  constructor(buffer, index2) {
    this.buffer = buffer;
    this.index = index2;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
}
class TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result = [];
    for (let index2 = 0; index2 < this.buffer.length; ) {
      result.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result.join(",");
  }
  /**
  @internal
  */
  childString(index2) {
    let id2 = this.buffer[index2], endIndex = this.buffer[index2 + 3];
    let type = this.set.types[id2], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index2 += 4;
    if (endIndex == index2)
      return result;
    let children2 = [];
    while (index2 < endIndex) {
      children2.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result + "(" + children2.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i3 = startIndex; i3 != endIndex; i3 = buffer[i3 + 3]) {
      if (checkSide(side, pos, buffer[i3 + 1], buffer[i3 + 2])) {
        pick = i3;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  /**
  @internal
  */
  slice(startI, endI, from) {
    let b10 = this.buffer;
    let copy = new Uint16Array(endI - startI), len = 0;
    for (let i3 = startI, j10 = 0; i3 < endI; ) {
      copy[j10++] = b10[i3++];
      copy[j10++] = b10[i3++] - from;
      let to2 = copy[j10++] = b10[i3++] - from;
      copy[j10++] = b10[i3++] - startI;
      len = Math.max(len, to2);
    }
    return new TreeBuffer(copy, len, this.set);
  }
}
function checkSide(side, pos, from, to2) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to2 >= pos && from < pos;
    case 0:
      return from < pos && to2 > pos;
    case 1:
      return from <= pos && to2 > pos;
    case 2:
      return to2 > pos;
    case 4:
      return true;
  }
}
function resolveNode(node2, pos, side, overlays) {
  var _a2;
  while (node2.from == node2.to || (side < 1 ? node2.from >= pos : node2.from > pos) || (side > -1 ? node2.to <= pos : node2.to < pos)) {
    let parent = !overlays && node2 instanceof TreeNode && node2.index < 0 ? null : node2.parent;
    if (!parent)
      return node2;
    node2 = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node2, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
        node2 = parent;
    }
  for (; ; ) {
    let inner = node2.enter(pos, side, mode);
    if (!inner)
      return node2;
    node2 = inner;
  }
}
class BaseNode {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before = null, after = null) {
    let r3 = getChildren(this, type, before, after);
    return r3.length ? r3[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node2 = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node2 = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node2;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class TreeNode extends BaseNode {
  constructor(_tree, from, index2, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index2;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i3, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children: children2, positions } = parent._tree, e3 = dir > 0 ? children2.length : -1; i3 != e3; i3 += dir) {
        let next = children2[i3], start = positions[i3] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index2 = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index2 > -1)
            return new BufferNode(new BufferContext(parent, next, i3, start), null, index2);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
            return new TreeNode(mounted.tree, start, i3, parent);
          let inner = new TreeNode(next, start, i3, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i3 = parent.index + dir;
      else
        i3 = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to: to2 } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to2 >= rPos : to2 > rPos))
          return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function getChildren(node2, type, before, after) {
  let cur = node2.cursor(), result = [];
  if (!cur.firstChild())
    return result;
  if (before != null) {
    while (!cur.type.is(before))
      if (!cur.nextSibling())
        return result;
  }
  for (; ; ) {
    if (after != null && cur.type.is(after))
      return result;
    if (cur.type.is(type))
      result.push(cur.node);
    if (!cur.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node2, context, i3 = context.length - 1) {
  for (let p10 = node2.parent; i3 >= 0; p10 = p10.parent) {
    if (!p10)
      return false;
    if (!p10.type.isAnonymous) {
      if (context[i3] && context[i3] != p10.name)
        return false;
      i3--;
    }
  }
  return true;
}
class BufferContext {
  constructor(parent, buffer, index2, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index2;
    this.start = start;
  }
}
class BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index2) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index2;
    this.type = context.buffer.set.types[context.buffer.buffer[index2]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index2 < 0 ? null : new BufferNode(this.context, this, index2);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index2 < 0 ? null : new BufferNode(this.context, this, index2);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children2 = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children2.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children2, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function iterStack(heads) {
  if (!heads.length)
    return null;
  if (heads.length == 1)
    return heads[0];
  let pick = 0, picked = heads[0];
  for (let i3 = 1; i3 < heads.length; i3++) {
    let node2 = heads[i3];
    if (node2.from > picked.from || node2.to < picked.to) {
      picked = node2;
      pick = i3;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick] = next;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
class StackIterator {
  constructor(heads, node2) {
    this.heads = heads;
    this.node = node2;
  }
  get next() {
    return iterStack(this.heads);
  }
}
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root2 = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, 0, null);
        (layers || (layers = [inner])).push(resolveNode(root2, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
class TreeCursor {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node2, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node2 instanceof TreeNode) {
      this.yieldNode(node2);
    } else {
      this._tree = node2.context.parent;
      this.buffer = node2.context;
      for (let n3 = node2._parent; n3; n3 = n3._parent)
        this.stack.unshift(n3.index);
      this.bufferNode = node2;
      this.yieldBuf(node2.index);
    }
  }
  yieldNode(node2) {
    if (!node2)
      return false;
    this._tree = node2;
    this.type = node2.type;
    this.from = node2.from;
    this.to = node2.to;
    return true;
  }
  yieldBuf(index2, type) {
    this.index = index2;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index2]];
    this.from = start + buffer.buffer[index2 + 1];
    this.to = start + buffer.buffer[index2 + 2];
    return true;
  }
  yield(node2) {
    if (!node2)
      return false;
    if (node2 instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node2);
    }
    this.buffer = node2.context;
    return this.yieldBuf(node2.index, node2.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index2 < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index2);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d3 = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d3 < 0 ? 0 : this.stack[d3] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d3 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d3] + 3]))
        return this.yieldBuf(after);
    }
    return d3 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index2, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i3 = 0; i3 < this.index; i3++)
          if (buffer.buffer.buffer[i3 + 3] < this.index)
            return false;
      }
      ({ index: index2, parent } = buffer);
    } else {
      ({ index: index2, _parent: parent } = this._tree);
    }
    for (; parent; { index: index2, _parent: parent } = parent) {
      if (index2 > -1)
        for (let i3 = index2 + dir, e3 = dir < 0 ? -1 : parent._tree.children.length; i3 != e3; i3 += dir) {
          let child = parent._tree.children[i3];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth = 0;
    if (cache && cache.context == this.buffer) {
      scan:
        for (let index2 = this.index, d3 = this.stack.length; d3 >= 0; ) {
          for (let c3 = cache; c3; c3 = c3._parent)
            if (c3.index == index2) {
              if (index2 == this.index)
                return c3;
              result = c3;
              depth = d3 + 1;
              break scan;
            }
          index2 = this.stack[--d3];
        }
    }
    for (let i3 = depth; i3 < this.stack.length; i3++)
      result = new BufferNode(this.buffer, result, this.stack[i3]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (this.nextSibling())
          break;
        if (!depth)
          return;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node, context);
    let { buffer } = this.buffer, { types: types2 } = buffer.set;
    for (let i3 = context.length - 1, d3 = this.stack.length - 1; i3 >= 0; d3--) {
      if (d3 < 0)
        return matchNodeContext(this.node, context, i3);
      let type = types2[buffer.buffer[this.stack[d3]]];
      if (!type.isAnonymous) {
        if (context[i3] && context[i3] != type.name)
          return false;
        i3--;
      }
    }
    return true;
  }
}
function hasChild(tree) {
  return tree.children.some((ch2) => ch2 instanceof TreeBuffer || !ch2.type.isAnonymous || hasChild(ch2));
}
function buildTree(data) {
  var _a2;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children3, positions2, inRepeat) {
    let { id: id2, start, end, size } = cursor;
    let lookAheadAtStart = lookAhead;
    while (size < 0) {
      cursor.next();
      if (size == -1) {
        let node3 = reused[id2];
        children3.push(node3);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types2[id2], node2, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index2 = data2.length;
      while (cursor.pos > endPos)
        index2 = copyToBuffer(buffer2.start, data2, index2);
      node2 = new TreeBuffer(data2, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type);
        node2 = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node2 = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
      }
    }
    children3.push(node2);
    positions2.push(startPos);
  }
  function makeBalanced(type) {
    return (children3, positions2, length2) => {
      let lookAhead2 = 0, lastI = children3.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children3[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children3, positions2, length2, lookAhead2);
    };
  }
  function makeRepeatLeaf(children3, positions2, base2, i3, from, to2, type, lookAhead2) {
    let localChildren = [], localPositions = [];
    while (children3.length > i3) {
      localChildren.push(children3.pop());
      localPositions.push(positions2.pop() + base2 - from);
    }
    children3.push(makeTree(nodeSet.types[type], localChildren, localPositions, to2 - from, lookAhead2 - to2));
    positions2.push(from - base2);
  }
  function makeTree(type, children3, positions2, length2, lookAhead2 = 0, props) {
    if (contextHash) {
      let pair = [NodeProp.contextHash, contextHash];
      props = props ? [pair].concat(props) : [pair];
    }
    if (lookAhead2 > 25) {
      let pair = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair].concat(props) : [pair];
    }
    return new Tree(type, children3, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan:
      for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart;
        size += nodeSize2;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index2) {
    let { id: id2, start, end, size } = cursor;
    cursor.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index2;
      if (size > 4) {
        let endPos = cursor.pos - (size - 4);
        while (cursor.pos > endPos)
          index2 = copyToBuffer(bufferStart, buffer2, index2);
      }
      buffer2[--index2] = startIndex;
      buffer2[--index2] = end - bufferStart;
      buffer2[--index2] = start - bufferStart;
      buffer2[--index2] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index2;
  }
  let children2 = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children2, positions, -1);
  let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children2.length ? positions[0] + children2[0].length : 0;
  return new Tree(types2[data.topID], children2.reverse(), positions.reverse(), length);
}
const nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node2) {
  if (!balanceType.isAnonymous || node2 instanceof TreeBuffer || node2.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node2);
  if (size == null) {
    size = 1;
    for (let child of node2.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node2, size);
  }
  return size;
}
function balanceRange(balanceType, children2, positions, from, to2, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i3 = from; i3 < to2; i3++)
    total += nodeSize(balanceType, children2[i3]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children3, positions2, from2, to3, offset) {
    for (let i3 = from2; i3 < to3; ) {
      let groupFrom = i3, groupStart = positions2[i3], groupSize = nodeSize(balanceType, children3[i3]);
      i3++;
      for (; i3 < to3; i3++) {
        let nextSize = nodeSize(balanceType, children3[i3]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i3 == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children3[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children3[groupFrom]);
      } else {
        let length2 = positions2[i3 - 1] + children3[i3 - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children3, positions2, groupFrom, i3, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children2, positions, from, to2, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
class TreeFragment {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(from, to2, tree, offset, openStart = false, openEnd = false) {
    this.from = from;
    this.to = to2;
    this.tree = tree;
    this.offset = offset;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(tree, fragments = [], partial = false) {
    let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
    for (let f3 of fragments)
      if (f3.to > tree.length)
        result.push(f3);
    return result;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
}
class Parser {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range$1(0, input.length)] : ranges.length ? ranges.map((r3) => new Range$1(r3.from, r3.to)) : [new Range$1(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input, fragments, ranges) {
    let parse2 = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse2.advance();
      if (done)
        return done;
    }
  }
}
class StringInput {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to2) {
    return this.string.slice(from, to2);
  }
}
new NodeProp({ perNode: true });
let nextTagID = 0;
class Tag {
  /**
  @internal
  */
  constructor(set, base2, modified) {
    this.set = set;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(parent) {
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new Tag([], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t10 of parent.set)
        tag.set.push(t10);
    return tag;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let mod = new Modifier();
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a3, b10) => a3.id - b10.id));
    };
  }
}
let nextModifierID = 0;
class Modifier {
  constructor() {
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t10) => t10.base == base2 && sameArray$1(mods, t10.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(set, base2, mods);
    for (let m10 of mods)
      m10.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base2.set)
      if (!parent.modified.length)
        for (let config of configs)
          set.push(Modifier.get(parent, config));
    return tag;
  }
}
function sameArray$1(a3, b10) {
  return a3.length == b10.length && a3.every((x10, i3) => x10 == b10[i3]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i3 = 0; i3 < array.length; i3++) {
    for (let j10 = 0, e3 = sets.length; j10 < e3; j10++) {
      sets.push(sets[j10].concat(array[i3]));
    }
  }
  return sets.sort((a3, b10) => b10.length - a3.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m10 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m10)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m10[0] == "*" ? "" : m10[0][0] == '"' ? JSON.parse(m10[0]) : m10[0]);
          pos += m10[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
const ruleNodeProp = new NodeProp();
class Rule {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags2, options) {
  let map2 = /* @__PURE__ */ Object.create(null);
  for (let style2 of tags2) {
    if (!Array.isArray(style2.tag))
      map2[style2.tag.id] = style2.class;
    else
      for (let tag of style2.tag)
        map2[tag.id] = style2.class;
  }
  let { scope, all: all2 = null } = options || {};
  return {
    style: (tags3) => {
      let cls = all2;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map2[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags2) {
  let result = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags2);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree, highlighter, putStyle, from = 0, to2 = tree.length) {
  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree.cursor(), from, to2, "", builder.highlighters);
  builder.flush(to2);
}
class HighlightBuilder {
  constructor(at, highlighters, span) {
    this.at = at;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at);
      if (at > this.at)
        this.at = at;
      this.class = cls;
    }
  }
  flush(to2) {
    if (to2 > this.at && this.class)
      this.span(this.at, to2, this.class);
  }
  highlightRange(cursor, from, to2, inheritedClass, highlighters) {
    let { type, from: start, to: end } = cursor;
    if (start >= to2 || end <= from)
      return;
    if (type.isTop)
      highlighters = this.highlighters.filter((h10) => !h10.scope || h10.scope(type));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls)
        cls += " ";
      cls += tagCls;
      if (rule.mode == 1)
        inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(Math.max(from, start), cls);
    if (rule.opaque)
      return;
    let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
      let innerHighlighters = this.highlighters.filter((h10) => !h10.scope || h10.scope(mounted.tree.type));
      let hasChild2 = cursor.firstChild();
      for (let i3 = 0, pos = start; ; i3++) {
        let next = i3 < mounted.overlay.length ? mounted.overlay[i3] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to2, nextPos);
        if (rangeFrom < rangeTo && hasChild2) {
          while (cursor.from < rangeTo) {
            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo, cursor.to), cls);
            if (cursor.to >= nextPos || !cursor.nextSibling())
              break;
          }
        }
        if (!next || nextPos > to2)
          break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to2, pos), "", innerHighlighters);
          this.startSpan(Math.min(to2, pos), cls);
        }
      }
      if (hasChild2)
        cursor.parent();
    } else if (cursor.firstChild()) {
      if (mounted)
        inheritedClass = "";
      do {
        if (cursor.to <= from)
          continue;
        if (cursor.from >= to2)
          break;
        this.highlightRange(cursor, from, to2, inheritedClass, highlighters);
        this.startSpan(Math.min(to2, cursor.to), cls);
      } while (cursor.nextSibling());
      cursor.parent();
    }
  }
}
function getStyleTags(node2) {
  let rule = node2.type.prop(ruleNodeProp);
  while (rule && rule.context && !node2.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
const t$5 = Tag.define;
const comment$1 = t$5(), name = t$5(), typeName = t$5(name), propertyName = t$5(name), literal = t$5(), string = t$5(literal), number$1 = t$5(literal), content = t$5(), heading = t$5(content), keyword = t$5(), operator = t$5(), punctuation = t$5(), bracket = t$5(punctuation), meta = t$5();
const tags = {
  /**
  A comment.
  */
  comment: comment$1,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t$5(comment$1),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t$5(comment$1),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t$5(comment$1),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t$5(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t$5(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t$5(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t$5(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t$5(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t$5(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t$5(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t$5(string),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t$5(string),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t$5(string),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: number$1,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t$5(number$1),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t$5(number$1),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t$5(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t$5(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t$5(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t$5(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t$5(literal),
  /**
  A language keyword.
  */
  keyword,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t$5(keyword),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t$5(keyword),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t$5(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t$5(keyword),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t$5(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t$5(keyword),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t$5(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t$5(keyword),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t$5(keyword),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t$5(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t$5(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t$5(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t$5(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t$5(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t$5(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t$5(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t$5(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t$5(operator),
  /**
  Program or markup punctuation.
  */
  punctuation,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t$5(punctuation),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t$5(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t$5(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t$5(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t$5(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t$5(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t$5(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t$5(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t$5(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t$5(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t$5(heading),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: t$5(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t$5(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t$5(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t$5(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t$5(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t$5(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t$5(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t$5(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t$5(),
  /**
  Deleted text.
  */
  deleted: t$5(),
  /**
  Changed text.
  */
  changed: t$5(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t$5(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t$5(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t$5(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t$5(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag.defineModifier()
};
tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);
class Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n3) {
    if (n3 < 1 || n3 > this.lines)
      throw new RangeError(`Invalid line number ${n3} in ${this.lines}-line document`);
    return this.lineInner(n3, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from, to2, text2) {
    let parts = [];
    this.decompose(
      0,
      from,
      parts,
      2
      /* Open.To */
    );
    if (text2.length)
      text2.decompose(
        0,
        text2.length,
        parts,
        1 | 2
        /* Open.To */
      );
    this.decompose(
      to2,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to2 - from) + text2.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from, to2 = this.length) {
    let parts = [];
    this.decompose(from, to2, parts, 0);
    return TextNode.from(parts, to2 - from);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a3 = new RawTextCursor(this), b10 = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a3.next(skip);
      b10.next(skip);
      skip = 0;
      if (a3.lineBreak != b10.lineBreak || a3.done != b10.done || a3.value != b10.value)
        return false;
      pos += a3.value.length;
      if (a3.done || pos >= end)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from, to2 = this.length) {
    return new PartialTextCursor(this, from, to2);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from, to2) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to2 == null)
        to2 = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to2 == this.lines + 1 ? this.length : to2 <= 1 ? 0 : this.line(to2 - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text2) {
    if (text2.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text2.length == 1 && !text2[0])
      return Text.empty;
    return text2.length <= 32 ? new TextLeaf(text2) : TextNode.from(TextLeaf.split(text2, []));
  }
}
class TextLeaf extends Text {
  constructor(text2, length = textLength(text2)) {
    super();
    this.text = text2;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i3 = 0; ; i3++) {
      let string2 = this.text[i3], end = offset + string2.length;
      if ((isLine ? line : end) >= target)
        return new Line(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to2, target, open) {
    let text2 = from <= 0 && to2 >= this.length ? this : new TextLeaf(sliceText(this.text, from, to2), Math.min(to2, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text2.text, prev.text.slice(), 0, text2.length);
      if (joined.length <= 32) {
        target.push(new TextLeaf(joined, prev.length + text2.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text2);
    }
  }
  replace(from, to2, text2) {
    if (!(text2 instanceof TextLeaf))
      return super.replace(from, to2, text2);
    let lines = appendText(this.text, appendText(text2.text, sliceText(this.text, 0, from)), to2);
    let newLen = this.length + text2.length - (to2 - from);
    if (lines.length <= 32)
      return new TextLeaf(lines, newLen);
    return TextNode.from(TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to2 = this.length, lineSep = "\n") {
    let result = "";
    for (let pos = 0, i3 = 0; pos <= to2 && i3 < this.text.length; i3++) {
      let line = this.text[i3], end = pos + line.length;
      if (pos > from && i3)
        result += lineSep;
      if (from < end && to2 > pos)
        result += line.slice(Math.max(0, from - pos), to2 - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line of this.text)
      target.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text2, target) {
    let part = [], len = -1;
    for (let line of text2) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new TextLeaf(part, len));
    return target;
  }
}
class TextNode extends Text {
  constructor(children2, length) {
    super();
    this.children = children2;
    this.length = length;
    this.lines = 0;
    for (let child of children2)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset) {
    for (let i3 = 0; ; i3++) {
      let child = this.children[i3], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target)
        return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to2, target, open) {
    for (let i3 = 0, pos = 0; pos <= to2 && i3 < this.children.length; i3++) {
      let child = this.children[i3], end = pos + child.length;
      if (from <= end && to2 >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to2 ? 2 : 0));
        if (pos >= from && end <= to2 && !childOpen)
          target.push(child);
        else
          child.decompose(from - pos, to2 - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to2, text2) {
    if (text2.lines < this.lines)
      for (let i3 = 0, pos = 0; i3 < this.children.length; i3++) {
        let child = this.children[i3], end = pos + child.length;
        if (from >= pos && to2 <= end) {
          let updated = child.replace(from - pos, to2 - pos, text2);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy = this.children.slice();
            copy[i3] = updated;
            return new TextNode(copy, this.length - (to2 - from) + text2.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to2, text2);
  }
  sliceString(from, to2 = this.length, lineSep = "\n") {
    let result = "";
    for (let i3 = 0, pos = 0; i3 < this.children.length && pos <= to2; i3++) {
      let child = this.children[i3], end = pos + child.length;
      if (pos > from && i3)
        result += lineSep;
      if (from < end && to2 > pos)
        result += child.sliceString(from - pos, to2 - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof TextNode))
      return 0;
    let length = 0;
    let [iA2, iB2, eA2, eB2] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA2 += dir, iB2 += dir) {
      if (iA2 == eA2 || iB2 == eB2)
        return length;
      let chA = this.children[iA2], chB = other.children[iB2];
      if (chA != chB)
        return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children2, length = children2.reduce((l3, ch2) => l3 + ch2.length + 1, -1)) {
    let lines = 0;
    for (let ch2 of children2)
      lines += ch2.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch2 of children2)
        ch2.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add(child) {
      let last;
      if (child.lines > maxChunk && child instanceof TextNode) {
        for (let node2 of child.children)
          add(node2);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children2)
      add(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
  }
}
Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
function textLength(text2) {
  let length = -1;
  for (let line of text2)
    length += line.length + 1;
  return length;
}
function appendText(text2, target, from = 0, to2 = 1e9) {
  for (let pos = 0, i3 = 0, first = true; i3 < text2.length && pos <= to2; i3++) {
    let line = text2[i3], end = pos + line.length;
    if (end >= from) {
      if (end > to2)
        line = line.slice(0, to2 - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text2, from, to2) {
  return appendText(text2, [""], from, to2);
}
class RawTextCursor {
  constructor(text2, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text2];
    this.offsets = [dir > 0 ? 1 : (text2 instanceof TextLeaf ? text2.text.length : text2.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last = this.nodes.length - 1;
      let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0)
            this.offsets[last]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
}
class PartialTextCursor {
  constructor(text2, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text2, start > end ? -1 : 1);
    this.pos = start > end ? text2.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class LineCursor {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
}
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
class Line {
  /**
  @internal
  */
  constructor(from, to2, number2, text2) {
    this.from = from;
    this.to = to2;
    this.number = number2;
    this.text = text2;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
let extend$2 = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s3) => s3 ? parseInt(s3, 36) : 1);
for (let i3 = 1; i3 < extend$2.length; i3++)
  extend$2[i3] += extend$2[i3 - 1];
function isExtendingChar(code) {
  for (let i3 = 1; i3 < extend$2.length; i3 += 2)
    if (extend$2[i3] > code)
      return extend$2[i3 - 1] <= code;
  return false;
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
const ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length)
    return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
    pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i3 = pos - 2;
      while (i3 >= 0 && isRegionalIndicator(codePointAt(str, i3))) {
        countBefore++;
        i3 -= 2;
      }
      if (countBefore % 2 == 0)
        break;
      else
        pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos)
      return found;
    pos--;
  }
  return 0;
}
function surrogateLow(ch2) {
  return ch2 >= 56320 && ch2 < 57344;
}
function surrogateHigh(ch2) {
  return ch2 >= 55296 && ch2 < 56320;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}
const DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
class ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result = 0;
    for (let i3 = 0; i3 < this.sections.length; i3 += 2)
      result += this.sections[i3];
    return result;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result = 0;
    for (let i3 = 0; i3 < this.sections.length; i3 += 2) {
      let ins = this.sections[i3 + 1];
      result += ins < 0 ? this.sections[i3] : ins;
    }
    return result;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f3) {
    for (let i3 = 0, posA = 0, posB = 0; i3 < this.sections.length; ) {
      let len = this.sections[i3++], ins = this.sections[i3++];
      if (ins < 0) {
        f3(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f3, individual = false) {
    iterChanges(this, f3, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i3 = 0; i3 < this.sections.length; ) {
      let len = this.sections[i3++], ins = this.sections[i3++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i3 = 0; i3 < this.sections.length; ) {
      let len = this.sections[i3++], ins = this.sections[i3++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from, to2 = from) {
    for (let i3 = 0, pos = 0; i3 < this.sections.length && pos <= to2; ) {
      let len = this.sections[i3++], ins = this.sections[i3++], end = pos + len;
      if (ins >= 0 && pos <= to2 && end >= from)
        return pos < from && end > to2 ? "cover" : true;
      pos = end;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result = "";
    for (let i3 = 0; i3 < this.sections.length; ) {
      let len = this.sections[i3++], ins = this.sections[i3++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json2) {
    if (!Array.isArray(json2) || json2.length % 2 || json2.some((a3) => typeof a3 != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ChangeDesc(json2);
  }
  /**
  @internal
  */
  static create(sections) {
    return new ChangeDesc(sections);
  }
}
class ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text2) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text2), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i3 = 0, pos = 0; i3 < sections.length; i3 += 2) {
      let len = sections[i3], ins = sections[i3 + 1];
      if (ins >= 0) {
        sections[i3] = ins;
        sections[i3 + 1] = len;
        let index2 = i3 >> 1;
        while (inserted.length < index2)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f3, individual = false) {
    iterChanges(this, f3, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done:
      for (let i3 = 0, pos = 0; ; ) {
        let next = i3 == ranges.length ? 1e9 : ranges[i3++];
        while (pos < next || pos == next && iter.len == 0) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, next - pos);
          addSection(filteredSections, len, -1);
          let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection(resultSections, len, ins);
          if (ins > 0)
            addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        let end = ranges[i3++];
        while (pos < end) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, end - pos);
          addSection(resultSections, len, -1);
          addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len);
          pos += len;
        }
      }
    return {
      changes: new ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i3 = 0; i3 < this.sections.length; i3 += 2) {
      let len = this.sections[i3], ins = this.sections[i3 + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i3 >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set = new ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from, to: to2 = from, insert: insert2 } = spec;
        if (from > to2 || from < 0 || to2 > length)
          throw new RangeError(`Invalid change range ${from} to ${to2} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to2 && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to2 - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to2;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length) {
    return new ChangeSet(length ? [length, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json2) {
    if (!Array.isArray(json2))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i3 = 0; i3 < json2.length; i3++) {
      let part = json2[i3];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e3, i10) => i10 && typeof e3 != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i3)
          inserted.push(Text.empty);
        inserted[i3] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i3].length);
      }
    }
    return new ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new ChangeSet(sections, inserted);
  }
}
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1])
    sections[last] += len;
  else if (len == 0 && sections[last] == 0)
    sections[last + 1] += ins;
  else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0)
    return;
  let index2 = sections.length - 2 >> 1;
  if (index2 < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index2)
      values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f3, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i3 = 0; i3 < desc.sections.length; ) {
    let len = desc.sections[i3++], ins = desc.sections[i3++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text2 = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text2 = text2.append(inserted[i3 - 2 >> 1]);
        if (individual || i3 == desc.sections.length || desc.sections[i3 + 1] < 0)
          break;
        len = desc.sections[i3++];
        ins = desc.sections[i3++];
      }
      f3(posA, endA, posB, endB, text2);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a3 = new SectionIter(setA), b10 = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a3.ins == -1 && b10.ins == -1) {
      let len = Math.min(a3.len, b10.len);
      addSection(sections, len, -1);
      a3.forward(len);
      b10.forward(len);
    } else if (b10.ins >= 0 && (a3.ins < 0 || inserted == a3.i || a3.off == 0 && (b10.len < a3.len || b10.len == a3.len && !before))) {
      let len = b10.len;
      addSection(sections, b10.ins, -1);
      while (len) {
        let piece = Math.min(a3.len, len);
        if (a3.ins >= 0 && inserted < a3.i && a3.len <= piece) {
          addSection(sections, 0, a3.ins);
          if (insert2)
            addInsert(insert2, sections, a3.text);
          inserted = a3.i;
        }
        a3.forward(piece);
        len -= piece;
      }
      b10.next();
    } else if (a3.ins >= 0) {
      let len = 0, left = a3.len;
      while (left) {
        if (b10.ins == -1) {
          let piece = Math.min(left, b10.len);
          len += piece;
          left -= piece;
          b10.forward(piece);
        } else if (b10.ins == 0 && b10.len < left) {
          left -= b10.len;
          b10.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a3.i ? a3.ins : 0);
      if (insert2 && inserted < a3.i)
        addInsert(insert2, sections, a3.text);
      inserted = a3.i;
      a3.forward(a3.len - left);
    } else if (a3.done && b10.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a3 = new SectionIter(setA), b10 = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a3.done && b10.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a3.ins == 0) {
      addSection(sections, a3.len, 0, open);
      a3.next();
    } else if (b10.len == 0 && !b10.done) {
      addSection(sections, 0, b10.ins, open);
      if (insert2)
        addInsert(insert2, sections, b10.text);
      b10.next();
    } else if (a3.done || b10.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a3.len2, b10.len), sectionLen = sections.length;
      if (a3.ins == -1) {
        let insB = b10.ins == -1 ? -1 : b10.off ? 0 : b10.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b10.text);
      } else if (b10.ins == -1) {
        addSection(sections, a3.off ? 0 : a3.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a3.textBit(len));
      } else {
        addSection(sections, a3.off ? 0 : a3.len, b10.off ? 0 : b10.ins, open);
        if (insert2 && !b10.off)
          addInsert(insert2, sections, b10.text);
      }
      open = (a3.ins > len || b10.ins >= 0 && b10.len > len) && (open || sections.length > sectionLen);
      a3.forward2(len);
      b10.forward(len);
    }
  }
}
class SectionIter {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length ? Text.empty : inserted[index2];
  }
  textBit(len) {
    let { inserted } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length && !len ? Text.empty : inserted[index2].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
}
class SelectionRange {
  constructor(from, to2, flags) {
    this.from = from;
    this.to = to2;
    this.flags = flags;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 3;
    return level == 3 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 5;
    return value == 33554431 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from, to2;
    if (this.empty) {
      from = to2 = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to2 = change.mapPos(this.to, -1);
    }
    return from == this.from && to2 == this.to ? this : new SelectionRange(from, to2, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from, to2 = from) {
    if (from <= this.anchor && to2 >= this.anchor)
      return EditorSelection.range(from, to2);
    let head2 = Math.abs(from - this.anchor) > Math.abs(to2 - this.anchor) ? from : to2;
    return EditorSelection.range(this.anchor, head2);
  }
  /**
  Compare this range to another range.
  */
  eq(other) {
    return this.anchor == other.anchor && this.head == other.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json2) {
    if (!json2 || typeof json2.anchor != "number" || typeof json2.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json2.anchor, json2.head);
  }
  /**
  @internal
  */
  static create(from, to2, flags) {
    return new SelectionRange(from, to2, flags);
  }
}
class EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return EditorSelection.create(this.ranges.map((r3) => r3.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */
  eq(other) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i3 = 0; i3 < this.ranges.length; i3++)
      if (!this.ranges[i3].eq(other.ranges[i3]))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range, main = true) {
    return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r3) => r3.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json2) {
    if (!json2 || !Array.isArray(json2.ranges) || typeof json2.main != "number" || json2.main >= json2.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new EditorSelection(json2.ranges.map((r3) => SelectionRange.fromJSON(r3)), json2.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head2 = anchor) {
    return new EditorSelection([EditorSelection.range(anchor, head2)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i3 = 0; i3 < ranges.length; i3++) {
      let range = ranges[i3];
      if (range.empty ? range.from <= pos : range.from < pos)
        return EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
  }
  /**
  Create a selection range.
  */
  static range(anchor, head2, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5 | (bidiLevel == null ? 3 : Math.min(2, bidiLevel));
    return head2 < anchor ? SelectionRange.create(head2, anchor, 16 | 8 | flags) : SelectionRange.create(anchor, head2, (head2 > anchor ? 4 : 0) | flags);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a3, b10) => a3.from - b10.from);
    mainIndex = ranges.indexOf(main);
    for (let i3 = 1; i3 < ranges.length; i3++) {
      let range = ranges[i3], prev = ranges[i3 - 1];
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from, to2 = Math.max(range.to, prev.to);
        if (i3 <= mainIndex)
          mainIndex--;
        ranges.splice(--i3, 2, range.anchor > range.head ? EditorSelection.range(to2, from) : EditorSelection.range(from, to2));
      }
    }
    return new EditorSelection(ranges, mainIndex);
  }
}
function checkSelection(selection, docLength) {
  for (let range of selection.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
let nextID = 0;
class Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Define a new facet.
  */
  static define(config = {}) {
    return new Facet(config.combine || ((a3) => a3), config.compareInput || ((a3, b10) => a3 === b10), config.compare || (!config.combine ? sameArray : (a3, b10) => a3 === b10), !!config.static, config.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get)
      get = (x10) => x10;
    return this.compute([field], (state) => get(state.field(field)));
  }
}
function sameArray(a3, b10) {
  return a3 == b10 || a3.length == b10.length && a3.every((e3, i3) => e3 === b10[i3]);
}
class FacetProvider {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a2;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr2) {
        if (depDoc && tr2.docChanged || depSel && (tr2.docChanged || tr2.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id2];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
}
function compareArray(a3, b10, compare2) {
  if (a3.length != b10.length)
    return false;
  for (let i3 = 0; i3 < a3.length; i3++)
    if (!compare2(a3[i3], b10[i3]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p10) => addresses[p10.id]);
  let providerTypes = providers.map((p10) => p10.type);
  let dynamic = providerAddrs.filter((p10) => !(p10 & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values = [];
    for (let i3 = 0; i3 < providerAddrs.length; i3++) {
      let value = getAddr(state, providerAddrs[i3]);
      if (providerTypes[i3] == 2)
        for (let val of value)
          values.push(val);
      else
        values.push(value);
    }
    return facet.combine(values);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr2) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
const initField = /* @__PURE__ */ Facet.define({ static: true });
class StateField {
  constructor(id2, createF, updateF, compareF, spec) {
    this.id = id2;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config) {
    let field = new StateField(nextID++, config.create, config.update, config.compare || ((a3, b10) => a3 === b10), config);
    if (config.provide)
      field.provides = config.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i3) => i3.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr2) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr2);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create2) {
    return [this, initField.of({ field: this, create: create2 })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
const Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ prec(Prec_.lowest)
};
class PrecExtension {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
}
class Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
}
class CompartmentInstance {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
}
class Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a3) => field.slot(a3));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id2 in facets) {
      let providers = facets[id2], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id2] || [];
      if (providers.every(
        (p10) => p10.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p10) => p10.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p10 of providers) {
          if (p10.type == 0) {
            address[p10.id] = staticValues.length << 1 | 1;
            staticValues.push(p10.value);
          } else {
            address[p10.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a3) => p10.dynamicSlot(a3));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a3) => dynamicFacetSlot(a3, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f3) => f3(address));
    return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
}
function flatten(extension2, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e3 of ext)
        inner(e3, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension2, Prec_.default);
  return result.reduce((a3, b10) => a3.concat(b10));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
const languageData = /* @__PURE__ */ Facet.define();
const allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((v10) => v10),
  static: true
});
const lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : void 0,
  static: true
});
const changeFilter = /* @__PURE__ */ Facet.define();
const transactionFilter = /* @__PURE__ */ Facet.define();
const transactionExtender = /* @__PURE__ */ Facet.define();
const readOnly = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : false
});
class Annotation {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
}
class AnnotationType {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
}
class StateEffectType {
  /**
  @internal
  */
  constructor(map2) {
    this.map = map2;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
}
class StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v10) => v10));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
}
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
class Transaction {
  constructor(startState, changes, selection, effects, annotations, scrollIntoView2) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView2;
    this._doc = null;
    this._state = null;
    if (selection)
      checkSelection(selection, changes.newLength);
    if (!annotations.some((a3) => a3.type == Transaction.time))
      this.annotations = annotations.concat(Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection, effects, annotations, scrollIntoView2) {
    return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView2);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event) {
    let e3 = this.annotation(Transaction.userEvent);
    return !!(e3 && (e3 == event || e3.length > event.length && e3.slice(0, event.length) == event && e3[event.length] == "."));
  }
}
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a3, b10) {
  let result = [];
  for (let iA2 = 0, iB2 = 0; ; ) {
    let from, to2;
    if (iA2 < a3.length && (iB2 == b10.length || b10[iB2] >= a3[iA2])) {
      from = a3[iA2++];
      to2 = a3[iA2++];
    } else if (iB2 < b10.length) {
      from = b10[iB2++];
      to2 = b10[iB2++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to2);
    else if (result[result.length - 1] < to2)
      result[result.length - 1] = to2;
  }
}
function mergeTransaction(a3, b10, sequential) {
  var _a2;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b10.changes;
    mapForB = ChangeSet.empty(b10.changes.length);
    changes = a3.changes.compose(b10.changes);
  } else {
    mapForA = b10.changes.map(a3.changes);
    mapForB = a3.changes.mapDesc(b10.changes, true);
    changes = a3.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b10.selection ? b10.selection.map(mapForB) : (_a2 = a3.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
    effects: StateEffect.mapEffects(a3.effects, mapForA).concat(StateEffect.mapEffects(b10.effects, mapForB)),
    annotations: a3.annotations.length ? a3.annotations.concat(b10.annotations) : b10.annotations,
    scrollIntoView: a3.scrollIntoView || b10.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s3 = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i3 = 1; i3 < specs.length; i3++) {
    if (specs[i3].filter === false)
      filter = false;
    let seq = !!specs[i3].sequential;
    s3 = mergeTransaction(s3, resolveTransactionInner(state, specs[i3], seq ? s3.changes.newLength : state.doc.length), seq);
  }
  let tr2 = Transaction.create(state, s3.changes, s3.selection, s3.effects, s3.annotations, s3.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr2) : tr2);
}
function filterTransaction(tr2) {
  let state = tr2.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr2);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr2.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr2.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr2 = Transaction.create(state, changes, tr2.selection && tr2.selection.map(back), StateEffect.mapEffects(tr2.effects, back), tr2.annotations, tr2.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i3 = filters.length - 1; i3 >= 0; i3--) {
    let filtered = filters[i3](tr2);
    if (filtered instanceof Transaction)
      tr2 = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr2 = filtered[0];
    else
      tr2 = resolveTransaction(state, asArray(filtered), false);
  }
  return tr2;
}
function extendTransaction(tr2) {
  let state = tr2.startState, extenders = state.facet(transactionExtender), spec = tr2;
  for (let i3 = extenders.length - 1; i3 >= 0; i3--) {
    let extension2 = extenders[i3](tr2);
    if (extension2 && Object.keys(extension2).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension2, tr2.changes.newLength), true);
  }
  return spec == tr2 ? tr2 : Transaction.create(state, tr2.changes, tr2.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_10) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i3 = 0; i3 < str.length; i3++) {
    let ch2 = str[i3];
    if (/\w/.test(ch2) || ch2 > "" && (ch2.toUpperCase() != ch2.toLowerCase() || nonASCIISingleCaseWordChar.test(ch2)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i3 = 0; i3 < wordChars.length; i3++)
      if (char.indexOf(wordChars[i3]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
class EditorState {
  constructor(config, doc2, selection, values, computeSlot, tr2) {
    this.config = config;
    this.doc = doc2;
    this.selection = selection;
    this.values = values;
    this.status = config.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr2)
      tr2._state = this;
    for (let i3 = 0; i3 < this.config.dynamicSlots.length; i3++)
      ensureAddr(this, i3 << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr2) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect of tr2.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key2) => compartments.set(key2, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr2.startState.values.slice();
    }
    new EditorState(conf, tr2.newDoc, tr2.newSelection, startValues, (state, slot) => slot.update(state, tr2), tr2);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text2) {
    if (typeof text2 == "string")
      text2 = this.toText(text2);
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text2 },
      range: EditorSelection.cursor(range.from + text2.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f3) {
    let sel = this.selection;
    let result1 = f3(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i3 = 1; i3 < sel.ranges.length; i3++) {
      let result = f3(sel.ranges[i3]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j10 = 0; j10 < i3; j10++)
        ranges[j10] = ranges[j10].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string2) {
    return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from = 0, to2 = this.doc.length) {
    return this.doc.sliceString(from, to2, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json2, config = {}, fields) {
    if (!json2 || typeof json2.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json2, prop)) {
          let field = fields[prop], value = json2[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return EditorState.create({
      doc: json2.doc,
      selection: EditorSelection.fromJSON(json2.selection),
      extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(config = {}) {
    let configuration = Configuration.resolve(config.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
    let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
    checkSelection(selection, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection = selection.asSingle();
    return new EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase, ...insert2) {
    for (let map2 of this.facet(EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map2, phrase)) {
        phrase = map2[phrase];
        break;
      }
    if (insert2.length)
      phrase = phrase.replace(/\$(\$|\d*)/g, (m10, i3) => {
        if (i3 == "$")
          return "$";
        let n3 = +(i3 || 1);
        return !n3 || n3 > insert2.length ? m10 : insert2[n3 - 1];
      });
    return phrase;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values.push(result[name2]);
      }
    }
    return values;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text: text2, from, length } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak(text2, start, false);
      if (cat(text2.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak(text2, end);
      if (cat(text2.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
}
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = /* @__PURE__ */ Facet.define({
  compare(a3, b10) {
    let kA2 = Object.keys(a3), kB2 = Object.keys(b10);
    return kA2.length == kB2.length && kA2.every((k10) => a3[k10] == b10[k10]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
class RangeValue {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from, to2 = from) {
    return Range2.create(from, to2, this);
  }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
class Range2 {
  constructor(from, to2, value) {
    this.from = from;
    this.to = to2;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from, to2, value) {
    return new Range2(from, to2, value);
  }
}
function cmpRange(a3, b10) {
  return a3.from - b10.from || a3.value.startSide - b10.value.startSide;
}
class Chunk {
  constructor(from, to2, value, maxPoint) {
    this.from = from;
    this.to = to2;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi2 = arr.length; ; ) {
      if (lo == hi2)
        return lo;
      let mid = lo + hi2 >> 1;
      let diff2 = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff2 >= 0 ? lo : hi2;
      if (diff2 >= 0)
        hi2 = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset, from, to2, f3) {
    for (let i3 = this.findIndex(from, -1e9, true), e3 = this.findIndex(to2, 1e9, false, i3); i3 < e3; i3++)
      if (f3(this.from[i3] + offset, this.to[i3] + offset, this.value[i3]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from = [], to2 = [], newPos = -1, maxPoint = -1;
    for (let i3 = 0; i3 < this.value.length; i3++) {
      let val = this.value[i3], curFrom = this.from[i3] + offset, curTo = this.to[i3] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to2.push(newTo - newPos);
    }
    return { mapped: value.length ? new Chunk(from, to2, value, maxPoint) : null, pos: newPos };
  }
}
class RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  /**
  @internal
  */
  chunkEnd(index2) {
    return this.chunkPos[index2] + this.chunk[index2].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter = updateSpec.filter;
    if (add.length == 0 && !filter)
      return this;
    if (sort)
      add = add.slice().sort(cmpRange);
    if (this.isEmpty)
      return add.length ? RangeSet.of(add) : this;
    let cur = new LayerCursor(this, null, -1).goto(0), i3 = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur.value || i3 < add.length) {
      if (i3 < add.length && (cur.from - add[i3].from || cur.startSide - add[i3].value.startSide) >= 0) {
        let range = add[i3++];
        if (!builder.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i3 == add.length || this.chunkEnd(cur.chunkIndex) < add[i3].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
        cur.nextChunk();
      } else {
        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
          if (!builder.addInner(cur.from, cur.to, cur.value))
            spill.push(Range2.create(cur.from, cur.to, cur.value));
        }
        cur.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i3 = 0; i3 < this.chunk.length; i3++) {
      let start = this.chunkPos[i3], chunk = this.chunk[i3];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from, to2, f3) {
    if (this.isEmpty)
      return;
    for (let i3 = 0; i3 < this.chunk.length; i3++) {
      let start = this.chunkPos[i3], chunk = this.chunk[i3];
      if (to2 >= start && from <= start + chunk.length && chunk.between(start, from - start, to2 - start, f3) === false)
        return;
    }
    this.nextLayer.between(from, to2, f3);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a3 = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let b10 = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a3, b10, textDiff);
    let sideA = new SpanCursor(a3, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b10, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from = 0, to2) {
    if (to2 == null)
      to2 = 1e9 - 1;
    let a3 = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
    let b10 = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
    if (a3.length != b10.length)
      return false;
    if (!a3.length)
      return true;
    let sharedChunks = findSharedChunks(a3, b10);
    let sideA = new SpanCursor(a3, sharedChunks, 0).goto(from), sideB = new SpanCursor(b10, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to > to2)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from, to2, iterator, minPointSize = -1) {
    let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let openRanges = cursor.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor.to, to2);
      if (cursor.point) {
        let active = cursor.activeForPoint(cursor.to);
        let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
        openRanges = Math.min(cursor.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor.active, openRanges);
        openRanges = cursor.openEnd(curTo);
      }
      if (cursor.to > to2)
        return openRanges + (cursor.point && cursor.to > to2 ? 1 : 0);
      pos = cursor.to;
      cursor.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range2 ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
}
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i3 = 1; i3 < ranges.length; i3++) {
      let cur = ranges[i3];
      if (cmpRange(prev, cur) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
class RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from, to2, value) {
    if (!this.addInner(from, to2, value))
      (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to2, value);
  }
  /**
  @internal
  */
  addInner(from, to2, value) {
    let diff2 = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff2 <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff2 < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to2 - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to2;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to2 - from);
    return true;
  }
  /**
  @internal
  */
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
}
function findSharedChunks(a3, b10, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set of a3)
    for (let i3 = 0; i3 < set.chunk.length; i3++)
      if (set.chunk[i3].maxPoint <= 0)
        inA.set(set.chunk[i3], set.chunkPos[i3]);
  let shared = /* @__PURE__ */ new Set();
  for (let set of b10)
    for (let i3 = 0; i3 < set.chunk.length; i3++) {
      let known = inA.get(set.chunk[i3]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i3] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i3].length)))
        shared.add(set.chunk[i3]);
    }
  return shared;
}
class LayerCursor {
  constructor(layer, skip, minPoint, rank = 0) {
    this.layer = layer;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index2) {
    if (index2 == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index2;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
}
class HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i3 = 0; i3 < sets.length; i3++) {
      for (let cur = sets[i3]; !cur.isEmpty; cur = cur.nextLayer) {
        if (cur.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur, skip, minPoint, i3));
      }
    }
    return heap.length == 1 ? heap[0] : new HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur of this.heap)
      cur.goto(pos, side);
    for (let i3 = this.heap.length >> 1; i3 >= 0; i3--)
      heapBubble(this.heap, i3);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur of this.heap)
      cur.forward(pos, side);
    for (let i3 = this.heap.length >> 1; i3 >= 0; i3--)
      heapBubble(this.heap, i3);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
}
function heapBubble(heap, index2) {
  for (let cur = heap[index2]; ; ) {
    let childIndex = (index2 << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur.compare(child) < 0)
      break;
    heap[childIndex] = cur;
    heap[index2] = child;
    index2 = childIndex;
  }
}
class SpanCursor {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index2) {
    remove(this.active, index2);
    remove(this.activeTo, index2);
    remove(this.activeRank, index2);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i3 = 0, { value, to: to2, rank } = this.cursor;
    while (i3 < this.activeRank.length && this.activeRank[i3] <= rank)
      i3++;
    insert(this.active, i3, value);
    insert(this.activeTo, i3, to2);
    insert(this.activeRank, i3, rank);
    if (trackOpen)
      insert(trackOpen, i3, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a3 = this.minActive;
      if (a3 > -1 && (this.activeTo[a3] - this.cursor.from || this.active[a3].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a3] > from) {
          this.to = this.activeTo[a3];
          this.endSide = this.active[a3].endSide;
          break;
        }
        this.removeActive(a3);
        if (trackOpen)
          remove(trackOpen, a3);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i3 = trackOpen.length - 1; i3 >= 0 && trackOpen[i3] < from; i3--)
        this.openStart++;
    }
  }
  activeForPoint(to2) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i3 = this.active.length - 1; i3 >= 0; i3--) {
      if (this.activeRank[i3] < this.pointRank)
        break;
      if (this.activeTo[i3] > to2 || this.activeTo[i3] == to2 && this.active[i3].endSide >= this.point.endSide)
        active.push(this.active[i3]);
    }
    return active.reverse();
  }
  openEnd(to2) {
    let open = 0;
    for (let i3 = this.activeTo.length - 1; i3 >= 0 && this.activeTo[i3] > to2; i3--)
      open++;
    return open;
  }
}
function compare(a3, startA, b10, startB, length, comparator) {
  a3.goto(startA);
  b10.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let diff2 = a3.to + dPos - b10.to || a3.endSide - b10.endSide;
    let end = diff2 < 0 ? a3.to + dPos : b10.to, clipEnd = Math.min(end, endB);
    if (a3.point || b10.point) {
      if (!(a3.point && b10.point && (a3.point == b10.point || a3.point.eq(b10.point)) && sameValues(a3.activeForPoint(a3.to), b10.activeForPoint(b10.to))))
        comparator.comparePoint(pos, clipEnd, a3.point, b10.point);
    } else {
      if (clipEnd > pos && !sameValues(a3.active, b10.active))
        comparator.compareRange(pos, clipEnd, a3.active, b10.active);
    }
    if (end > endB)
      break;
    pos = end;
    if (diff2 <= 0)
      a3.next();
    if (diff2 >= 0)
      b10.next();
  }
}
function sameValues(a3, b10) {
  if (a3.length != b10.length)
    return false;
  for (let i3 = 0; i3 < a3.length; i3++)
    if (a3[i3] != b10[i3] && !a3[i3].eq(b10[i3]))
      return false;
  return true;
}
function remove(array, index2) {
  for (let i3 = index2, e3 = array.length - 1; i3 < e3; i3++)
    array[i3] = array[i3 + 1];
  array.pop();
}
function insert(array, index2, value) {
  for (let i3 = array.length - 1; i3 >= index2; i3--)
    array[i3 + 1] = array[i3];
  array[index2] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i3 = 0; i3 < array.length; i3++)
    if ((array[i3] - foundPos || value[i3].endSide - value[found].endSide) < 0) {
      found = i3;
      foundPos = array[i3];
    }
  return found;
}
function findColumn(string2, col, tabSize, strict) {
  for (let i3 = 0, n3 = 0; ; ) {
    if (n3 >= col)
      return i3;
    if (i3 == string2.length)
      break;
    n3 += string2.charCodeAt(i3) == 9 ? tabSize - n3 % tabSize : 1;
    i3 = findClusterBreak(string2, i3);
  }
  return strict === true ? -1 : string2.length;
}
const C$1 = "ͼ";
const COUNT = typeof Symbol == "undefined" ? "__" + C$1 : Symbol.for(C$1);
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
class StyleModule {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = [];
    let { finish } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null)
        return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render(
            prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a3, b10) => a3.concat(b10)),
            value,
            target
          );
        } else if (value && typeof value == "object") {
          if (!isAt)
            throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l3) => "-" + l3.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec)
      render(splitSelector(prop), spec[prop], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join("\n");
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let id2 = top[COUNT] || 1;
    top[COUNT] = id2 + 1;
    return C$1 + id2.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root2, modules, options) {
    let set = root2[SET], nonce = options && options.nonce;
    if (!set)
      set = new StyleSet(root2, nonce);
    else if (nonce)
      set.setNonce(nonce);
    set.mount(Array.isArray(modules) ? modules : [modules]);
  }
}
let adoptedSet = /* @__PURE__ */ new Map();
class StyleSet {
  constructor(root2, nonce) {
    let doc2 = root2.ownerDocument || root2, win = doc2.defaultView;
    if (!root2.head && root2.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc2);
      if (adopted) {
        root2.adoptedStyleSheets = [adopted.sheet, ...root2.adoptedStyleSheets];
        return root2[SET] = adopted;
      }
      this.sheet = new win.CSSStyleSheet();
      root2.adoptedStyleSheets = [this.sheet, ...root2.adoptedStyleSheets];
      adoptedSet.set(doc2, this);
    } else {
      this.styleTag = doc2.createElement("style");
      if (nonce)
        this.styleTag.setAttribute("nonce", nonce);
      let target = root2.head || root2;
      target.insertBefore(this.styleTag, target.firstChild);
    }
    this.modules = [];
    root2[SET] = this;
  }
  mount(modules) {
    let sheet = this.sheet;
    let pos = 0, j10 = 0;
    for (let i3 = 0; i3 < modules.length; i3++) {
      let mod = modules[i3], index2 = this.modules.indexOf(mod);
      if (index2 < j10 && index2 > -1) {
        this.modules.splice(index2, 1);
        j10--;
        index2 = -1;
      }
      if (index2 == -1) {
        this.modules.splice(j10++, 0, mod);
        if (sheet)
          for (let k10 = 0; k10 < mod.rules.length; k10++)
            sheet.insertRule(mod.rules[k10], pos++);
      } else {
        while (j10 < index2)
          pos += this.modules[j10++].rules.length;
        pos += mod.rules.length;
        j10++;
      }
    }
    if (!sheet) {
      let text2 = "";
      for (let i3 = 0; i3 < this.modules.length; i3++)
        text2 += this.modules[i3].getRules() + "\n";
      this.styleTag.textContent = text2;
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
      this.styleTag.setAttribute("nonce", nonce);
  }
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
for (var i$2 = 0; i$2 < 10; i$2++)
  base[48 + i$2] = base[96 + i$2] = String(i$2);
for (var i$2 = 1; i$2 <= 24; i$2++)
  base[i$2 + 111] = "F" + i$2;
for (var i$2 = 65; i$2 <= 90; i$2++) {
  base[i$2] = String.fromCharCode(i$2 + 32);
  shift[i$2] = String.fromCharCode(i$2);
}
for (var code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
function getSelection(root2) {
  let target;
  if (root2.nodeType == 11) {
    target = root2.getSelection ? root2 : root2.ownerDocument;
  } else {
    target = root2;
  }
  return target.getSelection();
}
function contains$1(dom, node2) {
  return node2 ? dom == node2 || dom.contains(node2.nodeType != 1 ? node2.parentNode : node2) : false;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function hasSelection(dom, selection) {
  if (!selection.anchorNode)
    return false;
  try {
    return contains$1(dom, selection.anchorNode);
  } catch (_10) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node2, off, targetNode, targetOff) {
  return targetNode ? scanFor(node2, off, targetNode, targetOff, -1) || scanFor(node2, off, targetNode, targetOff, 1) : false;
}
function domIndex(node2) {
  for (var index2 = 0; ; index2++) {
    node2 = node2.previousSibling;
    if (!node2)
      return index2;
  }
}
function scanFor(node2, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node2 == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node2))) {
      if (node2.nodeName == "DIV")
        return false;
      let parent = node2.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node2) + (dir < 0 ? 0 : 1);
      node2 = parent;
    } else if (node2.nodeType == 1) {
      node2 = node2.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node2.nodeType == 1 && node2.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node2) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node2) {
  return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
}
function flattenRect(rect, left) {
  let x10 = left ? rect.left : rect.right;
  return { left: x10, right: x10, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function scrollRectIntoView(dom, rect, side, x10, y10, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur = dom, stop = false; cur && !stop; ) {
    if (cur.nodeType == 1) {
      let bounding, top2 = cur == doc2.body;
      let scaleX = 1, scaleY = 1;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
          stop = true;
        if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
          cur = cur.assignedSlot || cur.parentNode;
          continue;
        }
        let rect2 = cur.getBoundingClientRect();
        scaleX = rect2.width / cur.offsetWidth;
        scaleY = rect2.height / cur.offsetHeight;
        bounding = {
          left: rect2.left,
          right: rect2.left + cur.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur.clientHeight * scaleY
        };
      }
      let moveX = 0, moveY = 0;
      if (y10 == "nearest") {
        if (rect.top < bounding.top) {
          moveY = -(bounding.top - rect.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + moveY + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = -(bounding.top + moveY - rect.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y10 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y10 == "start" || y10 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x10 == "nearest") {
        if (rect.left < bounding.left) {
          moveX = -(bounding.left - rect.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + moveX + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = -(bounding.left + moveX - rect.left + xMargin);
        }
      } else {
        let targetLeft = x10 == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x10 == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start = cur.scrollTop;
            cur.scrollTop += moveY / scaleY;
            movedY = (cur.scrollTop - start) * scaleY;
          }
          if (moveX) {
            let start = cur.scrollLeft;
            cur.scrollLeft += moveX / scaleX;
            movedX = (cur.scrollLeft - start) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x10 = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y10 = "nearest";
        }
      }
      if (top2)
        break;
      cur = cur.assignedSlot || cur.parentNode;
    } else if (cur.nodeType == 11) {
      cur = cur.host;
    } else {
      break;
    }
  }
}
function scrollableParent(dom) {
  let doc2 = dom.ownerDocument;
  for (let cur = dom.parentNode; cur; ) {
    if (cur == doc2.body) {
      break;
    } else if (cur.nodeType == 1) {
      if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth)
        return cur;
      cur = cur.assignedSlot || cur.parentNode;
    } else if (cur.nodeType == 11) {
      cur = cur.host;
    } else {
      break;
    }
  }
  return null;
}
class DOMSelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range) {
    let { anchorNode, focusNode } = range;
    this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur = dom; cur; cur = cur.parentNode) {
    stack.push(cur, cur.scrollTop, cur.scrollLeft);
    if (cur == cur.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i3 = 0; i3 < stack.length; ) {
      let elt = stack[i3++], top2 = stack[i3++], left = stack[i3++];
      if (elt.scrollTop != top2)
        elt.scrollTop = top2;
      if (elt.scrollLeft != left)
        elt.scrollLeft = left;
    }
  }
}
let scratchRange;
function textRange(node2, from, to2 = from) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node2, to2);
  range.setStart(node2, from);
  return range;
}
function dispatchKey(elt, name2, code) {
  let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up2 = new KeyboardEvent("keyup", options);
  up2.synthetic = true;
  elt.dispatchEvent(up2);
  return down.defaultPrevented || up2.defaultPrevented;
}
function getRoot(node2) {
  while (node2) {
    if (node2 && (node2.nodeType == 9 || node2.nodeType == 11 && node2.host))
      return node2;
    node2 = node2.assignedSlot || node2.parentNode;
  }
  return null;
}
function clearAttributes(node2) {
  while (node2.attributes.length)
    node2.removeAttributeNode(node2.attributes[0]);
}
function atElementStart(doc2, selection) {
  let node2 = selection.focusNode, offset = selection.focusOffset;
  if (!node2 || selection.anchorNode != node2 || selection.anchorOffset != offset)
    return false;
  offset = Math.min(offset, maxOffset(node2));
  for (; ; ) {
    if (offset) {
      if (node2.nodeType != 1)
        return false;
      let prev = node2.childNodes[offset - 1];
      if (prev.contentEditable == "false")
        offset--;
      else {
        node2 = prev;
        offset = maxOffset(node2);
      }
    } else if (node2 == doc2) {
      return true;
    } else {
      offset = domIndex(node2);
      node2 = node2.parentNode;
    }
  }
}
function isScrolledToBottom(elt) {
  return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
class DOMPos {
  constructor(node2, offset, precise = true) {
    this.node = node2;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
}
const noChildren = [];
class ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  sync(view, track2) {
    if (this.flags & 2) {
      let parent = this.dom;
      let prev = null, next;
      for (let child of this.children) {
        if (child.flags & 7) {
          if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
            let contentView = ContentView.get(next);
            if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
              child.reuseDOM(next);
          }
          child.sync(view, track2);
          child.flags &= ~7;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (track2 && !track2.written && track2.node == parent && next != child.dom)
          track2.written = true;
        if (child.dom.parentNode == parent) {
          while (next && next != child.dom)
            next = rm$1(next);
        } else {
          parent.insertBefore(child.dom, next);
        }
        prev = child.dom;
      }
      next = prev ? prev.nextSibling : parent.firstChild;
      if (next && track2 && track2.node == parent)
        track2.written = true;
      while (next)
        next = rm$1(next);
    } else if (this.flags & 1) {
      for (let child of this.children)
        if (child.flags & 7) {
          child.sync(view, track2);
          child.flags &= ~7;
        }
    }
  }
  reuseDOM(_dom) {
  }
  localPosFromDOM(node2, offset) {
    let after;
    if (node2 == this.dom) {
      after = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node2) == 0 ? 0 : offset == 0 ? -1 : 1;
      for (; ; ) {
        let parent = node2.parentNode;
        if (parent == this.dom)
          break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node2 == parent.firstChild)
            bias = -1;
          else
            bias = 1;
        }
        node2 = parent;
      }
      if (bias < 0)
        after = node2;
      else
        after = node2.nextSibling;
    }
    if (after == this.dom.firstChild)
      return 0;
    while (after && !ContentView.get(after))
      after = after.nextSibling;
    if (!after)
      return this.length;
    for (let i3 = 0, pos = 0; ; i3++) {
      let child = this.children[i3];
      if (child.dom == after)
        return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from, to2, offset = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i3 = 0, pos = offset, prevEnd = offset; i3 < this.children.length; i3++) {
      let child = this.children[i3], end = pos + child.length;
      if (pos < from && end > to2)
        return child.domBoundsAround(from, to2, pos);
      if (end >= from && fromI == -1) {
        fromI = i3;
        fromStart = pos;
      }
      if (pos > to2 && child.dom.parentNode == this.dom) {
        toI = i3;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent = false) {
    this.flags |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList)
        parent.flags |= 2;
      if (parent.flags & 1)
        return;
      parent.flags |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.flags & 7)
        this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    if (this.dom == dom)
      return;
    if (this.dom)
      this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v10 = this; ; ) {
      let parent = v10.parent;
      if (!parent)
        return v10;
      v10 = parent;
    }
  }
  replaceChildren(from, to2, children2 = noChildren) {
    this.markDirty();
    for (let i3 = from; i3 < to2; i3++) {
      let child = this.children[i3];
      if (child.parent == this)
        child.destroy();
    }
    this.children.splice(from, to2 - from, ...children2);
    for (let i3 = 0; i3 < children2.length; i3++)
      children2[i3].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name2 = this.constructor.name.replace("View", "");
    return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node2) {
    return node2.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(from, to2, source2, hasStart, openStart, openEnd) {
    return false;
  }
  become(other) {
    return false;
  }
  canReuseDOM(other) {
    return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class ChildCursor {
  constructor(children2, pos, i3) {
    this.children = children2;
    this.pos = pos;
    this.i = i3;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
  let { children: children2 } = parent;
  let before = children2.length ? children2[fromI] : null;
  let last = insert2.length ? insert2[insert2.length - 1] : null;
  let breakAtEnd = last ? last.breakAfter : breakAtStart;
  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
    return;
  if (toI < children2.length) {
    let after = children2[toI];
    if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after;
      } else {
        if (toOff)
          after.merge(0, toOff, null, false, 0, openEnd);
        insert2.push(after);
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last)
        last.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
  }
  if (before) {
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
        before.breakAfter = insert2.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert2.length) {
    if (children2[toI - 1].become(insert2[insert2.length - 1])) {
      toI--;
      insert2.pop();
      openEnd = insert2.length ? 0 : openStart;
    } else if (children2[fromI].become(insert2[0])) {
      fromI++;
      insert2.shift();
      openStart = insert2.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert2.length && fromI && toI < children2.length && !children2[fromI - 1].breakAfter && children2[toI].merge(0, 0, children2[fromI - 1], false, openStart, openEnd))
    fromI--;
  if (fromI < toI || insert2.length)
    parent.replaceChildren(fromI, toI, insert2);
}
function mergeChildrenInto(parent, from, to2, insert2, openStart, openEnd) {
  let cur = parent.childCursor();
  let { i: toI, off: toOff } = cur.findPos(to2, 1);
  let { i: fromI, off: fromOff } = cur.findPos(from, -1);
  let dLen = from - to2;
  for (let view of insert2)
    dLen += view.length;
  parent.length += dLen;
  replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
}
let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
const ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !ie && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
const ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
  windows: /* @__PURE__ */ /Win/.test(nav.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
  ie,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const MaxJoinLen = 256;
class TextView extends ContentView {
  constructor(text2) {
    super();
    this.text = text2;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(view, track2) {
    if (!this.dom)
      this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track2 && track2.node == this.dom)
        track2.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3)
      this.createDOM(dom);
  }
  merge(from, to2, source2) {
    if (this.flags & 8 || source2 && (!(source2 instanceof TextView) || this.length - (to2 - from) + source2.length > MaxJoinLen || source2.flags & 8))
      return false;
    this.text = this.text.slice(0, from) + (source2 ? source2.text : "") + this.text.slice(to2);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = new TextView(this.text.slice(from));
    this.text = this.text.slice(0, from);
    this.markDirty();
    result.flags |= this.flags & 8;
    return result;
  }
  localPosFromDOM(node2, offset) {
    return node2 == this.dom ? offset : offset ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset) {
    return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
}
class MarkView extends ContentView {
  constructor(mark2, children2 = [], length = 0) {
    super();
    this.mark = mark2;
    this.children = children2;
    this.length = length;
    for (let ch2 of children2)
      ch2.setParent(this);
  }
  setAttrs(dom) {
    clearAttributes(dom);
    if (this.mark.class)
      dom.className = this.mark.class;
    if (this.mark.attrs)
      for (let name2 in this.mark.attrs)
        dom.setAttribute(name2, this.mark.attrs[name2]);
    return dom;
  }
  canReuseDOM(other) {
    return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
  }
  reuseDOM(node2) {
    if (node2.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node2);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track2) {
    if (!this.dom)
      this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
    else if (this.flags & 4)
      this.setAttrs(this.dom);
    super.sync(view, track2);
  }
  merge(from, to2, source2, _hasStart, openStart, openEnd) {
    if (source2 && (!(source2 instanceof MarkView && source2.mark.eq(this.mark)) || from && openStart <= 0 || to2 < this.length && openEnd <= 0))
      return false;
    mergeChildrenInto(this, from, to2, source2 ? source2.children : [], openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = [], off = 0, detachFrom = -1, i3 = 0;
    for (let elt of this.children) {
      let end = off + elt.length;
      if (end > from)
        result.push(off < from ? elt.split(from - off) : elt);
      if (detachFrom < 0 && off >= from)
        detachFrom = i3;
      off = end;
      i3++;
    }
    let length = this.length - from;
    this.length = from;
    if (detachFrom > -1) {
      this.children.length = detachFrom;
      this.markDirty();
    }
    return new MarkView(this.mark, result, length);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
}
function textCoords(text2, pos, side) {
  let length = text2.nodeValue.length;
  if (pos > length)
    pos = length;
  let from = pos, to2 = pos, flatten2 = 0;
  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from--;
        flatten2 = 1;
      } else if (to2 < length) {
        to2++;
        flatten2 = -1;
      }
    }
  } else {
    if (side < 0)
      from--;
    else if (to2 < length)
      to2++;
  }
  let rects = textRange(text2, from, to2).getClientRects();
  if (!rects.length)
    return null;
  let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten2 && rect.width == 0)
    rect = Array.prototype.find.call(rects, (r3) => r3.width) || rect;
  return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
}
class WidgetView extends ContentView {
  static create(widget, length, side) {
    return new WidgetView(widget, length, side);
  }
  constructor(widget, length, side) {
    super();
    this.widget = widget;
    this.length = length;
    this.side = side;
    this.prevWidget = null;
  }
  split(from) {
    let result = WidgetView.create(this.widget, this.length - from, this.side);
    this.length -= from;
    return result;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from, to2, source2, hasStart, openStart, openEnd) {
    if (source2 && (!(source2 instanceof WidgetView) || !this.widget.compare(source2.widget) || from > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0))
      return false;
    this.length = from + (source2 ? source2.length : 0) + (this.length - to2);
    return true;
  }
  become(other) {
    if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
      if (!this.widget.compare(other.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Text.empty;
    let top2 = this;
    while (top2.parent)
      top2 = top2.parent;
    let { view } = top2, text2 = view && view.state.doc, start = this.posAtStart;
    return text2 ? text2.slice(start, start + this.length) : Text.empty;
  }
  domAtPos(pos) {
    return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let custom2 = this.widget.coordsAt(this.dom, pos, side);
    if (custom2)
      return custom2;
    let rects = this.dom.getClientRects(), rect = null;
    if (!rects.length)
      return null;
    let fromBack = this.side ? this.side < 0 : pos > 0;
    for (let i3 = fromBack ? rects.length - 1 : 0; ; i3 += fromBack ? -1 : 1) {
      rect = rects[i3];
      if (pos > 0 ? i3 == 0 : i3 == rects.length - 1 || rect.top < rect.bottom)
        break;
    }
    return flattenRect(rect, !fromBack);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
}
class WidgetBufferView extends ContentView {
  constructor(side) {
    super();
    this.side = side;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(other) {
    return other instanceof WidgetBufferView && other.side == this.side;
  }
  split() {
    return new WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement("img");
      dom.className = "cm-widgetBuffer";
      dom.setAttribute("aria-hidden", "true");
      this.setDOM(dom);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(pos) {
    return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Text.empty;
  }
  get isHidden() {
    return true;
  }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
  let dom = parent.dom, { children: children2 } = parent, i3 = 0;
  for (let off = 0; i3 < children2.length; i3++) {
    let child = children2[i3], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (pos > off && pos < end && child.dom.parentNode == dom)
      return child.domAtPos(pos - off);
    if (pos <= off)
      break;
    off = end;
  }
  for (let j10 = i3; j10 > 0; j10--) {
    let prev = children2[j10 - 1];
    if (prev.dom.parentNode == dom)
      return prev.domAtPos(prev.length);
  }
  for (let j10 = i3; j10 < children2.length; j10++) {
    let next = children2[j10];
    if (next.dom.parentNode == dom)
      return next.domAtPos(0);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last, { children: children2 } = parent;
  if (open > 0 && view instanceof MarkView && children2.length && (last = children2[children2.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
    joinInlineInto(last, view.children[0], open - 1);
  } else {
    children2.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  let before = null, beforePos = -1, after = null, afterPos = -1;
  function scan(view2, pos2) {
    for (let i3 = 0, off = 0; i3 < view2.children.length && off <= pos2; i3++) {
      let child = view2.children[i3], end = off + child.length;
      if (end >= pos2) {
        if (child.children.length) {
          scan(child, pos2 - off);
        } else if ((!after || after.isHidden && side > 0) && (end > pos2 || off == end && child.getSide() > 0)) {
          after = child;
          afterPos = pos2 - off;
        } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
          before = child;
          beforePos = pos2 - off;
        }
      }
      off = end;
    }
  }
  scan(view, pos);
  let target = (side < 0 ? before : after) || before || after;
  if (target)
    return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
  return fallbackRect(view);
}
function fallbackRect(view) {
  let last = view.dom.lastChild;
  if (!last)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1] || null;
}
function combineAttrs(source2, target) {
  for (let name2 in source2) {
    if (name2 == "class" && target.class)
      target.class += " " + source2.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source2.style;
    else
      target[name2] = source2[name2];
  }
  return target;
}
const noAttrs = /* @__PURE__ */ Object.create(null);
function attrsEq(a3, b10, ignore2) {
  if (a3 == b10)
    return true;
  if (!a3)
    a3 = noAttrs;
  if (!b10)
    b10 = noAttrs;
  let keysA = Object.keys(a3), keysB = Object.keys(b10);
  if (keysA.length - (ignore2 && keysA.indexOf(ignore2) > -1 ? 1 : 0) != keysB.length - (ignore2 && keysB.indexOf(ignore2) > -1 ? 1 : 0))
    return false;
  for (let key2 of keysA) {
    if (key2 != ignore2 && (keysB.indexOf(key2) == -1 || a3[key2] !== b10[key2]))
      return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  let changed = false;
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs)) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = "";
        else
          dom.removeAttribute(name2);
      }
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2])) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = attrs[name2];
        else
          dom.setAttribute(name2, attrs[name2]);
      }
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let i3 = 0; i3 < dom.attributes.length; i3++) {
    let attr = dom.attributes[i3];
    attrs[attr.name] = attr.value;
  }
  return attrs;
}
class LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  // Consumes source
  merge(from, to2, source2, hasStart, openStart, openEnd) {
    if (source2) {
      if (!(source2 instanceof LineView))
        return false;
      if (!this.dom)
        source2.transferDOM(this);
    }
    if (hasStart)
      this.setDeco(source2 ? source2.attrs : null);
    mergeChildrenInto(this, from, to2, source2 ? source2.children : [], openStart, openEnd);
    return true;
  }
  split(at) {
    let end = new LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0)
      return end;
    let { i: i3, off } = this.childPos(at);
    if (off) {
      end.append(this.children[i3].split(off), 0);
      this.children[i3].merge(off, this.children[i3].length, null, false, 0, 0);
      i3++;
    }
    for (let j10 = i3; j10 < this.children.length; j10++)
      end.append(this.children[j10], 0);
    while (i3 > 0 && this.children[i3 - 1].length == 0)
      this.children[--i3].destroy();
    this.children.length = i3;
    this.markDirty();
    this.length = at;
    return end;
  }
  transferDOM(other) {
    if (!this.dom)
      return;
    this.markDirty();
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(deco) {
    let attrs = deco.spec.attributes, cls = deco.spec.class;
    if (attrs)
      this.attrs = combineAttrs(attrs, this.attrs || {});
    if (cls)
      this.attrs = combineAttrs({ class: cls }, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  reuseDOM(node2) {
    if (node2.nodeName == "DIV") {
      this.setDOM(node2);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track2) {
    var _a2;
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    } else if (this.flags & 4) {
      clearAttributes(this.dom);
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(view, track2);
    let last = this.dom.lastChild;
    while (last && ContentView.get(last) instanceof MarkView)
      last = last.lastChild;
    if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch2) => ch2 instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let totalWidth = 0, textHeight;
    for (let child of this.children) {
      if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
        return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1)
        return null;
      totalWidth += rects[0].width;
      textHeight = rects[0].height;
    }
    return !totalWidth ? null : {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length,
      textHeight
    };
  }
  coordsAt(pos, side) {
    let rect = coordsInChildren(this, pos, side);
    if (!this.children.length && rect && this.parent) {
      let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
      if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
        let dist2 = (height - heightOracle.textHeight) / 2;
        return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
      }
    }
    return rect;
  }
  become(_other) {
    return false;
  }
  covers() {
    return true;
  }
  static find(docView, pos) {
    for (let i3 = 0, off = 0; i3 < docView.children.length; i3++) {
      let block = docView.children[i3], end = off + block.length;
      if (end >= pos) {
        if (block instanceof LineView)
          return block;
        if (end > pos)
          break;
      }
      off = end + block.breakAfter;
    }
    return null;
  }
}
class BlockWidgetView extends ContentView {
  constructor(widget, length, deco) {
    super();
    this.widget = widget;
    this.length = length;
    this.deco = deco;
    this.breakAfter = 0;
    this.prevWidget = null;
  }
  merge(from, to2, source2, _takeDeco, openStart, openEnd) {
    if (source2 && (!(source2 instanceof BlockWidgetView) || !this.widget.compare(source2.widget) || from > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0))
      return false;
    this.length = from + (source2 ? source2.length : 0) + (this.length - to2);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at) {
    let len = this.length - at;
    this.length = at;
    let end = new BlockWidgetView(this.widget, len, this.deco);
    end.breakAfter = this.breakAfter;
    return end;
  }
  get children() {
    return noChildren;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(other) {
    if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.compare(this.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      this.deco = other.deco;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(pos, side) {
    return this.widget.coordsAt(this.dom, pos, side);
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
  covers(side) {
    let { startSide, endSide } = this.deco;
    return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
  }
}
class WidgetType {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false;
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(dom, pos, side) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {
  }
}
var BlockType = /* @__PURE__ */ function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
class Decoration extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
    side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let { start, end } = getInclusive(spec, block);
      startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
      endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of2, sort = false) {
    return RangeSet.of(of2, sort);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
}
Decoration.none = RangeSet.empty;
class MarkDecoration extends Decoration {
  constructor(spec) {
    let { start, end } = getInclusive(spec);
    super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    var _a2, _b2;
    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other.class || ((_b2 = other.attrs) === null || _b2 === void 0 ? void 0 : _b2.class)) && attrsEq(this.attrs, other.attrs, "class");
  }
  range(from, to2 = from) {
    if (from >= to2)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to2);
  }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to2 = from) {
    if (to2 != from)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to2);
  }
}
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(other) {
    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to2 = from) {
    if (this.isReplace && (from > to2 || from == to2 && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to2 != from)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to2);
  }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a3, b10) {
  return a3 == b10 || !!(a3 && b10 && a3.compare(b10));
}
function addRange(from, to2, ranges, margin = 0) {
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin >= from)
    ranges[last] = Math.max(ranges[last], to2);
  else
    ranges.push(from, to2);
}
class ContentBuilder {
  constructor(doc2, pos, end, disallowBlockEffectsFor) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.pendingBuffer = 0;
    this.bufferMarks = [];
    this.atCursorPos = true;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last = this.content[this.content.length - 1];
    return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
  }
  getLine() {
    if (!this.curLine) {
      this.content.push(this.curLine = new LineView());
      this.atCursorPos = true;
    }
    return this.curLine;
  }
  flushBuffer(active = this.bufferMarks) {
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
      this.pendingBuffer = 0;
    }
  }
  addBlockWidget(view) {
    this.flushBuffer();
    this.curLine = null;
    this.content.push(view);
  }
  finish(openEnd) {
    if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
      this.flushBuffer();
    else
      this.pendingBuffer = 0;
    if (!openEnd && !this.posCovered())
      this.getLine();
  }
  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let { value, lineBreak, done } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done)
          throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered())
            this.getLine();
          if (this.content.length)
            this.content[this.content.length - 1].breakAfter = 1;
          else
            this.breakAtStart = 1;
          this.flushBuffer();
          this.curLine = null;
          this.atCursorPos = true;
          length--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(
        this.text.length - this.textOff,
        length,
        512
        /* T.Chunk */
      );
      this.flushBuffer(active.slice(active.length - openStart));
      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.atCursorPos = true;
      this.textOff += take;
      length -= take;
      openStart = 0;
    }
  }
  span(from, to2, active, openStart) {
    this.buildText(to2 - from, active, openStart);
    this.pos = to2;
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  point(from, to2, deco, active, openStart, index2) {
    if (this.disallowBlockEffectsFor[index2] && deco instanceof PointDecoration) {
      if (deco.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (to2 > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let len = to2 - from;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        if (deco.startSide > 0 && !this.posCovered())
          this.getLine();
        this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, deco));
      } else {
        let view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to2 || deco.startSide > 0);
        let cursorAfter = !view.isEditable && (from < to2 || openStart > active.length || deco.startSide <= 0);
        let line = this.getLine();
        if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
          this.pendingBuffer = 0;
        this.flushBuffer(active);
        if (cursorBefore) {
          line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
          openStart = active.length + Math.max(0, openStart - active.length);
        }
        line.append(wrapMarks(view, active), openStart);
        this.atCursorPos = cursorAfter;
        this.pendingBuffer = !cursorAfter ? 0 : from < to2 || openStart > active.length ? 1 : 2;
        if (this.pendingBuffer)
          this.bufferMarks = active.slice();
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to2;
    }
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  static build(text2, from, to2, decorations2, dynamicDecorationMap) {
    let builder = new ContentBuilder(text2, from, to2, dynamicDecorationMap);
    builder.openEnd = RangeSet.spans(decorations2, from, to2, builder);
    if (builder.openStart < 0)
      builder.openStart = builder.openEnd;
    builder.finish(builder.openEnd);
    return builder;
  }
}
function wrapMarks(view, active) {
  for (let mark2 of active)
    view = new MarkView(mark2, [view], view.length);
  return view;
}
class NullWidget extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
}
const clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
const dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
const mouseSelectionStyle = /* @__PURE__ */ Facet.define();
const exceptionSink = /* @__PURE__ */ Facet.define();
const updateListener = /* @__PURE__ */ Facet.define();
const inputHandler = /* @__PURE__ */ Facet.define();
const focusChangeEffect = /* @__PURE__ */ Facet.define();
const perLineTextDirection = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x10) => x10)
});
const nativeSelectionHidden = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x10) => x10)
});
class ScrollTarget {
  constructor(range, y10 = "nearest", x10 = "nearest", yMargin = 5, xMargin = 5) {
    this.range = range;
    this.y = y10;
    this.x = x10;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
  }
  map(changes) {
    return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t10, ch2) => t10.map(ch2) });
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror)
    window.onerror(String(exception), context, void 0, void 0, exception);
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
const editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
let nextPluginID = 0;
const viewPlugin = /* @__PURE__ */ Facet.define();
class ViewPlugin {
  constructor(id2, create2, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id2;
    this.create = create2;
    this.domEventHandlers = domEventHandlers;
    this.domEventObservers = domEventObservers;
    this.extension = buildExtensions(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create2, spec) {
    const { eventHandlers, eventObservers, provide: provide2, decorations: deco } = spec || {};
    return new ViewPlugin(nextPluginID++, create2, eventHandlers, eventObservers, (plugin) => {
      let ext = [viewPlugin.of(plugin)];
      if (deco)
        ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
      if (provide2)
        ext.push(provide2(plugin));
      return ext;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls, spec) {
    return ViewPlugin.define((view) => new cls(view), spec);
  }
}
class PluginInstance {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.create(view);
        } catch (e3) {
          logException(view.state, e3, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e3) {
          logException(update.state, e3, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_10) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a2;
    if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
      try {
        this.value.destroy();
      } catch (e3) {
        logException(view.state, e3, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const editorAttributes = /* @__PURE__ */ Facet.define();
const contentAttributes = /* @__PURE__ */ Facet.define();
const decorations = /* @__PURE__ */ Facet.define();
const atomicRanges = /* @__PURE__ */ Facet.define();
const bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
function getIsolatedRanges(view, from, to2) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length)
    return isolates;
  let sets = isolates.map((i3) => i3 instanceof Function ? i3(view) : i3);
  let result = [];
  RangeSet.spans(sets, from, to2, {
    point() {
    },
    span(from2, to3, active, open) {
      let level = result;
      for (let i3 = active.length - 1; i3 >= 0; i3--, open--) {
        let iso = active[i3].spec.bidiIsolate, update;
        if (iso == null)
          continue;
        if (open > 0 && level.length && (update = level[level.length - 1]).to == from2 && update.direction == iso) {
          update.to = to3;
          level = update.inner;
        } else {
          let add = { from: from2, to: to3, direction: iso, inner: [] };
          level.push(add);
          level = add.inner;
        }
      }
    }
  });
  return result;
}
const scrollMargins = /* @__PURE__ */ Facet.define();
function getScrollMargins(view) {
  let left = 0, right = 0, top2 = 0, bottom = 0;
  for (let source2 of view.state.facet(scrollMargins)) {
    let m10 = source2(view);
    if (m10) {
      if (m10.left != null)
        left = Math.max(left, m10.left);
      if (m10.right != null)
        right = Math.max(right, m10.right);
      if (m10.top != null)
        top2 = Math.max(top2, m10.top);
      if (m10.bottom != null)
        bottom = Math.max(bottom, m10.bottom);
    }
  }
  return { left, right, top: top2, bottom };
}
const styleModule = /* @__PURE__ */ Facet.define();
class ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set) {
    let i3 = set.length, me = this;
    for (; i3 > 0; i3--) {
      let range = set[i3 - 1];
      if (range.fromA > me.toA)
        continue;
      if (range.toA < me.fromA)
        break;
      me = me.join(range);
      set.splice(i3 - 1, 1);
    }
    set.splice(i3, 0, me);
    return set;
  }
  static extendWithRanges(diff2, ranges) {
    if (ranges.length == 0)
      return diff2;
    let result = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next = dI == diff2.length ? null : diff2[dI], off = posA - posB;
      let end = next ? next.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI], to2 = ranges[rI + 1];
        let fromB = Math.max(posB, from), toB = Math.min(end, to2);
        if (fromB <= toB)
          new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
        if (to2 > end)
          break;
        else
          rI += 2;
      }
      if (!next)
        return result;
      new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
      posA = next.toA;
      posB = next.toB;
    }
  }
}
class ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr2 of transactions)
      this.changes = this.changes.compose(tr2.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new ViewUpdate(view, state, transactions);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (8 | 2)) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr2) => tr2.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var Direction = /* @__PURE__ */ function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i3 = 0; i3 < str.length; i3++)
    result.push(1 << +str[i3]);
  return result;
}
const LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
const ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = /* @__PURE__ */ Object.create(null), BracketStack = [];
for (let p10 of ["()", "[]", "{}"]) {
  let l3 = /* @__PURE__ */ p10.charCodeAt(0), r3 = /* @__PURE__ */ p10.charCodeAt(1);
  Brackets[l3] = r3;
  Brackets[r3] = -l3;
}
function charType(ch2) {
  return ch2 <= 247 ? LowTypes[ch2] : 1424 <= ch2 && ch2 <= 1524 ? 2 : 1536 <= ch2 && ch2 <= 1785 ? ArabicTypes[ch2 - 1536] : 1774 <= ch2 && ch2 <= 2220 ? 4 : 8192 <= ch2 && ch2 <= 8203 ? 256 : 64336 <= ch2 && ch2 <= 65023 ? 4 : ch2 == 8204 ? 256 : 1;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class BidiSpan {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */
  constructor(from, to2, level) {
    this.from = from;
    this.to = to2;
    this.level = level;
  }
  /**
  @internal
  */
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  /**
  @internal
  */
  static find(order2, index2, level, assoc) {
    let maybe = -1;
    for (let i3 = 0; i3 < order2.length; i3++) {
      let span = order2[i3];
      if (span.from <= index2 && span.to >= index2) {
        if (span.level == level)
          return i3;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index2 : span.to > index2 : order2[maybe].level > span.level))
          maybe = i3;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
}
function isolatesEq(a3, b10) {
  if (a3.length != b10.length)
    return false;
  for (let i3 = 0; i3 < a3.length; i3++) {
    let iA2 = a3[i3], iB2 = b10[i3];
    if (iA2.from != iB2.from || iA2.to != iB2.to || iA2.direction != iB2.direction || !isolatesEq(iA2.inner, iB2.inner))
      return false;
  }
  return true;
}
const types$1 = [];
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i3 = from, prev = prevType, prevStrong = prevType; i3 < to2; i3++) {
      let type = charType(line.charCodeAt(i3));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types$1[i3] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i3 = from, prev = prevType, prevStrong = prevType; i3 < to2; i3++) {
      let type = types$1[i3];
      if (type == 128) {
        if (i3 < to2 - 1 && prev == types$1[i3 + 1] && prev & 24)
          type = types$1[i3] = prev;
        else
          types$1[i3] = 256;
      } else if (type == 64) {
        let end = i3 + 1;
        while (end < to2 && types$1[end] == 64)
          end++;
        let replace2 = i3 && prev == 8 || end < rTo && types$1[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j10 = i3; j10 < end; j10++)
          types$1[j10] = replace2;
        i3 = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types$1[i3] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i3 = from, ch2, br2, type; i3 < to2; i3++) {
      if (br2 = Brackets[ch2 = line.charCodeAt(i3)]) {
        if (br2 < 0) {
          for (let sJ2 = sI - 3; sJ2 >= 0; sJ2 -= 3) {
            if (BracketStack[sJ2 + 1] == -br2) {
              let flags = BracketStack[sJ2 + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types$1[i3] = types$1[BracketStack[sJ2]] = type2;
              sI = sJ2;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i3;
          BracketStack[sI++] = ch2;
          BracketStack[sI++] = context;
        }
      } else if ((type = types$1[i3]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ2 = sI - 3; sJ2 >= 0; sJ2 -= 3) {
          let cur = BracketStack[sJ2 + 2];
          if (cur & 2)
            break;
          if (embed) {
            BracketStack[sJ2 + 2] |= 2;
          } else {
            if (cur & 4)
              break;
            BracketStack[sJ2 + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i3 = from; i3 < to2; ) {
      let type = types$1[i3];
      if (type == 256) {
        let end = i3 + 1;
        for (; ; ) {
          if (end == to2) {
            if (iI == isolates.length)
              break;
            end = isolates[iI++].to;
            to2 = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types$1[end] == 256) {
            end++;
          } else {
            break;
          }
        }
        let beforeL = prev == 1;
        let afterL = (end < rTo ? types$1[end] : outerType) == 1;
        let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j10 = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j10 > i3; ) {
          if (j10 == fromJ) {
            j10 = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types$1[--j10] = replace2;
        }
        i3 = end;
      } else {
        prev = type;
        i3++;
      }
    }
  }
}
function emitSpans(line, from, to2, level, baseLevel, isolates, order2) {
  let ourType = level % 2 ? 2 : 1;
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from, iI = 0; iCh < to2; ) {
      let sameDir = true, isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types$1[iCh];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run:
        for (; ; ) {
          if (iI < isolates.length && iScan == isolates[iI].from) {
            if (isNum)
              break run;
            let iso = isolates[iI];
            if (!sameDir)
              for (let upto = iso.to, jI = iI + 1; ; ) {
                if (upto == to2)
                  break run;
                if (jI < isolates.length && isolates[jI].from == upto)
                  upto = isolates[jI++].to;
                else if (types$1[upto] == ourType)
                  break run;
                else
                  break;
              }
            iI++;
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.from > iCh)
                order2.push(new BidiSpan(iCh, iso.from, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order2);
              iCh = iso.to;
            }
            iScan = iso.to;
          } else if (iScan == to2 || (sameDir ? types$1[iScan] != ourType : types$1[iScan] == ourType)) {
            break;
          } else {
            iScan++;
          }
        }
      if (recurse)
        emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order2);
      else if (iCh < iScan)
        order2.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to2, iI = isolates.length; iCh > from; ) {
      let sameDir = true, isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types$1[iCh - 1];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run:
        for (; ; ) {
          if (iI && iScan == isolates[iI - 1].to) {
            if (isNum)
              break run;
            let iso = isolates[--iI];
            if (!sameDir)
              for (let upto = iso.from, jI = iI; ; ) {
                if (upto == from)
                  break run;
                if (jI && isolates[jI - 1].to == upto)
                  upto = isolates[--jI].from;
                else if (types$1[upto - 1] == ourType)
                  break run;
                else
                  break;
              }
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.to < iCh)
                order2.push(new BidiSpan(iso.to, iCh, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order2);
              iCh = iso.from;
            }
            iScan = iso.from;
          } else if (iScan == from || (sameDir ? types$1[iScan - 1] != ourType : types$1[iScan - 1] == ourType)) {
            break;
          } else {
            iScan--;
          }
        }
      if (recurse)
        emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order2);
      else if (iScan < iCh)
        order2.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to2, order2) {
  let outerType = level % 2 ? 2 : 1;
  computeCharTypes(line, from, to2, isolates, outerType);
  processBracketPairs(line, from, to2, isolates, outerType);
  processNeutrals(from, to2, isolates, outerType);
  emitSpans(line, from, to2, level, baseLevel, isolates, order2);
}
function computeOrder(line, direction, isolates) {
  if (!line)
    return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line))
    return trivialOrder(line.length);
  if (isolates.length)
    while (line.length > types$1.length)
      types$1[types$1.length] = 256;
  let order2 = [], level = direction == LTR ? 0 : 1;
  computeSectionOrder(line, level, level, isolates, 0, line.length, order2);
  return order2;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
function moveVisually(line, order2, dir, start, forward) {
  var _a2;
  let startIndex = start.head - line.from, spanI = -1;
  if (startIndex == 0) {
    if (!forward || !line.length)
      return null;
    if (order2[0].level != dir) {
      startIndex = order2[0].side(false, dir);
      spanI = 0;
    }
  } else if (startIndex == line.length) {
    if (forward)
      return null;
    let last = order2[order2.length - 1];
    if (last.level != dir) {
      startIndex = last.side(true, dir);
      spanI = order2.length - 1;
    }
  }
  if (spanI < 0)
    spanI = BidiSpan.find(order2, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
  let span = order2[spanI];
  if (startIndex == span.side(forward, dir)) {
    span = order2[spanI += forward ? 1 : -1];
    startIndex = span.side(!forward, dir);
  }
  let indexForward = forward == (span.dir == dir);
  let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  if (nextIndex != span.side(forward, dir))
    return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
  let nextSpan = spanI == (forward ? order2.length - 1 : 0) ? null : order2[spanI + (forward ? 1 : -1)];
  if (!nextSpan && span.level != dir)
    return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
  if (nextSpan && nextSpan.level < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
}
class DocView extends ContentView {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(view) {
    super();
    this.view = view;
    this.decorations = [];
    this.dynamicDecorationMap = [];
    this.domChanged = null;
    this.hasComposition = null;
    this.markedForComposition = /* @__PURE__ */ new Set();
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateDeco();
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(update) {
    var _a2;
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    let readCompositionAt = -1;
    if (this.view.inputState.composing >= 0) {
      if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
        readCompositionAt = this.domChanged.newSel.head;
      else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
        readCompositionAt = update.state.selection.main.head;
    }
    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
    this.domChanged = null;
    if (this.hasComposition) {
      this.markedForComposition.clear();
      let { from, to: to2 } = this.hasComposition;
      changedRanges = new ChangedRange(from, to2, update.changes.mapPos(from, -1), update.changes.mapPos(to2, 1)).addToSet(changedRanges.slice());
    }
    this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
    if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    if (!(this.flags & 7) && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, update.startState.doc.length, composition);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, oldLength, composition) {
    this.view.viewState.mustMeasureContent = true;
    this.updateChildren(changes, oldLength, composition);
    let { observer } = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
      this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track2 = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, track2);
      this.flags &= ~7;
      if (track2 && (track2.written || observer.selectionRange.focusNode != track2.node))
        this.forceSelection = true;
      this.dom.style.height = "";
    });
    this.markedForComposition.forEach(
      (cView) => cView.flags &= ~8
      /* ViewFlag.Composition */
    );
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.children)
        if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateChildren(changes, oldLength, composition) {
    let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
    let cursor = this.childCursor(oldLength);
    for (let i3 = ranges.length - 1; ; i3--) {
      let next = i3 >= 0 ? ranges[i3] : null;
      if (!next)
        break;
      let { fromA, toA, fromB, toB } = next, content2, breakAtStart, openStart, openEnd;
      if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
        let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
        let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
        breakAtStart = before.breakAtStart;
        openStart = before.openStart;
        openEnd = after.openEnd;
        let compLine = this.compositionView(composition);
        if (after.breakAtStart) {
          compLine.breakAfter = 1;
        } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
          compLine.breakAfter = after.content[0].breakAfter;
          after.content.shift();
        }
        if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
          before.content.pop();
        }
        content2 = before.content.concat(compLine).concat(after.content);
      } else {
        ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
      }
      let { i: toI, off: toOff } = cursor.findPos(toA, 1);
      let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
      replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
    }
    if (composition)
      this.fixCompositionDOM(composition);
  }
  compositionView(composition) {
    let cur = new TextView(composition.text.nodeValue);
    cur.flags |= 8;
    for (let { deco } of composition.marks)
      cur = new MarkView(deco, [cur], cur.length);
    let line = new LineView();
    line.append(cur, 0);
    return line;
  }
  fixCompositionDOM(composition) {
    let fix = (dom, cView2) => {
      cView2.flags |= 8 | (cView2.children.some(
        (c3) => c3.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0);
      this.markedForComposition.add(cView2);
      let prev = ContentView.get(dom);
      if (prev && prev != cView2)
        prev.dom = null;
      cView2.setDOM(dom);
    };
    let pos = this.childPos(composition.range.fromB, 1);
    let cView = this.children[pos.i];
    fix(composition.line, cView);
    for (let i3 = composition.marks.length - 1; i3 >= -1; i3--) {
      pos = cView.childPos(pos.off, 1);
      cView = cView.children[pos.i];
      fix(i3 >= 0 ? composition.marks[i3].node : composition.text, cView);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange();
    let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
    let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
    if (!(focused || fromPointer || selectionNotFocus))
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main;
    let anchor = this.moveToLine(this.domAtPos(main.anchor));
    let head2 = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
    if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head2 = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head2.node, head2.offset, domSel.focusNode, domSel.focusOffset)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
          this.dom.blur();
          this.dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel)
          ;
        else if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text2 = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
              if (text2)
                anchor = new DOMPos(text2.node, text2.offset);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
            rawSel.caretBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head2.node, head2.offset);
          } catch (_10) {
          }
        } else {
          let range = document.createRange();
          if (main.anchor > main.head)
            [anchor, head2] = [head2, anchor];
          range.setEnd(head2.node, head2.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
        if (selectionNotFocus && this.view.root.activeElement == this.dom) {
          this.dom.blur();
          if (activeElt)
            activeElt.focus();
        }
      });
      this.view.observer.setSelectionRange(anchor, head2);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head2.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view } = this, cursor = view.state.selection.main;
    let sel = getSelection(view.root);
    let { anchorNode, anchorOffset } = view.observer.selectionRange;
    if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
      return;
    let line = LineView.find(this, cursor.head);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor.head == lineStart || cursor.head == lineStart + line.length)
      return;
    let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor.head + cursor.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
      sel.collapse(anchorNode, anchorOffset);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(pos) {
    let dom = this.dom, newPos;
    if (pos.node != dom)
      return pos;
    for (let i3 = pos.offset; !newPos && i3 < dom.childNodes.length; i3++) {
      let view = ContentView.get(dom.childNodes[i3]);
      if (view instanceof LineView)
        newPos = view.domAtPos(0);
    }
    for (let i3 = pos.offset - 1; !newPos && i3 >= 0; i3--) {
      let view = ContentView.get(dom.childNodes[i3]);
      if (view instanceof LineView)
        newPos = view.domAtPos(view.length);
    }
    return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
  }
  nearest(dom) {
    for (let cur = dom; cur; ) {
      let domView = ContentView.get(cur);
      if (domView && domView.rootView == this)
        return domView;
      cur = cur.parentNode;
    }
    return null;
  }
  posFromDOM(node2, offset) {
    let view = this.nearest(node2);
    if (!view)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node2, offset) + view.posAtStart;
  }
  domAtPos(pos) {
    let { i: i3, off } = this.childCursor().findPos(pos, -1);
    for (; i3 < this.children.length - 1; ) {
      let child = this.children[i3];
      if (off < child.length || child instanceof LineView)
        break;
      i3++;
      off = 0;
    }
    return this.children[i3].domAtPos(off);
  }
  coordsAt(pos, side) {
    let best = null, bestPos = 0;
    for (let off = this.length, i3 = this.children.length - 1; i3 >= 0; i3--) {
      let child = this.children[i3], end = off - child.breakAfter, start = end - child.length;
      if (end < pos)
        break;
      if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
        best = child;
        bestPos = start;
      }
      off = start;
    }
    return best ? best.coordsAt(pos - bestPos, side) : null;
  }
  coordsForChar(pos) {
    let { i: i3, off } = this.childPos(pos, 1), child = this.children[i3];
    if (!(child instanceof LineView))
      return null;
    while (child.children.length) {
      let { i: i10, off: childOff } = child.childPos(off, 1);
      for (; ; i10++) {
        if (i10 == child.children.length)
          return null;
        if ((child = child.children[i10]).length)
          break;
      }
      off = childOff;
    }
    if (!(child instanceof TextView))
      return null;
    let end = findClusterBreak(child.text, off);
    if (end == off)
      return null;
    let rects = textRange(child.dom, off, end).getClientRects();
    return !rects.length || rects[0].top >= rects[0].bottom ? null : rects[0];
  }
  measureVisibleLineHeights(viewport) {
    let result = [], { from, to: to2 } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    for (let pos = 0, i3 = 0; i3 < this.children.length; i3++) {
      let child = this.children[i3], end = pos + child.length;
      if (end > to2)
        break;
      if (pos >= from) {
        let childRect = child.dom.getBoundingClientRect();
        result.push(childRect.height);
        if (isWider) {
          let last = child.dom.lastChild;
          let rects = last ? clientRectsFor(last) : [];
          if (rects.length) {
            let rect = rects[rects.length - 1];
            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
            if (width > widest) {
              widest = width;
              this.minWidth = contentWidth;
              this.minWidthFrom = pos;
              this.minWidthTo = end;
            }
          }
        }
      }
      pos = end + child.breakAfter;
    }
    return result;
  }
  textDirectionAt(pos) {
    let { i: i3 } = this.childPos(pos, 1);
    return getComputedStyle(this.children[i3].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure)
          return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.style.position = "absolute";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      textHeight = rect ? rect.height : lineHeight;
      dummy.remove();
    });
    return { lineHeight, charWidth, textHeight };
  }
  childCursor(pos = this.length) {
    let i3 = this.children.length;
    if (i3)
      pos -= this.children[--i3].length;
    return new ChildCursor(this.children, pos, i3);
  }
  computeBlockGapDeco() {
    let deco = [], vs2 = this.view.viewState;
    for (let pos = 0, i3 = 0; ; i3++) {
      let next = i3 == vs2.viewports.length ? null : vs2.viewports[i3];
      let end = next ? next.from - 1 : this.length;
      if (end > pos) {
        let height = (vs2.lineBlockAt(end).bottom - vs2.lineBlockAt(pos).top) / this.view.scaleY;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let allDeco = this.view.state.facet(decorations).map((d3, i3) => {
      let dynamic = this.dynamicDecorationMap[i3] = typeof d3 == "function";
      return dynamic ? d3(this.view) : d3;
    });
    for (let i3 = allDeco.length; i3 < allDeco.length + 3; i3++)
      this.dynamicDecorationMap[i3] = false;
    return this.decorations = [
      ...allDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(target) {
    let { range } = target;
    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
    if (!rect)
      return;
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
      rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      };
    let margins = getScrollMargins(this.view);
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    };
    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
  }
}
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
class BlockGapWidget extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
  if (!textNode)
    return null;
  let from = headPos - textNode.offset;
  return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos);
  if (!found)
    return null;
  let { node: textNode, from, to: to2 } = found, text2 = textNode.nodeValue;
  if (/[\n\r]/.test(text2))
    return null;
  if (view.state.doc.sliceString(found.from, found.to) != text2)
    return null;
  let inv = changes.invertedDesc;
  let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to2), from, to2);
  let marks = [];
  for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
    let parentView = ContentView.get(parent);
    if (parentView instanceof MarkView)
      marks.push({ node: parent, deco: parentView.mark });
    else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
      return { range, text: textNode, marks, line: parent };
    else if (parent != view.contentDOM)
      marks.push({ node: parent, deco: new MarkDecoration({
        inclusive: true,
        attributes: getAttrs(parent),
        tagName: parent.tagName.toLowerCase()
      }) });
    else
      return null;
  }
}
function nearbyTextNode(startNode, startOffset, side) {
  if (side <= 0)
    for (let node2 = startNode, offset = startOffset; ; ) {
      if (node2.nodeType == 3)
        return { node: node2, offset };
      if (node2.nodeType == 1 && offset > 0) {
        node2 = node2.childNodes[offset - 1];
        offset = maxOffset(node2);
      } else {
        break;
      }
    }
  if (side >= 0)
    for (let node2 = startNode, offset = startOffset; ; ) {
      if (node2.nodeType == 3)
        return { node: node2, offset };
      if (node2.nodeType == 1 && offset < node2.childNodes.length && side >= 0) {
        node2 = node2.childNodes[offset];
        offset = 0;
      } else {
        break;
      }
    }
  return null;
}
function nextToUneditable(node2, offset) {
  if (node2.nodeType != 1)
    return 0;
  return (offset && node2.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node2.childNodes.length && node2.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
let DecorationComparator$1 = class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to2) {
    addRange(from, to2, this.changes);
  }
  comparePoint(from, to2) {
    addRange(from, to2, this.changes);
  }
};
function findChangedDeco(a3, b10, diff2) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a3, b10, diff2, comp);
  return comp.changes;
}
function inUneditable(node2, inside2) {
  for (let cur = node2; cur && cur != inside2; cur = cur.assignedSlot || cur.parentNode) {
    if (cur.nodeType == 1 && cur.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition)
    changes.iterChangedRanges((from, to2) => {
      if (from < composition.to && to2 > composition.from)
        touched = true;
    });
  return touched;
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from = linePos, to2 = linePos;
  if (bias < 0)
    from = findClusterBreak(line.text, linePos, false);
  else
    to2 = findClusterBreak(line.text, linePos);
  let cat = categorize(line.text.slice(from, to2));
  while (from > 0) {
    let prev = findClusterBreak(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat)
      break;
    from = prev;
  }
  while (to2 < line.length) {
    let next = findClusterBreak(line.text, to2);
    if (categorize(line.text.slice(to2, next)) != cat)
      break;
    to2 = next;
  }
  return EditorSelection.range(from + line.from, to2 + line.from);
}
function getdx(x10, rect) {
  return rect.left > x10 ? rect.left - x10 : Math.max(0, x10 - rect.right);
}
function getdy(y10, rect) {
  return rect.top > y10 ? rect.top - y10 : Math.max(0, y10 - rect.bottom);
}
function yOverlap(a3, b10) {
  return a3.top < b10.bottom - 1 && a3.bottom > b10.top + 1;
}
function upTop(rect, top2) {
  return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x10, y10) {
  let closest, closestRect, closestX, closestY, closestOverlap = false;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i3 = 0; i3 < rects.length; i3++) {
      let rect = rects[i3];
      if (closestRect && yOverlap(closestRect, rect))
        rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx2 = getdx(x10, rect), dy2 = getdy(y10, rect);
      if (dx2 == 0 && dy2 == 0)
        return child.nodeType == 3 ? domPosInText(child, x10, y10) : domPosAtCoords(child, x10, y10);
      if (!closest || closestY > dy2 || closestY == dy2 && closestX > dx2) {
        closest = child;
        closestRect = rect;
        closestX = dx2;
        closestY = dy2;
        let side = dy2 ? y10 < rect.top ? -1 : 1 : dx2 ? x10 < rect.left ? -1 : 1 : 0;
        closestOverlap = !side || (side > 0 ? i3 < rects.length - 1 : i3 > 0);
      }
      if (dx2 == 0) {
        if (y10 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y10 < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y10) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y10) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return { node: parent, offset: 0 };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x10));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y10);
  if (closestOverlap && closest.contentEditable != "false")
    return domPosAtCoords(closest, clipX, y10);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x10 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return { node: parent, offset };
}
function domPosInText(node2, x10, y10) {
  let len = node2.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i3 = 0; i3 < len; i3++) {
    let rects = textRange(node2, i3, i3 + 1).getClientRects();
    for (let j10 = 0; j10 < rects.length; j10++) {
      let rect = rects[j10];
      if (rect.top == rect.bottom)
        continue;
      if (!generalSide)
        generalSide = x10 - rect.left;
      let dy2 = (rect.top > y10 ? rect.top - y10 : y10 - rect.bottom) - 1;
      if (rect.left - 1 <= x10 && rect.right + 1 >= x10 && dy2 < closestDY) {
        let right = x10 >= (rect.left + rect.right) / 2, after = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node2, i3).getBoundingClientRect();
          if (rectBefore.left == rect.right)
            after = !right;
        }
        if (dy2 <= 0)
          return { node: node2, offset: i3 + (after ? 1 : 0) };
        closestOffset = i3 + (after ? 1 : 0);
        closestDY = dy2;
      }
    }
  }
  return { node: node2, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node2.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
  var _a2, _b2;
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let block, { docHeight } = view.viewState;
  let { x: x10, y: y10 } = coords, yOffset = y10 - docTop;
  if (yOffset < 0)
    return 0;
  if (yOffset > docHeight)
    return view.state.doc.length;
  for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
    block = view.elementAtHeight(yOffset);
    if (block.type == BlockType.Text)
      break;
    for (; ; ) {
      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight)
        break;
      if (bounced)
        return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y10 = docTop + yOffset;
  let lineStart = block.from;
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x10, y10);
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x10, y10);
  let doc2 = view.dom.ownerDocument;
  let root2 = view.root.elementFromPoint ? view.root : doc2;
  let element2 = root2.elementFromPoint(x10, y10);
  if (element2 && !view.contentDOM.contains(element2))
    element2 = null;
  if (!element2) {
    x10 = Math.max(content2.left + 1, Math.min(content2.right - 1, x10));
    element2 = root2.elementFromPoint(x10, y10);
    if (element2 && !view.contentDOM.contains(element2))
      element2 = null;
  }
  let node2, offset = -1;
  if (element2 && ((_a2 = view.docView.nearest(element2)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x10, y10);
      if (pos)
        ({ offsetNode: node2, offset } = pos);
    } else if (doc2.caretRangeFromPoint) {
      let range = doc2.caretRangeFromPoint(x10, y10);
      if (range) {
        ({ startContainer: node2, startOffset: offset } = range);
        if (!view.contentDOM.contains(node2) || browser.safari && isSuspiciousSafariCaretResult(node2, offset, x10) || browser.chrome && isSuspiciousChromeCaretResult(node2, offset, x10))
          node2 = void 0;
      }
    }
  }
  if (!node2 || !view.docView.dom.contains(node2)) {
    let line = LineView.find(view.docView, lineStart);
    if (!line)
      return yOffset > block.top + block.height / 2 ? block.to : block.from;
    ({ node: node2, offset } = domPosAtCoords(line.dom, x10, y10));
  }
  let nearest = view.docView.nearest(node2);
  if (!nearest)
    return null;
  if (nearest.isWidget && ((_b2 = nearest.dom) === null || _b2 === void 0 ? void 0 : _b2.nodeType) == 1) {
    let rect = nearest.dom.getBoundingClientRect();
    return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
  } else {
    return nearest.localPosFromDOM(node2, offset) + nearest.posAtStart;
  }
}
function posAtCoordsImprecise(view, contentRect, block, x10, y10) {
  let into = Math.round((x10 - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line = Math.floor((y10 - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function isSuspiciousSafariCaretResult(node2, offset, x10) {
  let len;
  if (node2.nodeType != 3 || offset != (len = node2.nodeValue.length))
    return false;
  for (let next = node2.nextSibling; next; next = next.nextSibling)
    if (next.nodeType != 1 || next.nodeName != "BR")
      return false;
  return textRange(node2, len - 1, len).getBoundingClientRect().left > x10;
}
function isSuspiciousChromeCaretResult(node2, offset, x10) {
  if (offset != 0)
    return false;
  for (let cur = node2; ; ) {
    let parent = cur.parentNode;
    if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
      return false;
    if (parent.classList.contains("cm-line"))
      break;
    cur = parent;
  }
  let rect = node2.nodeType == 1 ? node2.getBoundingClientRect() : textRange(node2, 0, Math.max(node2.nodeValue.length, 1)).getBoundingClientRect();
  return x10 - rect.left > 5;
}
function blockAt(view, pos) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type))
    for (let l3 of line.type) {
      if (l3.to > pos || l3.to == pos && (l3.to == line.to || l3.type == BlockType.Text))
        return l3;
    }
  return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head);
  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by2) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur = start, check = null; ; ) {
    let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = EditorSelection.cursor(forward ? line.from : line.to);
    }
    if (!check) {
      if (!by2)
        return next;
      check = by2(char);
    } else if (!check(char)) {
      return cur;
    }
    cur = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist2 + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
      let charRect = view.docView.coordsForChar(pos);
      let assoc = !charRect || curY < charRect.top ? -1 : 1;
      return EditorSelection.cursor(pos, assoc, void 0, goal);
    }
  }
}
function skipAtomicRanges(atoms, pos, bias) {
  for (; ; ) {
    let moved = 0;
    for (let set of atoms) {
      set.between(pos - 1, pos + 1, (from, to2, value) => {
        if (pos > from && pos < to2) {
          let side = moved || bias || (pos - from < to2 - pos ? -1 : 1);
          pos = side < 0 ? from : to2;
          moved = side;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f3) => f3(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
class InputState {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  constructor(view) {
    this.view = view;
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.pendingIOSKey = void 0;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastEscPress = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.compositionPendingKey = false;
    this.compositionPendingChange = false;
    this.mouseSelection = null;
    this.handleEvent = this.handleEvent.bind(this);
    view.scrollDOM.addEventListener("mousedown", (event) => {
      if (event.target == view.scrollDOM && event.clientY > view.contentDOM.getBoundingClientRect().bottom) {
        this.runHandlers("mousedown", event);
        if (!event.defaultPrevented && event.button == 2) {
          let start = view.contentDOM.style.minHeight;
          view.contentDOM.style.minHeight = "100%";
          setTimeout(() => view.contentDOM.style.minHeight = start, 200);
        }
      }
    });
    view.scrollDOM.addEventListener("drop", (event) => {
      if (event.target == view.scrollDOM && event.clientY > view.contentDOM.getBoundingClientRect().bottom)
        this.runHandlers("drop", event);
    });
    this.notifiedFocused = view.hasFocus;
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
    if (browser.gecko)
      firefoxCopyCutHack(view.contentDOM.ownerDocument);
  }
  handleEvent(event) {
    if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
      return;
    if (event.type == "keydown" && this.keydown(event))
      return;
    this.runHandlers(event.type, event);
  }
  runHandlers(type, event) {
    let handlers2 = this.handlers[type];
    if (handlers2) {
      for (let observer of handlers2.observers)
        observer(this.view, event);
      for (let handler of handlers2.handlers) {
        if (event.defaultPrevented)
          break;
        if (handler(this.view, event)) {
          event.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
    for (let type in handlers2)
      if (type != "scroll") {
        let passive = !handlers2[type].handlers.length;
        let exists = prev[type];
        if (exists && passive != !exists.handlers.length) {
          dom.removeEventListener(type, this.handleEvent);
          exists = null;
        }
        if (!exists)
          dom.addEventListener(type, this.handleEvent, { passive });
      }
    for (let type in prev)
      if (type != "scroll" && !handlers2[type])
        dom.removeEventListener(type, this.handleEvent);
    this.handlers = handlers2;
  }
  keydown(event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return true;
    if (event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
      this.view.inputState.lastEscPress = 0;
    if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
      this.view.observer.delayAndroidKey(event.key, event.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key2) => key2.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
      this.pendingIOSKey = pending || event;
      setTimeout(() => this.flushIOSKey(), 250);
      return true;
    }
    if (event.keyCode != 229)
      this.view.observer.forceFlush();
    return false;
  }
  flushIOSKey() {
    let key2 = this.pendingIOSKey;
    if (!key2)
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(this.view.contentDOM, key2.key, key2.keyCode);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type))
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
      this.compositionPendingKey = false;
      return true;
    }
    return false;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
}
function bindHandler(plugin, handler) {
  return (view, event) => {
    try {
      return handler.call(plugin, event, view);
    } catch (e3) {
      logException(view.state, e3);
    }
  };
}
function computeHandlers(plugins) {
  let result = /* @__PURE__ */ Object.create(null);
  function record(type) {
    return result[type] || (result[type] = { observers: [], handlers: [] });
  }
  for (let plugin of plugins) {
    let spec = plugin.spec;
    if (spec && spec.domEventHandlers)
      for (let type in spec.domEventHandlers) {
        let f3 = spec.domEventHandlers[type];
        if (f3)
          record(type).handlers.push(bindHandler(plugin.value, f3));
      }
    if (spec && spec.domEventObservers)
      for (let type in spec.domEventObservers) {
        let f3 = spec.domEventObservers[type];
        if (f3)
          record(type).observers.push(bindHandler(plugin.value, f3));
      }
  }
  for (let type in handlers)
    record(type).handlers.push(handlers[type]);
  for (let type in observers)
    record(type).observers.push(observers[type]);
  return result;
}
const PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const EmacsyPendingKeys = "dthko";
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
const dragScrollMargin = 6;
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8;
}
function dist(a3, b10) {
  return Math.max(Math.abs(a3.clientX - b10.clientX), Math.abs(a3.clientY - b10.clientY));
}
class MouseSelection {
  constructor(view, startEvent, style2, mustSelect) {
    this.view = view;
    this.startEvent = startEvent;
    this.style = style2;
    this.mustSelect = mustSelect;
    this.scrollSpeed = { x: 0, y: 0 };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParent = scrollableParent(view.contentDOM);
    this.atoms = view.state.facet(atomicRanges).map((f3) => f3(view));
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event) {
    if (this.dragging === false)
      this.select(event);
  }
  move(event) {
    var _a2;
    if (event.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
      return;
    this.select(this.lastEvent = event);
    let sx2 = 0, sy2 = 0;
    let rect = ((_a2 = this.scrollParent) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
    let margins = getScrollMargins(this.view);
    if (event.clientX - margins.left <= rect.left + dragScrollMargin)
      sx2 = -dragScrollSpeed(rect.left - event.clientX);
    else if (event.clientX + margins.right >= rect.right - dragScrollMargin)
      sx2 = dragScrollSpeed(event.clientX - rect.right);
    if (event.clientY - margins.top <= rect.top + dragScrollMargin)
      sy2 = -dragScrollSpeed(rect.top - event.clientY);
    else if (event.clientY + margins.bottom >= rect.bottom - dragScrollMargin)
      sy2 = dragScrollSpeed(event.clientY - rect.bottom);
    this.setScrollSpeed(sx2, sy2);
  }
  up(event) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = null;
  }
  setScrollSpeed(sx2, sy2) {
    this.scrollSpeed = { x: sx2, y: sy2 };
    if (sx2 || sy2) {
      if (this.scrolling < 0)
        this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    if (this.scrollParent) {
      this.scrollParent.scrollLeft += this.scrollSpeed.x;
      this.scrollParent.scrollTop += this.scrollSpeed.y;
    } else {
      this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);
    }
    if (this.dragging === false)
      this.select(this.lastEvent);
  }
  skipAtoms(sel) {
    let ranges = null;
    for (let i3 = 0; i3 < sel.ranges.length; i3++) {
      let range = sel.ranges[i3], updated = null;
      if (range.empty) {
        let pos = skipAtomicRanges(this.atoms, range.from, 0);
        if (pos != range.from)
          updated = EditorSelection.cursor(pos, -1);
      } else {
        let from = skipAtomicRanges(this.atoms, range.from, -1);
        let to2 = skipAtomicRanges(this.atoms, range.to, 1);
        if (from != range.from || to2 != range.to)
          updated = EditorSelection.range(range.from == range.anchor ? from : to2, range.from == range.head ? from : to2);
      }
      if (updated) {
        if (!ranges)
          ranges = sel.ranges.slice();
        ranges[i3] = updated;
      }
    }
    return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
  }
  select(event) {
    let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
    if (this.mustSelect || !selection.eq(view.state.selection) || selection.main.assoc != view.state.selection.main.assoc && this.dragging === false)
      this.view.dispatch({
        selection,
        userEvent: "select.pointer"
      });
    this.mustSelect = false;
  }
  update(update) {
    if (update.docChanged && this.dragging)
      this.dragging = this.dragging.map(update.changes);
    if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i3 = 0; i3 < rects.length; i3++) {
    let rect = rects[i3];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node2 = event.target, cView; node2 != view.contentDOM; node2 = node2.parentNode)
    if (!node2 || node2.nodeType == 11 || (cView = ContentView.get(node2)) && cView.ignoreEvent(event))
      return false;
  return true;
}
const handlers = /* @__PURE__ */ Object.create(null);
const observers = /* @__PURE__ */ Object.create(null);
const brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function doPaste(view, input) {
  let { state } = view, changes, i3 = 1, text2 = state.toText(input);
  let byLine = text2.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r3) => r3.empty) && lastLinewiseCopy == text2.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine)
        return { range };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text2.line(i3++).text : input) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text2.line(i3++);
      return {
        changes: { from: range.from, to: range.to, insert: line.text },
        range: EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text2);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
observers.scroll = (view) => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
  if (event.keyCode == 27)
    view.inputState.lastEscPress = Date.now();
  return false;
};
observers.touchstart = (view, e3) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3)
    return false;
  let style2 = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style2 = makeStyle(view, event);
    if (style2)
      break;
  }
  if (!style2 && event.button == 0)
    style2 = basicMouseSelection(view, event);
  if (style2) {
    let mustFocus = !view.hasFocus;
    view.inputState.startMouseSelection(new MouseSelection(view, event, style2, mustFocus));
    if (mustFocus)
      view.observer.ignore(() => focusPreventScroll(view.contentDOM));
    let mouseSel = view.inputState.mouseSelection;
    if (mouseSel) {
      mouseSel.start(event);
      return !mouseSel.dragging;
    }
  }
  return false;
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to2 = visual ? visual.posAtEnd : line.to;
    if (to2 < view.state.doc.length && to2 == line.to)
      to2++;
    return EditorSelection.range(from, to2);
  }
}
let insideY = (y10, rect) => y10 >= rect.top && y10 <= rect.bottom;
let inside = (x10, y10, rect) => insideY(y10, rect) && x10 >= rect.left && x10 <= rect.right;
function findPositionSide(view, pos, x10, y10) {
  let line = LineView.find(view.docView, pos);
  if (!line)
    return 1;
  let off = pos - line.posAtStart;
  if (off == 0)
    return 1;
  if (off == line.length)
    return -1;
  let before = line.coordsAt(off, -1);
  if (before && inside(x10, y10, before))
    return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x10, y10, after))
    return 1;
  return before && insideY(y10, before) ? -1 : 1;
}
function queryPos(view, event) {
  let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = queryPos(view, event), type = getClickType(event);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, extend3, multiple) {
      let cur = queryPos(view, event2), removed;
      let range = rangeForClick(view, cur.pos, cur.bias, type);
      if (start.pos != cur.pos && !extend3) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from = Math.min(startRange.from, range.from), to2 = Math.max(startRange.to, range.to);
        range = from < range.from ? EditorSelection.range(from, to2) : EditorSelection.range(to2, from);
      }
      if (extend3)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
        return removed;
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i3 = 0; i3 < sel.ranges.length; i3++) {
    let { from, to: to2 } = sel.ranges[i3];
    if (from <= pos && to2 >= pos)
      return EditorSelection.create(sel.ranges.slice(0, i3).concat(sel.ranges.slice(i3 + 1)), sel.mainIndex == i3 ? 0 : sel.mainIndex - (sel.mainIndex > i3 ? 1 : 0));
  }
  return null;
}
handlers.dragstart = (view, event) => {
  let { selection: { main } } = view.state;
  let { mouseSelection } = view.inputState;
  if (mouseSelection)
    mouseSelection.dragging = main;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
    event.dataTransfer.effectAllowed = "copyMove";
  }
  return false;
};
function dropText(view, event, text2, direct) {
  if (!text2)
    return;
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let { mouseSelection } = view.inputState;
  let del = direct && mouseSelection && mouseSelection.dragging && dragMovesSelection(view, event) ? { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
  let ins = { from: dropPos, insert: text2 };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer)
    return false;
  if (view.state.readOnly)
    return true;
  let files = event.dataTransfer.files;
  if (files && files.length) {
    let text2 = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event, text2.filter((s3) => s3 != null).join(view.state.lineBreak), false);
    };
    for (let i3 = 0; i3 < files.length; i3++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text2[i3] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i3]);
    }
    return true;
  } else {
    let text2 = event.dataTransfer.getData("Text");
    if (text2) {
      dropText(view, event, text2, true);
      return true;
    }
  }
  return false;
};
handlers.paste = (view, event) => {
  if (view.state.readOnly)
    return true;
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    doPaste(view, data.getData("text/plain") || data.getData("text/uri-text"));
    return true;
  } else {
    capturePaste(view);
    return false;
  }
};
function captureCopy(view, text2) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text2;
  target.focus();
  target.selectionEnd = text2.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from } of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: content2.join(state.lineBreak), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let { text: text2, ranges, linewise } = copiedRange(view.state);
  if (!text2 && !linewise)
    return false;
  lastLinewiseCopy = linewise ? text2 : null;
  if (event.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    data.clearData();
    data.setData("text/plain", text2);
    return true;
  } else {
    captureCopy(view, text2);
    return false;
  }
};
const isFocusChange = /* @__PURE__ */ Annotation.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect = getEffect(state, focus);
    if (effect)
      effects.push(effect);
  }
  return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr2 = focusChangeTransaction(view.state, focus);
      if (tr2)
        view.dispatch(tr2);
      else
        view.update([]);
    }
  }, 10);
}
observers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
observers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = (view) => {
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
observers.compositionend = (view) => {
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionPendingKey = true;
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
  view.inputState.compositionFirstChange = null;
  if (browser.chrome && browser.android) {
    view.observer.flushSoon();
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush());
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition)
        view.update([]);
    }, 50);
  }
};
observers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
  var _a2;
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find((key2) => key2.inputType == event.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
      setTimeout(() => {
        var _a3;
        if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
  return false;
};
const appliedFirefoxHack = /* @__PURE__ */ new Set();
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2);
    doc2.addEventListener("copy", () => {
    });
    doc2.addEventListener("cut", () => {
    });
  }
}
const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class HeightOracle {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = Text.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.textHeight = 14;
    this.lineLength = 30;
    this.heightChanged = false;
  }
  heightForGap(from, to2) {
    let lines = this.doc.lineAt(to2).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping)
      lines += Math.max(0, Math.ceil((to2 - from - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i3 = 0; i3 < lineHeights.length; i3++) {
      let h10 = lineHeights[i3];
      if (h10 < 0) {
        i3++;
      } else if (!this.heightSamples[Math.floor(h10 * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h10 * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.textHeight = textHeight;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i3 = 0; i3 < knownHeights.length; i3++) {
        let h10 = knownHeights[i3];
        if (h10 < 0)
          i3++;
        else
          this.heightSamples[Math.floor(h10 * 10)] = true;
      }
    }
    return changed;
  }
}
class MeasuredHeights {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class BlockInfo {
  /**
  @internal
  */
  constructor(from, length, top2, height, _content) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this._content = _content;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(other) {
    let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
  }
}
var QueryType = /* @__PURE__ */ function(QueryType2) {
  QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
  QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
  QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType2;
}(QueryType || (QueryType = {}));
const Epsilon = 1e-3;
class HeightMap {
  constructor(length, height, flags = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(oracle, height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        oracle.heightChanged = true;
      this.height = height;
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return HeightMap.of(nodes);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this, doc2 = oracle.doc;
    for (let i3 = changes.length - 1; i3 >= 0; i3--) {
      let { fromA, toA, fromB, toB } = changes[i3];
      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i3 > 0 && start.from <= changes[i3 - 1].toA) {
        fromA = changes[i3 - 1].fromA;
        fromB = changes[i3 - 1].fromB;
        i3--;
        if (fromA < start.from)
          start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
      me = me.replace(fromA, toA, nodes);
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i3 = 0, j10 = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i3 == j10) {
        if (before > after * 2) {
          let split = nodes[i3 - 1];
          if (split.break)
            nodes.splice(--i3, 1, split.left, null, split.right);
          else
            nodes.splice(--i3, 1, split.left, split.right);
          j10 += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j10];
          if (split.break)
            nodes.splice(j10, 1, split.left, null, split.right);
          else
            nodes.splice(j10, 1, split.left, split.right);
          j10 += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i3++];
        if (next)
          before += next.size;
      } else {
        let next = nodes[--j10];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i3 - 1] == null) {
      brk = 1;
      i3--;
    } else if (nodes[i3] == null) {
      brk = 1;
      j10++;
    }
    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i3)), brk, HeightMap.of(nodes.slice(j10)));
  }
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
  constructor(length, height, deco) {
    super(length, height);
    this.deco = deco;
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.deco || 0);
  }
  lineAt(_value, _type, oracle, top2, offset) {
    return this.blockAt(0, oracle, top2, offset);
  }
  forEachLine(from, to2, oracle, top2, offset, f3) {
    if (from <= offset + this.length && to2 >= offset)
      f3(this.blockAt(0, oracle, top2, offset));
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class HeightMapText extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, null);
    this.collapsed = 0;
    this.widgetHeight = 0;
    this.breaks = 0;
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.breaks);
  }
  replace(_from, _to, nodes) {
    let node2 = nodes[0];
    if (nodes.length == 1 && (node2 instanceof HeightMapText || node2 instanceof HeightMapGap && node2.flags & 4) && Math.abs(this.length - node2.length) < 10) {
      if (node2 instanceof HeightMapGap)
        node2 = new HeightMapText(node2.length, this.height);
      else
        node2.height = this.height;
      if (!this.outdated)
        node2.outdated = false;
      return node2;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    else if (force || this.outdated)
      this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  heightMetrics(oracle, offset) {
    let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine, perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      if (this.length > lines + 1)
        perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return { firstLine, lastLine, perLine, perChar };
  }
  blockAt(height, oracle, top2, offset) {
    let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    if (oracle.lineWrapping) {
      let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length);
      let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
      let lineTop = Math.max(top2, height - lineHeight / 2);
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
      let { from, length } = oracle.doc.line(firstLine + line);
      return new BlockInfo(from, length, top2 + perLine * line, perLine, 0);
    }
  }
  lineAt(value, type, oracle, top2, offset) {
    if (type == QueryType.ByHeight)
      return this.blockAt(value, oracle, top2, offset);
    if (type == QueryType.ByPosNoHeight) {
      let { from, to: to2 } = oracle.doc.lineAt(value);
      return new BlockInfo(from, to2 - from, 0, 0, 0);
    }
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
    let linesAbove = line.number - firstLine;
    let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
    return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
  }
  forEachLine(from, to2, oracle, top2, offset, f3) {
    from = Math.max(from, offset);
    to2 = Math.min(to2, offset + this.length);
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    for (let pos = from, lineTop = top2; pos <= to2; ) {
      let line = oracle.doc.lineAt(pos);
      if (pos == from) {
        let linesAbove = line.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
      }
      let lineHeight = perLine + perChar * line.length;
      f3(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
      lineTop += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to2, nodes) {
    let after = this.length - to2;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof HeightMapGap)
        nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
      else
        nodes.push(null, new HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof HeightMapGap)
        nodes[0] = new HeightMapGap(from + first.length);
      else
        nodes.unshift(new HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to2, result) {
    result.push(new HeightMapGap(to2 - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
      if (measured.from > offset)
        nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height = measured.heights[measured.index++];
        if (singleHeight == -1)
          singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line = new HeightMapText(len, height);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
        oracle.heightChanged = true;
      return result;
    } else if (force || this.outdated) {
      this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class HeightMapBranch extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top2, offset) {
    let mid = top2 + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type, oracle, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
  }
  forEachLine(from, to2, oracle, top2, offset, f3) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset)
        this.left.forEachLine(from, to2, oracle, top2, offset, f3);
      if (to2 >= rightOffset)
        this.right.forEachLine(from, to2, oracle, rightTop, rightOffset, f3);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset);
      if (from < mid.from)
        this.left.forEachLine(from, mid.from - 1, oracle, top2, offset, f3);
      if (mid.to >= from && mid.from <= to2)
        f3(mid);
      if (to2 > mid.to)
        this.right.forEachLine(mid.to + 1, to2, oracle, rightTop, rightOffset, f3);
    }
  }
  replace(from, to2, nodes) {
    let rightStart = this.left.length + this.break;
    if (to2 < rightStart)
      return this.balanced(this.left.replace(from, to2, nodes), this.right);
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to2 - rightStart, nodes));
    let result = [];
    if (from > 0)
      this.decomposeLeft(from, result);
    let left = result.length;
    for (let node2 of nodes)
      result.push(node2);
    if (from > 0)
      mergeGaps(result, left - 1);
    if (to2 < this.length) {
      let right = result.length;
      this.decomposeRight(to2, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to2, result) {
    let left = this.left.length;
    if (to2 <= left)
      return this.left.decomposeLeft(to2, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to2 >= left)
        result.push(null);
    }
    if (to2 > left)
      this.right.decomposeLeft(to2 - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length, right = left + this.break;
    if (from >= right)
      return this.right.decomposeRight(from - right, result);
    if (from < left)
      this.left.decomposeRight(from, result);
    if (this.break && from < right)
      result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = left;
    this.right = right;
    this.height = left.height + right.height;
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else
      left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to2) {
    if (this.lineStart > -1) {
      let end = Math.min(to2, this.lineEnd), last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText)
        last.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;
      if (to2 > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to2;
  }
  point(from, to2, deco) {
    if (from < to2 || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      let breaks = deco.widget ? deco.widget.lineBreaks : 0;
      if (height < 0)
        height = this.oracle.lineHeight;
      let len = to2 - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco));
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len);
      }
    } else if (to2 > from) {
      this.span(from, to2);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from, to: to2 } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to2;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from)
      this.nodes.push(new HeightMapText(this.pos - from, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from, to2) {
    let gap = new HeightMapGap(to2 - from);
    if (this.oracle.doc.lineAt(from).to == to2)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText)
      return last;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    let deco = block.deco;
    if (deco && deco.startSide > 0 && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (deco && deco.endSide > 0)
      this.covering = block;
  }
  addLineDeco(height, breaks, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    line.breaks += breaks;
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node2 of this.nodes) {
      if (node2 instanceof HeightMapText)
        node2.updateHeight(this.oracle, pos);
      pos += node2 ? node2.length : 1;
    }
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from, to2) {
    let builder = new NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to2, builder, 0);
    return builder.finish(from);
  }
}
function heightRelevantDecoChanges(a3, b10, diff2) {
  let comp = new DecorationComparator2();
  RangeSet.compare(a3, b10, diff2, comp, 0);
  return comp.changes;
}
class DecorationComparator2 {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to2, a3, b10) {
    if (from < to2 || a3 && a3.heightRelevant || b10 && b10.heightRelevant)
      addRange(from, to2, this.changes, 5);
  }
}
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt = parent;
      let style2 = window.getComputedStyle(elt);
      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style2.overflow != "visible") {
        let parentRect = elt.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
      }
      parent = style2.position == "absolute" || style2.position == "fixed" ? elt.offsetParent : elt.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  };
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
class LineGap {
  constructor(from, to2, size) {
    this.from = from;
    this.to = to2;
    this.size = size;
  }
  static same(a3, b10) {
    if (a3.length != b10.length)
      return false;
    for (let i3 = 0; i3 < a3.length; i3++) {
      let gA2 = a3[i3], gB2 = b10[i3];
      if (gA2.from != gB2.from || gA2.to != gB2.to || gA2.size != gB2.size)
        return false;
    }
    return true;
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
    }).range(this.from, this.to);
  }
}
class LineGapWidget extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class ViewState {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scrollTop = 0;
    this.scrolledToBottom = true;
    this.scaleX = 1;
    this.scaleY = 1;
    this.scrollAnchorPos = 0;
    this.scrollAnchorHeight = -1;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some((v10) => typeof v10 != "function" && v10.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = state.facet(decorations).filter((d3) => typeof d3 != "function");
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    this.viewport = this.getViewport(0, null);
    this.updateViewportLines();
    this.updateForViewport();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main } = this.state.selection;
    for (let i3 = 0; i3 <= 1; i3++) {
      let pos = i3 ? main.head : main.anchor;
      if (!viewports.some(({ from, to: to2 }) => pos >= from && pos <= to2)) {
        let { from, to: to2 } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from, to2));
      }
    }
    this.viewports = viewports.sort((a3, b10) => a3.from - b10.from);
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
      this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter((d3) => typeof d3 != "function");
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight)
      update.flags |= 2;
    if (scrollAnchor) {
      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
      this.scrollAnchorHeight = scrollAnchor.top;
    } else {
      this.scrollAnchorPos = -1;
      this.scrollAnchorHeight = this.heightMap.height;
    }
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTarget);
    let updateLines = !update.changes.empty || update.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    this.updateForViewport();
    if (updateLines)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges();
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style2 = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style2.whiteSpace;
    this.defaultTextDirection = style2.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result = 0, bias = 0;
    if (domRect.width && domRect.height) {
      let scaleX = domRect.width / dom.offsetWidth;
      let scaleY = domRect.height / dom.offsetHeight;
      if (scaleX > 0.995 && scaleX < 1.005)
        scaleX = 1;
      if (scaleY > 0.995 && scaleY < 1.005)
        scaleY = 1;
      if (this.scaleX != scaleX || this.scaleY != scaleY) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        result |= 8;
        refresh = measureContent = true;
      }
    }
    let paddingTop = (parseInt(style2.paddingTop) || 0) * this.scaleY;
    let paddingBottom = (parseInt(style2.paddingBottom) || 0) * this.scaleY;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result |= 8 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 8;
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1;
      this.scrollTop = scrollTop;
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView && !this.scrollTarget)
      return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 8;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 8;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      oracle.heightChanged = false;
      for (let vp2 of this.viewports) {
        let heights = vp2.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp2);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp2.from, heights));
      }
      if (oracle.heightChanged)
        result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange)
      this.viewport = this.getViewport(bias, this.scrollTarget);
    this.updateForViewport();
    if (result & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map2 = this.heightMap, oracle = this.heightOracle;
    let { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map2.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map2.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let { head: head2 } = scrollTarget.range;
      if (head2 < viewport.from || head2 > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map2.lineAt(head2, QueryType.ByPos, oracle, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head2 < viewport.from)
          topPos = block.top;
        else
          topPos = block.bottom - viewHeight;
        viewport = new Viewport(map2.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map2.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to2 = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to2, QueryType.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from, to: to2 }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
    let { bottom } = this.heightMap.lineAt(to2, QueryType.ByPos, this.heightOracle, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(
      -bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (to2 == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
      bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
    return mapped;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping)
      return [];
    let gaps = [];
    let addGap = (from, to2, line, structure) => {
      if (to2 - from < halfMargin)
        return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty)
        avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from && pos < to2) {
          addGap(from, pos - 10, line, structure);
          addGap(pos + 10, to2, line, structure);
          return;
        }
      }
      let gap = find$1(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to2) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to2 < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r3) => r3.from <= to2 && r3.to >= to2)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to2), false, true).head;
          if (lineStart > from)
            to2 = lineStart;
        }
        gap = new LineGap(from, to2, this.gapSize(line, from, to2, structure));
      }
      gaps.push(gap);
    };
    for (let line of this.viewportLines) {
      if (line.length < doubleMargin)
        continue;
      let structure = lineStructure(line.from, line.to, this.stateDeco);
      if (structure.total < doubleMargin)
        continue;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top2, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
          top2 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top2 = (this.visibleTop - line.top - marginHeight) / line.height;
          bot = (this.visibleBottom - line.top + marginHeight) / line.height;
        }
        viewFrom = findPosition(structure, top2);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let left, right;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
          left = targetFrac - spaceFrac;
          right = targetFrac + spaceFrac;
        } else {
          left = (this.pixelViewport.left - marginWidth) / totalWidth;
          right = (this.pixelViewport.right + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left);
        viewTo = findPosition(structure, right);
      }
      if (viewFrom > line.from)
        addGap(line.from, viewFrom, line, structure);
      if (viewTo < line.to)
        addGap(viewTo, line.to, line, structure);
    }
    return gaps;
  }
  gapSize(line, from, to2, structure) {
    let fraction = findFraction(structure, to2) - findFraction(structure, from);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges() {
    let deco = this.stateDeco;
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to2) {
        ranges.push({ from, to: to2 });
      },
      point() {
      }
    }, 20);
    let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r3, i3) => r3.from != ranges[i3].from || r3.to != ranges[i3].to);
    this.visibleRanges = ranges;
    return changed ? 4 : 0;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b10) => b10.from <= pos && b10.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(scrollTop) {
    let block = this.lineBlockAtHeight(scrollTop + 8);
    return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Viewport {
  constructor(from, to2) {
    this.from = from;
    this.to = to2;
  }
}
function lineStructure(from, to2, stateDeco) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(stateDeco, from, to2, {
    span() {
    },
    point(from2, to3) {
      if (from2 > pos) {
        ranges.push({ from: pos, to: from2 });
        total += from2 - pos;
      }
      pos = to3;
    }
  }, 20);
  if (pos < to2) {
    ranges.push({ from: pos, to: to2 });
    total += to2 - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i3 = 0; ; i3++) {
    let { from, to: to2 } = ranges[i3], size = to2 - from;
    if (dist2 <= size)
      return from + dist2;
    dist2 -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from, to: to2 } of structure.ranges) {
    if (pos <= to2) {
      counted += pos - from;
      break;
    }
    counted += to2 - from;
  }
  return counted / structure.total;
}
function find$1(array, f3) {
  for (let val of array)
    if (f3(val))
      return val;
  return void 0;
}
const IdScaler = {
  toDOM(n3) {
    return n3;
  },
  fromDOM(n3) {
    return n3;
  },
  scale: 1
};
class BigScaler {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from, to: to2 }) => {
      let top2 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
      let bottom = heightMap.lineAt(to2, QueryType.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom - top2;
      return { from, to: to2, top: top2, bottom, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n3) {
    for (let i3 = 0, base2 = 0, domBase = 0; ; i3++) {
      let vp2 = i3 < this.viewports.length ? this.viewports[i3] : null;
      if (!vp2 || n3 < vp2.top)
        return domBase + (n3 - base2) * this.scale;
      if (n3 <= vp2.bottom)
        return vp2.domTop + (n3 - vp2.top);
      base2 = vp2.bottom;
      domBase = vp2.domBottom;
    }
  }
  fromDOM(n3) {
    for (let i3 = 0, base2 = 0, domBase = 0; ; i3++) {
      let vp2 = i3 < this.viewports.length ? this.viewports[i3] : null;
      if (!vp2 || n3 < vp2.domTop)
        return base2 + (n3 - domBase) / this.scale;
      if (n3 <= vp2.domBottom)
        return vp2.top + (n3 - vp2.domTop);
      base2 = vp2.bottom;
      domBase = vp2.domBottom;
    }
  }
}
function scaleBlock(block, scaler) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b10) => scaleBlock(b10, scaler)) : block._content);
}
const theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
const darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
const baseThemeID = /* @__PURE__ */ StyleModule.newName(), baseLightID = /* @__PURE__ */ StyleModule.newName(), baseDarkID = /* @__PURE__ */ StyleModule.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m10) => {
        if (m10 == "&")
          return main;
        if (!scopes || !scopes[m10])
          throw new RangeError(`Unsupported selector: ${m10}`);
        return scopes[m10];
      }) : main + " " + sel;
    }
  });
}
const baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
const LineBreakPlaceholder = "￿";
class DOMReader {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(EditorState.lineSeparator);
  }
  append(text2) {
    this.text += text2;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start)
      return this;
    let parent = start.parentNode;
    for (let cur = start; ; ) {
      this.findPointBefore(parent, cur);
      let oldLen = this.text.length;
      this.readNode(cur);
      let next = cur.nextSibling;
      if (next == end)
        break;
      let view = ContentView.get(cur), nextView = ContentView.get(next);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen)
        this.lineBreak();
      cur = next;
    }
    this.findPointBefore(parent, end);
    return this;
  }
  readTextNode(node2) {
    let text2 = node2.nodeValue;
    for (let point2 of this.points)
      if (point2.node == node2)
        point2.pos = this.text.length + Math.min(point2.offset, text2.length);
    for (let off = 0, re2 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m10;
      if (this.lineSeparator) {
        nextBreak = text2.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m10 = re2.exec(text2)) {
        nextBreak = m10.index;
        breakSize = m10[0].length;
      }
      this.append(text2.slice(off, nextBreak < 0 ? text2.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point2 of this.points)
          if (point2.node == node2 && point2.pos > this.text.length)
            point2.pos -= breakSize - 1;
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node2) {
    if (node2.cmIgnore)
      return;
    let view = ContentView.get(node2);
    let fromView = view && view.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node2, fromView.length);
      for (let i3 = fromView.iter(); !i3.next().done; ) {
        if (i3.lineBreak)
          this.lineBreak();
        else
          this.append(i3.value);
      }
    } else if (node2.nodeType == 3) {
      this.readTextNode(node2);
    } else if (node2.nodeName == "BR") {
      if (node2.nextSibling)
        this.lineBreak();
    } else if (node2.nodeType == 1) {
      this.readRange(node2.firstChild, null);
    }
  }
  findPointBefore(node2, next) {
    for (let point2 of this.points)
      if (point2.node == node2 && node2.childNodes[point2.offset] == next)
        point2.pos = this.text.length;
  }
  findPointInside(node2, maxLen) {
    for (let point2 of this.points)
      if (node2.nodeType == 3 ? point2.node == node2 : node2.contains(point2.node))
        point2.pos = this.text.length + Math.min(maxLen, point2.offset);
  }
}
function isBlockElement(node2) {
  return node2.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node2.nodeName);
}
class DOMPoint {
  constructor(node2, offset) {
    this.node = node2;
    this.offset = offset;
    this.pos = -1;
  }
}
class DOMChange {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    if (view.state.readOnly && start > -1) {
      this.newSel = null;
    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head2 = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains$1(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains$1(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      this.newSel = EditorSelection.single(anchor, head2);
    }
  }
}
function applyDOMChange(view, domChange) {
  let change;
  let { newSel } = domChange, sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let { from, to: to2 } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (lastKey === 8 || browser.android && domChange.text.length < to2 - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff2 = findDiff(view.state.doc.sliceString(from, to2, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
    if (diff2) {
      if (browser.chrome && lastKey == 13 && diff2.toB == diff2.from + 2 && domChange.text.slice(diff2.from, diff2.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff2.toB--;
      change = {
        from: from + diff2.from,
        to: from + diff2.toA,
        insert: Text.of(domChange.text.slice(diff2.from, diff2.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change && !newSel)
    return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  }
  if (change) {
    if (browser.ios && view.inputState.flushIOSKey())
      return true;
    if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
      return true;
    let text2 = change.insert.toString();
    if (view.inputState.composing >= 0)
      view.inputState.composing++;
    let defaultTr;
    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
    if (!view.state.facet(inputHandler).some((h10) => h10(view, change.from, change.to, text2, defaultInsert)))
      view.dispatch(defaultInsert());
    return true;
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView2 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView2 = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
    return true;
  } else {
    return false;
  }
}
function applyDefaultInsert(view, change, newSel) {
  let tr2, startState = view.state, sel = startState.selection.main;
  if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr2 = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
    if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = { from: composition.from, to: composition.to - dLen };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset = sel.to - change.to, size = sel.to - sel.from;
      tr2 = startState.changeByRange((range) => {
        if (range.from == sel.from && range.to == sel.to)
          return { changes, range: mainSel || range.map(changes) };
        let to2 = range.to - offset, from = to2 - replaced.length;
        if (range.to - range.from != size || view.state.sliceDoc(from, to2) != replaced || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        range.to >= compositionRange.from && range.from <= compositionRange.to)
          return { range };
        let rangeChanges = startState.changes({ from, to: to2, insert: change.insert }), selOff = range.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr2 = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr2, { userEvent, scrollIntoView: true });
}
function findDiff(a3, b10, preferredPos, preferredSide) {
  let minLen = Math.min(a3.length, b10.length);
  let from = 0;
  while (from < minLen && a3.charCodeAt(from) == b10.charCodeAt(from))
    from++;
  if (from == minLen && a3.length == b10.length)
    return null;
  let toA = a3.length, toB = b10.length;
  while (toA > 0 && toB > 0 && a3.charCodeAt(toA - 1) == b10.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a3.length < b10.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }
  return { from, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head2 = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head2 > -1 ? EditorSelection.single(anchor + base2, head2 + base2) : null;
}
const observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.resizeContent = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m10) => m10.type == "childList" && m10.removedNodes.length || m10.type == "characterData" && m10.oldValue.length > m10.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a2;
        if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
          this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
      this.resizeContent = new ResizeObserver(() => this.view.requestMeasure());
      this.resizeContent.observe(view.contentDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, { threshold: [0, 1e-3] });
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e3) {
    this.view.inputState.runHandlers("scroll", e3);
    if (this.intersecting)
      this.view.measure();
  }
  onScroll(e3) {
    if (this.intersecting)
      this.flush(false);
    this.onScrollChanged(e3);
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
  }
  onPrint() {
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i3) => g != gaps[i3]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps)
        this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event)) {
      if (!wasChanged)
        this.selectionChanged = false;
      return;
    }
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { view } = this;
    let range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
    if (!range || this.selectionRange.eq(range))
      return false;
    let local = hasSelection(this.dom, range);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range);
    if (local)
      this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head2) {
    this.selectionRange.set(anchor.node, anchor.offset, head2.node, head2.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i3 = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i3 < this.scrollTargets.length && this.scrollTargets[i3] == dom)
          i3++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i3);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i3 < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i3);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f3) {
    if (!this.active)
      return f3();
    try {
      this.stop();
      return f3();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  // Throw away any pending changes
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key2, keyCode) {
    var _a2;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key3 = this.delayedAndroidKey;
        if (key3) {
          this.clearDelayedAndroidKey();
          this.view.inputState.lastKeyCode = key3.keyCode;
          this.view.inputState.lastKeyTime = Date.now();
          let flushed = this.flush();
          if (!flushed && key3.force)
            dispatchKey(this.dom, key3.key, key3.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key2 == "Enter")
      this.delayedAndroidKey = {
        key: key2,
        keyCode,
        // Only run the key handler when no changes are detected if
        // this isn't coming right after another change, in which case
        // it is probably part of a weird chain of updates, and should
        // be ignored if it returns the DOM to its previous state.
        force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
      };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  pendingRecords() {
    for (let mut of this.observer.takeRecords())
      this.queue.push(mut);
    return this.queue;
  }
  processRecords() {
    let records = this.pendingRecords();
    if (records.length)
      this.queue = [];
    let from = -1, to2 = -1, typeOver = false;
    for (let record of records) {
      let range = this.readMutation(record);
      if (!range)
        continue;
      if (range.typeOver)
        typeOver = true;
      if (from == -1) {
        ({ from, to: to2 } = range);
      } else {
        from = Math.min(range.from, from);
        to2 = Math.max(range.to, to2);
      }
    }
    return { from, to: to2, typeOver };
  }
  readChange() {
    let { from, to: to2, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from < 0 && !newSel)
      return null;
    if (from > -1)
      this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    let change = new DOMChange(this.view, from, to2, typeOver);
    this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
    return change;
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    if (readSelection)
      this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange)
      return false;
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState)
      this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec))
      return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes")
      cView.flags |= 4;
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var _a2, _b2, _c2, _d2;
    this.stop();
    (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    (_b2 = this.gapIntersection) === null || _b2 === void 0 ? void 0 : _b2.disconnect();
    (_c2 = this.resizeScroll) === null || _c2 === void 0 ? void 0 : _c2.disconnect();
    (_d2 = this.resizeContent) === null || _d2 === void 0 ? void 0 : _d2.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function safariSelectionRangeHack(view) {
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  if (!found)
    return null;
  let anchorNode = found.startContainer, anchorOffset = found.startOffset;
  let focusNode = found.endContainer, focusOffset = found.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
class EditorView {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config = {}) {
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.style.cssText = "position: fixed; top: -10000px";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    let { dispatch } = config;
    this.dispatchTransactions = config.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr2) => dispatch(tr2, this))) || ((trs) => this.update(trs));
    this.dispatch = this.dispatch.bind(this);
    this._root = config.root || getRoot(config.parent) || document;
    this.viewState = new ViewState(config.state || EditorState.create(config));
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin of this.plugins)
      plugin.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if (config.parent)
      config.parent.appendChild(this.dom);
  }
  dispatch(...input) {
    let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
    this.dispatchTransactions(trs, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update;
    let state = this.state;
    for (let tr2 of transactions) {
      if (tr2.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr2.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
    if (transactions.some((tr2) => tr2.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus)
        focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
        domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    update.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr2 of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr2.changes);
        if (tr2.scrollIntoView) {
          let { main } = tr2.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (let e3 of tr2.effects)
          if (e3.is(scrollIntoView))
            scrollTarget = e3.value;
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr2) => tr2.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener))
        listener(update);
    if (dispatchFocus || domChange)
      Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState)
          this.dispatch(dispatchFocus);
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force)
            dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
        }
      });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin of this.plugins)
        plugin.update(this);
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin = this.plugins[found];
          plugin.mustUpdate = update;
          newPlugins.push(plugin);
        }
      }
      for (let plugin of this.plugins)
        if (plugin.mustUpdate != update)
          plugin.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
      this.inputState.ensureHandlers(this.plugins);
    } else {
      for (let p10 of this.plugins)
        p10.mustUpdate = update;
    }
    for (let i3 = 0; i3 < this.plugins.length; i3++)
      this.plugins[i3].update(this);
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1;
      this.requestMeasure();
      return;
    }
    this.measureScheduled = 0;
    if (flush)
      this.observer.forceFlush();
    let updated = null;
    let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
    let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
      scrollAnchorHeight = -1;
    this.viewState.scrollAnchorHeight = -1;
    try {
      for (let i3 = 0; ; i3++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1;
            scrollAnchorHeight = this.viewState.heightMap.height;
          } else {
            let block = this.viewState.scrollAnchorAt(scrollTop);
            scrollAnchorPos = block.from;
            scrollAnchorHeight = block.top;
          }
        }
        this.updateState = 1;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i3 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m10) => {
          try {
            return m10.read(this);
          } catch (e3) {
            logException(this.state, e3);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []), redrawn = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
        }
        for (let i10 = 0; i10 < measuring.length; i10++)
          if (measured[i10] != BadMeasure) {
            try {
              let m10 = measuring[i10];
              if (m10.write)
                m10.write(measured[i10], this);
            } catch (e3) {
              logException(this.state, e3);
            }
          }
        if (redrawn)
          this.docView.updateSelection(true);
        if (!update.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              continue;
            } else {
              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
              let diff2 = newAnchorHeight - scrollAnchorHeight;
              if (diff2 > 1 || diff2 < -1) {
                scrollTop = scrollTop + diff2;
                sDOM.scrollTop = scrollTop / this.scaleY;
                scrollAnchorHeight = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr2 of trs)
      for (let effect of tr2.effects)
        if (effect.is(EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let nonce = this.state.facet(EditorView.cspNonce);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (this.measureRequests.indexOf(request) > -1)
        return;
      if (request.key != null)
        for (let i3 = 0; i3 < this.measureRequests.length; i3++) {
          if (this.measureRequests[i3].key === request.key) {
            this.measureRequests[i3] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin) {
    let known = this.pluginMap.get(plugin);
    if (known === void 0 || known && known.spec != plugin)
      this.pluginMap.set(plugin, known = this.plugins.find((p10) => p10.spec == plugin) || null);
    return known && known.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start, forward, by2) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by2));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node2, offset = 0) {
    return this.docView.posFromDOM(node2, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line = this.state.doc.lineAt(pos), order2 = this.bidiSpans(line);
    let span = order2[BidiSpan.find(order2, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(pos) {
    this.readMeasured();
    return this.docView.coordsForChar(pos);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
      return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirectionAt(line.from), isolates;
    for (let entry of this.bidiCache) {
      if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line.from, line.to))))
        return entry.order;
    }
    if (!isolates)
      isolates = getIsolatedRanges(this, line.from, line.to);
    let order2 = computeOrder(line.text, dir, isolates);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order2));
    return order2;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a2;
    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root2) {
    if (this._root != root2) {
      this._root = root2;
      this.observer.setWindow((root2.nodeType == 9 ? root2 : root2.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let plugin of this.plugins)
      plugin.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options = {}) {
    return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(observers2) {
    return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options) {
    let prefix = StyleModule.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a2;
    let content2 = dom.querySelector(".cm-content");
    let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
    return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
  }
}
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : "" });
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = /* @__PURE__ */ StateEffect.define();
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
  constructor(from, to2, dir, isolates, fresh, order2) {
    this.from = from;
    this.to = to2;
    this.dir = dir;
    this.isolates = isolates;
    this.fresh = fresh;
    this.order = order2;
  }
  static update(cache, changes) {
    if (changes.empty && !cache.some((c3) => c3.fresh))
      return cache;
    let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i3 = Math.max(0, cache.length - 10); i3 < cache.length; i3++) {
      let entry = cache[i3];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
    }
    return result;
  }
}
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i3 = sources.length - 1; i3 >= 0; i3--) {
    let source2 = sources[i3], value = typeof source2 == "function" ? source2(view) : source2;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
const CanHidePrimary = !browser.ios;
const themeSpec = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
if (CanHidePrimary)
  themeSpec[".cm-line"].caretColor = "transparent !important";
function iterMatches(doc2, re2, from, to2, f3) {
  re2.lastIndex = 0;
  for (let cursor = doc2.iterRange(from, to2), pos = from, m10; !cursor.next().done; pos += cursor.value.length) {
    if (!cursor.lineBreak)
      while (m10 = re2.exec(cursor.value))
        f3(pos + m10.index, m10);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
    return visible;
  let result = [];
  for (let { from, to: to2 } of visible) {
    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
    to2 = Math.min(view.state.doc.lineAt(to2).to, to2 + maxLength);
    if (result.length && result[result.length - 1].to >= from)
      result[result.length - 1].to = to2;
    else
      result.push({ from, to: to2 });
  }
  return result;
}
class MatchDecorator {
  /**
  Create a decorator.
  */
  constructor(config) {
    const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config;
    if (!regexp.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    if (decorate) {
      this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
    } else if (typeof decoration == "function") {
      this.addMatch = (match, view, from, add) => {
        let deco = decoration(match, view, from);
        if (deco)
          add(from, from + match[0].length, deco);
      };
    } else if (decoration) {
      this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);
    } else {
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    }
    this.boundary = boundary;
    this.maxLength = maxLength;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(view) {
    let build = new RangeSetBuilder(), add = build.add.bind(build);
    for (let { from, to: to2 } of matchRanges(view, this.maxLength))
      iterMatches(view.state.doc, this.regexp, from, to2, (from2, m10) => this.addMatch(m10, view, from2, add));
    return build.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(update, deco) {
    let changeFrom = 1e9, changeTo = -1;
    if (update.docChanged)
      update.changes.iterChanges((_f2, _t2, from, to2) => {
        if (to2 > update.view.viewport.from && from < update.view.viewport.to) {
          changeFrom = Math.min(from, changeFrom);
          changeTo = Math.max(to2, changeTo);
        }
      });
    if (update.viewportChanged || changeTo - changeFrom > 1e3)
      return this.createDeco(update.view);
    if (changeTo > -1)
      return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (let r3 of view.visibleRanges) {
      let from = Math.max(r3.from, updateFrom), to2 = Math.min(r3.to, updateTo);
      if (to2 > from) {
        let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to2 ? view.state.doc.lineAt(to2) : fromLine;
        let start = Math.max(r3.from, fromLine.from), end = Math.min(r3.to, toLine.to);
        if (this.boundary) {
          for (; from > fromLine.from; from--)
            if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
              start = from;
              break;
            }
          for (; to2 < toLine.to; to2++)
            if (this.boundary.test(toLine.text[to2 - toLine.from])) {
              end = to2;
              break;
            }
        }
        let ranges = [], m10;
        let add = (from2, to3, deco2) => ranges.push(deco2.range(from2, to3));
        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;
          while ((m10 = this.regexp.exec(fromLine.text)) && m10.index < end - fromLine.from)
            this.addMatch(m10, view, m10.index + fromLine.from, add);
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from2, m11) => this.addMatch(m11, view, from2, add));
        }
        deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to3) => from2 < start || to3 > end, add: ranges });
      }
    }
    return deco;
  }
}
class GutterMarker extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {
  }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
var _a$1;
const languageDataProp = /* @__PURE__ */ new NodeProp();
const sublanguageProp = /* @__PURE__ */ new NodeProp();
class Language {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(data, parser, extraExtensions = [], name2 = "") {
    this.data = data;
    this.name = name2;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => {
        let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
        if (!data2)
          return [];
        let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
        if (sub) {
          let innerNode = top2.resolve(pos - top2.from, side);
          for (let sublang of sub)
            if (sublang.test(innerNode, state)) {
              let data3 = state.facet(sublang.facet);
              return sublang.type == "replace" ? data3 : data3.concat(base2);
            }
        }
        return base2;
      })
    ].concat(extraExtensions);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(state, pos, side = -1) {
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang || !lang.allowsNesting)
      return [];
    let result = [];
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({ from, to: from + tree.length });
        return;
      }
      let mount = tree.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r3 of mount.overlay)
              result.push({ from: r3.from + from, to: r3.to + from });
          else
            result.push({ from, to: from + tree.length });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result.length > size)
            return;
        }
      }
      for (let i3 = 0; i3 < tree.children.length; i3++) {
        let ch2 = tree.children[i3];
        if (ch2 instanceof Tree)
          explore(ch2, tree.positions[i3] + from);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
}
Language.setState = /* @__PURE__ */ StateEffect.define();
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language), tree = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node2 = tree; node2; node2 = node2.enter(pos, side, IterMode.ExcludeBuffers))
      if (node2.type.isTop)
        tree = node2;
  }
  return tree;
}
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
class DocInput {
  /**
  Create an input object for the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from, to2) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to2 >= this.cursorPos)
      return this.doc.sliceString(from, to2);
    else
      return this.string.slice(from - stringStart, to2 - stringStart);
  }
}
let currentContext = null;
class ParseContext {
  constructor(parser, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(parser, state, viewport) {
    return new ParseContext(parser, state, [], Tree.empty, 0, viewport, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length)
      upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a2;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse)
        this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
        this.parse.stopAt(upto);
      for (; ; ) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        }
        if (until())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
        this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f3) {
    let prev = currentContext;
    currentContext = this;
    try {
      return f3();
    } finally {
      currentContext = prev;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r3; r3 = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r3.from, r3.to);
    return fragments;
  }
  /**
  @internal
  */
  changes(changes, newState) {
    let { fragments, tree, treeLen, viewport, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      treeLen = 0;
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r3 of this.skipped) {
          let from = changes.mapPos(r3.from, 1), to2 = changes.mapPos(r3.to, -1);
          if (from < to2)
            skipped.push({ from, to: to2 });
        }
      }
    }
    return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
      return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i3 = 0; i3 < this.skipped.length; i3++) {
      let { from, to: to2 } = this.skipped[i3];
      if (from < viewport.to && to2 > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to2);
        this.skipped.splice(i3--, 1);
      }
    }
    if (this.skipped.length >= startLen)
      return false;
    this.reset();
    return true;
  }
  /**
  @internal
  */
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(from, to2) {
    this.skipped.push({ from, to: to2 });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(until) {
    return new class extends Parser {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from, to2 = ranges[ranges.length - 1].to;
        let parser = {
          parsedPos: from,
          advance() {
            let cx2 = currentContext;
            if (cx2) {
              for (let r3 of ranges)
                cx2.tempSkipped.push(r3);
              if (until)
                cx2.scheduleOn = cx2.scheduleOn ? Promise.all([cx2.scheduleOn, until]) : until;
            }
            this.parsedPos = to2;
            return new Tree(NodeType.none, [], [], to2 - from);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser;
      }
    }();
  }
  /**
  @internal
  */
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return currentContext;
  }
}
function cutFragments(fragments, from, to2) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to2, fromB: from, toB: to2 }]);
}
class LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr2) {
    if (!tr2.docChanged && this.tree == this.context.tree)
      return this;
    let newCx = this.context.changes(tr2.changes, tr2.state);
    let upto = this.context.treeLen == tr2.startState.doc.length ? void 0 : Math.max(tr2.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto))
      newCx.takeTree();
    return new LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
    if (!parseState.work(20, vpTo))
      parseState.takeTree();
    return new LanguageState(parseState);
  }
}
Language.state = /* @__PURE__ */ StateField.define({
  create: LanguageState.init,
  update(value, tr2) {
    for (let e3 of tr2.effects)
      if (e3.is(Language.setState))
        return e3.value;
    if (tr2.startState.facet(language) != tr2.state.facet(language))
      return LanguageState.init(tr2.state);
    return value.apply(tr2);
  }
});
let requestIdle = (callback) => {
  let timeout = setTimeout(
    () => callback(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
  requestIdle = (callback) => {
    let idle = -1, timeout = setTimeout(
      () => {
        idle = requestIdleCallback(callback, {
          timeout: 500 - 100
          /* Work.MinPause */
        });
      },
      100
      /* Work.MinPause */
    );
    return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
  };
const isInputPending = typeof navigator != "undefined" && ((_a$1 = navigator.scheduling) === null || _a$1 === void 0 ? void 0 : _a$1.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
const parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx2 = this.view.state.field(Language.state).context;
    if (cx2.updateViewport(update.view.viewport) || this.view.viewport.to > cx2.treeLen)
      this.scheduleWork();
    if (update.docChanged || update.selectionSet) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx2);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
      this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(
      vpTo + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst))
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx2) {
    if (cx2.scheduleOn) {
      this.workScheduled++;
      cx2.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx2.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working)
      this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
const language = /* @__PURE__ */ Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: (language2) => [
    Language.state,
    parseWorker,
    EditorView.contentAttributes.compute([language2], (state) => {
      let lang = state.facet(language2);
      return lang && lang.name ? { "data-language": lang.name } : {};
    })
  ]
});
class HighlightStyle {
  constructor(specs, options) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
      return cls;
    }
    const all2 = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
    const scopeOpt = options.scope;
    this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
    this.style = tagHighlighter(specs.map((style2) => ({
      tag: style2.tag,
      class: style2.class || def(Object.assign({}, style2, { tag: null }))
    })), {
      all: all2
    }).style;
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.themeType = options.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(specs, options) {
    return new HighlightStyle(specs, options || {});
  }
}
const highlighterFacet = /* @__PURE__ */ Facet.define();
const fallbackHighlighter = /* @__PURE__ */ Facet.define({
  combine(values) {
    return values.length ? [values[0]] : null;
  }
});
function getHighlighters(state) {
  let main = state.facet(highlighterFacet);
  return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options) {
  let ext = [treeHighlighter], themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module)
      ext.push(EditorView.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (options === null || options === void 0 ? void 0 : options.fallback)
    ext.push(fallbackHighlighter.of(highlighter));
  else if (themeType)
    ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
    }));
  else
    ext.push(highlighterFacet.of(highlighter));
  return ext;
}
class TreeHighlighter {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
  }
  update(update) {
    let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
      this.decorations = this.decorations.map(update.changes);
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, highlighters);
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let { from, to: to2 } of view.visibleRanges) {
      highlightTree(this.tree, highlighters, (from2, to3, style2) => {
        builder.add(from2, to3, this.markCache[style2] || (this.markCache[style2] = Decoration.mark({ class: style2 })));
      }, from, to2);
    }
    return builder.finish();
  }
}
const treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v10) => v10.decorations
}));
const noTokens = /* @__PURE__ */ Object.create(null);
const typeArray = [NodeType.none];
const warned = [];
const defaultTable = /* @__PURE__ */ Object.create(null);
for (let [legacyName, name2] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1)
    return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tag = null;
  for (let part of tagStr.split(".")) {
    let value = extra[part] || tags[part];
    if (!value) {
      warnForPart(part, `Unknown highlighting tag ${part}`);
    } else if (typeof value == "function") {
      if (!tag)
        warnForPart(part, `Modifier ${part} used at start of tag`);
      else
        tag = value(tag);
    } else {
      if (tag)
        warnForPart(part, `Tag ${part} used as modifier`);
      else
        tag = value;
    }
  }
  if (!tag)
    return 0;
  let name2 = tagStr.replace(/ /g, "_"), type = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({ [name2]: tag })]
  });
  typeArray.push(type);
  return type.id;
}
var createTheme = (_ref) => {
  var {
    theme: theme2,
    settings = {},
    styles = []
  } = _ref;
  var themeOptions = {
    ".cm-gutters": {}
  };
  var baseStyle = {};
  if (settings.background) {
    baseStyle.backgroundColor = settings.background;
  }
  if (settings.foreground) {
    baseStyle.color = settings.foreground;
  }
  if (settings.background || settings.foreground) {
    themeOptions["&"] = baseStyle;
  }
  if (settings.fontFamily) {
    themeOptions["&.cm-editor .cm-scroller"] = {
      fontFamily: settings.fontFamily
    };
  }
  if (settings.gutterBackground) {
    themeOptions[".cm-gutters"].backgroundColor = settings.gutterBackground;
  }
  if (settings.gutterForeground) {
    themeOptions[".cm-gutters"].color = settings.gutterForeground;
  }
  if (settings.gutterBorder) {
    themeOptions[".cm-gutters"].borderRightColor = settings.gutterBorder;
  }
  if (settings.caret) {
    themeOptions[".cm-content"] = {
      caretColor: settings.caret
    };
    themeOptions[".cm-cursor, .cm-dropCursor"] = {
      borderLeftColor: settings.caret
    };
  }
  var activeLineGutterStyle = {};
  if (settings.gutterActiveForeground) {
    activeLineGutterStyle.color = settings.gutterActiveForeground;
  }
  if (settings.lineHighlight) {
    themeOptions[".cm-activeLine"] = {
      backgroundColor: settings.lineHighlight
    };
    activeLineGutterStyle.backgroundColor = settings.lineHighlight;
  }
  themeOptions[".cm-activeLineGutter"] = activeLineGutterStyle;
  if (settings.selection) {
    themeOptions["&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
      background: settings.selection + " !important"
    };
  }
  if (settings.selectionMatch) {
    themeOptions["& .cm-selectionMatch"] = {
      backgroundColor: settings.selectionMatch
    };
  }
  var themeExtension = EditorView.theme(themeOptions, {
    dark: theme2 === "dark"
  });
  var highlightStyle = HighlightStyle.define(styles);
  var extension2 = [themeExtension, syntaxHighlighting(highlightStyle)];
  return extension2;
};
function Context$2(indented, column, type, info, align, prev) {
  this.indented = indented;
  this.column = column;
  this.type = type;
  this.info = info;
  this.align = align;
  this.prev = prev;
}
function pushContext$2(state, col, type, info) {
  var indent2 = state.indented;
  if (state.context && state.context.type == "statement" && type != "statement")
    indent2 = state.context.indented;
  return state.context = new Context$2(indent2, col, type, info, null, state.context);
}
function popContext$2(state) {
  var t10 = state.context.type;
  if (t10 == ")" || t10 == "]" || t10 == "}")
    state.indented = state.context.indented;
  return state.context = state.context.prev;
}
function typeBefore(stream, state, pos) {
  if (state.prevToken == "variable" || state.prevToken == "type")
    return true;
  if (/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(stream.string.slice(0, pos)))
    return true;
  if (state.typeAtEndOfLine && stream.column() == stream.indentation())
    return true;
}
function isTopScope(context) {
  for (; ; ) {
    if (!context || context.type == "top")
      return true;
    if (context.type == "}" && context.prev.info != "namespace")
      return false;
    context = context.prev;
  }
}
function clike(parserConfig) {
  var statementIndentUnit = parserConfig.statementIndentUnit, dontAlignCalls = parserConfig.dontAlignCalls, keywords2 = parserConfig.keywords || {}, types2 = parserConfig.types || {}, builtin = parserConfig.builtin || {}, blockKeywords = parserConfig.blockKeywords || {}, defKeywords = parserConfig.defKeywords || {}, atoms2 = parserConfig.atoms || {}, hooks = parserConfig.hooks || {}, multiLineStrings = parserConfig.multiLineStrings, indentStatements = parserConfig.indentStatements !== false, indentSwitch = parserConfig.indentSwitch !== false, namespaceSeparator = parserConfig.namespaceSeparator, isPunctuationChar = parserConfig.isPunctuationChar || /[\[\]{}\(\),;\:\.]/, numberStart = parserConfig.numberStart || /[\d\.]/, number2 = parserConfig.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i, isOperatorChar2 = parserConfig.isOperatorChar || /[+\-*&%=<>!?|\/]/, isIdentifierChar = parserConfig.isIdentifierChar || /[\w\$_\xa1-\uffff]/, isReservedIdentifier = parserConfig.isReservedIdentifier || false;
  var curPunc2, isDefKeyword;
  function tokenBase2(stream, state) {
    var ch2 = stream.next();
    if (hooks[ch2]) {
      var result = hooks[ch2](stream, state);
      if (result !== false)
        return result;
    }
    if (ch2 == '"' || ch2 == "'") {
      state.tokenize = tokenString2(ch2);
      return state.tokenize(stream, state);
    }
    if (numberStart.test(ch2)) {
      stream.backUp(1);
      if (stream.match(number2))
        return "number";
      stream.next();
    }
    if (isPunctuationChar.test(ch2)) {
      curPunc2 = ch2;
      return null;
    }
    if (ch2 == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment2;
        return tokenComment2(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar2.test(ch2)) {
      while (!stream.match(/^\/[\/*]/, false) && stream.eat(isOperatorChar2)) {
      }
      return "operator";
    }
    stream.eatWhile(isIdentifierChar);
    if (namespaceSeparator)
      while (stream.match(namespaceSeparator))
        stream.eatWhile(isIdentifierChar);
    var cur = stream.current();
    if (contains(keywords2, cur)) {
      if (contains(blockKeywords, cur))
        curPunc2 = "newstatement";
      if (contains(defKeywords, cur))
        isDefKeyword = true;
      return "keyword";
    }
    if (contains(types2, cur))
      return "type";
    if (contains(builtin, cur) || isReservedIdentifier && isReservedIdentifier(cur)) {
      if (contains(blockKeywords, cur))
        curPunc2 = "newstatement";
      return "builtin";
    }
    if (contains(atoms2, cur))
      return "atom";
    return "variable";
  }
  function tokenString2(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {
          end = true;
          break;
        }
        escaped = !escaped && next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }
  function tokenComment2(stream, state) {
    var maybeEnd = false, ch2;
    while (ch2 = stream.next()) {
      if (ch2 == "/" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = ch2 == "*";
    }
    return "comment";
  }
  function maybeEOL(stream, state) {
    if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context))
      state.typeAtEndOfLine = typeBefore(stream, state, stream.pos);
  }
  return {
    name: parserConfig.name,
    startState: function(indentUnit) {
      return {
        tokenize: null,
        context: new Context$2(-indentUnit, 0, "top", null, false),
        indented: 0,
        startOfLine: true,
        prevToken: null
      };
    },
    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null)
          ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) {
        maybeEOL(stream, state);
        return null;
      }
      curPunc2 = isDefKeyword = null;
      var style2 = (state.tokenize || tokenBase2)(stream, state);
      if (style2 == "comment" || style2 == "meta")
        return style2;
      if (ctx.align == null)
        ctx.align = true;
      if (curPunc2 == ";" || curPunc2 == ":" || curPunc2 == "," && stream.match(/^\s*(?:\/\/.*)?$/, false))
        while (state.context.type == "statement")
          popContext$2(state);
      else if (curPunc2 == "{")
        pushContext$2(state, stream.column(), "}");
      else if (curPunc2 == "[")
        pushContext$2(state, stream.column(), "]");
      else if (curPunc2 == "(")
        pushContext$2(state, stream.column(), ")");
      else if (curPunc2 == "}") {
        while (ctx.type == "statement")
          ctx = popContext$2(state);
        if (ctx.type == "}")
          ctx = popContext$2(state);
        while (ctx.type == "statement")
          ctx = popContext$2(state);
      } else if (curPunc2 == ctx.type)
        popContext$2(state);
      else if (indentStatements && ((ctx.type == "}" || ctx.type == "top") && curPunc2 != ";" || ctx.type == "statement" && curPunc2 == "newstatement")) {
        pushContext$2(state, stream.column(), "statement", stream.current());
      }
      if (style2 == "variable" && (state.prevToken == "def" || parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) && isTopScope(state.context) && stream.match(/^\s*\(/, false)))
        style2 = "def";
      if (hooks.token) {
        var result = hooks.token(stream, state, style2);
        if (result !== void 0)
          style2 = result;
      }
      if (style2 == "def" && parserConfig.styleDefs === false)
        style2 = "variable";
      state.startOfLine = false;
      state.prevToken = isDefKeyword ? "def" : style2 || curPunc2;
      maybeEOL(stream, state);
      return style2;
    },
    indent: function(state, textAfter, context) {
      if (state.tokenize != tokenBase2 && state.tokenize != null || state.typeAtEndOfLine && isTopScope(state.context))
        return null;
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      var closing2 = firstChar == ctx.type;
      if (ctx.type == "statement" && firstChar == "}")
        ctx = ctx.prev;
      if (parserConfig.dontIndentStatements)
        while (ctx.type == "statement" && parserConfig.dontIndentStatements.test(ctx.info))
          ctx = ctx.prev;
      if (hooks.indent) {
        var hook = hooks.indent(state, ctx, textAfter, context.unit);
        if (typeof hook == "number")
          return hook;
      }
      var switchBlock = ctx.prev && ctx.prev.info == "switch";
      if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {
        while (ctx.type != "top" && ctx.type != "}")
          ctx = ctx.prev;
        return ctx.indented;
      }
      if (ctx.type == "statement")
        return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit || context.unit);
      if (ctx.align && (!dontAlignCalls || ctx.type != ")"))
        return ctx.column + (closing2 ? 0 : 1);
      if (ctx.type == ")" && !closing2)
        return ctx.indented + (statementIndentUnit || context.unit);
      return ctx.indented + (closing2 ? 0 : context.unit) + (!closing2 && switchBlock && !/^(?:case|default)\b/.test(textAfter) ? context.unit : 0);
    },
    languageData: {
      indentOnInput: indentSwitch ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
      commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
      autocomplete: Object.keys(keywords2).concat(Object.keys(types2)).concat(Object.keys(builtin)).concat(Object.keys(atoms2)),
      ...parserConfig.languageData
    }
  };
}
function words$1(str) {
  var obj = {}, words2 = str.split(" ");
  for (var i3 = 0; i3 < words2.length; ++i3)
    obj[words2[i3]] = true;
  return obj;
}
function contains(words2, word) {
  if (typeof words2 === "function") {
    return words2(word);
  } else {
    return words2.propertyIsEnumerable(word);
  }
}
var cKeywords = "auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile inline restrict asm fortran";
var cppKeywords = "alignas alignof and and_eq audit axiom bitand bitor catch class compl concept constexpr const_cast decltype delete dynamic_cast explicit export final friend import module mutable namespace new noexcept not not_eq operator or or_eq override private protected public reinterpret_cast requires static_assert static_cast template this thread_local throw try typeid typename using virtual xor xor_eq";
var objCKeywords = "bycopy byref in inout oneway out self super atomic nonatomic retain copy readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd @interface @implementation @end @protocol @encode @property @synthesize @dynamic @class @public @package @private @protected @required @optional @try @catch @finally @import @selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available";
var objCBuiltins = "FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION  NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT";
var basicCTypes = words$1("int long char short double float unsigned signed void bool");
var basicObjCTypes = words$1("SEL instancetype id Class Protocol BOOL");
function cTypes(identifier2) {
  return contains(basicCTypes, identifier2) || /.+_t$/.test(identifier2);
}
function objCTypes(identifier2) {
  return cTypes(identifier2) || contains(basicObjCTypes, identifier2);
}
var cBlockKeywords = "case do else for if switch while struct enum union";
var cDefKeywords = "struct enum union";
function cppHook(stream, state) {
  if (!state.startOfLine)
    return false;
  for (var ch2, next = null; ch2 = stream.peek(); ) {
    if (ch2 == "\\" && stream.match(/^.$/)) {
      next = cppHook;
      break;
    } else if (ch2 == "/" && stream.match(/^\/[\/\*]/, false)) {
      break;
    }
    stream.next();
  }
  state.tokenize = next;
  return "meta";
}
function pointerHook(_stream, state) {
  if (state.prevToken == "type")
    return "type";
  return false;
}
function cIsReservedIdentifier(token) {
  if (!token || token.length < 2)
    return false;
  if (token[0] != "_")
    return false;
  return token[1] == "_" || token[1] !== token[1].toLowerCase();
}
function cpp14Literal(stream) {
  stream.eatWhile(/[\w\.']/);
  return "number";
}
function cpp11StringHook(stream, state) {
  stream.backUp(1);
  if (stream.match(/^(?:R|u8R|uR|UR|LR)/)) {
    var match = stream.match(/^"([^\s\\()]{0,16})\(/);
    if (!match) {
      return false;
    }
    state.cpp11RawStringDelim = match[1];
    state.tokenize = tokenRawString;
    return tokenRawString(stream, state);
  }
  if (stream.match(/^(?:u8|u|U|L)/)) {
    if (stream.match(
      /^["']/,
      /* eat */
      false
    )) {
      return "string";
    }
    return false;
  }
  stream.next();
  return false;
}
function cppLooksLikeConstructor(word) {
  var lastTwo = /(\w+)::~?(\w+)$/.exec(word);
  return lastTwo && lastTwo[1] == lastTwo[2];
}
function tokenAtString(stream, state) {
  var next;
  while ((next = stream.next()) != null) {
    if (next == '"' && !stream.eat('"')) {
      state.tokenize = null;
      break;
    }
  }
  return "string";
}
function tokenRawString(stream, state) {
  var delim = state.cpp11RawStringDelim.replace(/[^\w\s]/g, "\\$&");
  var match = stream.match(new RegExp(".*?\\)" + delim + '"'));
  if (match)
    state.tokenize = null;
  else
    stream.skipToEnd();
  return "string";
}
clike({
  name: "c",
  keywords: words$1(cKeywords),
  types: cTypes,
  blockKeywords: words$1(cBlockKeywords),
  defKeywords: words$1(cDefKeywords),
  typeFirstDefinitions: true,
  atoms: words$1("NULL true false"),
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook
  }
});
clike({
  name: "cpp",
  keywords: words$1(cKeywords + " " + cppKeywords),
  types: cTypes,
  blockKeywords: words$1(cBlockKeywords + " class try catch"),
  defKeywords: words$1(cDefKeywords + " class namespace"),
  typeFirstDefinitions: true,
  atoms: words$1("true false NULL nullptr"),
  dontIndentStatements: /^template$/,
  isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook,
    "u": cpp11StringHook,
    "U": cpp11StringHook,
    "L": cpp11StringHook,
    "R": cpp11StringHook,
    "0": cpp14Literal,
    "1": cpp14Literal,
    "2": cpp14Literal,
    "3": cpp14Literal,
    "4": cpp14Literal,
    "5": cpp14Literal,
    "6": cpp14Literal,
    "7": cpp14Literal,
    "8": cpp14Literal,
    "9": cpp14Literal,
    token: function(stream, state, style2) {
      if (style2 == "variable" && stream.peek() == "(" && (state.prevToken == ";" || state.prevToken == null || state.prevToken == "}") && cppLooksLikeConstructor(stream.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
});
clike({
  name: "java",
  keywords: words$1("abstract assert break case catch class const continue default do else enum extends final finally for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),
  types: words$1("var byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),
  blockKeywords: words$1("catch class do else finally for if switch try while"),
  defKeywords: words$1("class interface enum @interface"),
  typeFirstDefinitions: true,
  atoms: words$1("true false null"),
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  hooks: {
    "@": function(stream) {
      if (stream.match("interface", false))
        return false;
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    '"': function(stream, state) {
      if (!stream.match(/""$/))
        return false;
      state.tokenize = tokenTripleString;
      return state.tokenize(stream, state);
    }
  }
});
clike({
  name: "csharp",
  keywords: words$1("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in init interface internal is lock namespace new operator out override params private protected public readonly record ref required return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),
  types: words$1("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),
  blockKeywords: words$1("catch class do else finally for foreach if struct switch try while"),
  defKeywords: words$1("class interface namespace record struct var"),
  typeFirstDefinitions: true,
  atoms: words$1("true false null"),
  hooks: {
    "@": function(stream, state) {
      if (stream.eat('"')) {
        state.tokenize = tokenAtString;
        return tokenAtString(stream, state);
      }
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    }
  }
});
function tokenTripleString(stream, state) {
  var escaped = false;
  while (!stream.eol()) {
    if (!escaped && stream.match('"""')) {
      state.tokenize = null;
      break;
    }
    escaped = stream.next() == "\\" && !escaped;
  }
  return "string";
}
function tokenNestedComment(depth) {
  return function(stream, state) {
    var ch2;
    while (ch2 = stream.next()) {
      if (ch2 == "*" && stream.eat("/")) {
        if (depth == 1) {
          state.tokenize = null;
          break;
        } else {
          state.tokenize = tokenNestedComment(depth - 1);
          return state.tokenize(stream, state);
        }
      } else if (ch2 == "/" && stream.eat("*")) {
        state.tokenize = tokenNestedComment(depth + 1);
        return state.tokenize(stream, state);
      }
    }
    return "comment";
  };
}
clike({
  name: "scala",
  keywords: words$1(
    /* scala */
    "abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"
  ),
  types: words$1(
    "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"
  ),
  multiLineStrings: true,
  blockKeywords: words$1("catch class enum do else finally for forSome if match switch try while"),
  defKeywords: words$1("class enum def object package trait type val var"),
  atoms: words$1("true false null"),
  indentStatements: false,
  indentSwitch: false,
  isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    '"': function(stream, state) {
      if (!stream.match('""'))
        return false;
      state.tokenize = tokenTripleString;
      return state.tokenize(stream, state);
    },
    "'": function(stream) {
      if (stream.match(/^(\\[^'\s]+|[^\\'])'/))
        return "character";
      stream.eatWhile(/[\w\$_\xa1-\uffff]/);
      return "atom";
    },
    "=": function(stream, state) {
      var cx2 = state.context;
      if (cx2.type == "}" && cx2.align && stream.eat(">")) {
        state.context = new Context$2(cx2.indented, cx2.column, cx2.type, cx2.info, null, cx2.prev);
        return "operator";
      } else {
        return false;
      }
    },
    "/": function(stream, state) {
      if (!stream.eat("*"))
        return false;
      state.tokenize = tokenNestedComment(1);
      return state.tokenize(stream, state);
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
function tokenKotlinString(tripleString) {
  return function(stream, state) {
    var escaped = false, next, end = false;
    while (!stream.eol()) {
      if (!tripleString && !escaped && stream.match('"')) {
        end = true;
        break;
      }
      if (tripleString && stream.match('"""')) {
        end = true;
        break;
      }
      next = stream.next();
      if (!escaped && next == "$" && stream.match("{"))
        stream.skipTo("}");
      escaped = !escaped && next == "\\" && !tripleString;
    }
    if (end || !tripleString)
      state.tokenize = null;
    return "string";
  };
}
clike({
  name: "kotlin",
  keywords: words$1(
    /*keywords*/
    "package as typealias class interface this super val operator var fun for is in This throw return annotation break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend actual expect setparam"
  ),
  types: words$1(
    /* package java.lang */
    "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy LazyThreadSafetyMode LongArray Nothing ShortArray Unit"
  ),
  intendSwitch: false,
  indentStatements: false,
  multiLineStrings: true,
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  blockKeywords: words$1("catch class do else finally for if where try while enum"),
  defKeywords: words$1("class val var object interface fun"),
  atoms: words$1("true false null this"),
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    "*": function(_stream, state) {
      return state.prevToken == "." ? "variable" : "operator";
    },
    '"': function(stream, state) {
      state.tokenize = tokenKotlinString(stream.match('""'));
      return state.tokenize(stream, state);
    },
    "/": function(stream, state) {
      if (!stream.eat("*"))
        return false;
      state.tokenize = tokenNestedComment(1);
      return state.tokenize(stream, state);
    },
    indent: function(state, ctx, textAfter, indentUnit) {
      var firstChar = textAfter && textAfter.charAt(0);
      if ((state.prevToken == "}" || state.prevToken == ")") && textAfter == "")
        return state.indented;
      if (state.prevToken == "operator" && textAfter != "}" && state.context.type != "}" || state.prevToken == "variable" && firstChar == "." || (state.prevToken == "}" || state.prevToken == ")") && firstChar == ".")
        return indentUnit * 2 + ctx.indented;
      if (ctx.align && ctx.type == "}")
        return ctx.indented + (state.context.type == (textAfter || "").charAt(0) ? 0 : indentUnit);
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
clike({
  name: "shader",
  keywords: words$1("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),
  types: words$1("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),
  blockKeywords: words$1("for while do if else struct"),
  builtin: words$1("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),
  atoms: words$1("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),
  indentSwitch: false,
  hooks: { "#": cppHook }
});
clike({
  name: "nesc",
  keywords: words$1(cKeywords + " as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),
  types: cTypes,
  blockKeywords: words$1(cBlockKeywords),
  atoms: words$1("null true false"),
  hooks: { "#": cppHook }
});
clike({
  name: "objectivec",
  keywords: words$1(cKeywords + " " + objCKeywords),
  types: objCTypes,
  builtin: words$1(objCBuiltins),
  blockKeywords: words$1(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),
  defKeywords: words$1(cDefKeywords + " @interface @implementation @protocol @class"),
  dontIndentStatements: /^@.*$/,
  typeFirstDefinitions: true,
  atoms: words$1("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook
  }
});
clike({
  name: "objectivecpp",
  keywords: words$1(cKeywords + " " + objCKeywords + " " + cppKeywords),
  types: objCTypes,
  builtin: words$1(objCBuiltins),
  blockKeywords: words$1(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),
  defKeywords: words$1(cDefKeywords + " @interface @implementation @protocol @class class namespace"),
  dontIndentStatements: /^@.*$|^template$/,
  typeFirstDefinitions: true,
  atoms: words$1("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: cIsReservedIdentifier,
  hooks: {
    "#": cppHook,
    "*": pointerHook,
    "u": cpp11StringHook,
    "U": cpp11StringHook,
    "L": cpp11StringHook,
    "R": cpp11StringHook,
    "0": cpp14Literal,
    "1": cpp14Literal,
    "2": cpp14Literal,
    "3": cpp14Literal,
    "4": cpp14Literal,
    "5": cpp14Literal,
    "6": cpp14Literal,
    "7": cpp14Literal,
    "8": cpp14Literal,
    "9": cpp14Literal,
    token: function(stream, state, style2) {
      if (style2 == "variable" && stream.peek() == "(" && (state.prevToken == ";" || state.prevToken == null || state.prevToken == "}") && cppLooksLikeConstructor(stream.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
});
clike({
  name: "squirrel",
  keywords: words$1("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),
  types: cTypes,
  blockKeywords: words$1("case catch class else for foreach if switch try while"),
  defKeywords: words$1("function local class"),
  typeFirstDefinitions: true,
  atoms: words$1("true false null"),
  hooks: { "#": cppHook }
});
var stringTokenizer = null;
function tokenCeylonString(type) {
  return function(stream, state) {
    var escaped = false, next, end = false;
    while (!stream.eol()) {
      if (!escaped && stream.match('"') && (type == "single" || stream.match('""'))) {
        end = true;
        break;
      }
      if (!escaped && stream.match("``")) {
        stringTokenizer = tokenCeylonString(type);
        end = true;
        break;
      }
      next = stream.next();
      escaped = type == "single" && !escaped && next == "\\";
    }
    if (end)
      state.tokenize = null;
    return "string";
  };
}
clike({
  name: "ceylon",
  keywords: words$1("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),
  types: function(word) {
    var first = word.charAt(0);
    return first === first.toUpperCase() && first !== first.toLowerCase();
  },
  blockKeywords: words$1("case catch class dynamic else finally for function if interface module new object switch try while"),
  defKeywords: words$1("class dynamic function interface module object package value"),
  builtin: words$1("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),
  isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
  isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
  numberStart: /[\d#$]/,
  number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
  multiLineStrings: true,
  typeFirstDefinitions: true,
  atoms: words$1("true false null larger smaller equal empty finished"),
  indentSwitch: false,
  styleDefs: false,
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    },
    '"': function(stream, state) {
      state.tokenize = tokenCeylonString(stream.match('""') ? "triple" : "single");
      return state.tokenize(stream, state);
    },
    "`": function(stream, state) {
      if (!stringTokenizer || !stream.match("`"))
        return false;
      state.tokenize = stringTokenizer;
      stringTokenizer = null;
      return state.tokenize(stream, state);
    },
    "'": function(stream) {
      if (stream.match(/^(\\[^'\s]+|[^\\'])'/))
        return "string.special";
      stream.eatWhile(/[\w\$_\xa1-\uffff]/);
      return "atom";
    },
    token: function(_stream, state, style2) {
      if ((style2 == "variable" || style2 == "type") && state.prevToken == ".") {
        return "variableName.special";
      }
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
function pushInterpolationStack(state) {
  (state.interpolationStack || (state.interpolationStack = [])).push(state.tokenize);
}
function popInterpolationStack(state) {
  return (state.interpolationStack || (state.interpolationStack = [])).pop();
}
function sizeInterpolationStack(state) {
  return state.interpolationStack ? state.interpolationStack.length : 0;
}
function tokenDartString(quote, stream, state, raw2) {
  var tripleQuoted = false;
  if (stream.eat(quote)) {
    if (stream.eat(quote))
      tripleQuoted = true;
    else
      return "string";
  }
  function tokenStringHelper(stream2, state2) {
    var escaped = false;
    while (!stream2.eol()) {
      if (!raw2 && !escaped && stream2.peek() == "$") {
        pushInterpolationStack(state2);
        state2.tokenize = tokenInterpolation$1;
        return "string";
      }
      var next = stream2.next();
      if (next == quote && !escaped && (!tripleQuoted || stream2.match(quote + quote))) {
        state2.tokenize = null;
        break;
      }
      escaped = !raw2 && !escaped && next == "\\";
    }
    return "string";
  }
  state.tokenize = tokenStringHelper;
  return tokenStringHelper(stream, state);
}
function tokenInterpolation$1(stream, state) {
  stream.eat("$");
  if (stream.eat("{")) {
    state.tokenize = null;
  } else {
    state.tokenize = tokenInterpolationIdentifier;
  }
  return null;
}
function tokenInterpolationIdentifier(stream, state) {
  stream.eatWhile(/[\w_]/);
  state.tokenize = popInterpolationStack(state);
  return "variable";
}
clike({
  name: "dart",
  keywords: words$1("this super static final const abstract class extends external factory implements mixin get native set typedef with enum throw rethrow assert break case continue default in return new deferred async await covariant try catch finally do else for if switch while import library export part of show hide is as extension on yield late required sealed base interface when inline"),
  blockKeywords: words$1("try catch finally do else for if switch while"),
  builtin: words$1("void bool num int double dynamic var String Null Never"),
  atoms: words$1("true false null"),
  hooks: {
    "@": function(stream) {
      stream.eatWhile(/[\w\$_\.]/);
      return "meta";
    },
    // custom string handling to deal with triple-quoted strings and string interpolation
    "'": function(stream, state) {
      return tokenDartString("'", stream, state, false);
    },
    '"': function(stream, state) {
      return tokenDartString('"', stream, state, false);
    },
    "r": function(stream, state) {
      var peek = stream.peek();
      if (peek == "'" || peek == '"') {
        return tokenDartString(stream.next(), stream, state, true);
      }
      return false;
    },
    "}": function(_stream, state) {
      if (sizeInterpolationStack(state) > 0) {
        state.tokenize = popInterpolationStack(state);
        return null;
      }
      return false;
    },
    "/": function(stream, state) {
      if (!stream.eat("*"))
        return false;
      state.tokenize = tokenNestedComment(1);
      return state.tokenize(stream, state);
    },
    token: function(stream, _10, style2) {
      if (style2 == "variable") {
        var isUpper = RegExp("^[_$]*[A-Z][a-zA-Z0-9_$]*$", "g");
        if (isUpper.test(stream.current())) {
          return "type";
        }
      }
    }
  }
});
var atoms$3 = ["false", "nil", "true"];
var specialForms = [
  ".",
  "catch",
  "def",
  "do",
  "if",
  "monitor-enter",
  "monitor-exit",
  "new",
  "quote",
  "recur",
  "set!",
  "throw",
  "try",
  "var"
];
var coreSymbols = [
  "*",
  "*'",
  "*1",
  "*2",
  "*3",
  "*agent*",
  "*allow-unresolved-vars*",
  "*assert*",
  "*clojure-version*",
  "*command-line-args*",
  "*compile-files*",
  "*compile-path*",
  "*compiler-options*",
  "*data-readers*",
  "*default-data-reader-fn*",
  "*e",
  "*err*",
  "*file*",
  "*flush-on-newline*",
  "*fn-loader*",
  "*in*",
  "*math-context*",
  "*ns*",
  "*out*",
  "*print-dup*",
  "*print-length*",
  "*print-level*",
  "*print-meta*",
  "*print-namespace-maps*",
  "*print-readably*",
  "*read-eval*",
  "*reader-resolver*",
  "*source-path*",
  "*suppress-read*",
  "*unchecked-math*",
  "*use-context-classloader*",
  "*verbose-defrecords*",
  "*warn-on-reflection*",
  "+",
  "+'",
  "-",
  "-'",
  "->",
  "->>",
  "->ArrayChunk",
  "->Eduction",
  "->Vec",
  "->VecNode",
  "->VecSeq",
  "-cache-protocol-fn",
  "-reset-methods",
  "..",
  "/",
  "<",
  "<=",
  "=",
  "==",
  ">",
  ">=",
  "EMPTY-NODE",
  "Inst",
  "StackTraceElement->vec",
  "Throwable->map",
  "accessor",
  "aclone",
  "add-classpath",
  "add-watch",
  "agent",
  "agent-error",
  "agent-errors",
  "aget",
  "alength",
  "alias",
  "all-ns",
  "alter",
  "alter-meta!",
  "alter-var-root",
  "amap",
  "ancestors",
  "and",
  "any?",
  "apply",
  "areduce",
  "array-map",
  "as->",
  "aset",
  "aset-boolean",
  "aset-byte",
  "aset-char",
  "aset-double",
  "aset-float",
  "aset-int",
  "aset-long",
  "aset-short",
  "assert",
  "assoc",
  "assoc!",
  "assoc-in",
  "associative?",
  "atom",
  "await",
  "await-for",
  "await1",
  "bases",
  "bean",
  "bigdec",
  "bigint",
  "biginteger",
  "binding",
  "bit-and",
  "bit-and-not",
  "bit-clear",
  "bit-flip",
  "bit-not",
  "bit-or",
  "bit-set",
  "bit-shift-left",
  "bit-shift-right",
  "bit-test",
  "bit-xor",
  "boolean",
  "boolean-array",
  "boolean?",
  "booleans",
  "bound-fn",
  "bound-fn*",
  "bound?",
  "bounded-count",
  "butlast",
  "byte",
  "byte-array",
  "bytes",
  "bytes?",
  "case",
  "cast",
  "cat",
  "char",
  "char-array",
  "char-escape-string",
  "char-name-string",
  "char?",
  "chars",
  "chunk",
  "chunk-append",
  "chunk-buffer",
  "chunk-cons",
  "chunk-first",
  "chunk-next",
  "chunk-rest",
  "chunked-seq?",
  "class",
  "class?",
  "clear-agent-errors",
  "clojure-version",
  "coll?",
  "comment",
  "commute",
  "comp",
  "comparator",
  "compare",
  "compare-and-set!",
  "compile",
  "complement",
  "completing",
  "concat",
  "cond",
  "cond->",
  "cond->>",
  "condp",
  "conj",
  "conj!",
  "cons",
  "constantly",
  "construct-proxy",
  "contains?",
  "count",
  "counted?",
  "create-ns",
  "create-struct",
  "cycle",
  "dec",
  "dec'",
  "decimal?",
  "declare",
  "dedupe",
  "default-data-readers",
  "definline",
  "definterface",
  "defmacro",
  "defmethod",
  "defmulti",
  "defn",
  "defn-",
  "defonce",
  "defprotocol",
  "defrecord",
  "defstruct",
  "deftype",
  "delay",
  "delay?",
  "deliver",
  "denominator",
  "deref",
  "derive",
  "descendants",
  "destructure",
  "disj",
  "disj!",
  "dissoc",
  "dissoc!",
  "distinct",
  "distinct?",
  "doall",
  "dorun",
  "doseq",
  "dosync",
  "dotimes",
  "doto",
  "double",
  "double-array",
  "double?",
  "doubles",
  "drop",
  "drop-last",
  "drop-while",
  "eduction",
  "empty",
  "empty?",
  "ensure",
  "ensure-reduced",
  "enumeration-seq",
  "error-handler",
  "error-mode",
  "eval",
  "even?",
  "every-pred",
  "every?",
  "ex-data",
  "ex-info",
  "extend",
  "extend-protocol",
  "extend-type",
  "extenders",
  "extends?",
  "false?",
  "ffirst",
  "file-seq",
  "filter",
  "filterv",
  "find",
  "find-keyword",
  "find-ns",
  "find-protocol-impl",
  "find-protocol-method",
  "find-var",
  "first",
  "flatten",
  "float",
  "float-array",
  "float?",
  "floats",
  "flush",
  "fn",
  "fn?",
  "fnext",
  "fnil",
  "for",
  "force",
  "format",
  "frequencies",
  "future",
  "future-call",
  "future-cancel",
  "future-cancelled?",
  "future-done?",
  "future?",
  "gen-class",
  "gen-interface",
  "gensym",
  "get",
  "get-in",
  "get-method",
  "get-proxy-class",
  "get-thread-bindings",
  "get-validator",
  "group-by",
  "halt-when",
  "hash",
  "hash-combine",
  "hash-map",
  "hash-ordered-coll",
  "hash-set",
  "hash-unordered-coll",
  "ident?",
  "identical?",
  "identity",
  "if-let",
  "if-not",
  "if-some",
  "ifn?",
  "import",
  "in-ns",
  "inc",
  "inc'",
  "indexed?",
  "init-proxy",
  "inst-ms",
  "inst-ms*",
  "inst?",
  "instance?",
  "int",
  "int-array",
  "int?",
  "integer?",
  "interleave",
  "intern",
  "interpose",
  "into",
  "into-array",
  "ints",
  "io!",
  "isa?",
  "iterate",
  "iterator-seq",
  "juxt",
  "keep",
  "keep-indexed",
  "key",
  "keys",
  "keyword",
  "keyword?",
  "last",
  "lazy-cat",
  "lazy-seq",
  "let",
  "letfn",
  "line-seq",
  "list",
  "list*",
  "list?",
  "load",
  "load-file",
  "load-reader",
  "load-string",
  "loaded-libs",
  "locking",
  "long",
  "long-array",
  "longs",
  "loop",
  "macroexpand",
  "macroexpand-1",
  "make-array",
  "make-hierarchy",
  "map",
  "map-entry?",
  "map-indexed",
  "map?",
  "mapcat",
  "mapv",
  "max",
  "max-key",
  "memfn",
  "memoize",
  "merge",
  "merge-with",
  "meta",
  "method-sig",
  "methods",
  "min",
  "min-key",
  "mix-collection-hash",
  "mod",
  "munge",
  "name",
  "namespace",
  "namespace-munge",
  "nat-int?",
  "neg-int?",
  "neg?",
  "newline",
  "next",
  "nfirst",
  "nil?",
  "nnext",
  "not",
  "not-any?",
  "not-empty",
  "not-every?",
  "not=",
  "ns",
  "ns-aliases",
  "ns-imports",
  "ns-interns",
  "ns-map",
  "ns-name",
  "ns-publics",
  "ns-refers",
  "ns-resolve",
  "ns-unalias",
  "ns-unmap",
  "nth",
  "nthnext",
  "nthrest",
  "num",
  "number?",
  "numerator",
  "object-array",
  "odd?",
  "or",
  "parents",
  "partial",
  "partition",
  "partition-all",
  "partition-by",
  "pcalls",
  "peek",
  "persistent!",
  "pmap",
  "pop",
  "pop!",
  "pop-thread-bindings",
  "pos-int?",
  "pos?",
  "pr",
  "pr-str",
  "prefer-method",
  "prefers",
  "primitives-classnames",
  "print",
  "print-ctor",
  "print-dup",
  "print-method",
  "print-simple",
  "print-str",
  "printf",
  "println",
  "println-str",
  "prn",
  "prn-str",
  "promise",
  "proxy",
  "proxy-call-with-super",
  "proxy-mappings",
  "proxy-name",
  "proxy-super",
  "push-thread-bindings",
  "pvalues",
  "qualified-ident?",
  "qualified-keyword?",
  "qualified-symbol?",
  "quot",
  "rand",
  "rand-int",
  "rand-nth",
  "random-sample",
  "range",
  "ratio?",
  "rational?",
  "rationalize",
  "re-find",
  "re-groups",
  "re-matcher",
  "re-matches",
  "re-pattern",
  "re-seq",
  "read",
  "read-line",
  "read-string",
  "reader-conditional",
  "reader-conditional?",
  "realized?",
  "record?",
  "reduce",
  "reduce-kv",
  "reduced",
  "reduced?",
  "reductions",
  "ref",
  "ref-history-count",
  "ref-max-history",
  "ref-min-history",
  "ref-set",
  "refer",
  "refer-clojure",
  "reify",
  "release-pending-sends",
  "rem",
  "remove",
  "remove-all-methods",
  "remove-method",
  "remove-ns",
  "remove-watch",
  "repeat",
  "repeatedly",
  "replace",
  "replicate",
  "require",
  "reset!",
  "reset-meta!",
  "reset-vals!",
  "resolve",
  "rest",
  "restart-agent",
  "resultset-seq",
  "reverse",
  "reversible?",
  "rseq",
  "rsubseq",
  "run!",
  "satisfies?",
  "second",
  "select-keys",
  "send",
  "send-off",
  "send-via",
  "seq",
  "seq?",
  "seqable?",
  "seque",
  "sequence",
  "sequential?",
  "set",
  "set-agent-send-executor!",
  "set-agent-send-off-executor!",
  "set-error-handler!",
  "set-error-mode!",
  "set-validator!",
  "set?",
  "short",
  "short-array",
  "shorts",
  "shuffle",
  "shutdown-agents",
  "simple-ident?",
  "simple-keyword?",
  "simple-symbol?",
  "slurp",
  "some",
  "some->",
  "some->>",
  "some-fn",
  "some?",
  "sort",
  "sort-by",
  "sorted-map",
  "sorted-map-by",
  "sorted-set",
  "sorted-set-by",
  "sorted?",
  "special-symbol?",
  "spit",
  "split-at",
  "split-with",
  "str",
  "string?",
  "struct",
  "struct-map",
  "subs",
  "subseq",
  "subvec",
  "supers",
  "swap!",
  "swap-vals!",
  "symbol",
  "symbol?",
  "sync",
  "tagged-literal",
  "tagged-literal?",
  "take",
  "take-last",
  "take-nth",
  "take-while",
  "test",
  "the-ns",
  "thread-bound?",
  "time",
  "to-array",
  "to-array-2d",
  "trampoline",
  "transduce",
  "transient",
  "tree-seq",
  "true?",
  "type",
  "unchecked-add",
  "unchecked-add-int",
  "unchecked-byte",
  "unchecked-char",
  "unchecked-dec",
  "unchecked-dec-int",
  "unchecked-divide-int",
  "unchecked-double",
  "unchecked-float",
  "unchecked-inc",
  "unchecked-inc-int",
  "unchecked-int",
  "unchecked-long",
  "unchecked-multiply",
  "unchecked-multiply-int",
  "unchecked-negate",
  "unchecked-negate-int",
  "unchecked-remainder-int",
  "unchecked-short",
  "unchecked-subtract",
  "unchecked-subtract-int",
  "underive",
  "unquote",
  "unquote-splicing",
  "unreduced",
  "unsigned-bit-shift-right",
  "update",
  "update-in",
  "update-proxy",
  "uri?",
  "use",
  "uuid?",
  "val",
  "vals",
  "var-get",
  "var-set",
  "var?",
  "vary-meta",
  "vec",
  "vector",
  "vector-of",
  "vector?",
  "volatile!",
  "volatile?",
  "vreset!",
  "vswap!",
  "when",
  "when-first",
  "when-let",
  "when-not",
  "when-some",
  "while",
  "with-bindings",
  "with-bindings*",
  "with-in-str",
  "with-loading-context",
  "with-local-vars",
  "with-meta",
  "with-open",
  "with-out-str",
  "with-precision",
  "with-redefs",
  "with-redefs-fn",
  "xml-seq",
  "zero?",
  "zipmap"
];
var haveBodyParameter = [
  "->",
  "->>",
  "as->",
  "binding",
  "bound-fn",
  "case",
  "catch",
  "comment",
  "cond",
  "cond->",
  "cond->>",
  "condp",
  "def",
  "definterface",
  "defmethod",
  "defn",
  "defmacro",
  "defprotocol",
  "defrecord",
  "defstruct",
  "deftype",
  "do",
  "doseq",
  "dotimes",
  "doto",
  "extend",
  "extend-protocol",
  "extend-type",
  "fn",
  "for",
  "future",
  "if",
  "if-let",
  "if-not",
  "if-some",
  "let",
  "letfn",
  "locking",
  "loop",
  "ns",
  "proxy",
  "reify",
  "struct-map",
  "some->",
  "some->>",
  "try",
  "when",
  "when-first",
  "when-let",
  "when-not",
  "when-some",
  "while",
  "with-bindings",
  "with-bindings*",
  "with-in-str",
  "with-loading-context",
  "with-local-vars",
  "with-meta",
  "with-open",
  "with-out-str",
  "with-precision",
  "with-redefs",
  "with-redefs-fn"
];
createLookupMap(atoms$3);
createLookupMap(specialForms);
createLookupMap(coreSymbols);
createLookupMap(haveBodyParameter);
function createLookupMap(words2) {
  var obj = {};
  for (var i3 = 0; i3 < words2.length; ++i3)
    obj[words2[i3]] = true;
  return obj;
}
function mlLike(parserConfig) {
  var words2 = {
    "as": "keyword",
    "do": "keyword",
    "else": "keyword",
    "end": "keyword",
    "exception": "keyword",
    "fun": "keyword",
    "functor": "keyword",
    "if": "keyword",
    "in": "keyword",
    "include": "keyword",
    "let": "keyword",
    "of": "keyword",
    "open": "keyword",
    "rec": "keyword",
    "struct": "keyword",
    "then": "keyword",
    "type": "keyword",
    "val": "keyword",
    "while": "keyword",
    "with": "keyword"
  };
  var extraWords = parserConfig.extraWords || {};
  for (var prop in extraWords) {
    if (extraWords.hasOwnProperty(prop)) {
      words2[prop] = parserConfig.extraWords[prop];
    }
  }
  var hintWords = [];
  for (var k10 in words2) {
    hintWords.push(k10);
  }
  function tokenBase2(stream, state) {
    var ch2 = stream.next();
    if (ch2 === '"') {
      state.tokenize = tokenString2;
      return state.tokenize(stream, state);
    }
    if (ch2 === "{") {
      if (stream.eat("|")) {
        state.longString = true;
        state.tokenize = tokenLongString;
        return state.tokenize(stream, state);
      }
    }
    if (ch2 === "(") {
      if (stream.match(/^\*(?!\))/)) {
        state.commentLevel++;
        state.tokenize = tokenComment2;
        return state.tokenize(stream, state);
      }
    }
    if (ch2 === "~" || ch2 === "?") {
      stream.eatWhile(/\w/);
      return "variableName.special";
    }
    if (ch2 === "`") {
      stream.eatWhile(/\w/);
      return "quote";
    }
    if (ch2 === "/" && parserConfig.slashComments && stream.eat("/")) {
      stream.skipToEnd();
      return "comment";
    }
    if (/\d/.test(ch2)) {
      if (ch2 === "0" && stream.eat(/[bB]/)) {
        stream.eatWhile(/[01]/);
      }
      if (ch2 === "0" && stream.eat(/[xX]/)) {
        stream.eatWhile(/[0-9a-fA-F]/);
      }
      if (ch2 === "0" && stream.eat(/[oO]/)) {
        stream.eatWhile(/[0-7]/);
      } else {
        stream.eatWhile(/[\d_]/);
        if (stream.eat(".")) {
          stream.eatWhile(/[\d]/);
        }
        if (stream.eat(/[eE]/)) {
          stream.eatWhile(/[\d\-+]/);
        }
      }
      return "number";
    }
    if (/[+\-*&%=<>!?|@\.~:]/.test(ch2)) {
      return "operator";
    }
    if (/[\w\xa1-\uffff]/.test(ch2)) {
      stream.eatWhile(/[\w\xa1-\uffff]/);
      var cur = stream.current();
      return words2.hasOwnProperty(cur) ? words2[cur] : "variable";
    }
    return null;
  }
  function tokenString2(stream, state) {
    var next, end = false, escaped = false;
    while ((next = stream.next()) != null) {
      if (next === '"' && !escaped) {
        end = true;
        break;
      }
      escaped = !escaped && next === "\\";
    }
    if (end && !escaped) {
      state.tokenize = tokenBase2;
    }
    return "string";
  }
  function tokenComment2(stream, state) {
    var prev, next;
    while (state.commentLevel > 0 && (next = stream.next()) != null) {
      if (prev === "(" && next === "*")
        state.commentLevel++;
      if (prev === "*" && next === ")")
        state.commentLevel--;
      prev = next;
    }
    if (state.commentLevel <= 0) {
      state.tokenize = tokenBase2;
    }
    return "comment";
  }
  function tokenLongString(stream, state) {
    var prev, next;
    while (state.longString && (next = stream.next()) != null) {
      if (prev === "|" && next === "}")
        state.longString = false;
      prev = next;
    }
    if (!state.longString) {
      state.tokenize = tokenBase2;
    }
    return "string";
  }
  return {
    startState: function() {
      return { tokenize: tokenBase2, commentLevel: 0, longString: false };
    },
    token: function(stream, state) {
      if (stream.eatSpace())
        return null;
      return state.tokenize(stream, state);
    },
    languageData: {
      autocomplete: hintWords,
      commentTokens: {
        line: parserConfig.slashComments ? "//" : void 0,
        block: { open: "(*", close: "*)" }
      }
    }
  };
}
mlLike({
  name: "ocaml",
  extraWords: {
    "and": "keyword",
    "assert": "keyword",
    "begin": "keyword",
    "class": "keyword",
    "constraint": "keyword",
    "done": "keyword",
    "downto": "keyword",
    "external": "keyword",
    "function": "keyword",
    "initializer": "keyword",
    "lazy": "keyword",
    "match": "keyword",
    "method": "keyword",
    "module": "keyword",
    "mutable": "keyword",
    "new": "keyword",
    "nonrec": "keyword",
    "object": "keyword",
    "private": "keyword",
    "sig": "keyword",
    "to": "keyword",
    "try": "keyword",
    "value": "keyword",
    "virtual": "keyword",
    "when": "keyword",
    // builtins
    "raise": "builtin",
    "failwith": "builtin",
    "true": "builtin",
    "false": "builtin",
    // Pervasives builtins
    "asr": "builtin",
    "land": "builtin",
    "lor": "builtin",
    "lsl": "builtin",
    "lsr": "builtin",
    "lxor": "builtin",
    "mod": "builtin",
    "or": "builtin",
    // More Pervasives
    "raise_notrace": "builtin",
    "trace": "builtin",
    "exit": "builtin",
    "print_string": "builtin",
    "print_endline": "builtin",
    "int": "type",
    "float": "type",
    "bool": "type",
    "char": "type",
    "string": "type",
    "unit": "type",
    // Modules
    "List": "builtin"
  }
});
mlLike({
  name: "fsharp",
  extraWords: {
    "abstract": "keyword",
    "assert": "keyword",
    "base": "keyword",
    "begin": "keyword",
    "class": "keyword",
    "default": "keyword",
    "delegate": "keyword",
    "do!": "keyword",
    "done": "keyword",
    "downcast": "keyword",
    "downto": "keyword",
    "elif": "keyword",
    "extern": "keyword",
    "finally": "keyword",
    "for": "keyword",
    "function": "keyword",
    "global": "keyword",
    "inherit": "keyword",
    "inline": "keyword",
    "interface": "keyword",
    "internal": "keyword",
    "lazy": "keyword",
    "let!": "keyword",
    "match": "keyword",
    "member": "keyword",
    "module": "keyword",
    "mutable": "keyword",
    "namespace": "keyword",
    "new": "keyword",
    "null": "keyword",
    "override": "keyword",
    "private": "keyword",
    "public": "keyword",
    "return!": "keyword",
    "return": "keyword",
    "select": "keyword",
    "static": "keyword",
    "to": "keyword",
    "try": "keyword",
    "upcast": "keyword",
    "use!": "keyword",
    "use": "keyword",
    "void": "keyword",
    "when": "keyword",
    "yield!": "keyword",
    "yield": "keyword",
    // Reserved words
    "atomic": "keyword",
    "break": "keyword",
    "checked": "keyword",
    "component": "keyword",
    "const": "keyword",
    "constraint": "keyword",
    "constructor": "keyword",
    "continue": "keyword",
    "eager": "keyword",
    "event": "keyword",
    "external": "keyword",
    "fixed": "keyword",
    "method": "keyword",
    "mixin": "keyword",
    "object": "keyword",
    "parallel": "keyword",
    "process": "keyword",
    "protected": "keyword",
    "pure": "keyword",
    "sealed": "keyword",
    "tailcall": "keyword",
    "trait": "keyword",
    "virtual": "keyword",
    "volatile": "keyword",
    // builtins
    "List": "builtin",
    "Seq": "builtin",
    "Map": "builtin",
    "Set": "builtin",
    "Option": "builtin",
    "int": "builtin",
    "string": "builtin",
    "not": "builtin",
    "true": "builtin",
    "false": "builtin",
    "raise": "builtin",
    "failwith": "builtin"
  },
  slashComments: true
});
mlLike({
  name: "sml",
  extraWords: {
    "abstype": "keyword",
    "and": "keyword",
    "andalso": "keyword",
    "case": "keyword",
    "datatype": "keyword",
    "fn": "keyword",
    "handle": "keyword",
    "infix": "keyword",
    "infixr": "keyword",
    "local": "keyword",
    "nonfix": "keyword",
    "op": "keyword",
    "orelse": "keyword",
    "raise": "keyword",
    "withtype": "keyword",
    "eqtype": "keyword",
    "sharing": "keyword",
    "sig": "keyword",
    "signature": "keyword",
    "structure": "keyword",
    "where": "keyword",
    "true": "keyword",
    "false": "keyword",
    // types
    "int": "builtin",
    "real": "builtin",
    "string": "builtin",
    "char": "builtin",
    "bool": "builtin"
  },
  slashComments: true
});
function buildRegexp(patterns, options) {
  options = options || {};
  var prefix = options.prefix !== void 0 ? options.prefix : "^";
  var suffix = options.suffix !== void 0 ? options.suffix : "\\b";
  for (var i3 = 0; i3 < patterns.length; i3++) {
    if (patterns[i3] instanceof RegExp) {
      patterns[i3] = patterns[i3].source;
    } else {
      patterns[i3] = patterns[i3].replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
  }
  return new RegExp(prefix + "(" + patterns.join("|") + ")" + suffix, "i");
}
var notCharacterOrDash = "(?=[^A-Za-z\\d\\-_]|$)";
buildRegexp([
  /begin|break|catch|continue|data|default|do|dynamicparam/,
  /else|elseif|end|exit|filter|finally|for|foreach|from|function|if|in/,
  /param|process|return|switch|throw|trap|try|until|where|while/
], { suffix: notCharacterOrDash });
var wordOperators = buildRegexp([
  "f",
  /b?not/,
  /[ic]?split/,
  "join",
  /is(not)?/,
  "as",
  /[ic]?(eq|ne|[gl][te])/,
  /[ic]?(not)?(like|match|contains)/,
  /[ic]?replace/,
  /b?(and|or|xor)/
], { prefix: "-" });
var symbolOperators = /[+\-*\/%]=|\+\+|--|\.\.|[+\-*&^%:=!|\/]|<(?!#)|(?!#)>/;
buildRegexp([wordOperators, symbolOperators], { suffix: "" });
var symbolBuiltins = /[A-Z]:|%|\?/i;
var namedBuiltins = buildRegexp([
  /Add-(Computer|Content|History|Member|PSSnapin|Type)/,
  /Checkpoint-Computer/,
  /Clear-(Content|EventLog|History|Host|Item(Property)?|Variable)/,
  /Compare-Object/,
  /Complete-Transaction/,
  /Connect-PSSession/,
  /ConvertFrom-(Csv|Json|SecureString|StringData)/,
  /Convert-Path/,
  /ConvertTo-(Csv|Html|Json|SecureString|Xml)/,
  /Copy-Item(Property)?/,
  /Debug-Process/,
  /Disable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)/,
  /Disconnect-PSSession/,
  /Enable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)/,
  /(Enter|Exit)-PSSession/,
  /Export-(Alias|Clixml|Console|Counter|Csv|FormatData|ModuleMember|PSSession)/,
  /ForEach-Object/,
  /Format-(Custom|List|Table|Wide)/,
  new RegExp("Get-(Acl|Alias|AuthenticodeSignature|ChildItem|Command|ComputerRestorePoint|Content|ControlPanelItem|Counter|Credential|Culture|Date|Event|EventLog|EventSubscriber|ExecutionPolicy|FormatData|Help|History|Host|HotFix|Item|ItemProperty|Job|Location|Member|Module|PfxCertificate|Process|PSBreakpoint|PSCallStack|PSDrive|PSProvider|PSSession|PSSessionConfiguration|PSSnapin|Random|Service|TraceSource|Transaction|TypeData|UICulture|Unique|Variable|Verb|WinEvent|WmiObject)"),
  /Group-Object/,
  /Import-(Alias|Clixml|Counter|Csv|LocalizedData|Module|PSSession)/,
  /ImportSystemModules/,
  /Invoke-(Command|Expression|History|Item|RestMethod|WebRequest|WmiMethod)/,
  /Join-Path/,
  /Limit-EventLog/,
  /Measure-(Command|Object)/,
  /Move-Item(Property)?/,
  new RegExp("New-(Alias|Event|EventLog|Item(Property)?|Module|ModuleManifest|Object|PSDrive|PSSession|PSSessionConfigurationFile|PSSessionOption|PSTransportOption|Service|TimeSpan|Variable|WebServiceProxy|WinEvent)"),
  /Out-(Default|File|GridView|Host|Null|Printer|String)/,
  /Pause/,
  /(Pop|Push)-Location/,
  /Read-Host/,
  /Receive-(Job|PSSession)/,
  /Register-(EngineEvent|ObjectEvent|PSSessionConfiguration|WmiEvent)/,
  /Remove-(Computer|Event|EventLog|Item(Property)?|Job|Module|PSBreakpoint|PSDrive|PSSession|PSSnapin|TypeData|Variable|WmiObject)/,
  /Rename-(Computer|Item(Property)?)/,
  /Reset-ComputerMachinePassword/,
  /Resolve-Path/,
  /Restart-(Computer|Service)/,
  /Restore-Computer/,
  /Resume-(Job|Service)/,
  /Save-Help/,
  /Select-(Object|String|Xml)/,
  /Send-MailMessage/,
  new RegExp("Set-(Acl|Alias|AuthenticodeSignature|Content|Date|ExecutionPolicy|Item(Property)?|Location|PSBreakpoint|PSDebug|PSSessionConfiguration|Service|StrictMode|TraceSource|Variable|WmiInstance)"),
  /Show-(Command|ControlPanelItem|EventLog)/,
  /Sort-Object/,
  /Split-Path/,
  /Start-(Job|Process|Service|Sleep|Transaction|Transcript)/,
  /Stop-(Computer|Job|Process|Service|Transcript)/,
  /Suspend-(Job|Service)/,
  /TabExpansion2/,
  /Tee-Object/,
  /Test-(ComputerSecureChannel|Connection|ModuleManifest|Path|PSSessionConfigurationFile)/,
  /Trace-Command/,
  /Unblock-File/,
  /Undo-Transaction/,
  /Unregister-(Event|PSSessionConfiguration)/,
  /Update-(FormatData|Help|List|TypeData)/,
  /Use-Transaction/,
  /Wait-(Event|Job|Process)/,
  /Where-Object/,
  /Write-(Debug|Error|EventLog|Host|Output|Progress|Verbose|Warning)/,
  /cd|help|mkdir|more|oss|prompt/,
  /ac|asnp|cat|cd|chdir|clc|clear|clhy|cli|clp|cls|clv|cnsn|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|dnsn|ebp/,
  /echo|epal|epcsv|epsn|erase|etsn|exsn|fc|fl|foreach|ft|fw|gal|gbp|gc|gci|gcm|gcs|gdr|ghy|gi|gjb|gl|gm|gmo|gp|gps/,
  /group|gsn|gsnp|gsv|gu|gv|gwmi|h|history|icm|iex|ihy|ii|ipal|ipcsv|ipmo|ipsn|irm|ise|iwmi|iwr|kill|lp|ls|man|md/,
  /measure|mi|mount|move|mp|mv|nal|ndr|ni|nmo|npssc|nsn|nv|ogv|oh|popd|ps|pushd|pwd|r|rbp|rcjb|rcsn|rd|rdr|ren|ri/,
  /rjb|rm|rmdir|rmo|rni|rnp|rp|rsn|rsnp|rujb|rv|rvpa|rwmi|sajb|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls/,
  /sort|sp|spjb|spps|spsv|start|sujb|sv|swmi|tee|trcm|type|where|wjb|write/
], { prefix: "", suffix: "" });
var variableBuiltins = buildRegexp([
  /[$?^_]|Args|ConfirmPreference|ConsoleFileName|DebugPreference|Error|ErrorActionPreference|ErrorView|ExecutionContext/,
  /FormatEnumerationLimit|Home|Host|Input|MaximumAliasCount|MaximumDriveCount|MaximumErrorCount|MaximumFunctionCount/,
  /MaximumHistoryCount|MaximumVariableCount|MyInvocation|NestedPromptLevel|OutputEncoding|Pid|Profile|ProgressPreference/,
  /PSBoundParameters|PSCommandPath|PSCulture|PSDefaultParameterValues|PSEmailServer|PSHome|PSScriptRoot|PSSessionApplicationName/,
  /PSSessionConfigurationName|PSSessionOption|PSUICulture|PSVersionTable|Pwd|ShellId|StackTrace|VerbosePreference/,
  /WarningPreference|WhatIfPreference/,
  /Event|EventArgs|EventSubscriber|Sender/,
  /Matches|Ofs|ForEach|LastExitCode|PSCmdlet|PSItem|PSSenderInfo|This/,
  /true|false|null/
], { prefix: "\\$", suffix: "" });
buildRegexp([symbolBuiltins, namedBuiltins, variableBuiltins], { suffix: notCharacterOrDash });
function wordObj$1(words2) {
  var res = {};
  for (var i3 = 0; i3 < words2.length; ++i3)
    res[words2[i3]] = true;
  return res;
}
var commonAtoms$1 = ["NULL", "NA", "Inf", "NaN", "NA_integer_", "NA_real_", "NA_complex_", "NA_character_", "TRUE", "FALSE"];
var commonBuiltins = ["list", "quote", "bquote", "eval", "return", "call", "parse", "deparse"];
var commonKeywords$1 = ["if", "else", "repeat", "while", "function", "for", "in", "next", "break"];
var commonBlockKeywords = ["if", "else", "repeat", "while", "function", "for"];
wordObj$1(commonAtoms$1);
wordObj$1(commonBuiltins);
wordObj$1(commonKeywords$1);
wordObj$1(commonBlockKeywords);
function wordObj(words2) {
  var o3 = {};
  for (var i3 = 0, e3 = words2.length; i3 < e3; ++i3)
    o3[words2[i3]] = true;
  return o3;
}
var keywordList = [
  "alias",
  "and",
  "BEGIN",
  "begin",
  "break",
  "case",
  "class",
  "def",
  "defined?",
  "do",
  "else",
  "elsif",
  "END",
  "end",
  "ensure",
  "false",
  "for",
  "if",
  "in",
  "module",
  "next",
  "not",
  "or",
  "redo",
  "rescue",
  "retry",
  "return",
  "self",
  "super",
  "then",
  "true",
  "undef",
  "unless",
  "until",
  "when",
  "while",
  "yield",
  "nil",
  "raise",
  "throw",
  "catch",
  "fail",
  "loop",
  "callcc",
  "caller",
  "lambda",
  "proc",
  "public",
  "protected",
  "private",
  "require",
  "load",
  "require_relative",
  "extend",
  "autoload",
  "__END__",
  "__FILE__",
  "__LINE__",
  "__dir__"
];
wordObj(keywordList);
wordObj([
  "def",
  "class",
  "case",
  "for",
  "while",
  "until",
  "module",
  "catch",
  "loop",
  "proc",
  "begin"
]);
wordObj(["end", "until"]);
var words = {};
function define(style2, dict) {
  for (var i3 = 0; i3 < dict.length; i3++) {
    words[dict[i3]] = style2;
  }
}
var commonAtoms = ["true", "false"];
var commonKeywords = [
  "if",
  "then",
  "do",
  "else",
  "elif",
  "while",
  "until",
  "for",
  "in",
  "esac",
  "fi",
  "fin",
  "fil",
  "done",
  "exit",
  "set",
  "unset",
  "export",
  "function"
];
var commonCommands = [
  "ab",
  "awk",
  "bash",
  "beep",
  "cat",
  "cc",
  "cd",
  "chown",
  "chmod",
  "chroot",
  "clear",
  "cp",
  "curl",
  "cut",
  "diff",
  "echo",
  "find",
  "gawk",
  "gcc",
  "get",
  "git",
  "grep",
  "hg",
  "kill",
  "killall",
  "ln",
  "ls",
  "make",
  "mkdir",
  "openssl",
  "mv",
  "nc",
  "nl",
  "node",
  "npm",
  "ping",
  "ps",
  "restart",
  "rm",
  "rmdir",
  "sed",
  "service",
  "sh",
  "shopt",
  "shred",
  "source",
  "sort",
  "sleep",
  "ssh",
  "start",
  "stop",
  "su",
  "sudo",
  "svn",
  "tee",
  "telnet",
  "top",
  "touch",
  "vi",
  "vim",
  "wall",
  "wc",
  "wget",
  "who",
  "write",
  "yes",
  "zsh"
];
define("atom", commonAtoms);
define("keyword", commonKeywords);
define("builtin", commonCommands);
function wordSet(words2) {
  var set = {};
  for (var i3 = 0; i3 < words2.length; i3++)
    set[words2[i3]] = true;
  return set;
}
wordSet([
  "_",
  "var",
  "let",
  "actor",
  "class",
  "enum",
  "extension",
  "import",
  "protocol",
  "struct",
  "func",
  "typealias",
  "associatedtype",
  "open",
  "public",
  "internal",
  "fileprivate",
  "private",
  "deinit",
  "init",
  "new",
  "override",
  "self",
  "subscript",
  "super",
  "convenience",
  "dynamic",
  "final",
  "indirect",
  "lazy",
  "required",
  "static",
  "unowned",
  "unowned(safe)",
  "unowned(unsafe)",
  "weak",
  "as",
  "is",
  "break",
  "case",
  "continue",
  "default",
  "else",
  "fallthrough",
  "for",
  "guard",
  "if",
  "in",
  "repeat",
  "switch",
  "where",
  "while",
  "defer",
  "return",
  "inout",
  "mutating",
  "nonmutating",
  "isolated",
  "nonisolated",
  "catch",
  "do",
  "rethrows",
  "throw",
  "throws",
  "async",
  "await",
  "try",
  "didSet",
  "get",
  "set",
  "willSet",
  "assignment",
  "associativity",
  "infix",
  "left",
  "none",
  "operator",
  "postfix",
  "precedence",
  "precedencegroup",
  "prefix",
  "right",
  "Any",
  "AnyObject",
  "Type",
  "dynamicType",
  "Self",
  "Protocol",
  "__COLUMN__",
  "__FILE__",
  "__FUNCTION__",
  "__LINE__"
]);
wordSet(["var", "let", "actor", "class", "enum", "extension", "import", "protocol", "struct", "func", "typealias", "associatedtype", "for"]);
wordSet(["true", "false", "nil", "self", "super", "_"]);
wordSet([
  "Array",
  "Bool",
  "Character",
  "Dictionary",
  "Double",
  "Float",
  "Int",
  "Int8",
  "Int16",
  "Int32",
  "Int64",
  "Never",
  "Optional",
  "Set",
  "String",
  "UInt8",
  "UInt16",
  "UInt32",
  "UInt64",
  "Void"
]);
createTheme({
  theme: "light",
  settings: {
    background: "var(--theme-background-2, var(--default-theme-background-2))",
    foreground: "var(--theme-color-1, var(--default-theme-color-1))",
    caret: "var(--theme-color-1, var(--default-theme-color-1))",
    selection: "var(--theme-background-3, var(--default-theme-background-3))",
    selectionMatch: "#e3dcce",
    gutterBackground: "var(--theme-background-2, var(--default-theme-background-2))",
    gutterForeground: "var(--theme-color-3, var(--default-theme-color-3))",
    gutterBorder: "transparent",
    lineHighlight: "var(--theme-background-3, var(--default-theme-background-3))",
    fontFamily: "var(--theme-font-code, var(--default-theme-font-code))"
  },
  styles: [
    {
      tag: [tags.standard(tags.tagName), tags.tagName],
      color: "var(--theme-color-purple, var(--default-theme-color-purple))"
    },
    {
      tag: [tags.comment],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [tags.className],
      color: "var(--theme-color-orange, var(--default-theme-color-orange))"
    },
    {
      tag: [tags.variableName, tags.propertyName, tags.attributeName],
      color: "var(--theme-color-1, var(--default-theme-color-1))"
    },
    {
      tag: [tags.operator],
      color: "var(--theme-color-2, var(--default-theme-color-2))"
    },
    {
      tag: [tags.keyword, tags.typeName, tags.typeOperator],
      color: "var(--theme-color-green, var(--default-theme-color-green))"
    },
    {
      tag: [tags.string],
      color: "var(--theme-color-blue, var(--default-theme-color-blue))"
    },
    {
      tag: [tags.bracket, tags.regexp, tags.meta],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [tags.number],
      color: "var(--theme-color-blue, var(--default-theme-color-blue))"
    },
    {
      tag: [tags.name, tags.quote],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [tags.heading],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      fontWeight: "bold"
    },
    {
      tag: [tags.emphasis],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      fontStyle: "italic"
    },
    {
      tag: [tags.deleted],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      backgroundColor: "transparent"
    },
    {
      tag: [tags.atom, tags.bool, tags.special(tags.variableName)],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [tags.url, tags.escape, tags.regexp, tags.link],
      color: "var(--theme-color-1, var(--default-theme-color-1))"
    },
    { tag: tags.link, textDecoration: "underline" },
    { tag: tags.strikethrough, textDecoration: "line-through" },
    {
      tag: tags.invalid,
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    }
  ]
});
createTheme({
  theme: "dark",
  settings: {
    background: "var(--theme-background-2, var(--default-theme-background-2))",
    foreground: "var(--theme-color-1, var(--default-theme-color-1))",
    caret: "var(--theme-color-1, var(--default-theme-color-1))",
    selection: "var(--theme-background-3, var(--default-theme-background-3))",
    selectionMatch: "#e3dcce",
    gutterBackground: "var(--theme-background-2, var(--default-theme-background-2))",
    gutterForeground: "var(--theme-color-3, var(--default-theme-color-3))",
    gutterBorder: "transparent",
    lineHighlight: "var(--theme-background-3, var(--default-theme-background-3))",
    fontFamily: "var(--theme-font-code, var(--default-theme-font-code))"
  },
  styles: [
    {
      tag: [tags.standard(tags.tagName), tags.tagName],
      color: "var(--theme-color-purple, var(--default-theme-color-purple))"
    },
    {
      tag: [tags.comment],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [tags.className],
      color: "var(--theme-color-orange, var(--default-theme-color-orange))"
    },
    {
      tag: [tags.variableName, tags.propertyName, tags.attributeName],
      color: "var(--theme-color-1, var(--default-theme-color-1))"
    },
    {
      tag: [tags.operator],
      color: "var(--theme-color-2, var(--default-theme-color-2))"
    },
    {
      tag: [tags.keyword, tags.typeName, tags.typeOperator],
      color: "var(--theme-color-green, var(--default-theme-color-green))"
    },
    {
      tag: [tags.string],
      color: "var(--theme-color-blue, var(--default-theme-color-blue))"
    },
    {
      tag: [tags.bracket, tags.regexp, tags.meta],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [tags.number],
      color: "var(--theme-color-blue, var(--default-theme-color-blue))"
    },
    {
      tag: [tags.name, tags.quote],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [tags.heading],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      fontWeight: "bold"
    },
    {
      tag: [tags.emphasis],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      fontStyle: "italic"
    },
    {
      tag: [tags.deleted],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      backgroundColor: "transparent"
    },
    {
      tag: [tags.atom, tags.bool, tags.special(tags.variableName)],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [tags.url, tags.escape, tags.regexp, tags.link],
      color: "var(--theme-color-1, var(--default-theme-color-1))"
    },
    { tag: tags.link, textDecoration: "underline" },
    { tag: tags.strikethrough, textDecoration: "line-through" },
    {
      tag: tags.invalid,
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    }
  ]
});
ref(false);
new MatchDecorator({
  regexp: /(\{[^}]+\})/g,
  decoration: () => Decoration.mark({
    attributes: {
      class: "scalar-api-client__variable"
    }
  })
});
(function() {
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode(".loader-wrapper[data-v-dbcbb0f9] {\n  position: relative;\n  height: var(--656643f5);\n  width: var(--656643f5);\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  --default-loader-size: 50%;\n}\n\n/*SVG Positioning for Loader Objects*/\n.svg-loader[data-v-dbcbb0f9] {\n  width: var(--loader-size, var(--default-loader-size));\n  height: var(--loader-size, var(--default-loader-size));\n  top: 1rem;\n  right: 0.9rem;\n  overflow: visible;\n\n  fill: none;\n  background-color: transparent;\n  stroke: currentColor;\n}\n.svg-path[data-v-dbcbb0f9] {\n  stroke-width: 14;\n  fill: none;\n  transition: 0.3s;\n}\n.svg-x-mark[data-v-dbcbb0f9] {\n  stroke-dasharray: 57;\n  stroke-dashoffset: 57;\n  transition-delay: 0s;\n}\n.svg-check-mark[data-v-dbcbb0f9] {\n  stroke-dasharray: 149;\n  stroke-dashoffset: 149;\n  transition-delay: 0s;\n}\n.icon-is-invalid .svg-x-mark[data-v-dbcbb0f9] {\n  stroke-dashoffset: 0;\n  transition-delay: 0.3s;\n}\n.icon-is-valid .svg-check-mark[data-v-dbcbb0f9] {\n  stroke-dashoffset: 0;\n  transition-delay: 0.3s;\n}\n.circular-loader[data-v-dbcbb0f9] {\n  animation:\n    rotate-dbcbb0f9 0.7s linear infinite,fade-in-dbcbb0f9 0.4s;\n\n  transform-origin: center center;\n  transform: scale(5);\n\n  background: transparent;\n}\n.loader-path[data-v-dbcbb0f9] {\n  stroke-dasharray: 50, 200;\n  stroke-dashoffset: -100;\n  stroke-linecap: round;\n}\n.loader-path-off[data-v-dbcbb0f9] {\n  stroke-dasharray: 50, 200;\n  stroke-dashoffset: -100;\n  transition: opacity 0.3s;\n  opacity: 0;\n}\n@keyframes fade-in-dbcbb0f9 {\n0% {\n    opacity: 0;\n}\n70% {\n    opacity: 0;\n}\n100% {\n    opacity: 1;\n}\n}\n@keyframes rotate-dbcbb0f9 {\nfrom {\n    transform: scale(5) rotate(0deg);\n}\nto {\n    transform: scale(5) rotate(360deg);\n}\n}\n\n.flow-button[data-v-823fe197] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 1;\n  position: relative;\n  appearance: none;\n  -webkit-appearance: none;\n  height: 40px;\n  padding: 0px 24px;\n  border-radius: var(--theme-radius, var(--default-theme-radius));\n  color: var(--theme-button-1-color, var(--default-theme-button-1-color));\n  font-size: var(--theme-small, var(--default-theme-small));\n  font-weight: 500;\n  cursor: pointer;\n  background: var(--theme-button-1, var(--default-theme-button-1));\n  border: none;\n  width: 100%;\n  box-shadow: rgba(0, 0, 0, 0.09) 0px 1px 4px;\n}\n.flow-button[data-v-823fe197]:hover,\n.flow-button[data-v-823fe197]:focus-visible {\n  background: var(--theme-button-1-hover, var(--default-theme-button-1-hover));\n}\n.flow-button[data-v-823fe197]:active {\n  box-shadow: none;\n  background: var(--theme-button-1, var(--default-theme-button-1));\n}\n.flow-button[disabled][data-v-823fe197] {\n  background: var(--theme-background-2, var(--default-theme-background-2));\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  cursor: unset;\n  box-shadow: none;\n}\n.flow-button.flow-button-icon-only[data-v-823fe197] {\n  width: 24px;\n  height: 24px;\n  padding: 0;\n}\n\n/* ----------------------------------------------------- */\n.flow-button-outlined[data-v-823fe197] {\n  background: var(--theme-background-1, var(--default-theme-background-1));\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  padding: 11px 23px;\n  border: 1px solid var(--theme-border-color, var(--default-theme-border-color));\n  box-shadow: rgba(0, 0, 0, 0.09) 0px 1px 4px;\n}\n.flow-button-outlined[data-v-823fe197]:hover,\n.flow-button-outlined[data-v-823fe197]:focus-visible {\n  background: var(--theme-background-2, var(--default-theme-background-2));\n}\n.flow-button-outlined[data-v-823fe197]:active {\n  background: var(--theme-background-2, var(--default-theme-background-2));\n}\n.flow-button-outlined[disabled][data-v-823fe197] {\n  background: var(--theme-background-2, var(--default-theme-background-2));\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  cursor: unset;\n  box-shadow: none;\n}\n\n/* ----------------------------------------------------- */\n.flow-button-clear[data-v-823fe197] {\n  background: transparent;\n  box-shadow: none;\n  color: var(--theme-color-3, var(--default-theme-color-3));\n}\n.flow-button-clear[data-v-823fe197]:active {\n  background: transparent;\n}\n.flow-button-clear[data-v-823fe197]:hover,\n.flow-button-clear[data-v-823fe197]:focus-visible {\n  background: var(--theme-background-2, var(--default-theme-background-2));\n  box-shadow: none;\n}\n.flow-button-clear[disabled][data-v-823fe197] {\n  background: var(--theme-background-2, var(--default-theme-background-2));\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  cursor: unset;\n  box-shadow: none;\n}\n\n/* ----------------------------------------------------- */\n.flow-button-text[data-v-823fe197] {\n  background: transparent;\n  box-shadow: none;\n  color: var(--theme-color-3, var(--default-theme-color-3));\n}\n.flow-button-text[data-v-823fe197]:active {\n  background: transparent;\n}\n.flow-button-text[data-v-823fe197]:hover,\n.flow-button-text[data-v-823fe197]:focus-visible {\n  color: var(--theme-color-2, var(--default-theme-color-2));\n  background: transparent;\n  box-shadow: none;\n}\n.flow-button-text[disabled][data-v-823fe197] {\n  background: transparent;\n  color: var(--theme-color-ghost, var(--default-theme-color-ghost));\n  cursor: unset;\n  box-shadow: none;\n}\n\n/* ----------------------------------------------------- */\n.flow-button--delete[data-v-823fe197] {\n  background: var(--theme-error-color, var(--default-theme-color-red));\n  color: white;\n}\n.flow-button--delete[data-v-823fe197]:active {\n  background: var(--theme-error-color, var(--default-theme-color-red));\n}\n.flow-button--delete[data-v-823fe197]:hover {\n  background: var(--theme-error-color, var(--default-theme-color-red));\n  opacity: 0.86;\n}\n\n/* ----------------------------------------------------- */\n.flow-button-loader[data-v-823fe197] {\n  position: absolute;\n  right: 8px;\n}\n.flow-button-decorator[data-v-823fe197] {\n  margin-right: 9px;\n  color: currentColor;\n  display: flex;\n  align-items: center;\n  height: 14px;\n  width: 14px;\n}\n.flow-button-icon-only .flow-button-decorator[data-v-823fe197] {\n  margin-right: 0;\n}\n\n.markdown[data-v-03f63b08] {\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  word-wrap: break-word;\n}\n.markdown[data-v-03f63b08] * {\n  margin: 12px 0;\n}\n.markdown[data-v-03f63b08] h1,\n.markdown[data-v-03f63b08] h2,\n.markdown[data-v-03f63b08] h3,\n.markdown[data-v-03f63b08] h4,\n.markdown[data-v-03f63b08] h5,\n.markdown[data-v-03f63b08] h6 {\n  font-size: var(--font-size, var(--default-font-size));\n  margin: 24px 0 6px;\n  font-weight: var(--theme-bold, var(--default-theme-bold));\n}\n.markdown[data-v-03f63b08] p {\n  font-size: var(\n    --font-size,\n    var(--default-font-size),\n    var(--theme-paragraph, var(--default-theme-paragraph))\n  );\n  /* prettier-ignore */\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  font-weight: var(\n    --font-weight,\n    var(--default-font-weight),\n    var(--theme-small, var(--default-theme-small))\n  );\n  line-height: 1.5;\n  margin-bottom: 0;\n}\n.markdown[data-v-03f63b08] ul,\n.markdown[data-v-03f63b08] ol {\n  padding-left: 24px;\n  line-height: 1.5;\n  margin: 12px 0;\n  display: block;\n}\n.markdown[data-v-03f63b08] ul {\n  list-style-type: disc;\n}\n.markdown[data-v-03f63b08] ol {\n  list-style-type: decimal;\n}\n.markdown[data-v-03f63b08] ul.contains-task-list {\n  list-style: none;\n  padding-left: 0;\n}\n.markdown[data-v-03f63b08] li {\n  margin: 6px 0;\n}\n.markdown[data-v-03f63b08] a {\n  color: var(\n    --theme-color-accent,\n    var(--default-theme-color-accent)\n  ) !important;\n  text-decoration: none !important;\n}\n.markdown[data-v-03f63b08] a:hover {\n  text-decoration: underline !important;\n}\n.markdown[data-v-03f63b08] code {\n  font-family: var(--theme-font-code, var(--default-theme-font-code));\n  background-color: var(\n    --theme-background-2,\n    var(--default-theme-background-2)\n  );\n  box-shadow: 0 0 0 1px\n    var(--theme-border-color, var(--default-theme-border-color));\n  font-size: var(--theme-micro, var(--default-theme-micro));\n  border-radius: 2px;\n  padding: 0 3px;\n}\n.markdown[data-v-03f63b08] pre code {\n  display: block;\n  white-space: pre;\n  padding: 12px;\n  line-height: 1.5;\n  margin: 12px 0;\n  -webkit-overflow-scrolling: touch;\n  overflow-x: auto;\n  max-width: 100%;\n  min-width: 100px;\n}\n.markdown[data-v-03f63b08] blockquote {\n  border-left: 3px solid\n    var(--theme-border-color, var(--default-theme-border-color));\n  padding-left: 12px;\n  margin: 0;\n}\n.markdown[data-v-03f63b08] table {\n  position: relative;\n  border-collapse: collapse;\n  table-layout: fixed;\n  width: 100%;\n  margin: 1em 0;\n  overflow: hidden;\n  box-shadow: 0 0 0 1px\n    var(--theme-border-color, var(--default-theme-border-color));\n  border-radius: var(--theme-radius-lg, var(--default-theme-radius-lg));\n}\n.markdown[data-v-03f63b08] td,\n.markdown[data-v-03f63b08] th {\n  min-width: 1em;\n  padding: 6px;\n  vertical-align: top;\n  box-sizing: border-box;\n  position: relative;\n  word-break: break-all;\n  border-right: 1px solid\n    var(--theme-border-color, var(--default-theme-border-color));\n  border-bottom: 1px solid\n    var(--theme-border-color, var(--default-theme-border-color));\n}\n.markdown[data-v-03f63b08] td > *,\n.markdown[data-v-03f63b08] th > * {\n  margin-bottom: 0;\n}\n.markdown.parameter-description[data-v-03f63b08] p {\n  margin-top: 4px;\n  font-size: var(--theme-small, var(--default-theme-small));\n  color: var(--theme-color-2, var(--default-theme-color-2));\n  line-height: 1.4;\n}\n.markdown[data-v-03f63b08] td:first-of-type,\n.markdown[data-v-03f63b08] th:first-of-type {\n  border-left: none;\n}\n.markdown[data-v-03f63b08] td:last-of-type,\n.markdown[data-v-03f63b08] th:last-of-type {\n  border-right: none;\n}\n.markdown[data-v-03f63b08] tr:last-of-type td {\n  border-bottom: none;\n}\n.markdown[data-v-03f63b08] th {\n  font-weight: bold !important;\n  text-align: left;\n  border-left-color: transparent;\n  background: var(--theme-background-2, var(--default-theme-background-2));\n}\n\n.markdown {\npre code.hljs {\n    display: block;\n    overflow-x: auto;\n    padding: 1em;\n}\ncode.hljs {\n    padding: 3px 5px;\n}\n.hljs {\n    background: var(--theme-background-4, var(--default-theme-background-4));\n    color: var(--theme-color-1, var(--default-theme-color-1));\n}\n.hljs-comment,\n  .hljs-quote {\n    color: var(--theme-color-3, var(--default-theme-color-3));\n    font-style: italic;\n}\n.hljs-addition,\n  .hljs-keyword,\n  .hljs-literal,\n  .hljs-selector-tag,\n  .hljs-type {\n    color: var(--theme-color-green, var(--default-theme-color-green));\n}\n.hljs-number,\n  .hljs-selector-attr,\n  .hljs-selector-pseudo {\n    color: var(--theme-color-orange, var(--default-theme-color-orange));\n}\n.hljs-doctag,\n  .hljs-regexp,\n  .hljs-string {\n    color: var(--theme-color-blue, var(--default-theme-color-blue));\n}\n.hljs-built_in,\n  .hljs-name,\n  .hljs-section,\n  .hljs-title {\n    color: var(--theme-color-1, var(--default-theme-color-1));\n}\n.hljs-class .hljs-title,\n  .hljs-selector-id,\n  .hljs-template-variable,\n  .hljs-title.class_,\n  .hljs-variable {\n    color: var(--theme-color-1, var(--default-theme-color-1));\n}\n.hljs-name,\n  .hljs-section,\n  .hljs-strong {\n    font-weight: var(--theme-semibold, var(--default-theme-semibold));\n}\n.hljs-bullet,\n  .hljs-link,\n  .hljs-meta,\n  .hljs-subst,\n  .hljs-symbol {\n    color: var(--theme-color-blue, var(--default-theme-color-blue));\n}\n.hljs-deletion {\n    color: var(--theme-color-red, var(--default-theme-color-red));\n}\n.hljs-formula {\n    background: var(--theme-color-1, var(--default-theme-color-1));\n}\n.hljs-attr,\n  .hljs-attribute {\n    color: var(--theme-color-1, var(--default-theme-color-1));\n}\n.hljs-emphasis {\n    font-style: italic;\n}\n}\n\n.human[data-v-fb8f84d0] {\n  width: 36px;\n  position: absolute;\n  right: 0;\n  top: 50%;\n  transform: translate3d(0, -50%, 0);\n  height: 66px;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  opacity: 0.7;\n}\n.dark-mode .human[data-v-fb8f84d0] {\n  opacity: 0.7;\n}\n.human i[data-v-fb8f84d0] {\n  width: 100%;\n  height: 1px;\n  background: var(--theme-color-3, var(--default-theme-color-3));\n  display: block;\n  position: relative;\n  transform: translate3d(100%, 0, 0);\n  animation: example-fb8f84d0 0.35s forwards;\n}\n@keyframes example-fb8f84d0 {\nfrom {\n    transform: translate3d(100%, 0, 0);\n}\nto {\n    transform: translate3d(0, 0, 0);\n}\n}\n.make-it-pop[data-v-fb8f84d0] {\n  overflow: hidden;\n  position: relative;\n  padding: 24px 60px 12px 24px;\n  min-height: 80px;\n  color: var(--theme-color-1, var(--default-theme-color-1));\n}\n.make-it-pop[data-v-fb8f84d0] h1 {\n  font-size: var(--theme-heading-2, var(--default-theme-heading-2));\n  margin-top: 0;\n  line-height: 1.45;\n  margin-bottom: 0;\n  font-weight: var(--theme-bold, var(--default-theme-bold));\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  width: 100%;\n}\n.make-it-pop p[data-v-fb8f84d0] {\n  margin-top: 3px;\n  font-weight: var(--theme-semibold, var(--default-theme-semibold));\n  font-size: var(--theme-mini, var(--default-theme-mini));\n  color: var(--theme-color-2, var(--default-theme-color-2));\n  line-height: 1.4;\n  width: 100%;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(1) {\n  left: 30px;\n  animation-delay: 0.1s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(2) {\n  left: 24px;\n  animation-delay: 0.15s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(3) {\n  left: 20px;\n  animation-delay: 0.2s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(4) {\n  left: 17px;\n  animation-delay: 0.25s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(5) {\n  left: 15px;\n  animation-delay: 0.3s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(6) {\n  left: 14.5px;\n  animation-delay: 0.35s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(7) {\n  left: 14px;\n  animation-delay: 0.4s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(8) {\n  left: 14px;\n  animation-delay: 0.45s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(9) {\n  left: 15px;\n  animation-delay: 0.5s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(10) {\n  left: 13px;\n  animation-delay: 0.55s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(11) {\n  left: 11px;\n  animation-delay: 0.6s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(12) {\n  left: 9px;\n  animation-delay: 0.65s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(13) {\n  left: 8px;\n  animation-delay: 0.7s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(14) {\n  left: 12px;\n  animation-delay: 0.75s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(15) {\n  left: 10px;\n  animation-delay: 0.8s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(16) {\n  left: 13px;\n  animation-delay: 0.85s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(17) {\n  left: 14px;\n  animation-delay: 0.9s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(18) {\n  left: 17px;\n  animation-delay: 0.95s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(19) {\n  left: 18px;\n  animation-delay: 1s;\n}\n.human i[data-v-fb8f84d0]:nth-of-type(20) {\n  left: 30px;\n  animation-delay: 1.05s;\n}\n\n.swagger-ai-writer[data-v-33c0baeb] {\n  padding: 24px;\n}\n.swagger-ai-writer[data-v-33c0baeb] .aiwriter span i {\n  display: none;\n}\n.swagger-ai-writer[data-v-33c0baeb] .page-node > .guide-node-component:first-of-type h1 {\n  margin-top: 0;\n}\n.aiwriter[data-v-33c0baeb] {\n  text-align: left;\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  border-radius: var(--theme-radius, var(--default-theme-radius));\n  border: 1px solid var(--theme-border-color, var(--default-theme-border-color));\n}\n.aiwriter input[data-v-33c0baeb]::placeholder {\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  font-family: var(--theme-font, var(--default-theme-font));\n}\n.aiwriter input[data-v-33c0baeb]:-ms-input-placeholder {\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  font-family: var(--theme-font, var(--default-theme-font));\n}\n.aiwriter input[data-v-33c0baeb]::-webkit-input-placeholder {\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  font-family: var(--theme-font, var(--default-theme-font));\n}\n.aiwriter-input[data-v-33c0baeb] {\n  appearance: none;\n  outline: none;\n  background: transparent;\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  font-size: var(--theme-font-size-3, var(--default-theme-font-size-3));\n  padding: 9px;\n  border: none;\n  border-bottom: 1px solid\n    var(--theme-border-color, var(--default-theme-border-color));\n}\n.aiwriter-input[data-v-33c0baeb]:last-of-type {\n  border-bottom: none;\n}\n.aiwriter-input + .aiwriter-input[data-v-33c0baeb] {\n  border-top: none;\n}\n.aiwriter-input[data-v-33c0baeb]::placeholder {\n  color: var(--theme-color-3, var(--deafult-theme-color-3));\n}\n.aiwriter-input[data-v-33c0baeb]:first-of-type:placeholder-shown {\n  opacity: 0;\n}\n.aiwriter-input[data-v-33c0baeb]:first-of-type:focus {\n  opacity: 1;\n}\n.aiwriter-input:focus-within ~ div[data-v-33c0baeb],\n.aiwriter-input:not(:placeholder-shown) ~ div[data-v-33c0baeb] {\n  display: none;\n}\n.aiwriter-input[data-v-33c0baeb]:focus {\n  box-shadow: 0 0 0 1px var(--theme-color-1, var(--default-theme-color-1));\n}\n.aiwriter-input[data-v-33c0baeb]:first-of-type {\n  border-radius: var(--theme-radius, var(--default-theme-radius))\n    var(--theme-radius, var(--default-theme-radius)) 0 0;\n}\n.aiwriter-input[data-v-33c0baeb]:last-of-type {\n  border-radius: 0 0 var(--theme-radius, var(--default-theme-radius))\n    var(--theme-radius, var(--default-theme-radius));\n}\n.aiwriter-input[data-v-33c0baeb]:first-of-type:last-of-type {\n  border-radius: var(--theme-radius, var(--default-theme-radius));\n}\n.swagger-ai-writer-inputs[data-v-33c0baeb] {\n  border: 1px solid var(--theme-border-color, var(--default-theme-border-color));\n  border-radius: var(--theme-radius-lg, var(--default-theme-radius-lg));\n}\n.swagger-ai-writer-inputs-container[data-v-33c0baeb] .flow-label {\n  background: var(--theme-background-2, var(--default-theme-background-2));\n  box-shadow: 0 0 2px 2px\n    var(--theme-background-2, var(--default-theme-background-2));\n}\n.swagger-ai-writer-inputs-container[data-v-33c0baeb] {\n  padding: 0 24px 24px 24px;\n  display: flex;\n  flex-direction: column;\n  gap: 12px;\n}\n.animated-input[data-v-33c0baeb] {\n  position: absolute;\n  white-space: nowrap;\n  background: var(\n    --theme-background-2,\n    var(--default-theme-background-2)\n  ) !important;\n  pointer-events: none;\n}\n.animated-input span[data-v-33c0baeb] {\n  font-size: var(--theme-font-size-3, var(--default-theme-font-size-3));\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  position: absolute;\n  pointer-events: none;\n  left: 9px;\n  top: 9px;\n  opacity: 0;\n}\n.animated-input span[data-v-33c0baeb]:nth-of-type(1) {\n  opacity: 1;\n  animation: flipin1-33c0baeb 10s ease-in-out infinite;\n}\n@keyframes flipin1-33c0baeb {\n27%,\n  100% {\n    opacity: 0;\n    transform: translate3d(0, 3px, 0);\n}\n0%,\n  25% {\n    opacity: 1;\n    transform: translate3d(0, 0, 0);\n}\n27% {\n    opacity: 0;\n    transform: translate3d(0, -3px, 0);\n}\n}\n.animated-input span[data-v-33c0baeb]:nth-of-type(2) {\n  opacity: 0;\n  animation: flipin2-33c0baeb 10s ease-in-out infinite;\n}\n@keyframes flipin2-33c0baeb {\n0%,\n  25%,\n  100% {\n    opacity: 0;\n    transform: translate3d(0, 3px, 0);\n}\n27%,\n  50% {\n    opacity: 1;\n    transform: translate3d(0, 0, 0);\n}\n52% {\n    opacity: 0;\n    transform: translate3d(0, -3px, 0);\n}\n}\n.animated-input span[data-v-33c0baeb]:nth-of-type(3) {\n  opacity: 0;\n  animation: flipin3-33c0baeb 10s ease-in-out infinite;\n}\n@keyframes flipin3-33c0baeb {\n0%,\n  50%,\n  100% {\n    opacity: 0;\n    transform: translate3d(0, 3px, 0);\n}\n52%,\n  75% {\n    opacity: 1;\n    transform: translate3d(0, 0, 0);\n}\n77% {\n    opacity: 0;\n    transform: translate3d(0, -3px, 0);\n}\n}\n.animated-input span[data-v-33c0baeb]:nth-of-type(4) {\n  opacity: 0;\n  animation: flipin4-33c0baeb 10s ease-in-out infinite;\n}\n@keyframes flipin4-33c0baeb {\n0%,\n  75% {\n    opacity: 0;\n    transform: translate3d(0, 3px, 0);\n}\n77%,\n  98% {\n    opacity: 1;\n    transform: translate3d(0, 0, 0);\n}\n100% {\n    opacity: 0;\n    transform: translate3d(0, -3px, 0);\n}\n}\n\n.start[data-v-77ae3690] {\n  padding: 24px 12px 24px 24px;\n  display: flex;\n  flex-flow: wrap;\n  justify-content: space-between;\n}\n.swagger-editor .start[data-v-77ae3690] {\n  padding-top: 24px;\n}\n.start-h1[data-v-77ae3690] {\n  font-size: var(--theme-heading-2, var(--default-theme-heading-2));\n  margin-top: 0;\n  line-height: 1.45;\n  margin-bottom: 0;\n  font-weight: var(--theme-bold, var(--default-theme-bold));\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  width: 100%;\n  position: relative;\n}\n.start-h3[data-v-77ae3690] {\n  font-size: var(--theme-paragraph, var(--default-theme-paragraph));\n  margin-top: 0;\n  margin-bottom: 6px;\n  display: block;\n  line-height: 1.45;\n  font-weight: var(--theme-bold, var(--default-theme-bold));\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  width: 100%;\n}\n.start-h1[data-v-77ae3690]:not(:first-of-type) {\n  margin-top: 24px;\n}\n.start-p[data-v-77ae3690] {\n  font-size: var(--theme-paragraph, var(--default-theme-paragraph));\n  color: var(--theme-color-2, var(--default-theme-color-2));\n  line-height: 1.5;\n  width: 100%;\n  margin-top: 12px;\n}\n.start-ul[data-v-77ae3690] {\n  margin-top: 12px;\n  font-size: var(--theme-paragraph, var(--default-theme-paragraph));\n  line-height: 1.5;\n  padding-left: 0;\n  list-style: initial;\n  display: flex;\n  flex-flow: wrap;\n  gap: 24px;\n}\n.start-ul li[data-v-77ae3690] {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  width: calc(50% - 24px);\n  color: var(--theme-color-2, var(--default-theme-color-2));\n}\n.start-ul li[data-v-77ae3690]:first-of-type {\n  margin-top: 0;\n}\n.start-section[data-v-77ae3690] {\n  width: 100%;\n  margin-bottom: 12px;\n  border-radius: var(--theme-radius-lg, var(--default-theme-radius-lg));\n  border: 1px solid var(--theme-border-color, var(--default-theme-border-color));\n  display: flex;\n  flex-flow: wrap;\n  background: var(--theme-background-2, var(--default-theme-background-2));\n}\n.start-section[data-v-77ae3690]:last-of-type {\n  margin-bottom: 48px;\n}\n.start-h2[data-v-77ae3690] {\n  padding: 9px;\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  font-size: var(--theme-mini, var(--default-theme-mini));\n  font-weight: var(--theme-semibold, var(--default-theme-semibold));\n  width: 100%;\n  border-bottom: 1px solid\n    var(--theme-border-color, var(--default-theme-border-color));\n}\n.start-h2 + .start-item[data-v-77ae3690] {\n  border-radius: 0 0 0 var(--theme-radius-lg, var(--default-theme-radius-lg));\n}\n.start-item[data-v-77ae3690]:nth-of-type(5) {\n  border-radius: 0 0 var(--theme-radius-lg, var(--default-theme-radius-lg)) 0;\n}\n.start-item[data-v-77ae3690] {\n  padding: 9px;\n  display: flex;\n  align-items: center;\n  user-select: none;\n  cursor: pointer;\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  font-weight: var(--theme-semibold, var(--default-theme-semibold));\n  font-size: var(--theme-mini, var(--default-theme-mini));\n  flex: 1;\n  text-transform: capitalize;\n}\n.start-section-colors .start-item[data-v-77ae3690] {\n  width: 20%;\n}\n.start-item[data-v-77ae3690]:not(:last-of-type) {\n  border-right: 1px solid\n    var(--theme-border-color, var(--default-theme-border-color));\n}\n.start-item[data-v-77ae3690]:empty {\n  pointer-events: none;\n}\n.start-item svg[data-v-77ae3690] {\n  width: 14px;\n  height: 14px;\n  margin-right: 6px;\n}\n.start-item[data-v-77ae3690]:hover {\n  background: var(--theme-background-2, var(--default-theme-background-2));\n}\n.start-item-active[data-v-77ae3690] {\n  box-shadow: 0 0 0 1px var(--theme-color-1, var(--default-theme-color-1));\n  z-index: 10;\n  position: relative;\n  color: var(--theme-color-1, var(--default-theme-color-1));\n}\n.start-item-color[data-v-77ae3690] {\n  border: 1px solid var(--theme-border-color, var(--default-theme-border-color));\n  margin-right: 6px;\n  border-radius: 50%;\n  height: 13px;\n  width: 13px;\n  display: block;\n}\n.start-item-color-moon[data-v-77ae3690] {\n  background: #cdc9b3;\n}\n.dark-mode .start-item-color-moon[data-v-77ae3690] {\n  background: #646664;\n}\n.start-item-color-solarized[data-v-77ae3690] {\n  background: #fdf6e3;\n}\n.dark-mode .start-item-color-solarized[data-v-77ae3690] {\n  background: #004156;\n}\n.start-item-color-purple[data-v-77ae3690] {\n  background: #f5f6fd;\n}\n.dark-mode .start-item-color-purple[data-v-77ae3690] {\n  background: #4d547f;\n}\n.start-item-color-alternate[data-v-77ae3690] {\n  background: #f6f6f6;\n}\n.dark-mode .start-item-color-alternate[data-v-77ae3690] {\n  background: #4a4a4a;\n}\n.start-item-color-default[data-v-77ae3690] {\n  background: #fff;\n}\n.dark-mode .start-item-color-default[data-v-77ae3690] {\n  background: #343434;\n}\n.start-section-color .start-item[data-v-77ae3690] {\n  text-transform: capitalize;\n}\n.start-cta[data-v-77ae3690] {\n  width: 100%;\n  margin-top: 24px;\n  margin-bottom: 0;\n}\n.start-a[data-v-77ae3690] {\n  color: var(\n    --theme-color-accent,\n    var(--default-theme-color-accent)\n  ) !important;\n}\n.start-a[data-v-77ae3690]:hover {\n  text-decoration: underline;\n}\n.start-section[data-v-77ae3690]:nth-of-type(2) {\n  border-left: 1px solid\n    var(--theme-border-color, var(--default-theme-border-color));\n  border-right: 1px solid\n    var(--theme-border-color, var(--default-theme-border-color));\n}\n.start-row[data-v-77ae3690] {\n  width: 100%;\n  margin-top: 12px;\n  overflow: hidden;\n}\n.start-hero-copy[data-v-77ae3690] {\n  background: var(--theme-background-2, var(--default-theme-background-2));\n  padding: 12px;\n  border-radius: var(--theme-radius-lg, var(--default-theme-radius-lg));\n}\n.start-p-small[data-v-77ae3690] {\n  font-weight: var(--theme-semibold, var(--default-theme-semibold));\n  font-size: var(--theme-mini, var(--default-theme-mini));\n  color: var(--theme-color-2, var(--default-theme-color-2));\n  margin-bottom: 12px;\n  line-height: 1.4;\n}\n.start-cta[data-v-77ae3690] {\n  margin-bottom: 12px;\n  width: fit-content;\n  white-space: nowrap;\n}\n.start-copy[data-v-77ae3690] {\n  padding: 76px 48px 48px 48px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n  text-align: center;\n}\n.start-logo[data-v-77ae3690] {\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  margin-bottom: 24px;\n  width: 72px;\n  aspect-ratio: 1;\n  position: relative;\n  box-shadow: var(--theme-shadow-2, var(--default-theme-shadow-2));\n  border-radius: 50%;\n}\n.start-logo[data-v-77ae3690]:before {\n  content: '';\n  width: 300%;\n  aspect-ratio: 1;\n  left: -100%;\n  top: -100%;\n  position: absolute;\n  border-radius: 50%;\n  background-size: 24px 24px;\n  box-shadow:\n    inset 0 0 50px var(--theme-background-1, var(--default-theme-background-1)),\n    inset 0 0 50px var(--theme-background-1, var(--default-theme-background-1));\n  background-image: linear-gradient(\n      to right,\n      var(--theme-border-color, var(--default-theme-border-color)) 1px,\n      transparent 1px\n    ),\n    linear-gradient(\n      to bottom,\n      var(--theme-border-color, var(--default-theme-border-color)) 1px,\n      transparent 1px\n    );\n}\n.start-logo svg[data-v-77ae3690] {\n  width: 100%;\n  height: auto;\n  background: var(--theme-background-1, var(--default-theme-background-1));\n  padding: 3px;\n  border-radius: 50%;\n  position: relative;\n}\n@media screen and (max-width: 600px) {\n.start-section-colors .start-item[data-v-77ae3690],\n  .start-item[data-v-77ae3690] {\n    width: 100%;\n    border-radius: 0 !important;\n    border-right: none !important;\n    border-top: 1px solid\n      var(--theme-border-color, var(--default-theme-border-color));\n}\n.start-item[data-v-77ae3690]:empty {\n    display: none;\n}\n.start-h2[data-v-77ae3690] {\n    border-bottom: none;\n}\n.start li[data-v-77ae3690] {\n    width: 100%;\n}\n.start-copy[data-v-77ae3690] {\n    padding: 48px 0 24px 0;\n}\n}\n\n.modal-layout[data-v-046a46e5] {\n  position: fixed;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  z-index: 1001;\n  background: rgba(0, 0, 0, 0.44);\n  padding: 20px;\n  opacity: 0;\n  animation: modal-fade-046a46e5 0.2s forwards;\n}\n.modal-body[data-v-046a46e5] {\n  padding: 24px 12px 18px 24px;\n  max-height: calc(100vh - 240px);\n  background: var(--theme-background-1, var(--default-theme-background-1));\n  border-radius: var(--theme-radius-lg, var(--default-theme-radius-lg));\n  font-family: var(--theme-font, var(--default-theme-font));\n  position: relative;\n}\n.modal[data-v-046a46e5] {\n  margin: 80px auto 0;\n  position: relative;\n  background: var(--theme-background-2, var(--default-theme-background-2));\n  border-radius: var(--theme-radius-lg, var(--default-theme-radius-lg));\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  width: 100%;\n  text-align: left;\n  line-height: 1.4;\n  opacity: 0;\n  transform: scale(0.98);\n  animation: modal-pop-046a46e5 0.15s 0.15s forwards;\n  display: flex;\n  flex-direction: column;\n}\n.modal[data-v-046a46e5]:before {\n  content: '';\n  display: block;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  z-index: 0;\n  border-radius: var(--theme-radius-lg, var(--default-theme-radius-lg));\n}\n.dark-mode .modal[data-v-046a46e5]:before {\n  background: #1a1a1a;\n}\n.light-mode .modal[data-v-046a46e5]:before {\n  background: #fff;\n}\n.modal-content-history[data-v-046a46e5] {\n  background: var(--theme-background-1, var(--default-theme-background-1));\n}\n.modal-content-history[data-v-046a46e5],\n.modal-content-large[data-v-046a46e5] {\n  max-width: 800px;\n}\n.modal-content-normal[data-v-046a46e5] {\n  max-width: 640px;\n}\n.modal-content-small[data-v-046a46e5] {\n  max-width: 480px;\n}\n@keyframes modal-fade-046a46e5 {\nfrom {\n    opacity: 0;\n}\nto {\n    opacity: 1;\n}\n}\n@keyframes modal-pop-046a46e5 {\n0% {\n    opacity: 0;\n}\n100% {\n    opacity: 1;\n    transform: scale(1);\n}\n}\n.modal-header[data-v-046a46e5] {\n  padding: 12px 24px;\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  font-size: var(--theme-font-size-4, var(--default-theme-font-size-4));\n  text-align: left;\n  font-weight: 600;\n  margin: 0;\n  border-radius: var(--theme-radius-lg, var(--default-theme-radius-lg))\n    var(--theme-radius-lg, var(--default-theme-radius-lg)) 0 0;\n}\n.modal-content-history .modal-header[data-v-046a46e5] {\n  padding-bottom: 0;\n  padding-top: 24px;\n}\n.modal-content-history .modal-body[data-v-046a46e5] {\n  padding-top: 12px;\n}\n.modal-content-search[data-v-046a46e5] {\n  max-width: 540px;\n}\n.modal-content-search .modal-body[data-v-046a46e5] {\n  padding: 0;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  max-height: 440px;\n}\n\n.flow-input-cont[data-v-a3bd12f9] {\n  position: relative;\n}\n.flow-input-wrapper[data-v-a3bd12f9] {\n  border-radius: var(--theme-radius, var(--default-theme-radius));\n  border: 1px solid var(--theme-border-color, var(--default-theme-border-color));\n  position: relative;\n  display: flex;\n  align-items: center;\n}\n.flow-input-wrapper--focus[data-v-a3bd12f9] {\n  border-color: var(--theme-color-3, var(--default-theme-color-3));\n}\n.flow-input-wrapper--focus[data-v-a3bd12f9]:has(button:active) {\n  border: 1px solid var(--theme-border-color, var(--default-theme-border-color)) !important;\n}\n.flow-input__multiline[data-v-a3bd12f9] {\n  min-height: 77px;\n}\n.flow-label[data-v-a3bd12f9] {\n  position: absolute;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n  padding: 0px 3px;\n  margin: 12px 9px;\n  width: fit-content;\n  background: transparent;\n  font-size: var(--theme-font-size-3, var(--default-theme-font-size-3));\n  background-color: var(\n    --theme-background-1,\n    var(--default-theme-background-1)\n  );\n  border-radius: var(--theme-radius, var(--default-theme-radius));\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  box-shadow: 0 0 2px 2px\n    var(--theme-background-1, var(--default-theme-background-1));\n  transition: transform 0.2s ease-in-out;\n  transform-origin: top left;\n  z-index: 10;\n  line-height: initial;\n}\n.flow-input[data-v-a3bd12f9] {\n  outline: none;\n  appearance: none;\n  -webkit-appearance: none;\n  font-size: var(--theme-font-size-3, var(--default-theme-font-size-3));\n  font-family: var(--theme-font, var(--default-theme-font));\n  border: none;\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  padding: 12px;\n  width: 100%;\n  background: transparent;\n  z-index: 10;\n  transition: opacity 0.15s ease-in-out;\n  resize: none;\n}\n.flow-input[data-v-a3bd12f9]:has(+ .flow-label) {\n  opacity: 0;\n}\n.flow-input[data-v-a3bd12f9]:not(:placeholder-shown),\n.flow-input-wrapper--focus .flow-input[data-v-a3bd12f9] {\n  opacity: 1;\n  transition: opacity 0.2s ease-in-out 0.15s;\n}\n.flow-input-wrapper--focus .flow-label[data-v-a3bd12f9] {\n  color: var(--theme-color-1, var(--default-theme-color-1));\n}\n.flow-input[data-v-a3bd12f9]::selection {\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  background: rgba(255, 165, 88, 0.35);\n}\n.flow-input[data-v-a3bd12f9]:-webkit-autofill,\n.flow-input[data-v-a3bd12f9]:-webkit-autofill:hover,\n.flow-input[data-v-a3bd12f9]:-webkit-autofill:focus,\n.flow-input[data-v-a3bd12f9]:-webkit-autofill:active,\n.flow-input[data-v-a3bd12f9]:focus-within:-webkit-autofill,\n.flow-input[data-v-a3bd12f9]:focus-within:-webkit-autofill:hover,\n.flow-input[data-v-a3bd12f9]:focus-within:-webkit-autofill:focus,\n.flow-input[data-v-a3bd12f9]:focus-within:-webkit-autofill:active {\n  -webkit-box-shadow: 0 0 0px 1000px\n    var(--theme-background-1, var(--default-theme-background-1)) inset !important;\n  -webkit-text-fill-color: var(--theme-color-1, var(--default-theme-color-1));\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  border-radius: var(--theme-radius, var(--default-theme-radius));\n}\n.helper-text[data-v-a3bd12f9] {\n  margin-top: 6px;\n  font-size: var(--theme-mini, var(--default-theme-mini));\n  color: var(--theme-error-color, var(--default-theme-color-red));\n  display: flex;\n  align-items: center;\n}\n.helper-text[data-v-a3bd12f9]:before {\n  content: '!';\n  border-radius: 50%;\n  background: var(--theme-error-color, var(--default-theme-color-red));\n  color: white;\n  font-weight: 900;\n  width: 15px;\n  height: 15px;\n  line-height: 15px;\n  display: block;\n  margin-right: 6px;\n  text-align: center;\n  font-size: var(--theme-micro, var(--default-theme-micro));\n}\n.helper-text[data-v-a3bd12f9]:empty {\n  display: none;\n}\n.flow-input-wrapper--error[data-v-a3bd12f9] {\n  border-color: var(--theme-error-color, var(--default-theme-color-red));\n}\n.flow-input-wrapper--error .flow-label[data-v-a3bd12f9] {\n  color: var(--theme-error-color, var(--default-theme-color-red));\n}\n.flow-input-wrapper--warn[data-v-a3bd12f9] {\n  border-color: var(--theme-error-color, var(--default-theme-color-red));\n}\n.flow-input-wrapper--warn .flow-label[data-v-a3bd12f9] {\n  color: var(--theme-error-color, var(--default-theme-color-red));\n}\n.flow-input-wrapper--focus .flow-label[data-v-a3bd12f9],\n.flow-input:not(:placeholder-shown) + .flow-label[data-v-a3bd12f9] {\n  transform: translate3d(0, -20px, 0) scale(0.8);\n  transform-origin: top left;\n}\n.flow-input-wrapper--focus:has(button:active) .flow-label[data-v-a3bd12f9] {\n  color: var(--theme-color-3, var(--default-theme-color-3)) !important;\n}\n.icon-slot[data-v-a3bd12f9]:not(:empty) {\n  display: flex;\n  align-items: center;\n  padding-right: 12px;\n  width: 28px;\n  cursor: pointer;\n  color: var(--theme-color-ghost, var(--default-theme-color-ghost));\n}\n.icon-slot[data-v-a3bd12f9]:hover {\n  color: var(--theme-color-1, var(--default-theme-color-1));\n}\n\n.swagger-editor-header {\n  padding: 11px 12px 0 12px;\n  display: flex;\n  align-items: center;\n  flex-flow: wrap;\n  position: relative;\n  border-bottom: 1px solid\n    var(--theme-border-color, var(--default-theme-border-color));\n}\n.swagger-editor-header span {\n  font-size: var(--theme-mini, var(--default-theme-mini));\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  font-weight: 600;\n  margin-right: 12px;\n  position: relative;\n  cursor: pointer;\n}\n.swagger-editor-title {\n  font-weight: var(--theme-semibold, var(--default-theme-semibold));\n  border-radius: var(--theme-radius, var(--default-theme-radius))\n    var(--theme-radius, var(--default-theme-radius)) 0 0;\n  color: var(--theme-color-2, var(--default-theme-color-2));\n  font-size: var(--theme-mini, var(--default-theme-mini));\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  position: relative;\n}\n.swagger-editor-title:hover:not(.swagger-editor-active):after {\n  content: '';\n  position: absolute;\n  top: 3px;\n  left: 3px;\n  width: calc(100% - 6px);\n  height: calc(100% - 6px);\n  border-radius: var(--theme-radius, var(--default-theme-radius));\n  background: var(--theme-background-2, var(--default-theme-background-2));\n}\n.swagger-editor-type {\n  padding: 9px 12px;\n  user-select: none;\n  position: relative;\n  z-index: 1;\n}\n.swagger-editor-buttons {\n  display: flex;\n  justify-content: space-between;\n  padding: 0 6px 0 12px;\n  height: 44px;\n  min-height: 44px;\n  align-items: center;\n  border-bottom: 1px solid\n    var(--theme-border-color, var(--default-theme-border-color));\n  background: var(--theme-background-1, var(--default-theme-background-1));\n}\n.swagger-editor-active {\n  /* use layered box shadow so opaque border overlap doesn't show  */\n  box-shadow:\n    0 1px 0 0px var(--theme-background-1, var(--default-theme-background-1)),\n    0px 0 0 1px var(--theme-border-color, var(--default-theme-border-color)),\n    0 0 0 1px var(--theme-background-1, var(--default-theme-background-1));\n  cursor: default;\n  color: var(--theme-color-1, var(--default-theme-color-1));\n}\n.swagger-editor-buttons button {\n  background: transparent;\n  appearance: none;\n  outline: none;\n  border: none;\n  color: var(--theme-color-1, var(--default-theme-color-1));\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  flex-shrink: 1;\n  min-width: 0;\n  padding: 9px;\n  border-radius: var(--theme-radius, var(--default-theme-radius));\n  font-weight: var(--theme-semibold, var(--default-theme-semibold));\n  font-size: var(--theme-font-size-4, var(--default-theme-font-size-4));\n  user-select: none;\n  display: flex;\n  align-items: center;\n}\n.swagger-editor-buttons button svg {\n  width: 14px;\n  height: 14px;\n  margin-right: 6px;\n}\n.swagger-editor-buttons div {\n  display: flex;\n}\n.swagger-editor-buttons button:hover {\n  cursor: pointer;\n  border-color: currentColor;\n  background: var(--theme-background-2, var(--default-theme-background-2));\n}\n.swagger-editor-heading {\n  font-weight: var(--theme-semibold, var(--default-theme-semibold));\n  font-size: var(--theme-mini, var(--default-theme-mini));\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  text-transform: uppercase;\n}\n.single-tab .swagger-editor-buttons,\n.single-tab-items {\n  display: none;\n}\n.single-tab .single-tab-items {\n  display: flex;\n  margin-left: auto;\n}\n.single-tab .swagger-editor-active .swagger-editor-type {\n  box-shadow:\n    0 1px 0 0px var(--theme-background-2, var(--default-theme-background-2)),\n    0px 0 0 1px var(--theme-border-color, var(--default-theme-border-color)),\n    0 0 0 1px var(--theme-background-2, var(--default-theme-background-2));\n  background: var(--theme-background-2, var(--default-theme-background-2));\n  border-radius: var(--theme-radius, var(--default-theme-radius))\n    var(--theme-radius, var(--default-theme-radius)) 0 0;\n}\n.single-tab .swagger-editor-header {\n  padding-right: 6px;\n}\n\n.swagger-editor-input {\n  height: 100%;\n  overflow: hidden;\n  background: var(--theme-background-2, var(--default-theme-background-2));\n}\n.swagger-editor-input .cm-line:first-of-type:last-of-type:has(br):before {\n  content: 'Paste your Swagger file here...';\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  position: absolute;\n  display: block;\n  height: 23px;\n}\n\n.swagger-editor-notification {\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  padding: 6px 12px;\n  font-size: var(--theme-font-size-5, var(--default-theme-font-size-5));\n}\n.swagger-editor-notification--error {\n  background: var(--theme-color-yellow, var(--default-theme-color-yellow));\n  color: var(--theme-background-color-1, var(--default-theme-background-1));\n  font-weight: var(--theme-semibold, var(--default-theme-semibold));\n}\n\n.swagger-editor-status-bar {\n  color: var(--theme-color-3, var(--default-theme-color-3));\n  padding: 6px 8px;\n  font-size: var(--theme-font-size-5, var(--default-theme-font-size-5));\n  background: var(--theme-background-3, var(--default-theme-background-3));\n}\n\n/** CSS Reset */\n.swagger-editor,\n#headlessui-portal-root {\np {\n    margin: 0;\n}\ni {\n    font-style: normal;\n}\nul,\n  ol {\n    margin: 0;\n    padding: 0;\n}\n\n  /** Add some more things which are normally applied to `html`. */\n  font-family: var(--theme-font, var(--default-theme-font));\n  line-height: 1.15;\n  -webkit-text-size-adjust: 100%;\n  -moz-tab-size: 4;\n  tab-size: 4;\n\n  /** Make sure box-sizing is set properly. */\n  box-sizing: border-box;\n*,\n  *:before,\n  *:after {\n    box-sizing: inherit;\n}\n\n  /** Smooth text rendering */\n* {\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n}\n}\n\n.swagger-editor[data-v-8afde6cd] {\n  min-width: 0;\n  min-height: 0;\n\n  display: flex;\n  flex: 1;\n  flex-direction: column;\n  overflow: auto;\n  border-right: 1px solid\n    var(--theme-border-color, var(--default-theme-border-color));\n  font-size: var(--theme-small, var(--default-theme-small));\n  /*  layered box shadow dilenator in case themes don't have borders on their sidebar*/\n  box-shadow:\n    -1px 0 0 0 var(--theme-border-color, var(--default-theme-border-color)),\n    -1px 0 0 0 var(--theme-background-1, var(--default-theme-background-1));\n}\n@media screen and (max-width: 1000px) {\n.swagger-editor[data-v-8afde6cd] {\n    border-right: none;\n    box-shadow: none;\n}\n}"));
      document.head.appendChild(elementStyle);
    }
  } catch (e3) {
    console.error("vite-plugin-css-injected-by-js", e3);
  }
})();
const isElement = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((element?: null | undefined) => false) &
   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)
   * )}
   */
  /**
   * @param {unknown} [element]
   * @param {Test | undefined} [test]
   * @param {number | null | undefined} [index]
   * @param {Parents | null | undefined} [parent]
   * @param {unknown} [context]
   * @returns {boolean}
   */
  // eslint-disable-next-line max-params
  function(element2, test, index2, parent, context) {
    const check = convertElement(test);
    if (index2 !== null && index2 !== void 0 && (typeof index2 !== "number" || index2 < 0 || index2 === Number.POSITIVE_INFINITY)) {
      throw new Error("Expected positive finite `index`");
    }
    if (parent !== null && parent !== void 0 && (!parent.type || !parent.children)) {
      throw new Error("Expected valid `parent`");
    }
    if ((index2 === null || index2 === void 0) !== (parent === null || parent === void 0)) {
      throw new Error("Expected both `index` and `parent`");
    }
    return looksLikeAnElement(element2) ? check.call(context, element2, index2, parent) : false;
  }
);
const convertElement = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return element$3;
    }
    if (typeof test === "string") {
      return tagNameFactory(test);
    }
    if (typeof test === "object") {
      return anyFactory$1(test);
    }
    if (typeof test === "function") {
      return castFactory$1(test);
    }
    throw new Error("Expected function, string, or array as `test`");
  }
);
function anyFactory$1(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convertElement(tests[index2]);
  }
  return castFactory$1(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function tagNameFactory(check) {
  return castFactory$1(tagName);
  function tagName(element2) {
    return element2.tagName === check;
  }
}
function castFactory$1(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeAnElement(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function element$3(element2) {
  return Boolean(
    element2 && typeof element2 === "object" && "type" in element2 && element2.type === "element" && "tagName" in element2 && typeof element2.tagName === "string"
  );
}
function looksLikeAnElement(value) {
  return value !== null && typeof value === "object" && "type" in value && "tagName" in value;
}
function stringify$1(values) {
  return values.join(" ").trim();
}
const convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok$1;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all2);
  function all2(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key2;
    for (key2 in check) {
      if (nodeAsRecord[key2] !== checkAsRecord[key2])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok$1() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
const embedded = convertElement(
  /**
   * @param element
   * @returns {element is {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}}
   */
  function(element2) {
    return element2.tagName === "audio" || element2.tagName === "canvas" || element2.tagName === "embed" || element2.tagName === "iframe" || element2.tagName === "img" || element2.tagName === "math" || element2.tagName === "object" || element2.tagName === "picture" || element2.tagName === "svg" || element2.tagName === "video";
  }
);
convertElement([
  "a",
  "abbr",
  // `area` is in fact only phrasing if it is inside a `map` element.
  // However, since `area`s are required to be inside a `map` element, and it’s
  // a rather involved check, it’s ignored here for now.
  "area",
  "b",
  "bdi",
  "bdo",
  "br",
  "button",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "i",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "map",
  "mark",
  "meter",
  "noscript",
  "output",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "template",
  "textarea",
  "time",
  "u",
  "var",
  "wbr"
]);
convertElement("meta");
const re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
}
function empty(value) {
  return value.replace(re, "") === "";
}
const blocks = [
  "address",
  // Flow content.
  "article",
  // Sections and headings.
  "aside",
  // Sections and headings.
  "blockquote",
  // Flow content.
  "body",
  // Page.
  "br",
  // Contribute whitespace intrinsically.
  "caption",
  // Similar to block.
  "center",
  // Flow content, legacy.
  "col",
  // Similar to block.
  "colgroup",
  // Similar to block.
  "dd",
  // Lists.
  "dialog",
  // Flow content.
  "dir",
  // Lists, legacy.
  "div",
  // Flow content.
  "dl",
  // Lists.
  "dt",
  // Lists.
  "figcaption",
  // Flow content.
  "figure",
  // Flow content.
  "footer",
  // Flow content.
  "form",
  // Flow content.
  "h1",
  // Sections and headings.
  "h2",
  // Sections and headings.
  "h3",
  // Sections and headings.
  "h4",
  // Sections and headings.
  "h5",
  // Sections and headings.
  "h6",
  // Sections and headings.
  "head",
  // Page.
  "header",
  // Flow content.
  "hgroup",
  // Sections and headings.
  "hr",
  // Flow content.
  "html",
  // Page.
  "legend",
  // Flow content.
  "li",
  // Block-like.
  "li",
  // Similar to block.
  "listing",
  // Flow content, legacy
  "main",
  // Flow content.
  "menu",
  // Lists.
  "nav",
  // Sections and headings.
  "ol",
  // Lists.
  "optgroup",
  // Similar to block.
  "option",
  // Similar to block.
  "p",
  // Flow content.
  "plaintext",
  // Flow content, legacy
  "pre",
  // Flow content.
  "section",
  // Sections and headings.
  "summary",
  // Similar to block.
  "table",
  // Similar to block.
  "tbody",
  // Similar to block.
  "td",
  // Block-like.
  "td",
  // Similar to block.
  "tfoot",
  // Similar to block.
  "th",
  // Block-like.
  "th",
  // Similar to block.
  "thead",
  // Similar to block.
  "tr",
  // Similar to block.
  "ul",
  // Lists.
  "wbr",
  // Contribute whitespace intrinsically.
  "xmp"
  // Flow content, legacy
];
const content$3 = [
  // Form.
  "button",
  "input",
  "select",
  "textarea"
];
const skippable$1 = [
  "area",
  "base",
  "basefont",
  "dialog",
  "datalist",
  "head",
  "link",
  "meta",
  "noembed",
  "noframes",
  "param",
  "rp",
  "script",
  "source",
  "style",
  "template",
  "track",
  "title"
];
const emptyOptions$7 = {};
const ignorableNode = convert(["doctype", "comment"]);
function rehypeMinifyWhitespace(options) {
  const settings = options || emptyOptions$7;
  const collapse = collapseFactory(
    settings.newlines ? replaceNewlines : replaceWhitespace
  );
  return function(tree) {
    minify(tree, { collapse, whitespace: "normal" });
  };
}
function minify(node2, state) {
  if ("children" in node2) {
    const settings = { ...state };
    if (node2.type === "root" || blocklike(node2)) {
      settings.before = true;
      settings.after = true;
    }
    settings.whitespace = inferWhiteSpace(node2, state);
    return all$2(node2, settings);
  }
  if (node2.type === "text") {
    if (state.whitespace === "normal") {
      return minifyText(node2, state);
    }
    if (state.whitespace === "nowrap") {
      node2.value = state.collapse(node2.value);
    }
  }
  return { ignore: ignorableNode(node2), stripAtStart: false, remove: false };
}
function minifyText(node2, state) {
  const value = state.collapse(node2.value);
  const result = { ignore: false, stripAtStart: false, remove: false };
  let start = 0;
  let end = value.length;
  if (state.before && removable(value.charAt(0))) {
    start++;
  }
  if (start !== end && removable(value.charAt(end - 1))) {
    if (state.after) {
      end--;
    } else {
      result.stripAtStart = true;
    }
  }
  if (start === end) {
    result.remove = true;
  } else {
    node2.value = value.slice(start, end);
  }
  return result;
}
function all$2(parent, state) {
  let before = state.before;
  const after = state.after;
  const children2 = parent.children;
  let length = children2.length;
  let index2 = -1;
  while (++index2 < length) {
    const result = minify(children2[index2], {
      ...state,
      after: collapsableAfter(children2, index2, after),
      before
    });
    if (result.remove) {
      children2.splice(index2, 1);
      index2--;
      length--;
    } else if (!result.ignore) {
      before = result.stripAtStart;
    }
    if (content$2(children2[index2])) {
      before = false;
    }
  }
  return { ignore: false, stripAtStart: Boolean(before || after), remove: false };
}
function collapsableAfter(nodes, index2, after) {
  while (++index2 < nodes.length) {
    const node2 = nodes[index2];
    let result = inferBoundary(node2);
    if (result === void 0 && "children" in node2 && !skippable(node2)) {
      result = collapsableAfter(node2.children, -1);
    }
    if (typeof result === "boolean") {
      return result;
    }
  }
  return after;
}
function inferBoundary(node2) {
  if (node2.type === "element") {
    if (content$2(node2)) {
      return false;
    }
    if (blocklike(node2)) {
      return true;
    }
  } else if (node2.type === "text") {
    if (!whitespace(node2)) {
      return false;
    }
  } else if (!ignorableNode(node2)) {
    return false;
  }
}
function content$2(node2) {
  return embedded(node2) || isElement(node2, content$3);
}
function blocklike(node2) {
  return isElement(node2, blocks);
}
function skippable(node2) {
  return Boolean(node2.type === "element" && node2.properties.hidden) || ignorableNode(node2) || isElement(node2, skippable$1);
}
function removable(character) {
  return character === " " || character === "\n";
}
function replaceNewlines(value) {
  const match = /\r?\n|\r/.exec(value);
  return match ? match[0] : " ";
}
function replaceWhitespace() {
  return " ";
}
function collapseFactory(replace2) {
  return collapse;
  function collapse(value) {
    return String(value).replace(/[\t\n\v\f\r ]+/g, replace2);
  }
}
function inferWhiteSpace(node2, state) {
  if ("tagName" in node2 && node2.properties) {
    switch (node2.tagName) {
      case "listing":
      case "plaintext":
      case "script":
      case "style":
      case "xmp": {
        return "pre";
      }
      case "nobr": {
        return "nowrap";
      }
      case "pre": {
        return node2.properties.wrap ? "pre-wrap" : "pre";
      }
      case "td":
      case "th": {
        return node2.properties.noWrap ? "nowrap" : state.whitespace;
      }
      case "textarea": {
        return "pre-wrap";
      }
    }
  }
  return state.whitespace;
}
rehypeMinifyWhitespace({ newlines: true });
convertElement("br");
convertElement(isCell);
convertElement("p");
convertElement("tr");
convertElement([
  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  hidden,
  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
  closedDialog
]);
convertElement([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function hidden(node2) {
  return Boolean((node2.properties || {}).hidden);
}
function isCell(node2) {
  return node2.tagName === "td" || node2.tagName === "th";
}
function closedDialog(node2) {
  return node2.tagName === "dialog" && !(node2.properties || {}).open;
}
function source$1(re2) {
  if (!re2)
    return null;
  if (typeof re2 === "string")
    return re2;
  return re2.source;
}
function concat$1(...args) {
  const joined = args.map((x22) => source$1(x22)).join("");
  return joined;
}
function stripOptionsFromArgs$1(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either$1(...args) {
  const opts = stripOptionsFromArgs$1(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x22) => source$1(x22)).join("|") + ")";
  return joined;
}
const keywordWrapper = (keyword2) => concat$1(
  /\b/,
  keyword2,
  /\w$/.test(keyword2) ? /\b/ : /\B/
);
[
  "Protocol",
  // contextual
  "Type"
  // contextual
].map(keywordWrapper);
[
  "init",
  "self"
].map(keywordWrapper);
const operatorHead = either$1(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
);
const operatorCharacter = either$1(
  operatorHead,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn't supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
);
concat$1(operatorHead, operatorCharacter, "*");
const identifierHead = either$1(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren't supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
);
const identifierCharacter = either$1(
  identifierHead,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
);
const identifier = concat$1(identifierHead, identifierCharacter, "*");
concat$1(/[A-Z]/, identifierCharacter, "*");
[
  "attached",
  "autoclosure",
  concat$1(/convention\(/, either$1("swift", "block", "c"), /\)/),
  "discardableResult",
  "dynamicCallable",
  "dynamicMemberLookup",
  "escaping",
  "freestanding",
  "frozen",
  "GKInspectable",
  "IBAction",
  "IBDesignable",
  "IBInspectable",
  "IBOutlet",
  "IBSegueAction",
  "inlinable",
  "main",
  "nonobjc",
  "NSApplicationMain",
  "NSCopying",
  "NSManaged",
  concat$1(/objc\(/, identifier, /\)/),
  "objc",
  "objcMembers",
  "propertyWrapper",
  "requires_stored_property_inits",
  "resultBuilder",
  "Sendable",
  "testable",
  "UIApplicationMain",
  "unchecked",
  "unknown",
  "usableFromInline",
  "warn_unqualified_access"
];
function getDefaultExportFromCjs(x22) {
  return x22 && x22.__esModule && Object.prototype.hasOwnProperty.call(x22, "default") ? x22["default"] : x22;
}
function deepFreeze(obj) {
  if (obj instanceof Map) {
    obj.clear = obj.delete = obj.set = function() {
      throw new Error("map is read-only");
    };
  } else if (obj instanceof Set) {
    obj.add = obj.clear = obj.delete = function() {
      throw new Error("set is read-only");
    };
  }
  Object.freeze(obj);
  Object.getOwnPropertyNames(obj).forEach((name2) => {
    const prop = obj[name2];
    const type = typeof prop;
    if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
      deepFreeze(prop);
    }
  });
  return obj;
}
class Response2 {
  /**
   * @param {CompiledMode} mode
   */
  constructor(mode) {
    if (mode.data === void 0)
      mode.data = {};
    this.data = mode.data;
    this.isMatchIgnored = false;
  }
  ignoreMatch() {
    this.isMatchIgnored = true;
  }
}
function escapeHTML(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function inherit$1(original, ...objects) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key2 in original) {
    result[key2] = original[key2];
  }
  objects.forEach(function(obj) {
    for (const key2 in obj) {
      result[key2] = obj[key2];
    }
  });
  return (
    /** @type {T} */
    result
  );
}
const SPAN_CLOSE = "</span>";
const emitsWrappingTags = (node2) => {
  return !!node2.scope;
};
const scopeToCSSClass = (name2, { prefix }) => {
  if (name2.startsWith("language:")) {
    return name2.replace("language:", "language-");
  }
  if (name2.includes(".")) {
    const pieces = name2.split(".");
    return [
      `${prefix}${pieces.shift()}`,
      ...pieces.map((x22, i22) => `${x22}${"_".repeat(i22 + 1)}`)
    ].join(" ");
  }
  return `${prefix}${name2}`;
};
class HTMLRenderer2 {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(text2) {
    this.buffer += escapeHTML(text2);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(node2) {
    if (!emitsWrappingTags(node2))
      return;
    const className = scopeToCSSClass(
      node2.scope,
      { prefix: this.classPrefix }
    );
    this.span(className);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(node2) {
    if (!emitsWrappingTags(node2))
      return;
    this.buffer += SPAN_CLOSE;
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(className) {
    this.buffer += `<span class="${className}">`;
  }
}
const newNode = (opts = {}) => {
  const result = { children: [] };
  Object.assign(result, opts);
  return result;
};
class TokenTree2 {
  constructor() {
    this.rootNode = newNode();
    this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(node2) {
    this.top.children.push(node2);
  }
  /** @param {string} scope */
  openNode(scope) {
    const node2 = newNode({ scope });
    this.add(node2);
    this.stack.push(node2);
  }
  closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    return void 0;
  }
  closeAllNodes() {
    while (this.closeNode())
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(builder) {
    return this.constructor._walk(builder, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(builder, node2) {
    if (typeof node2 === "string") {
      builder.addText(node2);
    } else if (node2.children) {
      builder.openNode(node2);
      node2.children.forEach((child) => this._walk(builder, child));
      builder.closeNode(node2);
    }
    return builder;
  }
  /**
   * @param {Node} node
   */
  static _collapse(node2) {
    if (typeof node2 === "string")
      return;
    if (!node2.children)
      return;
    if (node2.children.every((el2) => typeof el2 === "string")) {
      node2.children = [node2.children.join("")];
    } else {
      node2.children.forEach((child) => {
        TokenTree2._collapse(child);
      });
    }
  }
}
class TokenTreeEmitter2 extends TokenTree2 {
  /**
   * @param {*} options
   */
  constructor(options) {
    super();
    this.options = options;
  }
  /**
   * @param {string} text
   */
  addText(text2) {
    if (text2 === "") {
      return;
    }
    this.add(text2);
  }
  /** @param {string} scope */
  startScope(scope) {
    this.openNode(scope);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(emitter, name2) {
    const node2 = emitter.root;
    if (name2)
      node2.scope = `language:${name2}`;
    this.add(node2);
  }
  toHTML() {
    const renderer = new HTMLRenderer2(this, this.options);
    return renderer.value();
  }
  finalize() {
    this.closeAllNodes();
    return true;
  }
}
function source(re2) {
  if (!re2)
    return null;
  if (typeof re2 === "string")
    return re2;
  return re2.source;
}
function lookahead(re2) {
  return concat("(?=", re2, ")");
}
function anyNumberOfTimes(re2) {
  return concat("(?:", re2, ")*");
}
function optional(re2) {
  return concat("(?:", re2, ")?");
}
function concat(...args) {
  const joined = args.map((x22) => source(x22)).join("");
  return joined;
}
function stripOptionsFromArgs(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either(...args) {
  const opts = stripOptionsFromArgs(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x22) => source(x22)).join("|") + ")";
  return joined;
}
function countMatchGroups(re2) {
  return new RegExp(re2.toString() + "|").exec("").length - 1;
}
function startsWith(re2, lexeme) {
  const match = re2 && re2.exec(lexeme);
  return match && match.index === 0;
}
const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function _rewriteBackreferences(regexps, { joinWith }) {
  let numCaptures = 0;
  return regexps.map((regex2) => {
    numCaptures += 1;
    const offset = numCaptures;
    let re2 = source(regex2);
    let out = "";
    while (re2.length > 0) {
      const match = BACKREF_RE.exec(re2);
      if (!match) {
        out += re2;
        break;
      }
      out += re2.substring(0, match.index);
      re2 = re2.substring(match.index + match[0].length);
      if (match[0][0] === "\\" && match[1]) {
        out += "\\" + String(Number(match[1]) + offset);
      } else {
        out += match[0];
        if (match[0] === "(") {
          numCaptures++;
        }
      }
    }
    return out;
  }).map((re2) => `(${re2})`).join(joinWith);
}
const MATCH_NOTHING_RE = /\b\B/;
const IDENT_RE = "[a-zA-Z]\\w*";
const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
const BINARY_NUMBER_RE = "\\b(0b[01]+)";
const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
const SHEBANG = (opts = {}) => {
  const beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat(
      beginShebang,
      /.*\b/,
      opts.binary,
      /\b.*/
    );
  }
  return inherit$1({
    scope: "meta",
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (m22, resp) => {
      if (m22.index !== 0)
        resp.ignoreMatch();
    }
  }, opts);
};
const BACKSLASH_ESCAPE = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
};
const APOS_STRING_MODE = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const QUOTE_STRING_MODE = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const PHRASAL_WORDS_MODE = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
const COMMENT = function(begin, end, modeOptions = {}) {
  const mode = inherit$1(
    {
      scope: "comment",
      begin,
      end,
      contains: []
    },
    modeOptions
  );
  mode.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  const ENGLISH_WORD = either(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  mode.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: concat(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        ENGLISH_WORD,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  );
  return mode;
};
const C_LINE_COMMENT_MODE = COMMENT("//", "$");
const C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
const HASH_COMMENT_MODE = COMMENT("#", "$");
const NUMBER_MODE = {
  scope: "number",
  begin: NUMBER_RE,
  relevance: 0
};
const C_NUMBER_MODE = {
  scope: "number",
  begin: C_NUMBER_RE,
  relevance: 0
};
const BINARY_NUMBER_MODE = {
  scope: "number",
  begin: BINARY_NUMBER_RE,
  relevance: 0
};
const REGEXP_MODE = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    BACKSLASH_ESCAPE,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [BACKSLASH_ESCAPE]
    }
  ]
};
const TITLE_MODE = {
  scope: "title",
  begin: IDENT_RE,
  relevance: 0
};
const UNDERSCORE_TITLE_MODE = {
  scope: "title",
  begin: UNDERSCORE_IDENT_RE,
  relevance: 0
};
const METHOD_GUARD = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
  relevance: 0
};
const END_SAME_AS_BEGIN = function(mode) {
  return Object.assign(
    mode,
    {
      /** @type {ModeCallback} */
      "on:begin": (m22, resp) => {
        resp.data._beginMatch = m22[1];
      },
      /** @type {ModeCallback} */
      "on:end": (m22, resp) => {
        if (resp.data._beginMatch !== m22[1])
          resp.ignoreMatch();
      }
    }
  );
};
var MODES = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE,
  BACKSLASH_ESCAPE,
  BINARY_NUMBER_MODE,
  BINARY_NUMBER_RE,
  COMMENT,
  C_BLOCK_COMMENT_MODE,
  C_LINE_COMMENT_MODE,
  C_NUMBER_MODE,
  C_NUMBER_RE,
  END_SAME_AS_BEGIN,
  HASH_COMMENT_MODE,
  IDENT_RE,
  MATCH_NOTHING_RE,
  METHOD_GUARD,
  NUMBER_MODE,
  NUMBER_RE,
  PHRASAL_WORDS_MODE,
  QUOTE_STRING_MODE,
  REGEXP_MODE,
  RE_STARTERS_RE,
  SHEBANG,
  TITLE_MODE,
  UNDERSCORE_IDENT_RE,
  UNDERSCORE_TITLE_MODE
});
function skipIfHasPrecedingDot(match, response) {
  const before = match.input[match.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}
function scopeClassName(mode, _parent) {
  if (mode.className !== void 0) {
    mode.scope = mode.className;
    delete mode.className;
  }
}
function beginKeywords(mode, parent) {
  if (!parent)
    return;
  if (!mode.beginKeywords)
    return;
  mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
  mode.__beforeBegin = skipIfHasPrecedingDot;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;
  if (mode.relevance === void 0)
    mode.relevance = 0;
}
function compileIllegal(mode, _parent) {
  if (!Array.isArray(mode.illegal))
    return;
  mode.illegal = either(...mode.illegal);
}
function compileMatch(mode, _parent) {
  if (!mode.match)
    return;
  if (mode.begin || mode.end)
    throw new Error("begin & end are not supported with match");
  mode.begin = mode.match;
  delete mode.match;
}
function compileRelevance(mode, _parent) {
  if (mode.relevance === void 0)
    mode.relevance = 1;
}
const beforeMatchExt = (mode, parent) => {
  if (!mode.beforeMatch)
    return;
  if (mode.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const originalMode = Object.assign({}, mode);
  Object.keys(mode).forEach((key2) => {
    delete mode[key2];
  });
  mode.keywords = originalMode.keywords;
  mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
  mode.starts = {
    relevance: 0,
    contains: [
      Object.assign(originalMode, { endsParent: true })
    ]
  };
  mode.relevance = 0;
  delete originalMode.beforeMatch;
};
const COMMON_KEYWORDS = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
];
const DEFAULT_KEYWORD_SCOPE = "keyword";
function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
  const compiledKeywords = /* @__PURE__ */ Object.create(null);
  if (typeof rawKeywords === "string") {
    compileList(scopeName, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(scopeName, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(scopeName2) {
      Object.assign(
        compiledKeywords,
        compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
      );
    });
  }
  return compiledKeywords;
  function compileList(scopeName2, keywordList2) {
    if (caseInsensitive) {
      keywordList2 = keywordList2.map((x22) => x22.toLowerCase());
    }
    keywordList2.forEach(function(keyword2) {
      const pair = keyword2.split("|");
      compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
    });
  }
}
function scoreForKeyword(keyword2, providedScore) {
  if (providedScore) {
    return Number(providedScore);
  }
  return commonKeyword(keyword2) ? 0 : 1;
}
function commonKeyword(keyword2) {
  return COMMON_KEYWORDS.includes(keyword2.toLowerCase());
}
const seenDeprecations = {};
const error = (message) => {
  console.error(message);
};
const warn = (message, ...args) => {
  console.log(`WARN: ${message}`, ...args);
};
const deprecated = (version2, message) => {
  if (seenDeprecations[`${version2}/${message}`])
    return;
  console.log(`Deprecated as of ${version2}. ${message}`);
  seenDeprecations[`${version2}/${message}`] = true;
};
const MultiClassError = new Error();
function remapScopeNames(mode, regexes, { key: key2 }) {
  let offset = 0;
  const scopeNames = mode[key2];
  const emit = {};
  const positions = {};
  for (let i22 = 1; i22 <= regexes.length; i22++) {
    positions[i22 + offset] = scopeNames[i22];
    emit[i22 + offset] = true;
    offset += countMatchGroups(regexes[i22 - 1]);
  }
  mode[key2] = positions;
  mode[key2]._emit = emit;
  mode[key2]._multi = true;
}
function beginMultiClass(mode) {
  if (!Array.isArray(mode.begin))
    return;
  if (mode.skip || mode.excludeBegin || mode.returnBegin) {
    error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
    error("beginScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.begin, { key: "beginScope" });
  mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
}
function endMultiClass(mode) {
  if (!Array.isArray(mode.end))
    return;
  if (mode.skip || mode.excludeEnd || mode.returnEnd) {
    error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.endScope !== "object" || mode.endScope === null) {
    error("endScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.end, { key: "endScope" });
  mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
}
function scopeSugar(mode) {
  if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
    mode.beginScope = mode.scope;
    delete mode.scope;
  }
}
function MultiClass(mode) {
  scopeSugar(mode);
  if (typeof mode.beginScope === "string") {
    mode.beginScope = { _wrap: mode.beginScope };
  }
  if (typeof mode.endScope === "string") {
    mode.endScope = { _wrap: mode.endScope };
  }
  beginMultiClass(mode);
  endMultiClass(mode);
}
function compileLanguage(language2) {
  function langRe(value, global2) {
    return new RegExp(
      source(value),
      "m" + (language2.case_insensitive ? "i" : "") + (language2.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
    );
  }
  class MultiRegex {
    constructor() {
      this.matchIndexes = {};
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }
    // @ts-ignore
    addRule(re2, opts) {
      opts.position = this.position++;
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re2]);
      this.matchAt += countMatchGroups(re2) + 1;
    }
    compile() {
      if (this.regexes.length === 0) {
        this.exec = () => null;
      }
      const terminators = this.regexes.map((el2) => el2[1]);
      this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
      this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(s22) {
      this.matcherRe.lastIndex = this.lastIndex;
      const match = this.matcherRe.exec(s22);
      if (!match) {
        return null;
      }
      const i22 = match.findIndex((el2, i3) => i3 > 0 && el2 !== void 0);
      const matchData = this.matchIndexes[i22];
      match.splice(0, i22);
      return Object.assign(match, matchData);
    }
  }
  class ResumableMultiRegex {
    constructor() {
      this.rules = [];
      this.multiRegexes = [];
      this.count = 0;
      this.lastIndex = 0;
      this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(index2) {
      if (this.multiRegexes[index2])
        return this.multiRegexes[index2];
      const matcher = new MultiRegex();
      this.rules.slice(index2).forEach(([re2, opts]) => matcher.addRule(re2, opts));
      matcher.compile();
      this.multiRegexes[index2] = matcher;
      return matcher;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(re2, opts) {
      this.rules.push([re2, opts]);
      if (opts.type === "begin")
        this.count++;
    }
    /** @param {string} s */
    exec(s22) {
      const m22 = this.getMatcher(this.regexIndex);
      m22.lastIndex = this.lastIndex;
      let result = m22.exec(s22);
      if (this.resumingScanAtSamePosition()) {
        if (result && result.index === this.lastIndex)
          ;
        else {
          const m222 = this.getMatcher(0);
          m222.lastIndex = this.lastIndex + 1;
          result = m222.exec(s22);
        }
      }
      if (result) {
        this.regexIndex += result.position + 1;
        if (this.regexIndex === this.count) {
          this.considerAll();
        }
      }
      return result;
    }
  }
  function buildModeRegex(mode) {
    const mm2 = new ResumableMultiRegex();
    mode.contains.forEach((term) => mm2.addRule(term.begin, { rule: term, type: "begin" }));
    if (mode.terminatorEnd) {
      mm2.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm2.addRule(mode.illegal, { type: "illegal" });
    }
    return mm2;
  }
  function compileMode(mode, parent) {
    const cmode = (
      /** @type CompiledMode */
      mode
    );
    if (mode.isCompiled)
      return cmode;
    [
      scopeClassName,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      compileMatch,
      MultiClass,
      beforeMatchExt
    ].forEach((ext) => ext(mode, parent));
    language2.compilerExtensions.forEach((ext) => ext(mode, parent));
    mode.__beforeBegin = null;
    [
      beginKeywords,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      compileIllegal,
      // default to 1 relevance if not specified
      compileRelevance
    ].forEach((ext) => ext(mode, parent));
    mode.isCompiled = true;
    let keywordPattern = null;
    if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
      mode.keywords = Object.assign({}, mode.keywords);
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }
    keywordPattern = keywordPattern || /\w+/;
    if (mode.keywords) {
      mode.keywords = compileKeywords(mode.keywords, language2.case_insensitive);
    }
    cmode.keywordPatternRe = langRe(keywordPattern, true);
    if (parent) {
      if (!mode.begin)
        mode.begin = /\B|\b/;
      cmode.beginRe = langRe(cmode.begin);
      if (!mode.end && !mode.endsWithParent)
        mode.end = /\B|\b/;
      if (mode.end)
        cmode.endRe = langRe(cmode.end);
      cmode.terminatorEnd = source(cmode.end) || "";
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
      }
    }
    if (mode.illegal)
      cmode.illegalRe = langRe(
        /** @type {RegExp | string} */
        mode.illegal
      );
    if (!mode.contains)
      mode.contains = [];
    mode.contains = [].concat(...mode.contains.map(function(c22) {
      return expandOrCloneMode(c22 === "self" ? mode : c22);
    }));
    mode.contains.forEach(function(c22) {
      compileMode(
        /** @type Mode */
        c22,
        cmode
      );
    });
    if (mode.starts) {
      compileMode(mode.starts, parent);
    }
    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }
  if (!language2.compilerExtensions)
    language2.compilerExtensions = [];
  if (language2.contains && language2.contains.includes("self")) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }
  language2.classNameAliases = inherit$1(language2.classNameAliases || {});
  return compileMode(
    /** @type Mode */
    language2
  );
}
function dependencyOnParent(mode) {
  if (!mode)
    return false;
  return mode.endsWithParent || dependencyOnParent(mode.starts);
}
function expandOrCloneMode(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit$1(mode, { variants: null }, variant);
    });
  }
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }
  if (dependencyOnParent(mode)) {
    return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
  }
  if (Object.isFrozen(mode)) {
    return inherit$1(mode);
  }
  return mode;
}
var version = "11.9.0";
class HTMLInjectionError2 extends Error {
  constructor(reason, html2) {
    super(reason);
    this.name = "HTMLInjectionError";
    this.html = html2;
  }
}
const escape$1 = escapeHTML;
const inherit = inherit$1;
const NO_MATCH = Symbol("nomatch");
const MAX_KEYWORD_HITS = 7;
const HLJS = function(hljs) {
  const languages = /* @__PURE__ */ Object.create(null);
  const aliases = /* @__PURE__ */ Object.create(null);
  const plugins = [];
  let SAFE_MODE = true;
  const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
  let options = {
    ignoreUnescapedHTML: false,
    throwUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: TokenTreeEmitter2
  };
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }
  function blockLanguage(block) {
    let classes = block.className + " ";
    classes += block.parentNode ? block.parentNode.className : "";
    const match = options.languageDetectRe.exec(classes);
    if (match) {
      const language2 = getLanguage(match[1]);
      if (!language2) {
        warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
        warn("Falling back to no-highlight mode for this block.", block);
      }
      return language2 ? match[1] : "no-highlight";
    }
    return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
  }
  function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
    let code2 = "";
    let languageName = "";
    if (typeof optionsOrCode === "object") {
      code2 = codeOrLanguageName;
      ignoreIllegals = optionsOrCode.ignoreIllegals;
      languageName = optionsOrCode.language;
    } else {
      deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
      deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
      languageName = codeOrLanguageName;
      code2 = optionsOrCode;
    }
    if (ignoreIllegals === void 0) {
      ignoreIllegals = true;
    }
    const context = {
      code: code2,
      language: languageName
    };
    fire("before:highlight", context);
    const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
    result.code = context.code;
    fire("after:highlight", result);
    return result;
  }
  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
    const keywordHits = /* @__PURE__ */ Object.create(null);
    function keywordData(mode, matchText) {
      return mode.keywords[matchText];
    }
    function processKeywords() {
      if (!top2.keywords) {
        emitter.addText(modeBuffer);
        return;
      }
      let lastIndex = 0;
      top2.keywordPatternRe.lastIndex = 0;
      let match = top2.keywordPatternRe.exec(modeBuffer);
      let buf = "";
      while (match) {
        buf += modeBuffer.substring(lastIndex, match.index);
        const word = language2.case_insensitive ? match[0].toLowerCase() : match[0];
        const data = keywordData(top2, word);
        if (data) {
          const [kind, keywordRelevance] = data;
          emitter.addText(buf);
          buf = "";
          keywordHits[word] = (keywordHits[word] || 0) + 1;
          if (keywordHits[word] <= MAX_KEYWORD_HITS)
            relevance += keywordRelevance;
          if (kind.startsWith("_")) {
            buf += match[0];
          } else {
            const cssClass = language2.classNameAliases[kind] || kind;
            emitKeyword(match[0], cssClass);
          }
        } else {
          buf += match[0];
        }
        lastIndex = top2.keywordPatternRe.lastIndex;
        match = top2.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substring(lastIndex);
      emitter.addText(buf);
    }
    function processSubLanguage() {
      if (modeBuffer === "")
        return;
      let result2 = null;
      if (typeof top2.subLanguage === "string") {
        if (!languages[top2.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result2 = _highlight(top2.subLanguage, modeBuffer, true, continuations[top2.subLanguage]);
        continuations[top2.subLanguage] = /** @type {CompiledMode} */
        result2._top;
      } else {
        result2 = highlightAuto(modeBuffer, top2.subLanguage.length ? top2.subLanguage : null);
      }
      if (top2.relevance > 0) {
        relevance += result2.relevance;
      }
      emitter.__addSublanguage(result2._emitter, result2.language);
    }
    function processBuffer() {
      if (top2.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = "";
    }
    function emitKeyword(keyword2, scope) {
      if (keyword2 === "")
        return;
      emitter.startScope(scope);
      emitter.addText(keyword2);
      emitter.endScope();
    }
    function emitMultiClass(scope, match) {
      let i22 = 1;
      const max2 = match.length - 1;
      while (i22 <= max2) {
        if (!scope._emit[i22]) {
          i22++;
          continue;
        }
        const klass = language2.classNameAliases[scope[i22]] || scope[i22];
        const text2 = match[i22];
        if (klass) {
          emitKeyword(text2, klass);
        } else {
          modeBuffer = text2;
          processKeywords();
          modeBuffer = "";
        }
        i22++;
      }
    }
    function startNewMode(mode, match) {
      if (mode.scope && typeof mode.scope === "string") {
        emitter.openNode(language2.classNameAliases[mode.scope] || mode.scope);
      }
      if (mode.beginScope) {
        if (mode.beginScope._wrap) {
          emitKeyword(modeBuffer, language2.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
          modeBuffer = "";
        } else if (mode.beginScope._multi) {
          emitMultiClass(mode.beginScope, match);
          modeBuffer = "";
        }
      }
      top2 = Object.create(mode, { parent: { value: top2 } });
      return top2;
    }
    function endOfMode(mode, match, matchPlusRemainder) {
      let matched = startsWith(mode.endRe, matchPlusRemainder);
      if (matched) {
        if (mode["on:end"]) {
          const resp = new Response2(mode);
          mode["on:end"](match, resp);
          if (resp.isMatchIgnored)
            matched = false;
        }
        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match, matchPlusRemainder);
      }
    }
    function doIgnore(lexeme) {
      if (top2.matcher.regexIndex === 0) {
        modeBuffer += lexeme[0];
        return 1;
      } else {
        resumeScanAtSamePosition = true;
        return 0;
      }
    }
    function doBeginMatch(match) {
      const lexeme = match[0];
      const newMode = match.rule;
      const resp = new Response2(newMode);
      const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
      for (const cb of beforeCallbacks) {
        if (!cb)
          continue;
        cb(match, resp);
        if (resp.isMatchIgnored)
          return doIgnore(lexeme);
      }
      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode, match);
      return newMode.returnBegin ? 0 : lexeme.length;
    }
    function doEndMatch(match) {
      const lexeme = match[0];
      const matchPlusRemainder = codeToHighlight.substring(match.index);
      const endMode = endOfMode(top2, match, matchPlusRemainder);
      if (!endMode) {
        return NO_MATCH;
      }
      const origin = top2;
      if (top2.endScope && top2.endScope._wrap) {
        processBuffer();
        emitKeyword(lexeme, top2.endScope._wrap);
      } else if (top2.endScope && top2.endScope._multi) {
        processBuffer();
        emitMultiClass(top2.endScope, match);
      } else if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top2.scope) {
          emitter.closeNode();
        }
        if (!top2.skip && !top2.subLanguage) {
          relevance += top2.relevance;
        }
        top2 = top2.parent;
      } while (top2 !== endMode.parent);
      if (endMode.starts) {
        startNewMode(endMode.starts, match);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }
    function processContinuations() {
      const list2 = [];
      for (let current = top2; current !== language2; current = current.parent) {
        if (current.scope) {
          list2.unshift(current.scope);
        }
      }
      list2.forEach((item) => emitter.openNode(item));
    }
    let lastMatch = {};
    function processLexeme(textBeforeMatch, match) {
      const lexeme = match && match[0];
      modeBuffer += textBeforeMatch;
      if (lexeme == null) {
        processBuffer();
        return 0;
      }
      if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
        if (!SAFE_MODE) {
          const err = new Error(`0 width match regex (${languageName})`);
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match;
      if (match.type === "begin") {
        return doBeginMatch(match);
      } else if (match.type === "illegal" && !ignoreIllegals) {
        const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top2.scope || "<unnamed>") + '"');
        err.mode = top2;
        throw err;
      } else if (match.type === "end") {
        const processed = doEndMatch(match);
        if (processed !== NO_MATCH) {
          return processed;
        }
      }
      if (match.type === "illegal" && lexeme === "") {
        return 1;
      }
      if (iterations > 1e5 && iterations > match.index * 3) {
        const err = new Error("potential infinite loop, way more iterations than matches");
        throw err;
      }
      modeBuffer += lexeme;
      return lexeme.length;
    }
    const language2 = getLanguage(languageName);
    if (!language2) {
      error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }
    const md = compileLanguage(language2);
    let result = "";
    let top2 = continuation || md;
    const continuations = {};
    const emitter = new options.__emitter(options);
    processContinuations();
    let modeBuffer = "";
    let relevance = 0;
    let index2 = 0;
    let iterations = 0;
    let resumeScanAtSamePosition = false;
    try {
      if (!language2.__emitTokens) {
        top2.matcher.considerAll();
        for (; ; ) {
          iterations++;
          if (resumeScanAtSamePosition) {
            resumeScanAtSamePosition = false;
          } else {
            top2.matcher.considerAll();
          }
          top2.matcher.lastIndex = index2;
          const match = top2.matcher.exec(codeToHighlight);
          if (!match)
            break;
          const beforeMatch = codeToHighlight.substring(index2, match.index);
          const processedCount = processLexeme(beforeMatch, match);
          index2 = match.index + processedCount;
        }
        processLexeme(codeToHighlight.substring(index2));
      } else {
        language2.__emitTokens(codeToHighlight, emitter);
      }
      emitter.finalize();
      result = emitter.toHTML();
      return {
        language: languageName,
        value: result,
        relevance,
        illegal: false,
        _emitter: emitter,
        _top: top2
      };
    } catch (err) {
      if (err.message && err.message.includes("Illegal")) {
        return {
          language: languageName,
          value: escape$1(codeToHighlight),
          illegal: true,
          relevance: 0,
          _illegalBy: {
            message: err.message,
            index: index2,
            context: codeToHighlight.slice(index2 - 100, index2 + 100),
            mode: err.mode,
            resultSoFar: result
          },
          _emitter: emitter
        };
      } else if (SAFE_MODE) {
        return {
          language: languageName,
          value: escape$1(codeToHighlight),
          illegal: false,
          relevance: 0,
          errorRaised: err,
          _emitter: emitter,
          _top: top2
        };
      } else {
        throw err;
      }
    }
  }
  function justTextHighlightResult(code2) {
    const result = {
      value: escape$1(code2),
      illegal: false,
      relevance: 0,
      _top: PLAINTEXT_LANGUAGE,
      _emitter: new options.__emitter(options)
    };
    result._emitter.addText(code2);
    return result;
  }
  function highlightAuto(code2, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages);
    const plaintext2 = justTextHighlightResult(code2);
    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
      (name2) => _highlight(name2, code2, false)
    );
    results.unshift(plaintext2);
    const sorted = results.sort((a22, b22) => {
      if (a22.relevance !== b22.relevance)
        return b22.relevance - a22.relevance;
      if (a22.language && b22.language) {
        if (getLanguage(a22.language).supersetOf === b22.language) {
          return 1;
        } else if (getLanguage(b22.language).supersetOf === a22.language) {
          return -1;
        }
      }
      return 0;
    });
    const [best, secondBest] = sorted;
    const result = best;
    result.secondBest = secondBest;
    return result;
  }
  function updateClassName(element2, currentLang, resultLang) {
    const language2 = currentLang && aliases[currentLang] || resultLang;
    element2.classList.add("hljs");
    element2.classList.add(`language-${language2}`);
  }
  function highlightElement(element2) {
    let node2 = null;
    const language2 = blockLanguage(element2);
    if (shouldNotHighlight(language2))
      return;
    fire(
      "before:highlightElement",
      { el: element2, language: language2 }
    );
    if (element2.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", element2);
      return;
    }
    if (element2.children.length > 0) {
      if (!options.ignoreUnescapedHTML) {
        console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
        console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
        console.warn("The element with unescaped HTML:");
        console.warn(element2);
      }
      if (options.throwUnescapedHTML) {
        const err = new HTMLInjectionError2(
          "One of your code blocks includes unescaped HTML.",
          element2.innerHTML
        );
        throw err;
      }
    }
    node2 = element2;
    const text2 = node2.textContent;
    const result = language2 ? highlight2(text2, { language: language2, ignoreIllegals: true }) : highlightAuto(text2);
    element2.innerHTML = result.value;
    element2.dataset.highlighted = "yes";
    updateClassName(element2, language2, result.language);
    element2.result = {
      language: result.language,
      // TODO: remove with version 11.0
      re: result.relevance,
      relevance: result.relevance
    };
    if (result.secondBest) {
      element2.secondBest = {
        language: result.secondBest.language,
        relevance: result.secondBest.relevance
      };
    }
    fire("after:highlightElement", { el: element2, result, text: text2 });
  }
  function configure2(userOptions) {
    options = inherit(options, userOptions);
  }
  const initHighlighting = () => {
    highlightAll();
    deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function initHighlightingOnLoad() {
    highlightAll();
    deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let wantsHighlight = false;
  function highlightAll() {
    if (document.readyState === "loading") {
      wantsHighlight = true;
      return;
    }
    const blocks2 = document.querySelectorAll(options.cssSelector);
    blocks2.forEach(highlightElement);
  }
  function boot() {
    if (wantsHighlight)
      highlightAll();
  }
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("DOMContentLoaded", boot, false);
  }
  function registerLanguage(languageName, languageDefinition) {
    let lang = null;
    try {
      lang = languageDefinition(hljs);
    } catch (error$12) {
      error("Language definition for '{}' could not be registered.".replace("{}", languageName));
      if (!SAFE_MODE) {
        throw error$12;
      } else {
        error(error$12);
      }
      lang = PLAINTEXT_LANGUAGE;
    }
    if (!lang.name)
      lang.name = languageName;
    languages[languageName] = lang;
    lang.rawDefinition = languageDefinition.bind(null, hljs);
    if (lang.aliases) {
      registerAliases(lang.aliases, { languageName });
    }
  }
  function unregisterLanguage(languageName) {
    delete languages[languageName];
    for (const alias of Object.keys(aliases)) {
      if (aliases[alias] === languageName) {
        delete aliases[alias];
      }
    }
  }
  function listLanguages() {
    return Object.keys(languages);
  }
  function getLanguage(name2) {
    name2 = (name2 || "").toLowerCase();
    return languages[name2] || languages[aliases[name2]];
  }
  function registerAliases(aliasList, { languageName }) {
    if (typeof aliasList === "string") {
      aliasList = [aliasList];
    }
    aliasList.forEach((alias) => {
      aliases[alias.toLowerCase()] = languageName;
    });
  }
  function autoDetection(name2) {
    const lang = getLanguage(name2);
    return lang && !lang.disableAutodetect;
  }
  function upgradePluginAPI(plugin) {
    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
      plugin["before:highlightElement"] = (data) => {
        plugin["before:highlightBlock"](
          Object.assign({ block: data.el }, data)
        );
      };
    }
    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
      plugin["after:highlightElement"] = (data) => {
        plugin["after:highlightBlock"](
          Object.assign({ block: data.el }, data)
        );
      };
    }
  }
  function addPlugin(plugin) {
    upgradePluginAPI(plugin);
    plugins.push(plugin);
  }
  function removePlugin(plugin) {
    const index2 = plugins.indexOf(plugin);
    if (index2 !== -1) {
      plugins.splice(index2, 1);
    }
  }
  function fire(event, args) {
    const cb = event;
    plugins.forEach(function(plugin) {
      if (plugin[cb]) {
        plugin[cb](args);
      }
    });
  }
  function deprecateHighlightBlock(el2) {
    deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
    deprecated("10.7.0", "Please use highlightElement now.");
    return highlightElement(el2);
  }
  Object.assign(hljs, {
    highlight: highlight2,
    highlightAuto,
    highlightAll,
    highlightElement,
    // TODO: Remove with v12 API
    highlightBlock: deprecateHighlightBlock,
    configure: configure2,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage,
    unregisterLanguage,
    listLanguages,
    getLanguage,
    registerAliases,
    autoDetection,
    inherit,
    addPlugin,
    removePlugin
  });
  hljs.debugMode = function() {
    SAFE_MODE = false;
  };
  hljs.safeMode = function() {
    SAFE_MODE = true;
  };
  hljs.versionString = version;
  hljs.regex = {
    concat,
    lookahead,
    either,
    optional,
    anyNumberOfTimes
  };
  for (const key2 in MODES) {
    if (typeof MODES[key2] === "object") {
      deepFreeze(MODES[key2]);
    }
  }
  Object.assign(hljs, MODES);
  return hljs;
};
const highlight = HLJS({});
highlight.newInstance = () => HLJS({});
highlight.HighlightJS = highlight;
highlight.default = highlight;
class Schema2 {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property, normal, space2) {
    this.property = property;
    this.normal = normal;
    if (space2) {
      this.space = space2;
    }
  }
}
Schema2.prototype.property = {};
Schema2.prototype.normal = {};
Schema2.prototype.space = null;
function merge(definitions, space2) {
  const property = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions.length) {
    Object.assign(property, definitions[index2].property);
    Object.assign(normal, definitions[index2].normal);
  }
  return new Schema2(property, normal, space2);
}
function normalize$1(value) {
  return value.toLowerCase();
}
class Info2 {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
}
Info2.prototype.space = null;
Info2.prototype.boolean = false;
Info2.prototype.booleanish = false;
Info2.prototype.overloadedBoolean = false;
Info2.prototype.number = false;
Info2.prototype.commaSeparated = false;
Info2.prototype.spaceSeparated = false;
Info2.prototype.commaOrSpaceSeparated = false;
Info2.prototype.mustUseProperty = false;
Info2.prototype.defined = false;
let powers = 0;
const boolean = increment();
const booleanish = increment();
const overloadedBoolean = increment();
const number = increment();
const spaceSeparated = increment();
const commaSeparated = increment();
const commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
}, Symbol.toStringTag, { value: "Module" }));
const checks = Object.keys(types);
class DefinedInfo2 extends Info2 {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property, attribute, mask, space2) {
    let index2 = -1;
    super(property, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check = checks[index2];
        mark(this, checks[index2], (mask & types[check]) === types[check]);
      }
    }
  }
}
DefinedInfo2.prototype.defined = true;
function mark(values, key2, value) {
  if (value) {
    values[key2] = value;
  }
}
const own$6 = {}.hasOwnProperty;
function create(definition2) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition2.properties) {
    if (own$6.call(definition2.properties, prop)) {
      const value = definition2.properties[prop];
      const info2 = new DefinedInfo2(
        prop,
        definition2.transform(definition2.attributes || {}, prop),
        value,
        definition2.space
      );
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
        info2.mustUseProperty = true;
      }
      property[prop] = info2;
      normal[normalize$1(prop)] = prop;
      normal[normalize$1(info2.attribute)] = prop;
    }
  }
  return new Schema2(property, normal, definition2.space);
}
const xlink = create({
  space: "xlink",
  transform(_22, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
const xml = create({
  space: "xml",
  transform(_22, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}
const xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});
const aria = create({
  transform(_22, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});
const html$5 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});
const svg$1 = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
const valid = /^data[-\w.:]+$/i;
const dash = /-[a-z]/g;
const cap = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize$1(value);
  let prop = value;
  let Type = Info2;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo2;
  }
  return new Type(prop, value);
}
function kebab($02) {
  return "-" + $02.toLowerCase();
}
function camelcase($02) {
  return $02.charAt(1).toUpperCase();
}
merge([xml, xlink, xmlns, aria, html$5], "html");
const svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
const own$5 = {}.hasOwnProperty;
function zwitch(key2, options) {
  const settings = options || {};
  function one2(value, ...parameters) {
    let fn2 = one2.invalid;
    const handlers2 = one2.handlers;
    if (value && own$5.call(value, key2)) {
      const id2 = String(value[key2]);
      fn2 = own$5.call(handlers2, id2) ? handlers2[id2] : one2.unknown;
    }
    if (fn2) {
      return fn2.call(this, value, ...parameters);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}
function core(value, options) {
  value = value.replace(
    options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g,
    basic2
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    basic2
  );
  function surrogate(pair, index2, all2) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all2.charCodeAt(index2 + 2),
      options
    );
  }
  function basic2(character, index2, all2) {
    return options.format(
      character.charCodeAt(0),
      all2.charCodeAt(index2 + 1),
      options
    );
  }
}
function charactersToExpression(subset) {
  const groups = [];
  let index2 = -1;
  while (++index2 < subset.length) {
    groups.push(subset[index2].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}
function toHexadecimal(code2, next, omit) {
  const value = "&#x" + code2.toString(16).toUpperCase();
  return omit && next && !/[\dA-Fa-f]/.test(String.fromCharCode(next)) ? value : value + ";";
}
function toDecimal(code2, next, omit) {
  const value = "&#" + String(code2);
  return omit && next && !/\d/.test(String.fromCharCode(next)) ? value : value + ";";
}
const characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];
const characterEntitiesHtml4 = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
};
const dangerous = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];
const own$4 = {}.hasOwnProperty;
const characters = {};
let key;
for (key in characterEntitiesHtml4) {
  if (own$4.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}
function toNamed(code2, next, omit, attribute) {
  const character = String.fromCharCode(code2);
  if (own$4.call(characters, character)) {
    const name2 = characters[character];
    const value = "&" + name2;
    if (omit && characterEntitiesLegacy.includes(name2) && !dangerous.includes(name2) && (!attribute || next && next !== 61 && /[^\da-z]/i.test(String.fromCharCode(next)))) {
      return value;
    }
    return value + ";";
  }
  return "";
}
function formatSmart(code2, next, options) {
  let numeric = toHexadecimal(code2, next, options.omitOptionalSemicolons);
  let named;
  if (options.useNamedReferences || options.useShortestReferences) {
    named = toNamed(
      code2,
      next,
      options.omitOptionalSemicolons,
      options.attribute
    );
  }
  if ((options.useShortestReferences || !named) && options.useShortestReferences) {
    const decimal = toDecimal(code2, next, options.omitOptionalSemicolons);
    if (decimal.length < numeric.length) {
      numeric = decimal;
    }
  }
  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;
}
function stringifyEntities(value, options) {
  return core(value, Object.assign({ format: formatSmart }, options));
}
function comment(node2, _12, _22, state) {
  return state.settings.bogusComments ? "<?" + stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, { subset: [">"] })
  ) + ">" : "<!--" + node2.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, encode) + "-->";
  function encode($02) {
    return stringifyEntities(
      $02,
      Object.assign({}, state.settings.characterReferences, {
        subset: ["<", ">"]
      })
    );
  }
}
function doctype(_12, _22, _32, state) {
  return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
}
function ccount(value, character) {
  const source2 = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source2.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source2.indexOf(character, index2 + character.length);
  }
  return count;
}
function stringify(values, options) {
  const settings = options || {};
  const input = values[values.length - 1] === "" ? [...values, ""] : values;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
const siblingAfter = siblings(1);
const siblingBefore = siblings(-1);
const emptyChildren$1 = [];
function siblings(increment2) {
  return sibling;
  function sibling(parent, index2, includeWhitespace) {
    const siblings2 = parent ? parent.children : emptyChildren$1;
    let offset = (index2 || 0) + increment2;
    let next = siblings2[offset];
    if (!includeWhitespace) {
      while (next && whitespace(next)) {
        offset += increment2;
        next = siblings2[offset];
      }
    }
    return next;
  }
}
const own$3 = {}.hasOwnProperty;
function omission(handlers2) {
  return omit;
  function omit(node2, index2, parent) {
    return own$3.call(handlers2, node2.tagName) && handlers2[node2.tagName](node2, index2, parent);
  }
}
const closing = omission({
  body: body$1,
  caption: headOrColgroupOrCaption,
  colgroup: headOrColgroupOrCaption,
  dd: dd$1,
  dt,
  head: headOrColgroupOrCaption,
  html: html$3,
  li: li$1,
  optgroup,
  option,
  p: p$4,
  rp: rubyElement,
  rt: rubyElement,
  tbody: tbody$1,
  td: cells,
  tfoot,
  th: cells,
  thead,
  tr: tr$1
});
function headOrColgroupOrCaption(_22, index2, parent) {
  const next = siblingAfter(parent, index2, true);
  return !next || next.type !== "comment" && !(next.type === "text" && whitespace(next.value.charAt(0)));
}
function html$3(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type !== "comment";
}
function body$1(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type !== "comment";
}
function p$4(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
  !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
}
function li$1(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "li";
}
function dt(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd")
  );
}
function dd$1(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
}
function rubyElement(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
}
function optgroup(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "optgroup";
}
function option(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
}
function thead(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return Boolean(
    next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot")
  );
}
function tbody$1(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
}
function tfoot(_22, index2, parent) {
  return !siblingAfter(parent, index2);
}
function tr$1(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && next.tagName === "tr";
}
function cells(_22, index2, parent) {
  const next = siblingAfter(parent, index2);
  return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
}
const opening = omission({
  body,
  colgroup,
  head,
  html: html$2,
  tbody
});
function html$2(node2) {
  const head2 = siblingAfter(node2, -1);
  return !head2 || head2.type !== "comment";
}
function head(node2) {
  const children2 = node2.children;
  const seen = [];
  let index2 = -1;
  while (++index2 < children2.length) {
    const child = children2[index2];
    if (child.type === "element" && (child.tagName === "title" || child.tagName === "base")) {
      if (seen.includes(child.tagName))
        return false;
      seen.push(child.tagName);
    }
  }
  return children2.length > 0;
}
function body(node2) {
  const head2 = siblingAfter(node2, -1, true);
  return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
}
function colgroup(node2, index2, parent) {
  const previous2 = siblingBefore(parent, index2);
  const head2 = siblingAfter(node2, -1, true);
  if (parent && previous2 && previous2.type === "element" && previous2.tagName === "colgroup" && closing(previous2, parent.children.indexOf(previous2), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "col");
}
function tbody(node2, index2, parent) {
  const previous2 = siblingBefore(parent, index2);
  const head2 = siblingAfter(node2, -1);
  if (parent && previous2 && previous2.type === "element" && (previous2.tagName === "thead" || previous2.tagName === "tbody") && closing(previous2, parent.children.indexOf(previous2), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "tr");
}
const constants = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
    [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
    ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function element$1(node2, index2, parent, state) {
  const schema = state.schema;
  const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
  let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node2.tagName.toLowerCase());
  const parts = [];
  let last;
  if (schema.space === "html" && node2.tagName === "svg") {
    state.schema = svg;
  }
  const attrs = serializeAttributes(state, node2.properties);
  const content2 = state.all(
    schema.space === "html" && node2.tagName === "template" ? node2.content : node2
  );
  state.schema = schema;
  if (content2)
    selfClosing = false;
  if (attrs || !omit || !opening(node2, index2, parent)) {
    parts.push("<", node2.tagName, attrs ? " " + attrs : "");
    if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
      last = attrs.charAt(attrs.length - 1);
      if (!state.settings.tightSelfClosing || last === "/" || last && last !== '"' && last !== "'") {
        parts.push(" ");
      }
      parts.push("/");
    }
    parts.push(">");
  }
  parts.push(content2);
  if (!selfClosing && (!omit || !closing(node2, index2, parent))) {
    parts.push("</" + node2.tagName + ">");
  }
  return parts.join("");
}
function serializeAttributes(state, props) {
  const values = [];
  let index2 = -1;
  let key2;
  if (props) {
    for (key2 in props) {
      if (props[key2] !== null && props[key2] !== void 0) {
        const value = serializeAttribute(state, key2, props[key2]);
        if (value)
          values.push(value);
      }
    }
  }
  while (++index2 < values.length) {
    const last = state.settings.tightAttributes ? values[index2].charAt(values[index2].length - 1) : void 0;
    if (index2 !== values.length - 1 && last !== '"' && last !== "'") {
      values[index2] += " ";
    }
  }
  return values.join("");
}
function serializeAttribute(state, key2, value) {
  const info2 = find(state.schema, key2);
  const x22 = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
  const y22 = state.settings.allowDangerousCharacters ? 0 : 1;
  let quote = state.quote;
  let result;
  if (info2.overloadedBoolean && (value === info2.attribute || value === "")) {
    value = true;
  } else if (info2.boolean || info2.overloadedBoolean && typeof value !== "string") {
    value = Boolean(value);
  }
  if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
    return "";
  }
  const name2 = stringifyEntities(
    info2.attribute,
    Object.assign({}, state.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: constants.name[x22][y22]
    })
  );
  if (value === true)
    return name2;
  value = Array.isArray(value) ? (info2.commaSeparated ? stringify : stringify$1)(value, {
    padLeft: !state.settings.tightCommaSeparatedLists
  }) : String(value);
  if (state.settings.collapseEmptyAttributes && !value)
    return name2;
  if (state.settings.preferUnquoted) {
    result = stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        attribute: true,
        subset: constants.unquoted[x22][y22]
      })
    );
  }
  if (result !== value) {
    if (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative)) {
      quote = state.alternative;
    }
    result = quote + stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: (quote === "'" ? constants.single : constants.double)[x22][y22],
        attribute: true
      })
    ) + quote;
  }
  return name2 + (result ? "=" + result : result);
}
function text$5(node2, _22, parent, state) {
  return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node2.value : stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: ["<", "&"]
    })
  );
}
function raw(node2, index2, parent, state) {
  return state.settings.allowDangerousHtml ? node2.value : text$5(node2, index2, parent, state);
}
function root$2(node2, _12, _22, state) {
  return state.all(node2);
}
zwitch("type", {
  invalid,
  unknown,
  handlers: { comment, doctype, element: element$1, raw, root: root$2, text: text$5 }
});
function invalid(node2) {
  throw new Error("Expected node, not `" + node2 + "`");
}
function unknown(node_) {
  const node2 = (
    /** @type {Nodes} */
    node_
  );
  throw new Error("Cannot compile unknown node `" + node2.type + "`");
}
const unicodePunctuationInternal = regexCheck(/\p{P}/u);
const asciiAlpha = regexCheck(/[A-Za-z]/);
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
function asciiControl(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < 32 || code2 === 127)
  );
}
const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
function unicodePunctuation(code2) {
  return asciiPunctuation(code2) || unicodePunctuationInternal(code2);
}
const unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex2) {
  return check;
  function check(code2) {
    return code2 !== null && code2 > -1 && regex2.test(String.fromCharCode(code2));
  }
}
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
/** @type {(node?: unknown) => node is PhrasingContent} */
convert([
  "break",
  "delete",
  "emphasis",
  "footnote",
  "footnoteReference",
  "image",
  "imageReference",
  "inlineCode",
  "link",
  "linkReference",
  "strong",
  "text"
]);
document.createElement("i");
function splice(list2, start, remove2, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove2 = remove2 > 0 ? remove2 : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove2);
    list2.splice(...parameters);
  } else {
    if (remove2)
      list2.splice(start, remove2);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list2.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}
const wwwPrefix = {
  tokenize: tokenizeWwwPrefix,
  partial: true
};
const domain = {
  tokenize: tokenizeDomain,
  partial: true
};
const path$1 = {
  tokenize: tokenizePath,
  partial: true
};
const trail = {
  tokenize: tokenizeTrail,
  partial: true
};
const emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
const wwwAutolink = {
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
const protocolAutolink = {
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
const emailAutolink = {
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
const text$3 = {};
let code$1 = 48;
while (code$1 < 123) {
  text$3[code$1] = emailAutolink;
  code$1++;
  if (code$1 === 58)
    code$1 = 65;
  else if (code$1 === 91)
    code$1 = 97;
}
text$3[43] = emailAutolink;
text$3[45] = emailAutolink;
text$3[46] = emailAutolink;
text$3[95] = emailAutolink;
text$3[72] = [emailAutolink, protocolAutolink];
text$3[104] = [emailAutolink, protocolAutolink];
text$3[87] = [emailAutolink, wwwAutolink];
text$3[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok2, nok) {
  const self2 = this;
  let dot;
  let data;
  return start;
  function start(code2) {
    if (!gfmAtext(code2) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code2);
  }
  function atext(code2) {
    if (gfmAtext(code2)) {
      effects.consume(code2);
      return atext;
    }
    if (code2 === 64) {
      effects.consume(code2);
      return emailDomain;
    }
    return nok(code2);
  }
  function emailDomain(code2) {
    if (code2 === 46) {
      return effects.check(
        emailDomainDotTrail,
        emailDomainAfter,
        emailDomainDot
      )(code2);
    }
    if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
      data = true;
      effects.consume(code2);
      return emailDomain;
    }
    return emailDomainAfter(code2);
  }
  function emailDomainDot(code2) {
    effects.consume(code2);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code2) {
    if (data && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeWwwAutolink(effects, ok2, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code2) {
    if (code2 !== 87 && code2 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(
      wwwPrefix,
      effects.attempt(domain, effects.attempt(path$1, wwwAfter), nok),
      nok
    )(code2);
  }
  function wwwAfter(code2) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeProtocolAutolink(effects, ok2, nok) {
  const self2 = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code2) {
    if ((code2 === 72 || code2 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code2);
      effects.consume(code2);
      return protocolPrefixInside;
    }
    return nok(code2);
  }
  function protocolPrefixInside(code2) {
    if (asciiAlpha(code2) && buffer.length < 5) {
      buffer += String.fromCodePoint(code2);
      effects.consume(code2);
      return protocolPrefixInside;
    }
    if (code2 === 58) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code2);
        return protocolSlashesInside;
      }
    }
    return nok(code2);
  }
  function protocolSlashesInside(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code2);
  }
  function afterProtocol(code2) {
    return code2 === null || asciiControl(code2) || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path$1, protocolAfter), nok)(code2);
  }
  function protocolAfter(code2) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeWwwPrefix(effects, ok2, nok) {
  let size = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code2) {
    if ((code2 === 87 || code2 === 119) && size < 3) {
      size++;
      effects.consume(code2);
      return wwwPrefixInside;
    }
    if (code2 === 46 && size === 3) {
      effects.consume(code2);
      return wwwPrefixAfter;
    }
    return nok(code2);
  }
  function wwwPrefixAfter(code2) {
    return code2 === null ? nok(code2) : ok2(code2);
  }
}
function tokenizeDomain(effects, ok2, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code2) {
    if (code2 === 46 || code2 === 95) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code2);
    }
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
      return domainAfter(code2);
    }
    seen = true;
    effects.consume(code2);
    return domainInside;
  }
  function domainAtPunctuation(code2) {
    if (code2 === 95) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code2);
    return domainInside;
  }
  function domainAfter(code2) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code2);
    }
    return ok2(code2);
  }
}
function tokenizePath(effects, ok2) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code2) {
    if (code2 === 40) {
      sizeOpen++;
      effects.consume(code2);
      return pathInside;
    }
    if (code2 === 41 && sizeClose < sizeOpen) {
      return pathAtPunctuation(code2);
    }
    if (code2 === 33 || code2 === 34 || code2 === 38 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 93 || code2 === 95 || code2 === 126) {
      return effects.check(trail, ok2, pathAtPunctuation)(code2);
    }
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return ok2(code2);
    }
    effects.consume(code2);
    return pathInside;
  }
  function pathAtPunctuation(code2) {
    if (code2 === 41) {
      sizeClose++;
    }
    effects.consume(code2);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok2, nok) {
  return trail2;
  function trail2(code2) {
    if (code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 63 || code2 === 95 || code2 === 126) {
      effects.consume(code2);
      return trail2;
    }
    if (code2 === 38) {
      effects.consume(code2);
      return trailCharRefStart;
    }
    if (code2 === 93) {
      effects.consume(code2);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code2 === 60 || // So is whitespace.
      code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)
    ) {
      return ok2(code2);
    }
    return nok(code2);
  }
  function trailBracketAfter(code2) {
    if (code2 === null || code2 === 40 || code2 === 91 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return ok2(code2);
    }
    return trail2(code2);
  }
  function trailCharRefStart(code2) {
    return asciiAlpha(code2) ? trailCharRefInside(code2) : nok(code2);
  }
  function trailCharRefInside(code2) {
    if (code2 === 59) {
      effects.consume(code2);
      return trail2;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return trailCharRefInside;
    }
    return nok(code2);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    return asciiAlphanumeric(code2) ? nok(code2) : ok2(code2);
  }
}
function previousWww(code2) {
  return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 91 || code2 === 93 || code2 === 126 || markdownLineEndingOrSpace(code2);
}
function previousProtocol(code2) {
  return !asciiAlpha(code2);
}
function previousEmail(code2) {
  return !(code2 === 47 || gfmAtext(code2));
}
function gfmAtext(code2) {
  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token = events[index2][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}
function factorySpace(effects, ok2, type, max2) {
  const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok2(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok2(code2);
  }
}
function factoryDestination(effects, ok2, nok, type, literalType2, literalMarkerType, rawType, stringType2, max2) {
  const limit = max2 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === 60) {
      effects.enter(type);
      effects.enter(literalType2);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType2);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw2(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType2);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType2);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType2);
      return enclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw2(code2) {
    if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
      effects.exit("chunkString");
      effects.exit(stringType2);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code2);
    }
    if (balance < limit && code2 === 40) {
      effects.consume(code2);
      balance++;
      return raw2;
    }
    if (code2 === 41) {
      effects.consume(code2);
      balance--;
      return raw2;
    }
    if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? rawEscape : raw2;
  }
  function rawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return raw2;
    }
    return raw2(code2);
  }
}
function factoryLabel(effects, ok2, nok, type, markerType, stringType2) {
  const self2 = this;
  let size = 0;
  let seen;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType2);
    return atBreak;
  }
  function atBreak(code2) {
    if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType2);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen)
      seen = !markdownSpace(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
}
function factoryTitle(effects, ok2, nok, type, markerType, stringType2) {
  let marker;
  return start;
  function start(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === 40 ? 41 : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType2);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType2);
      return begin(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside2(code2);
  }
  function inside2(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? escape2 : inside2;
  }
  function escape2(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return inside2;
    }
    return inside2(code2);
  }
}
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        start,
        seen ? "linePrefix" : "lineSuffix"
      )(code2);
    }
    return ok2(code2);
  }
}
const labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
const resourceConstruct = {
  tokenize: tokenizeResource
};
const referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
const referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text2 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text2, context]]);
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text2, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({
          start: labelStart.end,
          end: self2.now()
        })
      )
    );
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code2) {
    if (code2 === 40) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code2);
    }
    if (code2 === 91) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code2);
  }
  function labelEndOk(code2) {
    return ok2(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === 41) {
      return resourceEnd(code2);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        "resourceTitle",
        "resourceTitleMarker",
        "resourceTitleString"
      )(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok2, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      "reference",
      "referenceMarker",
      "referenceString"
    )(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok2(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}
({
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
});
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
({
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
});
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point$1(value);
  }
  return "";
}
function point$1(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
function bail(error2) {
  if (error2) {
    throw error2;
  }
}
var hasOwn$1 = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray2 = function isArray22(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject$1 = function isPlainObject3(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn$1.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn$1.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key2;
  for (key2 in obj) {
  }
  return typeof key2 === "undefined" || hasOwn$1.call(obj, key2);
};
var setProperty2 = function setProperty22(target, options) {
  if (defineProperty && options.name === "__proto__") {
    defineProperty(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty2 = function getProperty22(obj, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn$1.call(obj, name2)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name2).value;
    }
  }
  return obj[name2];
};
var extend2 = function extend22() {
  var options, name2, src, copy, copyIsArray, clone;
  var target = arguments[0];
  var i22 = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i22 = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i22 < length; ++i22) {
    options = arguments[i22];
    if (options != null) {
      for (name2 in options) {
        src = getProperty2(target, name2);
        copy = getProperty2(options, name2);
        if (target !== copy) {
          if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray2(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray2(src) ? src : [];
            } else {
              clone = src && isPlainObject$1(src) ? src : {};
            }
            setProperty2(target, { name: name2, newValue: extend22(deep, clone, copy) });
          } else if (typeof copy !== "undefined") {
            setProperty2(target, { name: name2, newValue: copy });
          }
        }
      }
    }
  }
  return target;
};
const extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend2);
function isPlainObject22(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
  const fns = [];
  const pipeline = { run, use: use2 };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error2, ...output) {
      const fn2 = fns[++middlewareIndex];
      let index2 = -1;
      if (error2) {
        callback(error2);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn2) {
        wrap(fn2, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use2(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error2) {
      const exception = (
        /** @type {Error} */
        error2
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result instanceof Promise) {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error2, ...output) {
    if (!called) {
      called = true;
      callback(error2, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
class VFileMessage2 extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index2);
        options.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start ? start.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start ? start.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
}
VFileMessage2.prototype.file = "";
VFileMessage2.prototype.name = "";
VFileMessage2.prototype.reason = "";
VFileMessage2.prototype.message = "";
VFileMessage2.prototype.stack = "";
VFileMessage2.prototype.column = void 0;
VFileMessage2.prototype.line = void 0;
VFileMessage2.prototype.ancestors = void 0;
VFileMessage2.prototype.cause = void 0;
VFileMessage2.prototype.fatal = void 0;
VFileMessage2.prototype.place = void 0;
VFileMessage2.prototype.ruleId = void 0;
VFileMessage2.prototype.source = void 0;
const path = { basename, dirname, extname, join, sep: "/" };
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.codePointAt(index2) === ext.codePointAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname(path2) {
  assertPath$1(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath$1(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.codePointAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$1(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path2) {
  assertPath$1(path2);
  const absolute = path2.codePointAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.codePointAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1)
        ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$1(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
const proc = { cwd };
function cwd() {
  return "/";
}
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error2 = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error2.code = "ERR_INVALID_ARG_TYPE";
    throw error2;
  }
  if (path2.protocol !== "file:") {
    const error2 = new TypeError("The URL must be of scheme file");
    error2.code = "ERR_INVALID_URL_SCHEME";
    throw error2;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error2 = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error2.code = "ERR_INVALID_FILE_URL_HOST";
    throw error2;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error2 = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error2.code = "ERR_INVALID_FILE_URL_PATH";
        throw error2;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class VFile2 {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array$1(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = proc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage2(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
}
function assertPart(part, name2) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath(path2, name2) {
  if (!path2) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function isUint8Array$1(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property) {
    const self2 = this;
    const constr = self2.constructor;
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const func = proto[property];
    const apply = function() {
      return func.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto);
    const names = Object.getOwnPropertyNames(func);
    for (const p22 of names) {
      const descriptor = Object.getOwnPropertyDescriptor(func, p22);
      if (descriptor)
        Object.defineProperty(apply, p22, descriptor);
    }
    return apply;
  }
);
const own = {}.hasOwnProperty;
class Processor2 extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor2()
    );
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data(extend$1(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > 👉 **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > 👉 **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key2] = value;
        return this;
      }
      return own.call(this.namespace, key2) && this.namespace[key2] || void 0;
    }
    if (key2) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key2;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > 👉 **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > 👉 **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error2, tree, file2) {
        if (error2 || !tree || !file2) {
          return realDone(error2);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error2,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error2, file2) {
        if (error2 || !file2) {
          reject(error2);
        } else if (resolve) {
          resolve(file2);
        } else {
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > 👉 **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    return result;
    function realDone(error2, file2) {
      complete = true;
      bail(error2);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > 👉 **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error2, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error2) {
          reject(error2);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > 👉 **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    return result;
    function realDone(error2, tree2) {
      bail(error2);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > 👉 **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > 👉 **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = extend$1(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0)
        ;
      else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject22(currentPrimary) && isPlainObject22(primary)) {
          primary = extend$1(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
}
new Processor2().freeze();
function assertParser(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `parser`");
  }
}
function assertCompiler(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject22(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile2(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array(value);
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
function u$3(r22, n22, ...a22) {
  if (r22 in n22) {
    let e22 = n22[r22];
    return typeof e22 == "function" ? e22(...a22) : e22;
  }
  let t22 = new Error(`Tried to handle "${r22}" but there is no handler defined. Only defined handlers are: ${Object.keys(n22).map((e22) => `"${e22}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t22, u$3), t22;
}
var N$2 = ((o22) => (o22[o22.None = 0] = "None", o22[o22.RenderStrategy = 1] = "RenderStrategy", o22[o22.Static = 2] = "Static", o22))(N$2 || {}), S$2 = ((e22) => (e22[e22.Unmount = 0] = "Unmount", e22[e22.Hidden = 1] = "Hidden", e22))(S$2 || {});
function H$1({ visible: r22 = true, features: t22 = 0, ourProps: e22, theirProps: o22, ...i22 }) {
  var a22;
  let n22 = j(o22, e22), l22 = Object.assign(i22, { props: n22 });
  if (r22 || t22 & 2 && n22.static)
    return y$2(l22);
  if (t22 & 1) {
    let d22 = (a22 = n22.unmount) == null || a22 ? 0 : 1;
    return u$3(d22, { [0]() {
      return null;
    }, [1]() {
      return y$2({ ...i22, props: { ...n22, hidden: true, style: { display: "none" } } });
    } });
  }
  return y$2(l22);
}
function y$2({ props: r22, attrs: t22, slots: e22, slot: o22, name: i22 }) {
  var m22, h22;
  let { as: n22, ...l22 } = T$1(r22, ["unmount", "static"]), a22 = (m22 = e22.default) == null ? void 0 : m22.call(e22, o22), d22 = {};
  if (o22) {
    let u22 = false, c22 = [];
    for (let [p22, f22] of Object.entries(o22))
      typeof f22 == "boolean" && (u22 = true), f22 === true && c22.push(p22);
    u22 && (d22["data-headlessui-state"] = c22.join(" "));
  }
  if (n22 === "template") {
    if (a22 = b$1(a22 != null ? a22 : []), Object.keys(l22).length > 0 || Object.keys(t22).length > 0) {
      let [u22, ...c22] = a22 != null ? a22 : [];
      if (!v$1(u22) || c22.length > 0)
        throw new Error(['Passing props on "template"!', "", `The current component <${i22} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(l22).concat(Object.keys(t22)).map((s22) => s22.trim()).filter((s22, g, R10) => R10.indexOf(s22) === g).sort((s22, g) => s22.localeCompare(g)).map((s22) => `  - ${s22}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map((s22) => `  - ${s22}`).join(`
`)].join(`
`));
      let p22 = j((h22 = u22.props) != null ? h22 : {}, l22), f22 = cloneVNode(u22, p22);
      for (let s22 in p22)
        s22.startsWith("on") && (f22.props || (f22.props = {}), f22.props[s22] = p22[s22]);
      return f22;
    }
    return Array.isArray(a22) && a22.length === 1 ? a22[0] : a22;
  }
  return h$3(n22, Object.assign({}, l22, d22), { default: () => a22 });
}
function b$1(r22) {
  return r22.flatMap((t22) => t22.type === Fragment ? b$1(t22.children) : [t22]);
}
function j(...r22) {
  if (r22.length === 0)
    return {};
  if (r22.length === 1)
    return r22[0];
  let t22 = {}, e22 = {};
  for (let i22 of r22)
    for (let n22 in i22)
      n22.startsWith("on") && typeof i22[n22] == "function" ? (e22[n22] != null || (e22[n22] = []), e22[n22].push(i22[n22])) : t22[n22] = i22[n22];
  if (t22.disabled || t22["aria-disabled"])
    return Object.assign(t22, Object.fromEntries(Object.keys(e22).map((i22) => [i22, void 0])));
  for (let i22 in e22)
    Object.assign(t22, { [i22](n22, ...l22) {
      let a22 = e22[i22];
      for (let d22 of a22) {
        if (n22 instanceof Event && n22.defaultPrevented)
          return;
        d22(n22, ...l22);
      }
    } });
  return t22;
}
function T$1(r22, t22 = []) {
  let e22 = Object.assign({}, r22);
  for (let o22 of t22)
    o22 in e22 && delete e22[o22];
  return e22;
}
function v$1(r22) {
  return r22 == null ? false : typeof r22.type == "string" || typeof r22.type == "object" || typeof r22.type == "function";
}
let e$1 = 0;
function n$3() {
  return ++e$1;
}
function t$4() {
  return n$3();
}
var o$2 = ((r22) => (r22.Space = " ", r22.Enter = "Enter", r22.Escape = "Escape", r22.Backspace = "Backspace", r22.Delete = "Delete", r22.ArrowLeft = "ArrowLeft", r22.ArrowUp = "ArrowUp", r22.ArrowRight = "ArrowRight", r22.ArrowDown = "ArrowDown", r22.Home = "Home", r22.End = "End", r22.PageUp = "PageUp", r22.PageDown = "PageDown", r22.Tab = "Tab", r22))(o$2 || {});
function o$1(n22) {
  var l22;
  return n22 == null || n22.value == null ? null : (l22 = n22.value.$el) != null ? l22 : n22.value;
}
let n$2 = Symbol("Context");
var l$1 = ((e22) => (e22[e22.Open = 1] = "Open", e22[e22.Closed = 2] = "Closed", e22[e22.Closing = 4] = "Closing", e22[e22.Opening = 8] = "Opening", e22))(l$1 || {});
function p$3() {
  return inject(n$2, null);
}
var i$1 = Object.defineProperty;
var d$2 = (t22, e22, r22) => e22 in t22 ? i$1(t22, e22, { enumerable: true, configurable: true, writable: true, value: r22 }) : t22[e22] = r22;
var n$1 = (t22, e22, r22) => (d$2(t22, typeof e22 != "symbol" ? e22 + "" : e22, r22), r22);
class s {
  constructor() {
    n$1(this, "current", this.detect());
    n$1(this, "currentId", 0);
  }
  set(e22) {
    this.current !== e22 && (this.currentId = 0, this.current = e22);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
}
let c$2 = new s();
function m$2(r22) {
  if (c$2.isServer)
    return null;
  if (r22 instanceof Node)
    return r22.ownerDocument;
  if (r22 != null && r22.hasOwnProperty("value")) {
    let n22 = o$1(r22);
    if (n22)
      return n22.ownerDocument;
  }
  return document;
}
let c$1 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e22) => `${e22}:not([tabindex='-1'])`).join(",");
var N$1 = ((n22) => (n22[n22.First = 1] = "First", n22[n22.Previous = 2] = "Previous", n22[n22.Next = 4] = "Next", n22[n22.Last = 8] = "Last", n22[n22.WrapAround = 16] = "WrapAround", n22[n22.NoScroll = 32] = "NoScroll", n22))(N$1 || {}), T = ((o22) => (o22[o22.Error = 0] = "Error", o22[o22.Overflow = 1] = "Overflow", o22[o22.Success = 2] = "Success", o22[o22.Underflow = 3] = "Underflow", o22))(T || {}), F$1 = ((t22) => (t22[t22.Previous = -1] = "Previous", t22[t22.Next = 1] = "Next", t22))(F$1 || {});
function E$4(e22 = document.body) {
  return e22 == null ? [] : Array.from(e22.querySelectorAll(c$1)).sort((r22, t22) => Math.sign((r22.tabIndex || Number.MAX_SAFE_INTEGER) - (t22.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var h$1 = ((t22) => (t22[t22.Strict = 0] = "Strict", t22[t22.Loose = 1] = "Loose", t22))(h$1 || {});
function w$2(e22, r22 = 0) {
  var t22;
  return e22 === ((t22 = m$2(e22)) == null ? void 0 : t22.body) ? false : u$3(r22, { [0]() {
    return e22.matches(c$1);
  }, [1]() {
    let l22 = e22;
    for (; l22 !== null; ) {
      if (l22.matches(c$1))
        return true;
      l22 = l22.parentElement;
    }
    return false;
  } });
}
var y$1 = ((t22) => (t22[t22.Keyboard = 0] = "Keyboard", t22[t22.Mouse = 1] = "Mouse", t22))(y$1 || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e22) => {
  e22.metaKey || e22.altKey || e22.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e22) => {
  e22.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e22.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function S$1(e22) {
  e22 == null || e22.focus({ preventScroll: true });
}
let H = ["textarea", "input"].join(",");
function I(e22) {
  var r22, t22;
  return (t22 = (r22 = e22 == null ? void 0 : e22.matches) == null ? void 0 : r22.call(e22, H)) != null ? t22 : false;
}
function O(e22, r22 = (t22) => t22) {
  return e22.slice().sort((t22, l22) => {
    let o22 = r22(t22), i22 = r22(l22);
    if (o22 === null || i22 === null)
      return 0;
    let n22 = o22.compareDocumentPosition(i22);
    return n22 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : n22 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function P$1(e22, r22, { sorted: t22 = true, relativeTo: l22 = null, skipElements: o22 = [] } = {}) {
  var m22;
  let i22 = (m22 = Array.isArray(e22) ? e22.length > 0 ? e22[0].ownerDocument : document : e22 == null ? void 0 : e22.ownerDocument) != null ? m22 : document, n22 = Array.isArray(e22) ? t22 ? O(e22) : e22 : E$4(e22);
  o22.length > 0 && n22.length > 1 && (n22 = n22.filter((s22) => !o22.includes(s22))), l22 = l22 != null ? l22 : i22.activeElement;
  let x22 = (() => {
    if (r22 & 5)
      return 1;
    if (r22 & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), p22 = (() => {
    if (r22 & 1)
      return 0;
    if (r22 & 2)
      return Math.max(0, n22.indexOf(l22)) - 1;
    if (r22 & 4)
      return Math.max(0, n22.indexOf(l22)) + 1;
    if (r22 & 8)
      return n22.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), L22 = r22 & 32 ? { preventScroll: true } : {}, a22 = 0, d22 = n22.length, u22;
  do {
    if (a22 >= d22 || a22 + d22 <= 0)
      return 0;
    let s22 = p22 + a22;
    if (r22 & 16)
      s22 = (s22 + d22) % d22;
    else {
      if (s22 < 0)
        return 3;
      if (s22 >= d22)
        return 1;
    }
    u22 = n22[s22], u22 == null || u22.focus(L22), a22 += x22;
  } while (u22 !== i22.activeElement);
  return r22 & 6 && I(u22) && u22.select(), 2;
}
function u$2(e22, t22, n22) {
  c$2.isServer || watchEffect((o22) => {
    document.addEventListener(e22, t22, n22), o22(() => document.removeEventListener(e22, t22, n22));
  });
}
function w$1(e22, n22, t22) {
  c$2.isServer || watchEffect((o22) => {
    window.addEventListener(e22, n22, t22), o22(() => window.removeEventListener(e22, n22, t22));
  });
}
function y(f22, c22, i22 = computed(() => true)) {
  function a22(e22, r22) {
    if (!i22.value || e22.defaultPrevented)
      return;
    let t22 = r22(e22);
    if (t22 === null || !t22.getRootNode().contains(t22))
      return;
    let m22 = function o22(n22) {
      return typeof n22 == "function" ? o22(n22()) : Array.isArray(n22) || n22 instanceof Set ? n22 : [n22];
    }(f22);
    for (let o22 of m22) {
      if (o22 === null)
        continue;
      let n22 = o22 instanceof HTMLElement ? o22 : o$1(o22);
      if (n22 != null && n22.contains(t22) || e22.composed && e22.composedPath().includes(n22))
        return;
    }
    return !w$2(t22, h$1.Loose) && t22.tabIndex !== -1 && e22.preventDefault(), c22(e22, t22);
  }
  let u22 = ref(null);
  u$2("pointerdown", (e22) => {
    var r22, t22;
    i22.value && (u22.value = ((t22 = (r22 = e22.composedPath) == null ? void 0 : r22.call(e22)) == null ? void 0 : t22[0]) || e22.target);
  }, true), u$2("mousedown", (e22) => {
    var r22, t22;
    i22.value && (u22.value = ((t22 = (r22 = e22.composedPath) == null ? void 0 : r22.call(e22)) == null ? void 0 : t22[0]) || e22.target);
  }, true), u$2("click", (e22) => {
    u22.value && (a22(e22, () => u22.value), u22.value = null);
  }, true), u$2("touchend", (e22) => a22(e22, () => e22.target instanceof HTMLElement ? e22.target : null), true), w$1("blur", (e22) => a22(e22, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}
var a$2 = ((e22) => (e22[e22.None = 1] = "None", e22[e22.Focusable = 2] = "Focusable", e22[e22.Hidden = 4] = "Hidden", e22))(a$2 || {});
let f$1 = defineComponent({ name: "Hidden", props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } }, setup(r22, { slots: t22, attrs: d22 }) {
  return () => {
    let { features: e22, ...o22 } = r22, n22 = { "aria-hidden": (e22 & 2) === 2 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(e22 & 4) === 4 && (e22 & 2) !== 2 && { display: "none" } } };
    return H$1({ ourProps: n22, theirProps: o22, slot: {}, attrs: d22, slots: t22, name: "Hidden" });
  };
} });
function t$3() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function t$2(e22) {
  typeof queueMicrotask == "function" ? queueMicrotask(e22) : Promise.resolve().then(e22).catch((o22) => setTimeout(() => {
    throw o22;
  }));
}
function o() {
  let a22 = [], s22 = { addEventListener(e22, t22, r22, i22) {
    return e22.addEventListener(t22, r22, i22), s22.add(() => e22.removeEventListener(t22, r22, i22));
  }, requestAnimationFrame(...e22) {
    let t22 = requestAnimationFrame(...e22);
    s22.add(() => cancelAnimationFrame(t22));
  }, nextFrame(...e22) {
    s22.requestAnimationFrame(() => {
      s22.requestAnimationFrame(...e22);
    });
  }, setTimeout(...e22) {
    let t22 = setTimeout(...e22);
    s22.add(() => clearTimeout(t22));
  }, microTask(...e22) {
    let t22 = { current: true };
    return t$2(() => {
      t22.current && e22[0]();
    }), s22.add(() => {
      t22.current = false;
    });
  }, style(e22, t22, r22) {
    let i22 = e22.style.getPropertyValue(t22);
    return Object.assign(e22.style, { [t22]: r22 }), this.add(() => {
      Object.assign(e22.style, { [t22]: i22 });
    });
  }, group(e22) {
    let t22 = o();
    return e22(t22), this.add(() => t22.dispose());
  }, add(e22) {
    return a22.push(e22), () => {
      let t22 = a22.indexOf(e22);
      if (t22 >= 0)
        for (let r22 of a22.splice(t22, 1))
          r22();
    };
  }, dispose() {
    for (let e22 of a22.splice(0))
      e22();
  } };
  return s22;
}
var d$1 = ((r22) => (r22[r22.Forwards = 0] = "Forwards", r22[r22.Backwards = 1] = "Backwards", r22))(d$1 || {});
function n() {
  let o22 = ref(0);
  return w$1("keydown", (e22) => {
    e22.key === "Tab" && (o22.value = e22.shiftKey ? 1 : 0);
  }), o22;
}
function E$3(n22, e22, o22, r22) {
  c$2.isServer || watchEffect((t22) => {
    n22 = n22 != null ? n22 : window, n22.addEventListener(e22, o22, r22), t22(() => n22.removeEventListener(e22, o22, r22));
  });
}
function t$1(n22) {
  function e22() {
    document.readyState !== "loading" && (n22(), document.removeEventListener("DOMContentLoaded", e22));
  }
  typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("DOMContentLoaded", e22), e22());
}
function B(e22) {
  if (!e22)
    return /* @__PURE__ */ new Set();
  if (typeof e22 == "function")
    return new Set(e22());
  let t22 = /* @__PURE__ */ new Set();
  for (let l22 of e22.value) {
    let o22 = o$1(l22);
    o22 instanceof HTMLElement && t22.add(o22);
  }
  return t22;
}
var A = ((n22) => (n22[n22.None = 1] = "None", n22[n22.InitialFocus = 2] = "InitialFocus", n22[n22.TabLock = 4] = "TabLock", n22[n22.FocusLock = 8] = "FocusLock", n22[n22.RestoreFocus = 16] = "RestoreFocus", n22[n22.All = 30] = "All", n22))(A || {});
let ce = Object.assign(defineComponent({ name: "FocusTrap", props: { as: { type: [Object, String], default: "div" }, initialFocus: { type: Object, default: null }, features: { type: Number, default: 30 }, containers: { type: [Object, Function], default: ref(/* @__PURE__ */ new Set()) } }, inheritAttrs: false, setup(e22, { attrs: t22, slots: l22, expose: o22 }) {
  let r22 = ref(null);
  o22({ el: r22, $el: r22 });
  let i22 = computed(() => m$2(r22)), n$12 = ref(false);
  onMounted(() => n$12.value = true), onUnmounted(() => n$12.value = false), z({ ownerDocument: i22 }, computed(() => n$12.value && Boolean(e22.features & 16)));
  let m22 = J({ ownerDocument: i22, container: r22, initialFocus: computed(() => e22.initialFocus) }, computed(() => n$12.value && Boolean(e22.features & 2)));
  Q({ ownerDocument: i22, container: r22, containers: e22.containers, previousActiveElement: m22 }, computed(() => n$12.value && Boolean(e22.features & 8)));
  let c22 = n();
  function u22(a22) {
    let d22 = o$1(r22);
    if (!d22)
      return;
    ((g) => g())(() => {
      u$3(c22.value, { [d$1.Forwards]: () => {
        P$1(d22, N$1.First, { skipElements: [a22.relatedTarget] });
      }, [d$1.Backwards]: () => {
        P$1(d22, N$1.Last, { skipElements: [a22.relatedTarget] });
      } });
    });
  }
  let s22 = ref(false);
  function H22(a22) {
    a22.key === "Tab" && (s22.value = true, requestAnimationFrame(() => {
      s22.value = false;
    }));
  }
  function M22(a22) {
    if (!n$12.value)
      return;
    let d22 = B(e22.containers);
    o$1(r22) instanceof HTMLElement && d22.add(o$1(r22));
    let E22 = a22.relatedTarget;
    E22 instanceof HTMLElement && E22.dataset.headlessuiFocusGuard !== "true" && (N(d22, E22) || (s22.value ? P$1(o$1(r22), u$3(c22.value, { [d$1.Forwards]: () => N$1.Next, [d$1.Backwards]: () => N$1.Previous }) | N$1.WrapAround, { relativeTo: a22.target }) : a22.target instanceof HTMLElement && S$1(a22.target)));
  }
  return () => {
    let a22 = {}, d22 = { ref: r22, onKeydown: H22, onFocusout: M22 }, { features: E22, initialFocus: g, containers: X10, ...O22 } = e22;
    return h$3(Fragment, [Boolean(E22 & 4) && h$3(f$1, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: u22, features: a$2.Focusable }), H$1({ ourProps: d22, theirProps: { ...t22, ...O22 }, slot: a22, attrs: t22, slots: l22, name: "FocusTrap" }), Boolean(E22 & 4) && h$3(f$1, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: u22, features: a$2.Focusable })]);
  };
} }), { features: A }), L = [];
t$1(() => {
  function e22(t22) {
    t22.target instanceof HTMLElement && t22.target !== document.body && L[0] !== t22.target && (L.unshift(t22.target), L = L.filter((l22) => l22 != null && l22.isConnected), L.splice(10));
  }
  window.addEventListener("click", e22, { capture: true }), window.addEventListener("mousedown", e22, { capture: true }), window.addEventListener("focus", e22, { capture: true }), document.body.addEventListener("click", e22, { capture: true }), document.body.addEventListener("mousedown", e22, { capture: true }), document.body.addEventListener("focus", e22, { capture: true });
});
function x(e22) {
  let t22 = ref(L.slice());
  return watch([e22], ([l22], [o22]) => {
    o22 === true && l22 === false ? t$2(() => {
      t22.value.splice(0);
    }) : o22 === false && l22 === true && (t22.value = L.slice());
  }, { flush: "post" }), () => {
    var l22;
    return (l22 = t22.value.find((o22) => o22 != null && o22.isConnected)) != null ? l22 : null;
  };
}
function z({ ownerDocument: e22 }, t22) {
  let l22 = x(t22);
  onMounted(() => {
    watchEffect(() => {
      var o22, r22;
      t22.value || ((o22 = e22.value) == null ? void 0 : o22.activeElement) === ((r22 = e22.value) == null ? void 0 : r22.body) && S$1(l22());
    }, { flush: "post" });
  }), onUnmounted(() => {
    t22.value && S$1(l22());
  });
}
function J({ ownerDocument: e22, container: t22, initialFocus: l22 }, o22) {
  let r22 = ref(null), i22 = ref(false);
  return onMounted(() => i22.value = true), onUnmounted(() => i22.value = false), onMounted(() => {
    watch([t22, l22, o22], (n22, m22) => {
      if (n22.every((u22, s22) => (m22 == null ? void 0 : m22[s22]) === u22) || !o22.value)
        return;
      let c22 = o$1(t22);
      c22 && t$2(() => {
        var H22, M22;
        if (!i22.value)
          return;
        let u22 = o$1(l22), s22 = (H22 = e22.value) == null ? void 0 : H22.activeElement;
        if (u22) {
          if (u22 === s22) {
            r22.value = s22;
            return;
          }
        } else if (c22.contains(s22)) {
          r22.value = s22;
          return;
        }
        u22 ? S$1(u22) : P$1(c22, N$1.First | N$1.NoScroll) === T.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), r22.value = (M22 = e22.value) == null ? void 0 : M22.activeElement;
      });
    }, { immediate: true, flush: "post" });
  }), r22;
}
function Q({ ownerDocument: e22, container: t22, containers: l22, previousActiveElement: o22 }, r22) {
  var i22;
  E$3((i22 = e22.value) == null ? void 0 : i22.defaultView, "focus", (n22) => {
    if (!r22.value)
      return;
    let m22 = B(l22);
    o$1(t22) instanceof HTMLElement && m22.add(o$1(t22));
    let c22 = o22.value;
    if (!c22)
      return;
    let u22 = n22.target;
    u22 && u22 instanceof HTMLElement ? N(m22, u22) ? (o22.value = u22, S$1(u22)) : (n22.preventDefault(), n22.stopPropagation(), S$1(c22)) : S$1(o22.value);
  }, true);
}
function N(e22, t22) {
  for (let l22 of e22)
    if (l22.contains(t22))
      return true;
  return false;
}
let i = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
function E$2(d22, f22 = ref(true)) {
  watchEffect((o22) => {
    var a22;
    if (!f22.value)
      return;
    let e22 = o$1(d22);
    if (!e22)
      return;
    o22(function() {
      var u22;
      if (!e22)
        return;
      let r22 = (u22 = t.get(e22)) != null ? u22 : 1;
      if (r22 === 1 ? t.delete(e22) : t.set(e22, r22 - 1), r22 !== 1)
        return;
      let n22 = i.get(e22);
      n22 && (n22["aria-hidden"] === null ? e22.removeAttribute("aria-hidden") : e22.setAttribute("aria-hidden", n22["aria-hidden"]), e22.inert = n22.inert, i.delete(e22));
    });
    let l22 = (a22 = t.get(e22)) != null ? a22 : 0;
    t.set(e22, l22 + 1), l22 === 0 && (i.set(e22, { "aria-hidden": e22.getAttribute("aria-hidden"), inert: e22.inert }), e22.setAttribute("aria-hidden", "true"), e22.inert = true);
  });
}
let e = Symbol("ForcePortalRootContext");
function u$1() {
  return inject(e, false);
}
let P = defineComponent({ name: "ForcePortalRoot", props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: false } }, setup(o22, { slots: t22, attrs: r22 }) {
  return provide(e, o22.force), () => {
    let { force: f22, ...n22 } = o22;
    return H$1({ theirProps: n22, ourProps: {}, slot: {}, slots: t22, attrs: r22, name: "ForcePortalRoot" });
  };
} });
function E$1(t22) {
  let e22 = m$2(t22);
  if (!e22) {
    if (t22 === null)
      return null;
    throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${t22}`);
  }
  let u22 = e22.getElementById("headlessui-portal-root");
  if (u22)
    return u22;
  let r22 = e22.createElement("div");
  return r22.setAttribute("id", "headlessui-portal-root"), e22.body.appendChild(r22);
}
let U = defineComponent({ name: "Portal", props: { as: { type: [Object, String], default: "div" } }, setup(t22, { slots: e22, attrs: u22 }) {
  let r22 = ref(null), i22 = computed(() => m$2(r22)), l22 = u$1(), n22 = inject(h, null), o22 = ref(l22 === true || n22 == null ? E$1(r22.value) : n22.resolveTarget());
  watchEffect(() => {
    l22 || n22 != null && (o22.value = n22.resolveTarget());
  });
  let d22 = inject(f, null);
  return onMounted(() => {
    let a22 = o$1(r22);
    a22 && d22 && onUnmounted(d22.register(a22));
  }), onUnmounted(() => {
    var v22, P22;
    let a22 = (v22 = i22.value) == null ? void 0 : v22.getElementById("headlessui-portal-root");
    a22 && o22.value === a22 && o22.value.children.length <= 0 && ((P22 = o22.value.parentElement) == null || P22.removeChild(o22.value));
  }), () => {
    if (o22.value === null)
      return null;
    let a22 = { ref: r22, "data-headlessui-portal": "" };
    return h$3(Teleport, { to: o22.value }, H$1({ ourProps: a22, theirProps: t22, slot: {}, attrs: u22, slots: e22, name: "Portal" }));
  };
} }), f = Symbol("PortalParentContext");
function V() {
  let t22 = inject(f, null), e22 = ref([]);
  function u22(l22) {
    return e22.value.push(l22), t22 && t22.register(l22), () => r22(l22);
  }
  function r22(l22) {
    let n22 = e22.value.indexOf(l22);
    n22 !== -1 && e22.value.splice(n22, 1), t22 && t22.unregister(l22);
  }
  let i22 = { register: u22, unregister: r22, portals: e22 };
  return [e22, defineComponent({ name: "PortalWrapper", setup(l22, { slots: n22 }) {
    return provide(f, i22), () => {
      var o22;
      return (o22 = n22.default) == null ? void 0 : o22.call(n22);
    };
  } })];
}
let h = Symbol("PortalGroupContext"), _ = defineComponent({ name: "PortalGroup", props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } }, setup(t22, { attrs: e22, slots: u22 }) {
  let r22 = reactive({ resolveTarget() {
    return t22.target;
  } });
  return provide(h, r22), () => {
    let { target: i22, ...l22 } = t22;
    return H$1({ theirProps: l22, ourProps: {}, slot: {}, attrs: e22, slots: u22, name: "PortalGroup" });
  };
} });
let u = Symbol("StackContext");
var p$2 = ((e22) => (e22[e22.Add = 0] = "Add", e22[e22.Remove = 1] = "Remove", e22))(p$2 || {});
function v() {
  return inject(u, () => {
  });
}
function S({ type: o22, enabled: r22, element: e22, onUpdate: i22 }) {
  let a22 = v();
  function t22(...n22) {
    i22 == null || i22(...n22), a22(...n22);
  }
  onMounted(() => {
    watch(r22, (n22, d22) => {
      n22 ? t22(0, o22, e22) : d22 === true && t22(1, o22, e22);
    }, { immediate: true, flush: "sync" });
  }), onUnmounted(() => {
    r22.value && t22(1, o22, e22);
  }), provide(u, t22);
}
let p$1 = Symbol("DescriptionContext");
function b() {
  let t22 = inject(p$1, null);
  if (t22 === null)
    throw new Error("Missing parent");
  return t22;
}
function M$1({ slot: t22 = ref({}), name: i22 = "Description", props: o22 = {} } = {}) {
  let e22 = ref([]);
  function s22(n22) {
    return e22.value.push(n22), () => {
      let r22 = e22.value.indexOf(n22);
      r22 !== -1 && e22.value.splice(r22, 1);
    };
  }
  return provide(p$1, { register: s22, slot: t22, name: i22, props: o22 }), computed(() => e22.value.length > 0 ? e22.value.join(" ") : void 0);
}
defineComponent({ name: "Description", props: { as: { type: [Object, String], default: "p" }, id: { type: String, default: () => `headlessui-description-${t$4()}` } }, setup(t22, { attrs: i22, slots: o22 }) {
  let e22 = b();
  return onMounted(() => onUnmounted(e22.register(t22.id))), () => {
    let { name: s22 = "Description", slot: n22 = ref({}), props: r22 = {} } = e22, { id: d22, ...l22 } = t22, c22 = { ...Object.entries(r22).reduce((f22, [a22, g]) => Object.assign(f22, { [a22]: unref(g) }), {}), id: d22 };
    return H$1({ ourProps: c22, theirProps: l22, slot: n22.value, attrs: i22, slots: o22, name: s22 });
  };
} });
function m$1(t22) {
  let e22 = shallowRef(t22.getSnapshot());
  return onUnmounted(t22.subscribe(() => {
    e22.value = t22.getSnapshot();
  })), e22;
}
function a$1(o22, r22) {
  let t22 = o22(), n22 = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return t22;
  }, subscribe(e22) {
    return n22.add(e22), () => n22.delete(e22);
  }, dispatch(e22, ...s22) {
    let i22 = r22[e22].call(t22, ...s22);
    i22 && (t22 = i22, n22.forEach((c22) => c22()));
  } };
}
function c() {
  let o22;
  return { before({ doc: e22 }) {
    var l22;
    let n22 = e22.documentElement;
    o22 = ((l22 = e22.defaultView) != null ? l22 : window).innerWidth - n22.clientWidth;
  }, after({ doc: e22, d: n22 }) {
    let t22 = e22.documentElement, l22 = t22.clientWidth - t22.offsetWidth, r22 = o22 - l22;
    n22.style(t22, "paddingRight", `${r22}px`);
  } };
}
function w() {
  if (!t$3())
    return {};
  let r22;
  return { before() {
    r22 = window.pageYOffset;
  }, after({ doc: n22, d: o$12, meta: s22 }) {
    function i22(e22) {
      return s22.containers.flatMap((t22) => t22()).some((t22) => t22.contains(e22));
    }
    if (window.getComputedStyle(n22.documentElement).scrollBehavior !== "auto") {
      let e22 = o();
      e22.style(n22.documentElement, "scroll-behavior", "auto"), o$12.add(() => o$12.microTask(() => e22.dispose()));
    }
    o$12.style(n22.body, "marginTop", `-${r22}px`), window.scrollTo(0, 0);
    let l22 = null;
    o$12.addEventListener(n22, "click", (e22) => {
      if (e22.target instanceof HTMLElement)
        try {
          let t22 = e22.target.closest("a");
          if (!t22)
            return;
          let { hash: c22 } = new URL(t22.href), a22 = n22.querySelector(c22);
          a22 && !i22(a22) && (l22 = a22);
        } catch {
        }
    }, true), o$12.addEventListener(n22, "touchmove", (e22) => {
      e22.target instanceof HTMLElement && !i22(e22.target) && e22.preventDefault();
    }, { passive: false }), o$12.add(() => {
      window.scrollTo(0, window.pageYOffset + r22), l22 && l22.isConnected && (l22.scrollIntoView({ block: "nearest" }), l22 = null);
    });
  } };
}
function l() {
  return { before({ doc: e22, d: o22 }) {
    o22.style(e22.documentElement, "overflow", "hidden");
  } };
}
function m(e22) {
  let n22 = {};
  for (let t22 of e22)
    Object.assign(n22, t22(n22));
  return n22;
}
let a = a$1(() => /* @__PURE__ */ new Map(), { PUSH(e22, n22) {
  var o$12;
  let t22 = (o$12 = this.get(e22)) != null ? o$12 : { doc: e22, count: 0, d: o(), meta: /* @__PURE__ */ new Set() };
  return t22.count++, t22.meta.add(n22), this.set(e22, t22), this;
}, POP(e22, n22) {
  let t22 = this.get(e22);
  return t22 && (t22.count--, t22.meta.delete(n22)), this;
}, SCROLL_PREVENT({ doc: e22, d: n22, meta: t22 }) {
  let o22 = { doc: e22, d: n22, meta: m(t22) }, c$12 = [w(), c(), l()];
  c$12.forEach(({ before: r22 }) => r22 == null ? void 0 : r22(o22)), c$12.forEach(({ after: r22 }) => r22 == null ? void 0 : r22(o22));
}, SCROLL_ALLOW({ d: e22 }) {
  e22.dispose();
}, TEARDOWN({ doc: e22 }) {
  this.delete(e22);
} });
a.subscribe(() => {
  let e22 = a.getSnapshot(), n22 = /* @__PURE__ */ new Map();
  for (let [t22] of e22)
    n22.set(t22, t22.documentElement.style.overflow);
  for (let t22 of e22.values()) {
    let o22 = n22.get(t22.doc) === "hidden", c22 = t22.count !== 0;
    (c22 && !o22 || !c22 && o22) && a.dispatch(t22.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t22), t22.count === 0 && a.dispatch("TEARDOWN", t22);
  }
});
function d(t22, a$12, n22) {
  let i22 = m$1(a), l22 = computed(() => {
    let e22 = t22.value ? i22.value.get(t22.value) : void 0;
    return e22 ? e22.count > 0 : false;
  });
  return watch([t22, a$12], ([e22, m22], [r22], o22) => {
    if (!e22 || !m22)
      return;
    a.dispatch("PUSH", e22, n22);
    let f22 = false;
    o22(() => {
      f22 || (a.dispatch("POP", r22 != null ? r22 : e22, n22), f22 = true);
    });
  }, { immediate: true }), l22;
}
function p({ defaultContainers: t22 = [], portals: o22, mainTreeNodeRef: s22 } = {}) {
  let i22 = ref(null), r22 = m$2(i22);
  function u22() {
    var l22;
    let n22 = [];
    for (let e22 of t22)
      e22 !== null && (e22 instanceof HTMLElement ? n22.push(e22) : "value" in e22 && e22.value instanceof HTMLElement && n22.push(e22.value));
    if (o22 != null && o22.value)
      for (let e22 of o22.value)
        n22.push(e22);
    for (let e22 of (l22 = r22 == null ? void 0 : r22.querySelectorAll("html > *, body > *")) != null ? l22 : [])
      e22 !== document.body && e22 !== document.head && e22 instanceof HTMLElement && e22.id !== "headlessui-portal-root" && (e22.contains(o$1(i22)) || n22.some((c22) => e22.contains(c22)) || n22.push(e22));
    return n22;
  }
  return { resolveContainers: u22, contains(n22) {
    return u22().some((l22) => l22.contains(n22));
  }, mainTreeNodeRef: i22, MainTreeNode() {
    return s22 != null ? null : h$3(f$1, { features: a$2.Hidden, ref: i22 });
  } };
}
var Oe = ((t22) => (t22[t22.Open = 0] = "Open", t22[t22.Closed = 1] = "Closed", t22))(Oe || {});
let F = Symbol("DialogContext");
function C(o22) {
  let n22 = inject(F, null);
  if (n22 === null) {
    let t22 = new Error(`<${o22} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t22, C), t22;
  }
  return n22;
}
let M = "DC8F892D-2EBD-447C-A4C8-A03058436FF4";
defineComponent({ name: "Dialog", inheritAttrs: false, props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true }, open: { type: [Boolean, String], default: M }, initialFocus: { type: Object, default: null }, id: { type: String, default: () => `headlessui-dialog-${t$4()}` } }, emits: { close: (o22) => true }, setup(o22, { emit: n22, attrs: t22, slots: u22, expose: i22 }) {
  var N22;
  let r22 = ref(false);
  onMounted(() => {
    r22.value = true;
  });
  let s22 = ref(0), p$12 = p$3(), m22 = computed(() => o22.open === M && p$12 !== null ? (p$12.value & l$1.Open) === l$1.Open : o22.open), v22 = ref(null), T22 = computed(() => m$2(v22));
  if (i22({ el: v22, $el: v22 }), !(o22.open !== M || p$12 !== null))
    throw new Error("You forgot to provide an `open` prop to the `Dialog`.");
  if (typeof m22.value != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${m22.value === M ? void 0 : o22.open}`);
  let c22 = computed(() => r22.value && m22.value ? 0 : 1), R10 = computed(() => c22.value === 0), E22 = computed(() => s22.value > 1), $10 = inject(F, null) !== null, [G, V$12] = V(), { resolveContainers: x22, mainTreeNodeRef: j22, MainTreeNode: W5 } = p({ portals: G, defaultContainers: [computed(() => {
    var e22;
    return (e22 = y$12.panelRef.value) != null ? e22 : v22.value;
  })] }), J22 = computed(() => E22.value ? "parent" : "leaf"), H22 = computed(() => p$12 !== null ? (p$12.value & l$1.Closing) === l$1.Closing : false), Q22 = computed(() => $10 || H22.value ? false : R10.value), X10 = computed(() => {
    var e22, l22, f22;
    return (f22 = Array.from((l22 = (e22 = T22.value) == null ? void 0 : e22.querySelectorAll("body > *")) != null ? l22 : []).find((d22) => d22.id === "headlessui-portal-root" ? false : d22.contains(o$1(j22)) && d22 instanceof HTMLElement)) != null ? f22 : null;
  });
  E$2(X10, Q22);
  let Z = computed(() => E22.value ? true : R10.value), ee = computed(() => {
    var e22, l22, f22;
    return (f22 = Array.from((l22 = (e22 = T22.value) == null ? void 0 : e22.querySelectorAll("[data-headlessui-portal]")) != null ? l22 : []).find((d22) => d22.contains(o$1(j22)) && d22 instanceof HTMLElement)) != null ? f22 : null;
  });
  E$2(ee, Z), S({ type: "Dialog", enabled: computed(() => c22.value === 0), element: v22, onUpdate: (e22, l22) => {
    if (l22 === "Dialog")
      return u$3(e22, { [p$2.Add]: () => s22.value += 1, [p$2.Remove]: () => s22.value -= 1 });
  } });
  let te2 = M$1({ name: "DialogDescription", slot: computed(() => ({ open: m22.value })) }), k10 = ref(null), y$12 = { titleId: k10, panelRef: ref(null), dialogState: c22, setTitleId(e22) {
    k10.value !== e22 && (k10.value = e22);
  }, close() {
    n22("close", false);
  } };
  provide(F, y$12);
  let le = computed(() => !(!R10.value || E22.value));
  y(x22, (e22, l22) => {
    y$12.close(), nextTick(() => l22 == null ? void 0 : l22.focus());
  }, le);
  let oe2 = computed(() => !(E22.value || c22.value !== 0));
  E$3((N22 = T22.value) == null ? void 0 : N22.defaultView, "keydown", (e22) => {
    oe2.value && (e22.defaultPrevented || e22.key === o$2.Escape && (e22.preventDefault(), e22.stopPropagation(), y$12.close()));
  });
  let re2 = computed(() => !(H22.value || c22.value !== 0 || $10));
  return d(T22, re2, (e22) => {
    var l22;
    return { containers: [...(l22 = e22.containers) != null ? l22 : [], x22] };
  }), watchEffect((e22) => {
    if (c22.value !== 0)
      return;
    let l22 = o$1(v22);
    if (!l22)
      return;
    let f22 = new ResizeObserver((d22) => {
      for (let A22 of d22) {
        let D5 = A22.target.getBoundingClientRect();
        D5.x === 0 && D5.y === 0 && D5.width === 0 && D5.height === 0 && y$12.close();
      }
    });
    f22.observe(l22), e22(() => f22.disconnect());
  }), () => {
    let { id: e22, open: l22, initialFocus: f22, ...d22 } = o22, A22 = { ...t22, ref: v22, id: e22, role: "dialog", "aria-modal": c22.value === 0 ? true : void 0, "aria-labelledby": k10.value, "aria-describedby": te2.value }, D5 = { open: c22.value === 0 };
    return h$3(P, { force: true }, () => [h$3(U, () => h$3(_, { target: v22.value }, () => h$3(P, { force: false }, () => h$3(ce, { initialFocus: f22, containers: x22, features: R10.value ? u$3(J22.value, { parent: ce.features.RestoreFocus, leaf: ce.features.All & ~ce.features.FocusLock }) : ce.features.None }, () => h$3(V$12, {}, () => H$1({ ourProps: A22, theirProps: { ...d22, ...t22 }, slot: D5, attrs: t22, slots: u22, visible: c22.value === 0, features: N$2.RenderStrategy | N$2.Static, name: "Dialog" })))))), h$3(W5)]);
  };
} });
defineComponent({ name: "DialogOverlay", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: () => `headlessui-dialog-overlay-${t$4()}` } }, setup(o22, { attrs: n22, slots: t22 }) {
  let u22 = C("DialogOverlay");
  function i22(r22) {
    r22.target === r22.currentTarget && (r22.preventDefault(), r22.stopPropagation(), u22.close());
  }
  return () => {
    let { id: r22, ...s22 } = o22;
    return H$1({ ourProps: { id: r22, "aria-hidden": true, onClick: i22 }, theirProps: s22, slot: { open: u22.dialogState.value === 0 }, attrs: n22, slots: t22, name: "DialogOverlay" });
  };
} });
defineComponent({ name: "DialogBackdrop", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: () => `headlessui-dialog-backdrop-${t$4()}` } }, inheritAttrs: false, setup(o22, { attrs: n22, slots: t22, expose: u22 }) {
  let i22 = C("DialogBackdrop"), r22 = ref(null);
  return u22({ el: r22, $el: r22 }), onMounted(() => {
    if (i22.panelRef.value === null)
      throw new Error("A <DialogBackdrop /> component is being used, but a <DialogPanel /> component is missing.");
  }), () => {
    let { id: s22, ...p22 } = o22, m22 = { id: s22, ref: r22, "aria-hidden": true };
    return h$3(P, { force: true }, () => h$3(U, () => H$1({ ourProps: m22, theirProps: { ...n22, ...p22 }, slot: { open: i22.dialogState.value === 0 }, attrs: n22, slots: t22, name: "DialogBackdrop" })));
  };
} });
defineComponent({ name: "DialogPanel", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: () => `headlessui-dialog-panel-${t$4()}` } }, setup(o22, { attrs: n22, slots: t22, expose: u22 }) {
  let i22 = C("DialogPanel");
  u22({ el: i22.panelRef, $el: i22.panelRef });
  function r22(s22) {
    s22.stopPropagation();
  }
  return () => {
    let { id: s22, ...p22 } = o22, m22 = { id: s22, ref: i22.panelRef, onClick: r22 };
    return H$1({ ourProps: m22, theirProps: p22, slot: { open: i22.dialogState.value === 0 }, attrs: n22, slots: t22, name: "DialogPanel" });
  };
} });
defineComponent({ name: "DialogTitle", props: { as: { type: [Object, String], default: "h2" }, id: { type: String, default: () => `headlessui-dialog-title-${t$4()}` } }, setup(o22, { attrs: n22, slots: t22 }) {
  let u22 = C("DialogTitle");
  return onMounted(() => {
    u22.setTitleId(o22.id), onUnmounted(() => u22.setTitleId(null));
  }), () => {
    let { id: i22, ...r22 } = o22;
    return H$1({ ourProps: { id: i22 }, theirProps: r22, slot: { open: u22.dialogState.value === 0 }, attrs: n22, slots: t22, name: "DialogTitle" });
  };
} });
ref(false);
(function() {
  try {
    if (typeof document < "u") {
      var e3 = document.createElement("style");
      e3.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Inter:wght@100..900";@import"https://fonts.googleapis.com/css?family=JetBrains%20Mono";:root{--default-theme-border-width: 1px;--default-theme-radius: 3px;--default-theme-radius-lg: 6px;--default-theme-radius-xl: 8px;--default-theme-header-height: 50px;--default-theme-sidebar-width: 250px;--default-theme-toc-width: 250px;--default-theme-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;--default-theme-font-code: "JetBrains Mono";--default-theme-heading-1: 40px;--default-theme-page-description: 24px;--default-theme-heading-2: 24px;--default-theme-heading-3: 20px;--default-theme-heading-4: 16px;--default-theme-heading-5: 16px;--default-theme-heading-6: 16px;--default-theme-paragraph: 16px;--default-theme-small: 14px;--default-theme-mini: 13px;--default-theme-micro: 12px;--default-theme-bold: 600;--default-theme-semibold: 500;--default-theme-regular: 400;--default-theme-font-size-1: 24px;--default-theme-font-size-2: 16px;--default-theme-font-size-3: 14px;--default-theme-font-size-4: 13px;--default-theme-font-size-5: 12px;--default-theme-line-height-1: 32px;--default-theme-line-height-2: 24px;--default-theme-line-height-3: 20px;--default-theme-line-height-4: 18px;--default-theme-line-height-5: 16px;--default-theme-font-medium: 500;--default-theme-font-bold: 700}@media (max-width: 460px){:root{--default-theme-font-size-1: 22px;--default-theme-font-size-2: 14px;--default-theme-font-size-3: 12px}}@media (max-width: 720px){:root{--default-theme-heading-1: 24px;--default-theme-page-description: 20px}}.cm-scroller,.custom-scroll{overflow-y:scroll;scrollbar-color:transparent transparent;scrollbar-width:thin;-webkit-overflow-scrolling:touch}.custom-scroll-self-contain-overflow{overscroll-behavior:contain}.custom-scroll-extra-padding-right{padding-right:12px!important}@supports (-moz-appearance: none){.cm-scroller,.custom-scroll{padding-right:12px}.custom-scroll-extra-padding-right{padding-right:24px!important}}.cm-scroller:hover,.custom-scroll:hover{scrollbar-color:var( --theme-scrollbar-color, var(--default-theme-scrollbar-color) ) transparent}.cm-scroller:hover::-webkit-scrollbar-thumb,.custom-scroll:hover::-webkit-scrollbar-thumb{background:var( --theme-scrollbar-color, var(--default-theme-scrollbar-color) );background-clip:content-box;border:3px solid transparent}.cm-scroller::-webkit-scrollbar-thumb:active,.custom-scroll::-webkit-scrollbar-thumb:active{background:var( --theme-scrollbar-color-active, var(--default-theme-scrollbar-color-active) );background-clip:content-box;border:3px solid transparent}.cm-scroller::-webkit-scrollbar-corner,.custom-scroll::-webkit-scrollbar-corner{background:transparent}.cm-scroller::-webkit-scrollbar,.custom-scroll::-webkit-scrollbar{height:12px;width:12px}.cm-scroller::-webkit-scrollbar-track,.custom-scroll::-webkit-scrollbar-track{background:transparent}.cm-scroller::-webkit-scrollbar-thumb,.custom-scroll::-webkit-scrollbar-thumb{border-radius:20px;background:transparent;background-clip:content-box;border:3px solid transparent}@media (pointer: coarse){.cm-scroller,.custom-scroll{padding-right:12px}.custom-scroll-extra-padding-right{padding-right:24px!important}}.scalar-api-client__codemirror__wrapper{width:100%;height:100%;padding-top:4px;min-height:76px;background:var(--theme-background-2, var(--default-theme-background-2));color:var(--theme-color-1, var(--default-theme-color-1));display:flex;align-items:stretch}.scalar-api-client__codemirror{flex-grow:1;max-width:100%;cursor:text;font-size:var(--theme-small, var(--default-theme-small))}.scalar-api-client__url-input{font-weight:var(--theme-semibold, var(--default-theme-semibold));min-height:auto;padding-top:0}.scalar-api-client__url-input .ͼ1 .cm-scroller{align-items:center!important}.scalar-api-client__variable{color:var(--scalar-api-client-color, var(--default-scalar-api-client-color))}.cm-focused{outline:none!important}.modal-layout[data-v-046a46e5]{position:fixed;width:100vw;height:100vh;top:0;left:0;z-index:1001;background:rgba(0,0,0,.44);padding:20px;opacity:0;animation:modal-fade-046a46e5 .2s forwards}.modal-body[data-v-046a46e5]{padding:24px 12px 18px 24px;max-height:calc(100vh - 240px);background:var(--theme-background-1, var(--default-theme-background-1));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));font-family:var(--theme-font, var(--default-theme-font));position:relative}.modal[data-v-046a46e5]{margin:80px auto 0;position:relative;background:var(--theme-background-2, var(--default-theme-background-2));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));color:var(--theme-color-1, var(--default-theme-color-1));width:100%;text-align:left;line-height:1.4;opacity:0;transform:scale(.98);animation:modal-pop-046a46e5 .15s .15s forwards;display:flex;flex-direction:column}.modal[data-v-046a46e5]:before{content:"";display:block;width:100%;height:100%;position:absolute;z-index:0;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.dark-mode .modal[data-v-046a46e5]:before{background:#1a1a1a}.light-mode .modal[data-v-046a46e5]:before{background:#fff}.modal-content-history[data-v-046a46e5]{background:var(--theme-background-1, var(--default-theme-background-1))}.modal-content-history[data-v-046a46e5],.modal-content-large[data-v-046a46e5]{max-width:800px}.modal-content-normal[data-v-046a46e5]{max-width:640px}.modal-content-small[data-v-046a46e5]{max-width:480px}@keyframes modal-fade-046a46e5{0%{opacity:0}to{opacity:1}}@keyframes modal-pop-046a46e5{0%{opacity:0}to{opacity:1;transform:scale(1)}}.modal-header[data-v-046a46e5]{padding:12px 24px;color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));text-align:left;font-weight:600;margin:0;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg)) var(--theme-radius-lg, var(--default-theme-radius-lg)) 0 0}.modal-content-history .modal-header[data-v-046a46e5]{padding-bottom:0;padding-top:24px}.modal-content-history .modal-body[data-v-046a46e5]{padding-top:12px}.modal-content-search[data-v-046a46e5]{max-width:540px}.modal-content-search .modal-body[data-v-046a46e5]{padding:0;overflow:hidden;display:flex;flex-direction:column;max-height:440px}.navtable-mock{background-repeat:repeat;width:100%;background-size:31px 31px;background-position:center 1px;flex:1;position:relative;z-index:0;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color));background:repeating-linear-gradient(var(--theme-background-1, var(--default-theme-background-1)),var(--theme-background-1, var(--default-theme-background-1)) 34.8px,var(--theme-border-color, var(--default-theme-border-color)) 34.8px,var(--theme-border-color, var(--default-theme-border-color)) 35.8px)}.navtable-mock .navtable-item{position:absolute;width:100%;height:100%;left:0;top:0;background:transparent;box-shadow:none}.radio{height:10px;max-width:10px;width:10px;max-height:10px;background:transparent;border:var(--border, var(--default-border));flex-shrink:0;margin-right:6px;margin-left:0;border-radius:50%;display:flex;align-items:center;justify-content:center;outline:none;padding:0}.radio:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;cursor:pointer}.navtable-item__active:before{content:"";display:block;box-shadow:0 0 0 1px var(--theme-color-1, var(--default-theme-color-1))!important;width:100%;position:absolute;top:0;left:0;height:100%}.radio.post{background:var(--theme-color-green, var(--default-theme-color-green))}.radio.delete{background:var(--theme-color-red, var(--default-theme-color-red))}.radio.patch{background:var(--theme-color-yellow, var(--default-theme-color-yellow))}.radio.get{background:var(--theme-color-blue, var(--default-theme-color-blue))}.radio.put{background:var(--theme-color-orange, var(--default-theme-color-orange))}.navtable-item-request span{border:none;outline:none;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-1, var(--default-theme-color-1));width:100%;display:block;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.navtable-item-request span em{text-transform:uppercase;font-style:normal;font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var(--theme-micro, var(--default-theme-micro));margin-right:6px;font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-3, var(--default-theme-color-3))}.request-method-select[data-v-56483138]{position:relative;display:flex}.request-method-select select[data-v-56483138]{border:none;outline:none;cursor:pointer;background:var(--theme-background-3, var(--default-theme-background-3));box-shadow:-2px 0 0 0 var(--theme-background-3, var(--default-theme-background-3));position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.request-method-select select[disabled][data-v-56483138]{pointer-events:none}.request-method[data-v-56483138]{display:flex;align-items:center;color:var(--theme-color-3, var(--default-theme-color-3));-moz-appearance:none;appearance:none;-webkit-appearance:none;padding:0 12px;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));position:relative}.request-method span[data-v-56483138]{font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:500;font-size:var(--theme-micro, var(--default-theme-micro));text-transform:uppercase;display:flex;align-items:center}.request-method:not(.request-method--disabled) span[data-v-56483138]:after{content:"";width:7px;height:7px;transform:rotate(45deg) translate3d(-2px,-2px,0);display:block;margin-left:6px;box-shadow:1px 1px 0 currentColor}.request-method i[data-v-56483138]{width:10px;height:10px;border-radius:50%;margin-right:6px;text-align:center;line-height:18px;font-style:normal;flex-shrink:0;display:inline-block;color:var(--theme-color-disabled, var(--default-theme-color-disabled));background:var( --scalar-api-client-color, var(--default-scalar-api-client-color) )}.loader[data-v-3d52ecda]{position:absolute;z-index:3;height:2px;background:var( --scalar-api-client-color, var(--default-scalar-api-client-color) );animation:loading-3d52ecda 5s cubic-bezier(0,.5,.25,1)}@keyframes loading-3d52ecda{0%{width:0}to{width:100%}}.scalar-api-client__address-bar[data-v-3d52ecda]{width:100%;padding:12px 12px 10px;display:flex;align-items:center;position:relative;background:var(--theme-background-1, var(--default-theme-background-1))}.scalar-api-client__url-form[data-v-3d52ecda]{display:flex;width:100%;align-items:stretch;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.scalar-api-client__field[data-v-3d52ecda]{border-right:0;background:var(--theme-background-2, var(--default-theme-background-2));border-radius:var(--theme-radius, var(--default-theme-radius)) 0 0 var(--theme-radius, var(--default-theme-radius));display:flex;align-items:stretch;width:100%;overflow:hidden;min-height:31px}.scalar-api-client__address-bar-data[data-v-3d52ecda]{width:100%}.scalar-api-client__address-bar-data-meta[data-v-3d52ecda]{display:flex;margin-top:5px}.scalar-api-client__url-input[data-v-3d52ecda]{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client__request-type[data-v-3d52ecda]{display:flex;align-items:center;color:var(--theme-color-3, var(--default-theme-color-3));-moz-appearance:none;appearance:none;-webkit-appearance:none;padding:0 12px;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));position:relative}.scalar-api-client__request-type span[data-v-3d52ecda]{font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var(--theme-micro, var(--default-theme-micro));text-transform:uppercase}.scalar-api-client__request-type svg[data-v-3d52ecda]{margin-left:6px;width:8px}.scalar-api-client__request-type i[data-v-3d52ecda]{width:10px;height:10px;border-radius:50%;margin-right:6px;text-align:center;line-height:18px;font-style:normal;flex-shrink:0;display:inline-block;color:var(--theme-color-3, var(--default-theme-color-3));background:var( --scalar-api-client-color, var(--default-scalar-api-client-color) )}.meta-request-break[data-v-3d52ecda]{margin:0 5px}.scalar-api-client__history[data-v-3d52ecda]{-moz-appearance:none;appearance:none;-webkit-appearance:none;background:transparent;color:var(--theme-color-2, var(--default-theme-color-2));display:flex;align-items:center;border-radius:var(--theme-radius, var(--default-theme-radius));height:100%}.scalar-api-client__send-request-button[type=submit][data-v-3d52ecda]{font-size:var(--theme-micro, var(--default-theme-micro));letter-spacing:.25px;font-weight:var(--theme-semibold, var(--default-theme-semibold));color:#fff;border:none;white-space:nowrap;padding:0 12px;text-transform:uppercase;cursor:pointer;outline:none;font-family:(--theme-font,var(--default-theme-font));border-radius:0 var(--theme-radius, var(--default-theme-radius)) var(--theme-radius, var(--default-theme-radius)) 0;background:var( --scalar-api-client-color, var(--default-scalar-api-client-color) );position:relative;display:flex;align-items:center;overflow:hidden;flex-shrink:0}.scalar-api-client__send-request-button[data-v-3d52ecda]:before{content:"";position:absolute;top:-5%;left:-5%;width:110%;height:110%;pointer-events:none;cursor:pointer;border-radius:var(--theme-radius, var(--default-theme-radius));background:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.2))}.scalar-api-client__send-request-button[data-v-3d52ecda]:hover:before{background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.1))}.scalar-api-client__send-request-button svg[data-v-3d52ecda]{width:12px;height:12px;flex-shrink:0;margin-right:6px;position:relative}.scalar-api-client__send-request-button span[data-v-3d52ecda]{position:relative}@media screen and (max-width: 720px){.scalar-api-client__history-toggle span[data-v-3d52ecda],.scalar-api-client__send-request-button span[data-v-3d52ecda]{display:none}.scalar-api-client__history-toggle svg[data-v-3d52ecda],.scalar-api-client__send-request-button svg[data-v-3d52ecda]{margin-right:0}}.scalar-api-client__send-request-button[disabled][data-v-3d52ecda]{pointer-events:none;color:var(--theme-color-2, var(--default-theme-color-2));background:var(--theme-background-3, var(--default-theme-background-3));border:1px solid var(--default-theme-border-color)}.scalar-api-client__history-toggle[data-v-3d52ecda]{padding:0 12px;line-height:30px;color:var(--theme-color-3, var(--default-theme-color-3));font-size:var(--theme-micro, var(--default-theme-micro));letter-spacing:.125px;font-weight:var(--theme-semibold, var(--default-theme-semibold));text-transform:uppercase;height:100%;display:flex;align-items:center;cursor:pointer;white-space:nowrap;box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));margin-left:12px;border-radius:var(--theme-radius, var(--default-theme-radius));-webkit-user-select:none;user-select:none}.scalar-api-client__history-toggle[data-v-3d52ecda]:hover{background:var(--theme-background-2, var(--default-theme-background-2))}.scalar-api-client__history-toggle svg[data-v-3d52ecda]{height:13px;width:13px;margin-right:6px;color:var(--theme-color-3, var(--default-theme-color-3))}.scalar-api-client__address-bar-close[data-v-3d52ecda]{fill:var(--theme-color-3, var(--default-theme-color-3));margin-left:12px;height:24px}.scalar-api-client__address-bar-close[data-v-3d52ecda]:hover{cursor:pointer;fill:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client__address-bar__content[data-v-3d52ecda]{width:640px;height:100%;background:var(--theme-background-1, var(--default-theme-background-1));position:fixed;top:0;right:0;z-index:1000;transform:translate3d(640px,0,0);opacity:0;transition:transform .5s cubic-bezier(.77,0,.175,1),opacity .01s ease-in-out .5s;pointer-events:none}.scalar-api-client__address-bar-content-item[data-v-3d52ecda]{height:100vh;max-height:100vh;overflow:auto}.scalar-api-client__address-bar__on[data-v-3d52ecda]{z-index:100000}.scalar-api-client__address-bar__on .scalar-api-client__address-bar__content[data-v-3d52ecda]{transform:translateZ(0);opacity:1;pointer-events:all;transition:transform .5s cubic-bezier(.77,0,.175,1)}.scalar-api-client__address-bar__on .scalar-api-client__address-bar__close[data-v-3d52ecda]{opacity:1;pointer-events:all;cursor:pointer}.scalar-api-client__address-bar .navtable-item__active[data-v-3d52ecda]{background:var(--theme-background-2, var(--default-theme-background-2));cursor:default}.scalar-api-client__address-bar .navtable-item__active .radio[data-v-3d52ecda]:before{display:none}.navigation-back[data-v-3d52ecda]{stroke:var(--theme-color-2, var(--default-theme-color-2));cursor:pointer}.navigation-back[data-v-3d52ecda]:hover{stroke:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client__address-bar__close[data-v-3d52ecda]{width:100%;height:100%;position:fixed;top:0;left:0;pointer-events:none;opacity:0;transition:all .1s ease-in-out;z-index:1000}.navtable-item-time[data-v-3d52ecda]{font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-1, var(--default-theme-color-1));text-transform:capitalize;padding:0 9px}.scalar-api-client__item{border-radius:var(--theme-radius, var(--default-theme-radius));margin-bottom:6px;position:relative}.scalar-api-client__item button{background-color:transparent;text-align:left}.scalar-api-client__item:hover{cursor:pointer}.scalar-api-client__toggle:after{content:"";position:absolute;bottom:-6.5px;width:100%;height:6px;left:0}.scalar-api-client__item--open .scalar-api-client__toggle:after{display:none}.scalar-api-client__item:hover,.scalar-api-client__item--open{background:var(--theme-background-2, var(--default-theme-background-2))}.scalar-api-client__item--open .scalar-api-client__item__content{display:flex}.scalar-api-client__item--open:hover{cursor:default}.scalar-api-client__item--open .scalar-api-client__toggle__icon{transform:rotate(90deg)}.scalar-api-client__toggle{padding:6px;min-height:37px;display:flex;align-items:center;justify-content:space-between;position:relative;width:100%;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:0;border:none;font-family:(--theme-font,var(--default-theme-font));cursor:pointer}.scalar-api-client__item .scalar-api-client__item__title{color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-small, var(--default-theme-small));font-weight:var(--theme-semibold, var(--default-theme-semibold));font-family:(--theme-font,var(--default-theme-font));-webkit-user-select:none;user-select:none;flex:1;position:relative;z-index:1}.scalar-api-client__item .scalar-api-client__toggle__icon{width:10px;margin-right:6px;color:var(--theme-color-3, var(--default-theme-color-3));z-index:1;position:relative}.scalar-api-client__toggle:hover .scalar-api-client__toggle__icon{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client__item__options{position:relative;z-index:1}.scalar-api-client__item__options span{background:transparent;padding:2px 0;border-radius:3px;font-size:var(--theme-small, var(--default-theme-small));pointer-events:none;color:var(--theme-color-2, var(--default-theme-color-2));display:flex;align-items:center;justify-content:center}.scalar-api-client__item__options:hover span{color:var(--theme-color-1, var(--default-theme-color-1));border-color:currentColor}.scalar-api-client__item__options span svg{width:15px;height:15px;margin-left:3px}.scalar-api-client__item__options select{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer}.scalar-api-client__item__content .scalar-api-client__codemirror__wrapper{padding-top:0}.table{border:1px solid var(--theme-border-color, var(--default-theme-border-color));background:transparent;border-radius:var(--theme-radius, var(--default-theme-radius));width:100%}.table-row{border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color));display:flex;position:relative}.table-row__add{border-radius:0 0 var(--theme-radius-lg, var(--default-theme-radius-lg)) var(--theme-radius-lg, var(--default-theme-radius-lg));border-bottom:none}.table-row.required-parameter .table-row-item:nth-of-type(2):after{content:"Required";position:absolute;top:4px;right:0;padding:5px 9px 5px 6px;font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-micro, var(--default-theme-micro));background:var(--theme-background-2, var(--default-theme-background-2));box-shadow:-2px 0 4px var(--theme-background-2, var(--default-theme-background-2))}.table-row.required-parameter .table-row-item:nth-of-type(2):focus-within:after{display:none}.table-row:last-of-type{border-bottom:none}.table-row__active{border-radius:0 0 var(--theme-radius-lg, var(--default-theme-radius-lg)) var(--theme-radius-lg, var(--default-theme-radius-lg))}.table-row-drag{width:20px;flex-shrink:0;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));align-items:center;justify-content:center;display:none}.table-row-drag svg{width:6px;fill:var(--theme-color-3, var(--default-theme-color-3))}.table-row-drag .table-row-drag-add{width:8px}.table-row-item{width:100%;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));position:relative}.table-row-item-menu{position:absolute;right:6px;background:var(--theme-background-2, var(--default-theme-background-2));width:24px;height:24px;top:50%;transform:translate3d(0,-50%,0);border-radius:50%;display:flex;align-items:center;justify-content:center;opacity:0;cursor:pointer}.table-row-item input:focus+.table-row-item-menu,.table-row-item:hover .table-row-item-menu{opacity:1}.table-row-item-menu svg{height:12px;width:initial;fill:var(--theme-color-3, var(--default-theme-color-3))}.table-row-item-menu:hover svg{fill:var(--theme-color-1, var(--default-theme-color-1))}.table-row-item input{border:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;padding:9px;width:100%;min-height:100%;color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-micro, var(--default-theme-micro));background:transparent;font-family:var(--theme-font, var(--default-theme-font))}.table-row-item input[disabled]{background:transparent;font-family:var(--theme-font-code, var(--default-theme-font-code))}.table-row-item input:focus{box-shadow:0 0 0 1px var(--theme-color-1, var(--default-theme-color-1))}.table-row-item label{background:transparent;text-transform:uppercase;display:block;padding:9px;font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-2, var(--default-theme-color-2));font-size:var(--theme-micro, var(--default-theme-micro))}.table-row-meta{overflow:hidden;flex-shrink:0;transition:all .15s ease-in-out;display:flex;align-items:center;justify-content:center;width:51px;-webkit-user-select:none;user-select:none}.table-row-meta-check{width:18px;height:18px;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));background:rgba(47,177,228,.1)}.table-row-meta svg{width:13px;height:13px;margin:0 1px;color:var(--theme-color-3, var(--default-theme-color-3));cursor:pointer}.table-row-meta svg:hover{color:var(--theme-color-2, var(--default-theme-color-2))}.meta-check{display:flex;position:relative;cursor:pointer;align-items:center;font-size:var(--theme-micro, var(--default-theme-micro));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));-webkit-user-select:none;user-select:none;margin:0 1px;transition:all .15s ease-in-out}.meta-check input{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.meta-checkmark{height:17px;width:17px;background:var(--theme-background-3, var(--default-theme-background-3));border-radius:3px;display:flex;align-items:center;justify-content:center;position:relative}.meta-checkmark:hover{background:var(--theme-background-3, var(--default-theme-background-3))}.meta-check:focus-within .meta-checkmark{box-shadow:0 0 0 1px var(--theme-color-1, var(--default-theme-color-1))}.meta-check .meta-checkmark:after{content:"";display:none;width:5px;height:8px;border:solid var(--theme-color-1, var(--default-theme-color-1));border-width:0 1.5px 1.5px 0;transform:rotate(45deg) translate3d(0,-1px,0)}.meta-check input:checked~.meta-checkmark:after{display:block}.meta-check input:checked~.meta-checkmark:hover{background:transparent}.navtable{width:100%}.navtable-follow{background-color:#000;color:#fff;font-size:9px;padding:6px;display:-webkit-box;max-width:250px;-webkit-line-clamp:12;border-radius:3px;-webkit-box-orient:vertical;overflow:hidden;line-height:1.24;transform:translate3d(10px,0,0)}.navtable-follow:after{content:"";position:absolute;bottom:0;width:100%;height:6px;background-color:#000}.navtable-follow *{font-family:var( --theme-font-code, var(--default-theme-font-code) )!important}.navtable-table{position:relative;display:flex;flex-direction:column;min-height:389px;border-radius:var(--theme-radius, var(--default-theme-radius));border:1px solid var(--theme-border-color, var(--default-theme-border-color))}.navtable-radios{z-index:1;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}.navtable-item{display:flex;position:relative;color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-micro, var(--default-theme-micro));border-top:1px solid var(--theme-border-color, var(--default-theme-border-color));font-weight:var(--theme-semibold, var(--default-theme-semibold))}.navtable-item:first-of-type{border-top:none}.navtable-item>div{word-wrap:break-word}.navtable-item>div:not(:first-child){border-left:1px solid var(--theme-border-color, var(--default-theme-border-color))}.navtable-item-action{color:var(--theme-color-2, var(--default-theme-color-2));font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-bold, var(--default-theme-bold));background:var( --scalar-api-client-bg3, var(--default-scalar-api-client-bg3) );border:none;border-radius:30px;-webkit-appearance:none;-moz-appearance:none;appearance:none;max-height:25px;margin-left:12px;margin-right:6px;padding:4px 8px;outline:none;cursor:pointer;opacity:0;transition:opacity .15s ease-in-out;white-space:nowrap;position:relative}.navtable-item-action:hover{color:var(--theme-color-1, var(--default-theme-color-1));background:var( --scalar-api-client-gradient, var(--default-scalar-api-client-gradient) );box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color))}.navtable-item-action:focus{background:var(--theme-background-2, var(--default-theme-background-2))}.navtable-item:hover,.navtable-item:focus-within .navtable-item-action{opacity:1}.navtable-item-add{display:flex;align-items:center;padding:9px;font-weight:var(--theme-bold, var(--default-theme-bold));outline:none;border:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;color:var(--theme-color-1, var(--default-theme-color-1))}.navtable-item-add:hover{background:var(--theme-background-2, var(--default-theme-background-2));cursor:pointer}.navtable-item-25{width:25%;font-size:var(--theme-micro, var(--default-theme-micro));display:flex;align-items:center}.navtable-item-33{width:33.33333%;display:flex;font-size:var(--theme-micro, var(--default-theme-micro));align-items:center}.navtable-item-66{width:66.6666%;display:flex;font-size:var(--theme-micro, var(--default-theme-micro));align-items:center}.navtable-item-75{width:75%;display:flex;align-items:center}.navtable-item-75:focus-within{background:var(--theme-background-2, var(--default-theme-background-2))}.navtable-item-40{width:40%;display:flex;align-items:center;padding:9px}.navtable-item-20{width:20%;display:flex;align-items:center;padding:9px}.navtable-item-50{width:50%;display:flex;align-items:center}.navtable-item-50:focus-within{background:var(--theme-background-2, var(--default-theme-background-2))}.navtable-item p{padding:9px}.navtable-item input{padding:12px 6px;border:none;outline:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-1, var(--default-theme-color-1));background:transparent;width:100%}.navtable-item input:focus{background:var(--theme-background-2, var(--default-theme-background-2))}.navtable-item-select{position:relative}.navtable-item-select select{background:transparent;outline:none;border:none;font-size:var(--theme-micro, var(--default-theme-micro));-webkit-appearance:none;-moz-appearance:none;appearance:none;width:100%;padding:12px 6px;top:0;position:relative;cursor:pointer;color:var(--theme-color-2, var(--default-theme-color-2))}.navtable-item-select svg{position:absolute;right:6px;color:var(--theme-color-ghost, var(--default-theme-color-ghost));width:6px;top:12px;pointer-events:none}.navtable-item .option{padding:12px 6px;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-1, var(--default-theme-color-1));width:100%}.navtable-item label{color:var(--theme-color-3, var(--default-theme-color-3));font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-semibold, var(--default-theme-semibold));text-transform:uppercase;display:block;width:100%}.navtable-item-response{padding:0 9px}.navtable-item-response span{font-size:var(--theme-micro, var(--default-theme-micro));display:flex;align-items:center;margin-right:9px;min-width:40px}.scalar-api-client__status--1xx:before,.scalar-api-client__status--2xx:before,.scalar-api-client__status--3xx:before,.scalar-api-client__status--4xx:before,.scalar-api-client__status--5xx:before,.scalar-api-client__status--6xx:before{content:"";width:10px;height:10px;border-radius:50%;margin-right:4px;background:var(--theme-background-2, var(--default-theme-background-2))}.scalar-api-client__status--2xx:before{background:var(--theme-color-green, var(--default-theme-color-green))}.scalar-api-client__status--3xx:before{background:var(--theme-color-orange, var(--default-theme-color-orange))}.scalar-api-client__status--4xx:before{background:var(--theme-color-red, var(--default-theme-color-red))}.navtable-item-response span:empty{display:none}.simpletable.navtable{padding:0}.simpletable.navtable .navtable-item-66,.simpletable.navtable .navtable-item-33{display:block}.simpletable.navtable .navtable-table{height:fit-content}.meta-delete{position:absolute;right:-9px;background:var( --theme-background-3, var(--default-theme-background-3) )!important;height:20px;width:20px;border:none;outline:none;border-radius:50%;opacity:0;padding:5px;display:flex;align-items:center;justify-content:center;cursor:pointer}.meta-delete svg{width:11px;height:11px;color:var(--theme-color-3, var(--default-theme-color-3))}.meta-delete:hover svg{color:var(--theme-color-red, var(--default-theme-color-red))}.meta-delete:focus svg{color:var(--theme-color-1, var(--default-theme-color-1))}.meta-delete:focus{border-color:var(--theme-color-1, var(--default-theme-color-1));color:var(--theme-color-1, var(--default-theme-color-1))}.table-row:hover .meta-delete{opacity:1}@media (pointer: coarse){.table-row:hover .meta-delete{opacity:1}}.meta-add{border:none;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color));font-weight:var(--theme-semibold, var(--default-theme-semibold));padding:9px;width:100%;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;font-size:var(--theme-micro, var(--default-theme-micro));font-family:var(--theme-font, var(--default-theme-font));color:var(--theme-color-3, var(--default-theme-color-3));cursor:pointer;display:flex;align-items:center}.meta-add svg{width:12px;height:12px;margin-right:6px}.meta-add:hover,.meta-add:focus{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client-add{color:var(--theme-color-2, var(--default-theme-color-2));padding:6px;width:fit-content;border-radius:var(--theme-radius, var(--default-theme-radius));cursor:pointer;font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-semibold, var(--default-theme-semibold));margin:0 6px;border:none;font-family:var(--theme-font);-webkit-appearance:none;-moz-appearance:none;appearance:none;display:flex;align-items:center}.scalar-api-client-add svg{width:12px;height:12px;margin-right:6px}.scalar-api-client-add:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client-add:focus-within{background:var(--theme-background-3, var(--default-theme-background-3))}.scalar-api-client__main__left{width:50%;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));padding:0 6px 12px 18px}@media screen and (max-width: 820px){.scalar-api-client__main__left{width:100%;border-right:none;padding:0 0 12px 12px}}.scalar-api-client__item__content{flex-flow:wrap;padding:3px 9px 9px;border-radius:3px;color:var(--theme-color-3, var(--default-theme-color-3));font-size:var(--theme-micro, var(--default-theme-micro));margin-top:-3px;justify-content:space-between;overflow:auto}.scalar-api-client__item__content .scalar-api-client__codemirror__wrapper{width:100%;min-height:63px}.scalar-api-client__item__content .cm-s-default{border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.scalar-api-client__item__content .scalar-api-client__item__content--code{width:100%;max-height:calc(100vh - 200px);overflow:auto}.scalar-api-client__item__content .cm-scroller{border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:3px}.scalar-api-client__item__content .cm-editor{outline:none!important}.scalar-api-client__item__content .cm-editor .cm-gutters,.scalar-api-client__item__content .cm-scroll{background:transparent}.scalar-api-client__item__content .cm-editor *{font-size:var(--theme-micro, var(--default-theme-micro))}.scalar-api-client__item__content .cm-editor .cm-line{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client__item__content-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:none;font-size:var(--theme-micro, var(--default-theme-micro));background:var( --scalar-api-client-color, var(--default-scalar-api-client-color) )!important;text-align:center;font-weight:var(--theme-semibold, var(--default-theme-semibold));font-family:var(--theme-font, var(--default-theme-font));padding:6px;width:fit-content;margin:3px 3px 3px auto;text-transform:uppercase;border-radius:var(--theme-radius, var(--default-theme-radius));color:#fff;cursor:pointer;text-align:center!important;position:relative}.scalar-api-client__item__content-button span{position:relative}.scalar-api-client__item__content-button:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;cursor:pointer;border-radius:var(--theme-radius, var(--default-theme-radius));background:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.2))}.scalar-api-client__item__content-button:hover:before{background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.1))}.scalar-api-client__item__content__split{justify-content:space-between}.scalar-collapsible-section-flex{width:100%}.input{background:transparent;position:relative;width:100%;text-align:left;display:flex;box-shadow:0 1px 0 var(--theme-border-color, var(--default-theme-border-color))}.input:focus-within{box-shadow:0 0 0 1px var(--theme-color-1, var(--default-theme-color-1))!important;z-index:10}.input:first-of-type{border-radius:var(--theme-radius, var(--default-theme-radius)) var(--theme-radius, var(--default-theme-radius)) 0 0}.input:first-child:last-child{border-radius:var(--theme-radius, var(--default-theme-radius))}.input:last-child{box-shadow:none;border-radius:0 0 var(--theme-radius, var(--default-theme-radius)) var(--theme-radius, var(--default-theme-radius))}.input__half:first-of-type{border-radius:var(--theme-radius, var(--default-theme-radius)) 0 0 0}.input__half:nth-of-type(2){border-radius:0 var(--theme-radius, var(--default-theme-radius)) 0 0}.authentication-form{box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius, var(--default-theme-radius));width:100%;display:flex;flex-flow:wrap}.input__half{width:50%}.input__half+.input__half{border-left:1px solid var(--theme-border-color, var(--default-theme-border-color))}.input__half:focus-within{border-color:transparent}.input label,.input input{padding:9px;border:0;outline:none;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-2, var(--default-theme-color-2));width:100%;background:transparent;-moz-appearance:none;appearance:none;-webkit-appearance:none;left:0}.input label{color:var(--theme-color-1, var(--default-theme-color-1));width:fit-content;padding-right:0;white-space:nowrap;cursor:text}.input input{position:relative;z-index:99}.input input:not(:placeholder-shown)+label{color:var(--theme-color-2, var(--default-theme-color-2))}.select{background:--theme-background-1;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));font-size:var(--theme-micro, var(--default-theme-micro));border:1px solid var(--theme-border-color, var(--default-theme-border-color));width:100%;position:relative;margin-bottom:6px}.select:focus-within{background:var(--theme-background-3, var(--default-theme-background-3))}.select:hover{background:var(--theme-background-3, var(--default-theme-background-3))}.select svg{position:absolute;right:9px;pointer-events:none;color:var(--theme-color-2, var(--default-theme-color-2));width:6px;top:10px}.select label{display:block;font-size:10px;color:var(--theme-color-2, var(--default-theme-color-2));position:absolute;left:9px;top:6px}.select select{background:transparent;outline:none;border:none;-webkit-appearance:none;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-1, var(--default-theme-color-1));-moz-appearance:none;appearance:none;width:100%;padding:14px 9px 4px;top:0;position:relative;cursor:pointer}.check{display:flex;position:relative;cursor:pointer;align-items:center;font-size:var(--theme-micro, var(--default-theme-micro));padding:6px 9px;border-radius:0 0 var(--theme-radius, var(--default-theme-radius)) var(--theme-radius, var(--default-theme-radius));-webkit-user-select:none;user-select:none;width:100%;outline:none}.check:focus-within{box-shadow:0 0 0 1px var(--theme-color-1, var(--default-theme-color-1))}.checkmark:hover{background:var(--theme-background-3, var(--default-theme-background-3))}.check:focus-within{border-color:var(--theme-color-1, var(--default-theme-color-1))}.check p{color:var(--theme-color-3, var(--default-theme-color-3))}.check input{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.checkmark{height:17px;width:17px;background:var(--theme-background-3, var(--default-theme-background-3));margin-right:10px;border-radius:3px;display:flex;align-items:center;justify-content:center;position:relative}.check input:checked~p{color:var(--theme-color-1, var(--default-theme-color-1))}.check .checkmark:after{content:"";display:none;width:5px;height:8px;border:solid var(--theme-color-1, var(--default-theme-color-1));border-width:0 1.5px 1.5px 0;transform:rotate(45deg) translate3d(0,-1px,0)}.check input:checked~.checkmark:after{display:block}.scalar-api-client__main__scroll-container{height:calc(100vh - 320px)}.scalar-api-client__request-name{outline:none;border:none;-moz-appearance:none;appearance:none;-webkit-appearance:none;font-size:var(--theme-small, var(--default-theme-small));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-3, var(--default-theme-color-3));width:100%;padding:0;background:transparent;font-family:var(--theme-font, var(--default-theme-font))}.scalar-api-client__request-name::-webkit-input-placeholder{font-weight:var(--theme-semibold, var(--default-theme-semibold))}.scalar-api-client__request-name:-ms-input-placeholder{font-weight:var(--theme-semibold, var(--default-theme-semibold))}.scalar-api-client__request-name::placeholder{font-weight:var(--theme-semibold, var(--default-theme-semibold))}a[data-v-d11ff062]{color:var(--theme-color-3, var(--default-theme-color-3));text-decoration:underline;text-decoration-color:var( --theme-border-color, var(--default-theme-border-color) );text-underline-offset:2px;cursor:help}.simple-cell[data-v-01fffd78]{all:unset;display:table-cell;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));position:relative;padding:9px!important;color:var(--theme-color-1, var(--default-theme-color-1));white-space:nowrap}.simple-cell a[data-v-01fffd78]{color:var(--theme-color-1, var(--default-theme-color-1))!important}.simple-cell[data-v-01fffd78]:last-of-type{border-right:none}.simple-cell.wrap[data-v-01fffd78]{white-space:normal}.simple-cell.strong[data-v-01fffd78]{font-weight:var(--theme-semibold, var(--default-theme-semibold))}.simple-header[data-v-b2232089]{color:var(--theme-color-3, var(--default-theme-color-3));font-weight:var(--theme-semibold, var(--default-theme-semibold));text-transform:uppercase}.simple-row[data-v-0982ade4]{all:unset;display:table-row;box-shadow:0 -1px var(--theme-border-color, var(--default-theme-border-color))}.simple-row[data-v-0982ade4]:first-of-type{box-shadow:none}.simple-table[data-v-28fcbcb6]{all:unset;display:table;width:100%;border-spacing:0;box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius, var(--default-theme-radius))}.scalar-api-client__main__right{width:50%;padding:0 6px 12px 18px}@media screen and (max-width: 820px){.scalar-api-client__main__right{width:100%;border-right:none;padding:0 0 12px 12px}}.scalar-api-client__main__right :deep(.scalar-copilot__header-button){position:absolute;top:6px;right:12px}.scalar-api-client,#headlessui-portal-root{background:var(--theme-background-1, var(--default-theme-background-1));position:relative;height:100%;overflow:hidden!important;display:flex;flex-direction:column;font-family:var(--theme-font, var(--default-theme-font));box-sizing:border-box}.scalar-api-client *,.scalar-api-client *:before,.scalar-api-client *:after,#headlessui-portal-root *,#headlessui-portal-root *:before,#headlessui-portal-root *:after{box-sizing:inherit}.scalar-api-client{flex:1;max-height:100vh}@media screen and (max-width: 1000px){.scalar-api-client{width:100%}}.scalar-api-client pre{font-family:var(--theme-font-code, var(--default-theme-font-code))}.scalar-api-client--post{--default-scalar-api-client-color: var( --theme-color-green, var(--default-theme-color-green) );--default-scalar-api-client-background: var( --theme-post-background, var(--default-theme-post-background) )}.scalar-api-client--delete{--default-scalar-api-client-color: var( --theme-color-red, var(--default-theme-color-red) );--default-scalar-api-client-background: var( --theme-delete-background, var(--default-theme-delete-background) )}.scalar-api-client--patch{--default-scalar-api-client-color: var( --theme-color-yellow, var(--default-theme-color-yellow) );--default-scalar-api-client-background: var( --theme-patch-background, var(--default-theme-patch-background) )}.scalar-api-client--get{--default-scalar-api-client-color: var( --theme-color-blue, var(--default-theme-color-blue) );--default-scalar-api-client-background: var( --theme-get-background, var(--default-theme-get-background) )}.scalar-api-client--put{--default-scalar-api-client-color: var( --theme-color-orange, var(--default-theme-color-orange) );--default-scalar-api-client-background: var( --theme-put-background, var(--default-theme-put-background) )}.scalar-api-client__mobile-navigation{padding:12px 12px 0;display:flex;font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-2, var(--default-theme-color-2));font-weight:var(--theme-bold, var(--default-theme-bold))}.scalar-api-client__mobile-navigation__toggle{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:none;background:transparent;font-size:var(--theme-font-size-2);color:var(--theme-color-2);font-weight:var(--theme-semibold, var(--default-theme-semibold));font-family:var(--theme-font, var(--default-theme-font));padding:0;margin-right:9px;cursor:pointer}.scalar-api-client__mobile-navigation--active{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client__mobile-navigation--active:hover{cursor:pointer}.scalar-api-client__main{display:flex;height:100%;min-height:0;background:var(--theme-background-1, var(--default-theme-background-1));border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}@media screen and (max-width: 820px){.scalar-api-client__main{flex-direction:column}}.scalar-api-client__main__content{padding:12px 6px;background:var(--theme-background-1, var(--default-theme-background-1));top:0;position:sticky;z-index:100}.scalar-api-client__main__content label{font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var(--theme-semibold, var(--default-theme-semibold));display:flex;align-items:center}@media screen and (max-width: 820px){.scalar-api-client__main__content{padding:3px 0 12px}.scalar-api-client__main__content label{display:none}}.meta{display:flex;margin-top:3px;font-size:var(--theme-font-size-2, var(--default-theme-font-size-2));font-weight:var(--theme-font-size-2, var(--default-theme-font-size-2));color:var( --scalar-api-client-color2, var(--default-scalar-api-client-color2) )}.meta-item svg{fill:var(--theme-color-ghost, var(--default-theme-color-ghost));height:14px;width:14px;margin-right:6px}.meta-item{display:flex;align-items:center;margin-right:12px;white-space:nowrap;font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-3, var(--default-theme-color-3));min-height:17px}.meta-item__input{background:transparent;width:100%;margin-right:0}.types{margin:auto;width:580px;display:flex;align-items:center;justify-content:center;flex-flow:wrap}.types-heading{width:100%;text-align:center}.types-heading b{font-size:42px}.types-heading p{margin-bottom:20px;margin-top:12px;font-size:24px}.scalar-api-client__empty-state{border:1px dashed var(--theme-border-color, var(--default-theme-border-color));width:100%;text-align:center;border-radius:var(--theme-radius, var(--default-theme-radius));font-size:var(--theme-small, var(--default-theme-small));min-height:58px;display:flex;align-items:center;justify-content:center}.loader-wrapper[data-v-dbcbb0f9]{position:relative;height:var(--656643f5);width:var(--656643f5);display:flex;align-items:center;justify-content:center;--default-loader-size: 50%}.svg-loader[data-v-dbcbb0f9]{width:var(--loader-size, var(--default-loader-size));height:var(--loader-size, var(--default-loader-size));top:1rem;right:.9rem;overflow:visible;fill:none;background-color:transparent;stroke:currentColor}.svg-path[data-v-dbcbb0f9]{stroke-width:14;fill:none;transition:.3s}.svg-x-mark[data-v-dbcbb0f9]{stroke-dasharray:57;stroke-dashoffset:57;transition-delay:0s}.svg-check-mark[data-v-dbcbb0f9]{stroke-dasharray:149;stroke-dashoffset:149;transition-delay:0s}.icon-is-invalid .svg-x-mark[data-v-dbcbb0f9],.icon-is-valid .svg-check-mark[data-v-dbcbb0f9]{stroke-dashoffset:0;transition-delay:.3s}.circular-loader[data-v-dbcbb0f9]{animation:rotate-dbcbb0f9 .7s linear infinite,fade-in-dbcbb0f9 .4s;transform-origin:center center;transform:scale(5);background:transparent}.loader-path[data-v-dbcbb0f9]{stroke-dasharray:50,200;stroke-dashoffset:-100;stroke-linecap:round}.loader-path-off[data-v-dbcbb0f9]{stroke-dasharray:50,200;stroke-dashoffset:-100;transition:opacity .3s;opacity:0}@keyframes fade-in-dbcbb0f9{0%{opacity:0}70%{opacity:0}to{opacity:1}}@keyframes rotate-dbcbb0f9{0%{transform:scale(5) rotate(0)}to{transform:scale(5) rotate(360deg)}}.flow-button[data-v-262cdfdc]{display:flex;align-items:center;justify-content:center;z-index:1;position:relative;-moz-appearance:none;appearance:none;-webkit-appearance:none;height:40px;padding:0 24px;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));color:var(--theme-button-1-color, var(--default-theme-button-1-color));font-size:var(--theme-font-size-4, var(--default--theme-font-size-4));font-weight:var(--theme-semibold, var(--default-theme-semibold));cursor:pointer;background:var(--theme-button-1, var(--default-theme-button-1));border:none;width:100%;box-shadow:#00000017 0 1px 4px}.flow-button[data-v-262cdfdc]:hover,.flow-button[data-v-262cdfdc]:focus-visible{background:var(--theme-button-1-hover, var(--default-theme-button-1-hover))}.flow-button[data-v-262cdfdc]:active{box-shadow:none;background:var(--theme-button-1, var(--default-theme-button-1))}.flow-button[disabled][data-v-262cdfdc]{background:var(--theme-background-2, var(--default-theme-background-2));color:var(--theme-color-3, var(--default-theme-color-3));cursor:unset;box-shadow:none}.flow-button.flow-button-icon-only[data-v-262cdfdc]{width:24px;height:24px;padding:0}.flow-button-outlined[data-v-262cdfdc]{background:var(--theme-background-1, var(--default-theme-background-1));color:var(--theme-color-1, var(--default-theme-color-1));padding:11px 23px;border:1px solid var(--theme-border-color, var(--default-theme-border-color));box-shadow:#00000017 0 1px 4px}.flow-button-outlined[data-v-262cdfdc]:hover,.flow-button-outlined[data-v-262cdfdc]:focus-visible{background:var(--theme-background-2, var(--default-theme-background-2))}.flow-button-outlined[data-v-262cdfdc]:active{background:var(--theme-background-2, var(--default-theme-background-2))}.flow-button-outlined[disabled][data-v-262cdfdc]{background:var(--theme-background-2, var(--default-theme-background-2));color:var(--theme-color-3, var(--default-theme-color-3));cursor:unset;box-shadow:none}.flow-button-clear[data-v-262cdfdc]{background:transparent;box-shadow:none;color:var(--theme-color-3, var(--default-theme-color-3))}.flow-button-clear[data-v-262cdfdc]:active{background:transparent}.flow-button-clear[data-v-262cdfdc]:hover,.flow-button-clear[data-v-262cdfdc]:focus-visible{background:var(--theme-background-2, var(--default-theme-background-2));box-shadow:none}.flow-button-clear[disabled][data-v-262cdfdc]{background:var(--theme-background-2, var(--default-theme-background-2));color:var(--theme-color-3, var(--default-theme-color-3));cursor:unset;box-shadow:none}.flow-button-text[data-v-262cdfdc]{background:transparent;box-shadow:none;color:var(--theme-color-3, var(--default-theme-color-3))}.flow-button-text[data-v-262cdfdc]:active{background:transparent}.flow-button-text[data-v-262cdfdc]:hover,.flow-button-text[data-v-262cdfdc]:focus-visible{color:var(--theme-color-2, var(--default-theme-color-2));background:transparent;box-shadow:none}.flow-button-text[disabled][data-v-262cdfdc]{background:transparent;color:var(--theme-color-ghost, var(--default-theme-color-ghost));cursor:unset;box-shadow:none}.flow-button--delete[data-v-262cdfdc]{background:var(--theme-error-color, var(--default-theme-color-red));color:#fff}.flow-button--delete[data-v-262cdfdc]:active{background:var(--theme-error-color, var(--default-theme-color-red))}.flow-button--delete[data-v-262cdfdc]:hover{background:var(--theme-error-color, var(--default-theme-color-red));opacity:.86}.flow-button-loader[data-v-262cdfdc]{position:absolute;right:8px}.flow-button-decorator[data-v-262cdfdc]{margin-right:9px;color:currentColor;display:flex;align-items:center;height:14px;width:14px}.flow-button-icon-only .flow-button-decorator[data-v-262cdfdc]{margin-right:0}.action-menu[data-v-2fd8cd87]{position:absolute;top:5px;right:5px;display:flex;gap:6px}.action-menu[data-v-2fd8cd87] .button-wrapper button{opacity:0;width:20px;height:20px;padding:4px}.action-menu[data-v-2fd8cd87]:hover .button-wrapper button,.action-menu[data-v-2fd8cd87] .button-wrapper button:hover,.sidebar-heading:hover~.action-menu[data-v-2fd8cd87] .button-wrapper button,.action-menu[data-v-2fd8cd87] .button-wrapper button[aria-expanded=true]{opacity:1}.sidebar-heading[data-v-2fd8cd87]:has(~.action-menu:hover){color:var(--sidebar-color-1, var(--default-sidebar-color-1), var(--theme-color-1, var(--default-theme-color-1)));background:var(--sidebar-item-hover-background, var(--default-sidebar-item-hover-background), var(--theme-background-2, var(--default-theme-background-2)))}.sidebar-heading-type[data-v-2fd8cd87]{width:28px;height:12px;line-height:13px;top:3.5px;margin-left:2px;border-radius:30px;flex-shrink:0;color:var( --sidebar-background-1, var( --default-sidebar-background-1, var(--theme-background-1, var(--default-theme-background-1)) ) );font-size:0px;font-weight:700;text-align:center;position:relative;font-family:var(--theme-font-code, var(--default-theme-font-code))}.active_page .sidebar-heading-type[data-v-2fd8cd87]{background:transparent;box-shadow:inset 0 0 0 1px var( --sidebar-color-active, var( --default-sidebar-color-active, var(--theme-color-accent, var(--default-theme-color-accent)) ) );color:var( --sidebar-color-active, var( --default-sidebar-color-active, var(--theme-color-accent, var(--default-theme-color-accent)) ) )!important}.sidebar-group-item__folder .sidebar-heading-type[data-v-2fd8cd87]{display:none}.sidebar-heading-type[data-v-2fd8cd87]:before{font-size:8px}.sidebar-heading-type--post[data-v-2fd8cd87]{background:var(--theme-color-green, var(--default-theme-color-green))}.sidebar-heading-type--post[data-v-2fd8cd87]:before{content:"POST"}.sidebar-heading-type--delete[data-v-2fd8cd87]{background:var(--theme-color-red, var(--default-theme-color-red))}.sidebar-heading-type--delete[data-v-2fd8cd87]:before{content:"DEL"}.sidebar-heading-type--patch[data-v-2fd8cd87]{background:var(--theme-color-yellow, var(--default-theme-color-yellow))}.sidebar-heading-type--patch[data-v-2fd8cd87]:before{content:"PATCH"}.sidebar-heading-type--get[data-v-2fd8cd87]{background:var(--theme-color-blue, var(--default-theme-color-blue))}.sidebar-heading-type--get[data-v-2fd8cd87]:before{content:"GET"}.sidebar-heading-type--put[data-v-2fd8cd87]{background:var(--theme-color-orange, var(--default-theme-color-orange))}.sidebar-heading-type--put[data-v-2fd8cd87]:before{content:"PUT"}.sidebar{--default-theme-sidebar-indent-base: 6px}.sidebar{flex:1;height:100%;display:flex;flex-direction:column;border-right:1px solid var( --sidebar-border-color, var( --default-sidebar-border-color, var(--theme-border-color, var(--default-theme-border-color)) ) );background:var(--sidebar-background-1, var(--default-sidebar-background-1, var(--theme-background-1, var(--default-theme-background-1))));--default-sidebar-level: 0}.pages{flex:1;padding-top:9px;padding-bottom:9px}.sidebar-group{list-style:none;width:100%}.sidebar-heading{display:flex;gap:6px;color:var(--sidebar-color-2, var(--default-theme-color-2, var(--theme-color-2, var(--default-theme-color-2))));font-size:var(--theme-mini, var(--default-theme-mini));font-weight:var(--theme-semibold, var(--default-theme-semibold));word-break:break-word;line-height:1.385;align-items:center;max-width:100%;position:relative;cursor:pointer;border-radius:0 var(--theme-radius, var(--default-theme-radius)) var(--theme-radius, var(--default-theme-radius)) 0;flex:1;padding-right:12px;-webkit-user-select:none;user-select:none}.toggle-nested-icon{border:none;position:absolute!important;top:4px;color:currentColor}.toggle-nested-icon:hover,.toggle-nested-icon:focus-visible{color:currentColor;filter:drop-shadow(0 .125px 0 currentColor) drop-shadow(0 -.125px 0 currentColor)}.sidebar-indent-nested .sidebar-heading{padding-left:calc((var(--sidebar-level, var(--default-sidebar-level)) * var(--theme-sidebar-indent-base, var(--default-theme-sidebar-indent-base))) + 24px)!important}.sidebar-indent-nested .sidebar-heading .toggle-nested-icon{left:calc((var(--sidebar-level, var(--default-sidebar-level)) * var(--theme-sidebar-indent-base, var(--default-theme-sidebar-indent-base))) + 2px)!important}.sidebar-heading-link{padding:6px 0;display:flex;flex:1;justify-content:space-between;align-items:flex-start!important}.link-icon{position:relative;left:4px}.sidebar-icon{display:flex;align-items:center;justify-content:center;margin-right:6px;width:13px;height:13px}.sidebar-icon>svg{width:13px;height:13px}.sidebar-heading:hover{background:var(--sidebar-item-hover-background, var(--default-sidebar-item-hover-background, var(--theme-background-2, var(--default-theme-background-2))))}.sidebar-heading:hover p{color:var( --sidebar-item-hover-color, var( --default-sidebar-item-hover-color, var(--theme-color-accent, var(--default-theme-color-accent)) ) )}.sidebar-group-item{position:relative}.sidebar-group-item--without-parent .sidebar-heading{margin-left:12px;padding-left:12px!important;border-radius:var(--theme-radius, var(--default-theme-radius))}.sidebar-indent-nested .sidebar-heading{color:var(--sidebar-color-1, var(--default-sidebar-color-1, var(--theme-color-1, var(--default-theme-color-1))))}.sidebar-indent-nested .sidebar-indent-nested .sidebar-heading{color:var(--sidebar-color-2, var(--default-sidebar-color-2, var(--theme-color-2, var(--default-theme-color-2))))}.sidebar-mobile-header{display:flex;align-items:center;gap:12px;height:100%;width:100%;padding:0 6px}.sidebar-mobile-breadcrumbs{flex:1;min-width:0;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;font-size:var(--theme-small, var(--default-theme-small));font-weight:var(--theme-semibold, var(--default-theme-semibold))}.sidebar-mobile-actions{display:flex;flex-direction:row;gap:4px;height:24px;align-items:center;padding-left:4px}.sidebar-mobile-actions .sidebar-mobile-darkmode-toggle{width:auto;margin:0}.sidebar-mobile-actions .sidebar-mobile-darkmode-toggle .darklight{height:24px;width:24px;font-size:0;padding:0;margin-top:0;border-top:0;text-indent:0;color:var(--theme-color-3, var(--default-theme-color-3));display:flex;align-items:center;justify-content:center}.sidebar-mobile-actions .sidebar-mobile-darkmode-toggle svg{width:15px;height:15px}.sidebar-mobile-actions .darklight-reference-promo{display:none}.active_page.sidebar-heading:hover,.active_page.sidebar-heading{background:var(--sidebar-item-active-background, var(--default-sidebar-item-active-background, var(--theme-background-accent, var(--default-theme-background-accent))))!important}.active_page.sidebar-heading svg,.active_page.sidebar-heading:hover svg,.active_page.sidebar-heading p,.active_page.sidebar-heading:hover p{color:var(--sidebar-color-active, var(--default-sidebar-color-active, var(--theme-color-accent, var(--default-theme-color-accent))))!important}@media (max-width: 1000px){.sidebar{min-height:0}.pages{padding-top:12px}}@media (max-width: 500px){.header-item-link.header-item-active,.sidebar-section,.sidebar-heading{font-size:var(--theme-micro, var(--default-theme-micro))}}.scalar-api-client__container .scalar-api-client[data-v-07cec4a9]{width:calc(100% - var(--refs-sidebar-width))}@media screen and (max-width: 1000px){.scalar-api-client__container .scalar-api-client[data-v-07cec4a9]{width:100%}}.scalar-api-client__container[data-v-07cec4a9]{position:absolute;right:0;left:0;bottom:0;top:0;z-index:9;border-radius:0;box-shadow:none;opacity:1;pointer-events:all;background:var( --theme-background-1, var(--default-theme-background-1) )!important;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));box-shadow:var(--theme-shadow-1, var(--default-theme-shadow-1));height:100%;overflow:hidden;display:flex;flex-direction:column}.scalar-api-client__navigation[data-v-07cec4a9]{width:100%;display:flex;align-items:center;padding:11px 12px;height:var(--refs-header-height);background-color:var( --theme-background-1, var(--default-theme-background-1) );z-index:10;position:sticky;border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color));top:0}.scalar-api-client__close[data-v-07cec4a9]{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:none;display:flex;align-items:center;background:transparent;font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var(--theme-semibold, var(--default-theme-semibold))}.scalar-api-client__close[data-v-07cec4a9]:hover{cursor:pointer}.api-client-drawer[data-v-07cec4a9]{background:var(--theme-background-1, var(--default-theme-background-1));height:calc(100% - 58px);width:calc(100% - 8px);border-radius:12px;overflow:hidden;visibility:visible;position:fixed;bottom:4px;left:4px;z-index:1001;opacity:0;animation:apiclientfadein-07cec4a9 .35s forwards}.api-client-drawer[data-v-07cec4a9]:before{content:"";display:block;width:100%;height:100%;position:absolute;z-index:0}.dark-mode .api-client-drawer[data-v-07cec4a9]:before{background:#1a1a1a}.light-mode .api-client-drawer[data-v-07cec4a9]:before{background:#fff}@keyframes apiclientfadein-07cec4a9{0%{transform:translate3d(0,20px,0) scale(.985);opacity:0}to{transform:translateZ(0) scale(1);opacity:1}}.api-client-drawer-exit[data-v-07cec4a9]{position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,.44);transition:all .3s ease-in-out;z-index:1000;cursor:pointer;animation:drawerexitfadein-07cec4a9 .35s forwards}.api-client-drawer-exit[data-v-07cec4a9]:before{content:"×";font-family:sans-serif;position:absolute;top:0;font-size:30px;font-weight:100;line-height:50px;right:12px;text-align:center;color:#fff;opacity:.6}.api-client-drawer-exit[data-v-07cec4a9]:hover:before{opacity:1}@keyframes drawerexitfadein-07cec4a9{0%{opacity:0}to{opacity:1}}.scalar-api-client-height[data-v-07cec4a9]{height:100%}.scalar-api-client-height .sidebar[data-v-07cec4a9]{flex:1 1 0%;flex-grow:1;flex-shrink:1;flex-basis:0%;height:100%;display:flex;flex-direction:column;width:var(--refs-sidebar-width);max-width:var(--refs-sidebar-width);border-right:1px solid var( --sidebar-border-color, var( --default-sidebar-border-color, var(--theme-border-color, var(--default-theme-border-color)) ) )}.progress-ring[data-v-d16794fb]{transform:rotate(-90deg);transform-origin:50% 50%;animation:linear turn-d16794fb reverse forwards}@keyframes turn-d16794fb{0%{stroke-dashoffset:var(--399d17d8)}to{stroke-dashoffset:0}}.toast-layout[data-v-ce041b52]{pointer-events:initial;padding:18px;background:var(--theme-background-1, var(--default-theme-background-1));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));font-size:var(--theme-font-size-3, var(--default-theme-font-size-3));color:var(--theme-color-1, var(--default-theme-color-1));display:grid;grid-template-columns:auto 1fr auto;grid-template-areas:"icon title timeout" ". description description";align-items:center;position:relative;width:100%}.toast-title[data-v-ce041b52]{grid-area:title;font-weight:var(--theme-font-semibold, var(--default-theme-font-semibold));display:flex;align-items:center}.toast-description[data-v-ce041b52]{grid-area:description;margin-top:5px;line-height:1.45;color:var(--theme-color-2, var(--default-theme-color-2))}.toast-icon[data-v-ce041b52]{grid-area:icon;display:flex;align-items:center;justify-content:center;margin-right:10px;color:var(--theme-color-2, var(--default-theme-color-2))}.toast-icon[data-v-ce041b52]>*{width:14px;height:14px}.toast-timeout[data-v-ce041b52]{grid-area:timeout;margin-left:10px;width:16px;height:16px;display:flex;color:var(--theme-color-ghost, var(--default-theme-color-ghost))}.toast-error .toast-icon[data-v-ce041b52],.toast-error .toast-title[data-v-ce041b52]{color:var(--theme-error-color, var(--default-theme-color-red))}.toast[data-v-4e50f02e]{pointer-events:initial;filter:brightness(var(--theme-lifted-brightness, var(--default-theme-lifted-brightness)));background:var(--theme-background-1, var(--default-theme-background-1));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));box-shadow:var(--theme-shadow-2, var(--default-theme-shadow-2));font-family:var(--theme-font, var(--default-theme-font));width:380px;max-width:100%;min-width:0}.toast-container[data-v-b6c63ea1]{width:100dvw;height:100svh;position:fixed;bottom:0;z-index:1000000;pointer-events:none;display:flex;flex-direction:column;align-items:flex-end;justify-content:flex-end;gap:12px;padding:48px}@media screen and (max-width: 600px){.toast-container[data-v-b6c63ea1]{padding:24px}}.toasts-move[data-v-b6c63ea1],.toasts-enter-active[data-v-b6c63ea1],.toasts-leave-active[data-v-b6c63ea1]{transition:all .5s ease}.toasts-enter-from[data-v-b6c63ea1],.toasts-leave-to[data-v-b6c63ea1]{opacity:0;transform:translate(30px)}.toast-leave-active[data-v-b6c63ea1]{position:absolute}.section[data-v-30f8611d]{position:relative;display:flex;flex-direction:column;max-width:1120px;margin:auto;padding:90px 0}.references-narrow .section[data-v-30f8611d]{padding:48px 24px}.section[data-v-30f8611d]:not(:last-of-type){border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.section-column[data-v-7e657da0]{flex:1;min-width:0}.section-column[data-v-7e657da0]:nth-of-type(2){padding-top:48px}.references-narrow .section-column[data-v-7e657da0]:nth-of-type(2){padding-top:0}.section-columns[data-v-0bd51848]{display:flex;gap:48px}.references-narrow .section-columns[data-v-0bd51848]{flex-direction:column;gap:24px}.section-container[data-v-a27b5d0a]{position:relative;padding:0 60px;width:100%}.references-narrow .section-container[data-v-a27b5d0a]{padding:0}.section-container[data-v-a27b5d0a]:not(:last-of-type){border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.loading[data-v-99d52311]{background:var(--theme-background-3, var(--default-theme-background-3));animation:loading-skeleton-99d52311 1.5s infinite alternate;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));min-height:1.6em;margin:.6em 0;max-width:100%}.loading[data-v-99d52311]:first-of-type{min-height:3em;margin-bottom:24px;margin-top:0}.loading[data-v-99d52311]:last-of-type{width:60%}.loading.single-line[data-v-99d52311]{min-height:3em;margin:.6em 0;max-width:80%}@keyframes loading-skeleton-99d52311{0%{opacity:1}to{opacity:.33}}.references-narrow .section-content--with-columns[data-v-bba63beb]{flex-direction:column;gap:24px}.section-header[data-v-566623fe]{font-size:var( --font-size, var( --default-font-size, var(--theme-heading-2, var(--default-theme-heading-2)) ) );font-weight:var( --font-weight, var(--default-font-weight, var(--theme-bold, var(--default-theme-bold))) );color:var(--theme-color-1, var(--default-theme-color-1));word-wrap:break-word;line-height:1.45;margin-top:0;margin-bottom:0}.section-header.tight[data-v-566623fe]{margin-bottom:6px}.section-header.loading[data-v-566623fe]{width:80%}.label[data-v-41f5d83a]{position:relative;display:inline-block}.anchor[data-v-41f5d83a]{position:relative;display:inline-block;opacity:0}.anchor-copy[data-v-41f5d83a]{position:absolute;left:0;top:50%;transform:translateY(-50%);padding:0 6px;color:var(--theme-color-3, var(--default-theme-color-3));font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:.8em}.anchor-copy[data-v-41f5d83a]:hover,.anchor-copy[data-v-41f5d83a]:focus-visible{color:var(--theme-color-2, var(--default-theme-color-2))}.label:hover .anchor[data-v-41f5d83a]{opacity:1}.scalar-card[data-v-dbd5ab78]{all:unset;font-family:var(--theme-font, var(--default-theme-font));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));overflow:hidden;border:1px solid var(--theme-border-color, var(--default-theme-border-color));background:var(--theme-background-2, var(--default-theme-background-2));display:flex;flex-direction:column;max-height:calc(((var(--full-height) - var(--refs-header-height)) - 60px) / 2);position:relative}.scalar-card-content[data-v-4dc9c56e]{overflow:auto;border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.scalar-card-content[data-v-4dc9c56e] .simple-table .simple-header{display:none}.scalar-card-content[data-v-4dc9c56e]:last-of-type,.scalar-card-content.scalar-card--borderless[data-v-4dc9c56e]{border-bottom:none}.scalar-card--muted[data-v-4dc9c56e]{background:var(--theme-background-2, var(--default-theme-background-2))}.scalar-card--contrast[data-v-4dc9c56e]{background:var(--theme-background-3, var(--default-theme-background-3))}.scalar-card--frameless[data-v-4dc9c56e]{padding:0}.scalar-card--transparent[data-v-4dc9c56e]{background:var(--theme-background-1, var(--default-theme-background-1))}.scalar-card-header[data-v-a8e4ead5]{font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-mini, var(--default-theme-mini));color:var(--theme-color-3, var(--default-theme-color-3));flex-shrink:0}.scalar-card-header-slots[data-v-a8e4ead5]{display:flex;justify-content:space-between;margin:9px 0 9px 12px;line-height:1.35}.scalar-card-header-title[data-v-a8e4ead5]{text-transform:uppercase;word-break:break-all}.scalar-card-header-actions[data-v-a8e4ead5]{display:flex}.scalar-card-footer[data-v-5d002776]{flex-shrink:0}.tab-list[data-v-b81067df]{display:flex;gap:6px;position:relative;flex:1}.tab[data-v-d044c876]{background:none;border:none;font-size:var(--theme-mini, var(--default-theme-mini));font-family:var(--theme-font, var(--default-theme-font));color:var(--theme-color-2, var(--default-theme-color-2));font-weight:var(--theme-semibold, var(--default-theme-semibold));line-height:calc(var(--theme-mini, var(--default-theme-mini)) + 2px);white-space:nowrap;cursor:pointer;padding:0;margin-right:3px;text-transform:uppercase;position:relative;line-height:1.35}.tab[data-v-d044c876]:before{content:"";position:absolute;z-index:0;left:-6px;top:-6px;width:calc(100% + 12px);height:calc(100% + 12px);border-radius:var(--theme-radius, var(--default-theme-radius));background:var(--theme-background-3, var(--default-theme-background-3));opacity:0}.tab[data-v-d044c876]:hover:before{opacity:1}.tab span[data-v-d044c876]{z-index:1;position:relative}.tab-selected[data-v-d044c876]{color:var(--theme-color-1, var(--default-theme-color-1));text-decoration:underline;text-underline-offset:var(--theme-micro, var(--default-theme-micro))}.markdown[data-v-26c60f56]{color:var(--theme-color-1, var(--default-theme-color-1));all:unset;word-break:break-word}.markdown[data-v-26c60f56] *{all:unset;margin:12px 0;font-family:var(--theme-font, var(--default-theme-font));color:var(--theme-color-1, var(--default-theme-color-1))}.markdown[data-v-26c60f56] h1,.markdown[data-v-26c60f56] h2,.markdown[data-v-26c60f56] h3,.markdown[data-v-26c60f56] h4,.markdown[data-v-26c60f56] h5,.markdown[data-v-26c60f56] h6{font-size:var(--font-size, var(--default-font-size));margin:24px 0 6px;font-weight:var(--theme-bold, var(--default-theme-bold));display:block;line-height:1.45}.markdown[data-v-26c60f56] b,.markdown[data-v-26c60f56] strong{font-weight:var(--theme-bold, var(--default-theme-bold))}.markdown[data-v-26c60f56] p{font-size:var( --font-size, var(--default-font-size), var(--theme-paragraph, var(--default-theme-paragraph)) );color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var( --font-weight, var(--default-font-weight), var(--theme-small, var(--default-theme-small)) );line-height:1.5;margin-bottom:0;display:block}.markdown[data-v-26c60f56] ul,.markdown[data-v-26c60f56] ol{padding-left:24px;line-height:1.5;margin:12px 0;display:block}.markdown[data-v-26c60f56] ul{list-style:disc}.markdown[data-v-26c60f56] ol{list-style:decimal}.markdown[data-v-26c60f56] ul.contains-task-list{list-style:none;padding-left:0}.markdown[data-v-26c60f56] li{margin:6px 0;display:list-item}.markdown[data-v-26c60f56] a{color:var( --theme-color-accent, var(--default-theme-color-accent) )!important;text-decoration:none!important;cursor:pointer}.markdown[data-v-26c60f56] a:hover{text-decoration:underline!important}.markdown[data-v-26c60f56] code{font-family:var(--theme-font-code, var(--default-theme-font-code));background-color:var( --theme-background-2, var(--default-theme-background-2) );box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));font-size:var(--theme-micro, var(--default-theme-micro));border-radius:2px;padding:0 3px}.markdown[data-v-26c60f56] pre code{display:block;white-space:pre;padding:12px;line-height:1.5;margin:12px 0;-webkit-overflow-scrolling:touch;overflow-x:auto;max-width:100%;min-width:100px}.markdown[data-v-26c60f56] blockquote{border-left:3px solid var(--theme-border-color, var(--default-theme-border-color));padding-left:12px;margin:0;display:block}.markdown[data-v-26c60f56] table{display:table;position:relative;border-collapse:collapse;table-layout:fixed;width:100%;margin:1em 0;overflow:hidden;box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.markdown[data-v-26c60f56] tbody{display:table-row-group;vertical-align:middle}.markdown[data-v-26c60f56] thead{display:table-header-group;vertical-align:middle}.markdown[data-v-26c60f56] tr{display:table-row;border-color:inherit;vertical-align:inherit}.markdown[data-v-26c60f56] td,.markdown[data-v-26c60f56] th{display:table-cell;vertical-align:inherit;min-width:1em;padding:6px 9px;vertical-align:top;box-sizing:border-box;position:relative;word-break:break-all;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.markdown[data-v-26c60f56] td>*,.markdown[data-v-26c60f56] th>*{margin-bottom:0}.markdown[data-v-26c60f56] th:empty{display:none}.markdown.parameter-description[data-v-26c60f56] p{margin-top:4px;font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-2, var(--default-theme-color-2));line-height:1.4}.markdown[data-v-26c60f56] td:first-of-type,.markdown[data-v-26c60f56] th:first-of-type{border-left:none}.markdown[data-v-26c60f56] td:last-of-type,.markdown[data-v-26c60f56] th:last-of-type{border-right:none}.markdown[data-v-26c60f56] tr:last-of-type td{border-bottom:none}.markdown[data-v-26c60f56] th{font-weight:var(--theme-semibold, var(--default-theme-semibold))!important;text-align:left;border-left-color:transparent;background:var(--theme-background-2, var(--default-theme-background-2))}.markdown pre code.hljs{display:block;overflow-x:auto;padding:1em}.markdown pre *{font-size:var(--theme-small, var(--default-theme-small))!important;font-family:var( --theme-font-code, var(--default-theme-font-code) )!important}.markdown code.hljs{padding:3px 5px}.markdown .hljs{background:var(--theme-background-4, var(--default-theme-background-4));color:var(--theme-color-1, var(--default-theme-color-1))}.markdown .hljs-comment,.markdown .hljs-quote{color:var(--theme-color-3, var(--default-theme-color-3));font-style:italic}.markdown .hljs-addition,.markdown .hljs-keyword,.markdown .hljs-literal,.markdown .hljs-selector-tag,.markdown .hljs-type{color:var(--theme-color-green, var(--default-theme-color-green))}.markdown .hljs-number,.markdown .hljs-selector-attr,.markdown .hljs-selector-pseudo{color:var(--theme-color-orange, var(--default-theme-color-orange))}.markdown .hljs-doctag,.markdown .hljs-regexp,.markdown .hljs-string{color:var(--theme-color-blue, var(--default-theme-color-blue))}.markdown .hljs-built_in,.markdown .hljs-name,.markdown .hljs-section,.markdown .hljs-title,.markdown .hljs-class .hljs-title,.markdown .hljs-selector-id,.markdown .hljs-template-variable,.markdown .hljs-title.class_,.markdown .hljs-variable{color:var(--theme-color-1, var(--default-theme-color-1))}.markdown .hljs-name,.markdown .hljs-section,.markdown .hljs-strong{font-weight:var(--theme-semibold, var(--default-theme-semibold))}.markdown .hljs-bullet,.markdown .hljs-link,.markdown .hljs-meta,.markdown .hljs-subst,.markdown .hljs-symbol{color:var(--theme-color-blue, var(--default-theme-color-blue))}.markdown .hljs-deletion{color:var(--theme-color-red, var(--default-theme-color-red))}.markdown .hljs-formula{background:var(--theme-color-1, var(--default-theme-color-1))}.markdown .hljs-attr,.markdown .hljs-attribute{color:var(--theme-color-1, var(--default-theme-color-1))}.markdown .hljs-emphasis{font-style:italic}.endpoints[data-v-46127622]{overflow:auto;background:var(--theme-background-2, var(--default-theme-background-2));padding:10px 12px}@media (max-width: 580px){.endpoints[data-v-46127622]{max-height:calc(100vh - 150px)}}.endpoints span+span[data-v-46127622]{text-align:left;margin-left:12px;text-transform:initial}.endpoint[data-v-46127622]{display:flex;white-space:nowrap;cursor:pointer}.endpoint span[data-v-46127622]:first-of-type{text-transform:uppercase}.endpoint .post[data-v-46127622]{color:var(--theme-color-green, var(--default-theme-color-green))}.endpoint .patch[data-v-46127622]{color:var(--theme-color-yellow, var(--default-theme-color-yellow))}.endpoint .get[data-v-46127622]{color:var(--theme-color-blue, var(--default-theme-color-blue))}.endpoint .delete[data-v-46127622]{color:var(--theme-color-red, var(--default-theme-color-red))}.endpoint .put[data-v-46127622]{color:var(--theme-color-orange, var(--default-theme-color-orange))}.endpoint .post[data-v-46127622],.endpoint .get[data-v-46127622],.endpoint .delete[data-v-46127622],.endpoint .put[data-v-46127622]{white-space:nowrap}.endpoint span[data-v-46127622]{color:var(--theme-color-1, var(--default-theme-color-1));min-width:62px;display:inline-block;text-align:right;line-height:1.55;font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var(--theme-small, var(--default-theme-small));cursor:pointer}.security-scheme[data-v-931785ef]{margin:9px;color:var(--theme-color-1, var(--default-theme-color-1));border-radius:var(--theme-radius, var(--default-theme-radius));position:relative;box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color))}.security-scheme[data-v-931785ef] .input:nth-of-type(3)~.input{height:0px;opacity:0}.security-scheme[data-v-931785ef] .input:nth-of-type(3):not(:last-child):before{content:"Show More...";white-space:nowrap;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-3, var(--default-theme-color-3));font-weight:var(--theme-semibold, var(--default-theme-semibold));pointer-events:none;position:absolute;padding:9px}.security-scheme[data-v-931785ef] .input:hover:before{color:var(--theme-color-1, var(--default-theme-color-1))!important}.security-scheme[data-v-931785ef]:focus-within .input:nth-of-type(3):not(:last-child):before{display:none}.security-scheme[data-v-931785ef]:not(:focus-within) .input:nth-of-type(3):not(:last-child){box-shadow:none!important}.security-scheme[data-v-931785ef] .input:nth-of-type(3):not(:last-child) input,.security-scheme[data-v-931785ef] .input:nth-of-type(3):not(:last-child) label{opacity:0}.security-scheme[data-v-931785ef]:focus-within .input:nth-of-type(3) input,.security-scheme[data-v-931785ef]:focus-within .input:nth-of-type(3) label,.security-scheme[data-v-931785ef]:focus-within .input:nth-of-type(3)~.input{opacity:1;height:fit-content;transition:opacity .3s ease-in-out}.description[data-v-931785ef]{margin-bottom:12px}.work-in-progress[data-v-931785ef]{color:var(--theme-color-1, var(--default-theme-color-1));padding:9px;border-radius:var(--theme-radius, var(--default-theme-radius));font-size:var(--theme-micro, var(--default-theme-micro));display:flex;box-shadow:0 0 0 1px var(--theme-color-yellow, var(--default-theme-color-yellow));position:relative}.work-in-progress[data-v-931785ef]:before{content:"";position:absolute;left:0;top:0;width:100%;height:100%;background:var(--theme-color-yellow, var(--default-theme-color-yellow));opacity:.1}.work-in-progress-title[data-v-931785ef]{font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-micro, var(--default-theme-micro));margin-top:0;margin-bottom:0;margin-right:6px}.security-scheme-selector[data-v-6dd8f6a0]{position:relative;border-radius:var(--theme-radius, var(--default-theme-radius));color:var(--theme-color-2, var(--default-theme-color-2));display:flex;align-items:center;gap:4px;cursor:pointer}.security-scheme-selector[data-v-6dd8f6a0]:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.security-scheme-selector span[data-v-6dd8f6a0]{font-size:var(--theme-mini, var(--default-theme-mini))}.security-scheme-selector select[data-v-6dd8f6a0]{opacity:0;position:absolute;top:0;bottom:0;left:0;right:0;cursor:pointer}.security-scheme-selector svg[data-v-6dd8f6a0]{width:12px;stroke:currentColor}.selector[data-v-102a910e]{margin-right:12px}.client-libraries-content[data-v-07617be9]{display:flex;justify-content:center;gap:6px;padding:0 12px;overflow:hidden}.code-languages[data-v-07617be9]{display:flex;align-items:center;justify-content:center;flex-direction:column;max-width:68px;width:100%;padding:12px 0;position:relative;cursor:pointer;white-space:nowrap}@media screen and (max-width: 450px){.code-languages[data-v-07617be9]:nth-of-type(4),.code-languages[data-v-07617be9]:nth-of-type(6){display:none}}.code-languages-icon[data-v-07617be9]{max-width:48px;width:100%;max-height:48px;aspect-ratio:1;padding:7px;display:flex;align-items:center;justify-content:center;position:relative;box-sizing:border-box;color:var( --theme-code-language-color-supersede, var(--default-theme-code-language-color-supersede, #fff) )}.code-languages-background[data-v-07617be9]{border-radius:12px;position:relative;box-shadow:0 0 0 1px var( --theme-code-languages-border-color, var(--default-theme-code-languages-border-color) )}.code-languages-background[data-v-07617be9]:before{content:"";width:calc(100% + 2px);height:calc(100% + 2px);position:absolute;top:-1px;left:-1px;pointer-events:none;border-radius:12px;background:var( --theme-code-languages-background-supersede, var(--default-theme-code-languages-background-supersede) )}.code-languages-icon__shell[data-v-07617be9]{background:#000}.code-languages-icon__ruby[data-v-07617be9]{background:#d91404}.code-languages-icon__php[data-v-07617be9]{background:#6181b6}.code-languages-icon__python[data-v-07617be9]{background:#306998}.code-languages-icon__more[data-v-07617be9]{background:var(--theme-background-3, var(--default-theme-background-3))}.code-languages-icon__node[data-v-07617be9]{background:#83cd29}.code-languages-icon__c[data-v-07617be9]{background:#03599c}.code-languages-icon__csharp[data-v-07617be9]{background:#68217a}.code-languages-icon__cplusplus[data-v-07617be9]{background:#9c033a}.code-languages-icon__clojure[data-v-07617be9]{background:#5881d8}.code-languages-icon__go[data-v-07617be9]{background:#00acd7}.code-languages-icon__http[data-v-07617be9]{background:#005b9b}.code-languages-icon__java[data-v-07617be9]{background:#ea2d2e}.code-languages-icon__javascript[data-v-07617be9]{background:#f0db4f}.code-languages-icon__kotlin[data-v-07617be9]{background:#7f6cb1}.code-languages-icon__objc[data-v-07617be9]{background:#0b5a9d}.code-languages-icon__ocaml[data-v-07617be9]{background:#f29100}.code-languages-icon__powershell[data-v-07617be9]{background:#2671be}.code-languages-icon__r[data-v-07617be9]{background:#cbced0}.code-languages-icon__swift[data-v-07617be9]{background:#f05138}.code-languages__loading .code-languages-icon[data-v-07617be9]:before{border:1px solid rgba(255,255,255,.44);border-top:1px solid white;animation:codeloader-07617be9 .45s linear infinite;background:transparent;width:18px;height:18px;content:"";border-radius:50%}.code-languages__loading .code-languages-icon svg[data-v-07617be9]{display:none}.code-languages__active[data-v-07617be9]:after{content:"";position:absolute;bottom:0;height:2px;width:100%;background:var(--theme-color-1, var(--default-theme-color-1))}@keyframes codeloader-07617be9{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.code-languages span[data-v-07617be9]{margin-top:3px;color:var(--theme-color-2, var(--default-theme-color-2));font-size:var(--theme-micro, var(--default-theme-micro))}.code-languages__active span[data-v-07617be9]{color:var(--theme-color-1, var(--default-theme-color-1))}.code-languages__select select[data-v-07617be9]{opacity:0;width:100%;height:100%;position:absolute;top:0;left:0;cursor:pointer;z-index:1}.code-languages__select span[data-v-07617be9]{position:relative;display:flex;align-items:center}.code-languages__select span[data-v-07617be9]:after{content:"";width:8px;height:8px;background:var(--theme-background-1, var(--default-theme-background-1));box-shadow:1px 1px 0 currentColor;display:block;transform:rotate(45deg);margin-left:5px;margin-top:-7px}.download-cta[data-v-fa6b3604]{margin-bottom:24px}.download-cta a[data-v-fa6b3604]{color:var(--theme-color-accent, var(--default-theme-color-accent));text-decoration:none;font-size:var(--theme-paragraph, var(--default-theme-paragraph))}.download-cta a[data-v-fa6b3604]:hover{text-decoration:underline}.base-url-variable{color:var(--theme-color-1, var(--default-theme-color-1))}.base-url[data-v-5ca0a51c]{color:var(--theme-color-2, var(--default-theme-color-2));cursor:pointer;font-family:var(--theme-font-code, var(--default-theme-font-code));display:inline-block;padding:10px 0;font-size:var(--theme-micro, var(--default-theme-micro))}.input select[data-v-a157de95]{position:absolute;top:0;left:0;right:0;bottom:0;opacity:0}.input-value[data-v-a157de95]{color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-micro, var(--default-theme-micro));padding:9px}.variable-description[data-v-a157de95]{padding:6px 12px;font-size:var(--theme-small, var(--default-theme-small))}.variable-description[data-v-a157de95] .markdown{font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color--1, var(--default-theme-color-1));padding:4px 0;display:block}.variable-description[data-v-a157de95] .markdown>*:first-child{margin-top:0}.input[data-v-a157de95]{align-items:center}.input[data-v-a157de95]:first-of-type{border-radius:0;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}.server-item[data-v-7734c88f]{padding:0 9px}.scalar-card-serverlist[data-v-7734c88f]{padding:9px}.server-selector[data-v-7734c88f]{position:relative;display:flex;align-items:center;gap:2px;color:var(--theme-color-2, var(--default-theme-color-2))}.description[data-v-7734c88f]{padding:6px 12px;font-size:var(--theme-small, var(--default-theme-small))}.description[data-v-7734c88f] .markdown{font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color--1, var(--default-theme-color-1));padding:4px 0;display:block}.description[data-v-7734c88f] .markdown>*:first-child{margin-top:0}.server-selector select[data-v-7734c88f]{position:absolute;bottom:0;left:0;right:0;opacity:0;top:0}.server-selector svg[data-v-7734c88f]{width:12px}.scalar-card-serverlist-container[data-v-7734c88f]{box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius, var(--default-theme-radius))}.heading[data-v-37c3f0ff]{margin-top:0!important;word-wrap:break-word}.loading[data-v-37c3f0ff]{background:var(--theme-background-3, var(--default-theme-background-3));animation:loading-skeleton 1.5s infinite alternate;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.heading.loading[data-v-37c3f0ff]{width:80%}.font-mono[data-v-37c3f0ff]{color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-small, var(--default-theme-small));font-family:var(--theme-font-code, var(--default-theme-font-code));padding:10px 12px}.sticky-cards[data-v-37c3f0ff]{position:sticky;top:24px}.section-version[data-v-37c3f0ff],.section-oas[data-v-37c3f0ff]{color:var(--theme-color-2, var(--default-theme-color-2));font-size:var(--theme-micro, var(--default-theme-micro));background:var(--theme-background-2, var(--default-theme-background-2));padding:2px 6px;border-radius:12px;margin-right:4px;font-weight:var(--theme-semibold, var(--default-theme-semibold));margin-bottom:3px;display:inline-block}.property[data-v-ce036666]{padding:12px 0;overflow:auto}.property-information[data-v-ce036666]{display:flex;align-items:flex-end;gap:9px;white-space:nowrap}.property-description[data-v-ce036666]{margin-top:4px;color:var(--theme-color-2, var(--default-theme-color-2));line-height:1.4;font-size:var(--theme-small, var(--default-theme-small))}.property-rule[data-v-ce036666]{font-family:var(--theme-font-code, var(--default-theme-font-code));background:var(--theme-color-orange, var(--default-theme-color-orange));padding:0 6px}.property[data-v-ce036666]:not(:last-of-type){border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.property-name[data-v-ce036666]{font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var(--theme-mini, var(--default-theme-mini))}.required[data-v-ce036666],.optional[data-v-ce036666]{color:var(--theme-color-2, var(--default-theme-color-2));font-size:var( --default-theme-font-size-5, var(--default-default-theme-font-size-5) )}.required[data-v-ce036666]{text-transform:uppercase;color:var(--theme-color-orange, var(--default-theme-color-orange))}.property-type[data-v-ce036666]{color:var(--theme-color-2, var(--default-theme-color-2))}.property[data-v-ce036666]{padding:12px}.property-example[data-v-ce036666]{font-family:var(--theme-font-code, var(--default-theme-font-code))}.property-example-value[data-v-ce036666]{box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));background:var(--theme-background-2, var(--default-theme-background-2));border-radius:var(--theme-radius, var(--default-theme-radius));padding:2px 5px;font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var( --default-theme-font-size-5, var(--default-default-theme-font-size-5) )}.rule[data-v-ce036666]{margin-top:12px;padding:0 12px 12px;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));background:var(--theme-background-4, var(--default-theme-background-4));border:2px dotted var(--theme-border-color, var(--default-theme-border-color))}.property-enum-value[data-v-ce036666]{padding:3px 0}.property-enum-value[data-v-ce036666]:before{content:"◼";margin-right:6px;color:var(--theme-color-3, var(--default-theme-color-3))}.property-enum-values[data-v-ce036666]{margin-top:8px;list-style:none}.property-read-only[data-v-ce036666]{font-family:var(--theme-font-code, var(--default-theme-font-code))}.property-nullable[data-v-ce036666]{font-family:var(--theme-font-code, var(--default-theme-font-code));color:var(--theme-color-2, var(--default-theme-color-2))}.error[data-v-495e1c81]{background-color:red}.schema[data-v-495e1c81]{width:100%;font-size:var(--theme-font-size-3, var(--default-theme-font-size-3));color:var(--theme-color-1, var(--default-theme-color-1))}.type[data-v-495e1c81]{font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-2, var(--default-theme-color-2));font-family:var(--theme-font-code, var(--default-theme-font-code));font-weight:var(--theme-bold, var(--default-theme-bold));background:var(--theme-background-4, var(--default-theme-background-4));padding:10px 12px}.type-icon[data-v-495e1c81]{color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-micro, var(--default-theme-micro))}.properties[data-v-495e1c81]{border:1px solid var(--theme-border-color, var(--default-theme-border-color));margin:24px 0 0;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));overflow:hidden}.properties .properties[data-v-495e1c81]{margin-top:12px}.show-more[data-v-5ac202a8]{background:var(--theme-background-1, var(--default-theme-background-1));-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;border:1px solid var(--theme-border-color, var(--default-theme-border-color));padding:8px 12px;border-radius:30px;color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-small, var(--default-theme-small));display:flex;align-items:center;justify-content:center;position:relative;margin:48px auto}.show-more[data-v-5ac202a8]:hover{color:var(--theme-color-2, var(--default-theme-color-2));cursor:pointer}.show-more-icon[data-v-5ac202a8]{width:14px;height:14px;margin-left:3px}.show-more[data-v-5ac202a8]:active{box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color))}@media (max-width: 1165px){.show-more[data-v-5ac202a8]{margin:24px auto}}.title[data-v-d173780f]{margin-bottom:12px!important;margin-top:12px!important}.title[data-v-28fef31c]{margin-bottom:12px!important;margin-top:24px!important}.parameter p{margin-top:6px}.parameter .parameter-child{border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:20px;margin-top:12px;width:fit-content}.parameter .parameter{border:none!important}.parameter-child-trigger{padding:6px 12px;cursor:pointer;font-weight:500;color:var(--theme-color-3, var(--default-theme-color-3));font-size:var(--theme-micro, var(--default-theme-micro));display:flex;align-items:center;-webkit-user-select:none;user-select:none}.parameter-child-trigger:has(+.parameter li:first-of-type:last-of-type){display:none}.parameter-child-trigger:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.parameter-child-trigger>span:before{content:"Show "}.parameter-child__open>.parameter-child-trigger span:before{content:"Hide "}.parameter-child-trigger svg{height:10px;width:10px;margin-right:6px}.parameter-child__open .parameter-child-trigger svg{transform:rotate(45deg)}.parameter .parameter li:first-of-type{border-top:none}.parameter .parameter li{padding:10px 12px}.parameter-child__open>.parameter{display:block}.parameter .parameter-child__open{width:100%;border-radius:6px}.parameter .parameter-child__open>svg{transform:rotate(45deg)}.parameter-child__open>.parameter-child-trigger{border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.parameter{list-style:none;font-size:var(--theme-small, var(--default-theme-small))}.parameter li{border-top:1px solid var(--theme-border-color, var(--default-theme-border-color));padding:12px 0}.parameter-name{font-weight:500;margin-right:6px;font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var(--theme-mini, var(--default-theme-mini));color:var(--theme-color-1, var(--default-theme-color-1))}.parameter-type,.parameter-required{color:var(--theme-color-3, var(--default-theme-color-3));font-weight:var(--theme-semibold, var(--default-theme-semibold));margin-right:6px;position:relative}.parameter-description{margin-top:3px!important;font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-2, var(--default-theme-color-2));line-height:1.4}.parameter__required{text-transform:uppercase;font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-orange, var(--default-theme-color-orange))}.parameter-options{position:relative}.copy .title{font-size:var(--theme-heading-4, var(--default-theme-heading-4));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-1, var(--default-theme-color-1));line-height:1.45;margin:0}.copy .parameter-description:empty{display:none}.description[data-v-b9582b00]{margin-bottom:24px}.request-path-variable{color:var(--theme-color-1, var(--default-theme-color-1))}.request[data-v-39f0b6b9]{display:flex;flex-wrap:nowrap}.request-method[data-v-39f0b6b9]{white-space:nowrap}.request-method--post[data-v-39f0b6b9]{color:var(--theme-color-green, var(--default-theme-color-green))}.request-method--patch[data-v-39f0b6b9]{color:var(--theme-color-yellow, var(--default-theme-color-yellow))}.request-method--get[data-v-39f0b6b9]{color:var(--theme-color-blue, var(--default-theme-color-blue))}.request-method--delete[data-v-39f0b6b9]{color:var(--theme-color-red, var(--default-theme-color-red))}.request-method--put[data-v-39f0b6b9]{color:var(--theme-color-orange, var(--default-theme-color-orange))}.request-path[data-v-39f0b6b9]{margin-left:6px;color:var(--theme-color-2, var(--default-theme-color-2));overflow:hidden;cursor:default;word-wrap:break-word;text-transform:none!important}.language-select[data-v-39f0b6b9]{position:relative;padding-right:9px;height:fit-content;padding-left:12px;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color))}.language-select select[data-v-39f0b6b9]{border:none;outline:none;cursor:pointer;background:var(--theme-background-3, var(--default-theme-background-3));box-shadow:-2px 0 0 0 var(--theme-background-3, var(--default-theme-background-3));position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.language-select span[data-v-39f0b6b9]{font-size:var(--theme-mini, var(--default-theme-mini));color:var(--theme-color-2, var(--default-theme-color-2));font-weight:var(--theme-semibold, var(--default-theme-semibold));white-space:nowrap;display:flex;align-items:center;justify-content:center}.language-select:hover span[data-v-39f0b6b9]{color:var(--theme-color-1, var(--default-theme-color-1))}.language-select span[data-v-39f0b6b9]:after{content:"";width:7px;height:7px;transform:rotate(45deg) translate3d(-2px,-2px,0);display:block;margin-left:6px;box-shadow:1px 1px 0 currentColor}.language-select span[data-v-39f0b6b9]:hover{background:var(--theme-background-2, var(--default-theme-background-2))}.copy-button[data-v-39f0b6b9]{-moz-appearance:none;appearance:none;-webkit-appearance:none;outline:none;background:transparent;cursor:pointer;color:var(--theme-color-3, var(--default-theme-color-3));margin-left:6px;margin-right:12px;border:none;border-radius:3px;padding:0;display:flex;align-items:center;height:fit-content}.copy-button[data-v-39f0b6b9]:after{content:".";color:transparent;font-size:var(--theme-mini, var(--default-theme-mini));line-height:1.35;width:0px}.copy-button[data-v-39f0b6b9]:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.copy-button svg[data-v-39f0b6b9]{width:13px;height:13px}.show-api-client-button[data-v-39f0b6b9]{display:block;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;border:none;padding:6px;height:23px;margin:6px 6px 6px auto;border-radius:var(--theme-radius, var(--default-theme-radius));text-transform:uppercase;display:flex;justify-content:center;align-items:center;font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-background-2, var(--default-background-2));font-family:var(--theme-font, var(--default-theme-font));position:relative;cursor:pointer;box-sizing:border-box;box-shadow:inset 0 0 0 1px #0000001a}.show-api-client-button span[data-v-39f0b6b9],.show-api-client-button svg[data-v-39f0b6b9]{color:var(--theme-color-1, var(--default-theme-color-1));z-index:1}.show-api-client-button[data-v-39f0b6b9]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;cursor:pointer;border-radius:var(--theme-radius, var(--default-theme-radius))}.show-api-client-button[data-v-39f0b6b9]:before{background:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.2))}.show-api-client-button[data-v-39f0b6b9]:hover:before{background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.1))}.show-api-client-button svg[data-v-39f0b6b9]{height:12px;width:auto;margin-left:9px}.show-api-client-button--post[data-v-39f0b6b9]{background:var(--theme-color-green, var(--default-theme-color-green))}.show-api-client-button--patch[data-v-39f0b6b9]{background:var(--theme-color-yellow, var(--default-theme-color-yellow))}.show-api-client-button--get[data-v-39f0b6b9]{background:var(--theme-color-blue, var(--default-theme-color-blue))}.show-api-client-button--delete[data-v-39f0b6b9]{background:var(--theme-color-red, var(--default-theme-color-red))}.show-api-client-button--put[data-v-39f0b6b9]{background:var(--theme-color-orange, var(--default-theme-color-orange))}.request-method[data-v-39f0b6b9]{font-family:var(--theme-font-code, var(--default-theme-font-code));text-transform:uppercase}.request-path[data-v-39f0b6b9]{font-family:var(--theme-font-code, var(--default-theme-font-code))}.scalar-card-header-actions[data-v-39f0b6b9]{display:flex}@media screen and (max-width: 400px){.language-select[data-v-39f0b6b9]{position:absolute;bottom:9px;left:0;border-right:none}}.example-switcher[data-v-a88a80af]{display:flex;gap:6px;margin:12px 6px;flex-direction:column}.listbox-label[data-v-a88a80af]{font-size:var(--theme-mini, var(--default-theme-mini));font-weight:var(--theme-semibold, var(--default-theme-semibold));margin:0 4px;color:var(--theme-color-2, var(--default-theme-color-2))}.listbox-button[data-v-a88a80af]{border:1px solid var(--theme-border-color, var(--default-theme-border-color));background:var(--theme-background-1, var(--default-theme-background-1));padding:6px 12px;border-radius:var(--theme-radius, var(--default-theme-radius));text-align:left;display:block;font-size:var(--theme-mini, var(--default-theme-mini))}.listbox-button-content[data-v-a88a80af]{display:flex;align-items:center;justify-content:space-between}.listbox-button-label[data-v-a88a80af]{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.listbox-options[data-v-a88a80af]{background:var(--theme-background-1, var(--default-theme-background-1));padding:6px;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));box-shadow:var(--theme-shadow-2, var(--default-theme-shadow-2));position:absolute;margin:0 1px;transform:translateY(-50%);z-index:100}.listbox-option[data-v-a88a80af]{padding:6px 12px;cursor:pointer;color:var(--theme-color-1, var(--default-theme-color-1));border-radius:var(--theme-radius, var(--default-theme-radius));margin:2px 0}.listbox-option[data-headlessui-state=selected][data-v-a88a80af]{background:var(--theme-background-2, var(--default-theme-background-2))}.listbox-option[data-v-a88a80af]:hover{background:var(--theme-background-2, var(--default-theme-background-2));color:var(--theme-color-2, var(--default-theme-color-2))}.icon[data-v-a88a80af]{width:13px;height:13px;color:var(--theme-color-3, var(--default-theme-color-3))}.markdown[data-v-d49d8496] *{margin:0}.code-copy[data-v-d49d8496]{display:flex;align-items:center;justify-content:center;-moz-appearance:none;appearance:none;-webkit-appearance:none;outline:none;background:transparent;cursor:pointer;color:var(--theme-color-3, var(--default-theme-color-3));border:none;padding:0;margin-right:12px}.code-copy[data-v-d49d8496]:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.code-copy svg[data-v-d49d8496]{width:13px;height:13px}.description[data-v-d49d8496]{font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color--1, var(--default-theme-color-1));padding:10px 12px;min-height:35px;display:flex;align-items:center;box-sizing:border-box;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}.scalar-api-reference__empty-state[data-v-d49d8496]{margin:10px 0 10px 12px;text-align:center;font-size:var(--theme-micro, var(--default-theme-micro));min-height:56px;display:flex;align-items:center;justify-content:center;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));color:var(--theme-color-2, var(--default-theme-color-2))}.schema-type[data-v-d49d8496]{font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-2, var(--default-theme-color-2));font-weight:var(--theme-semibold, var(--default-theme-semibold));background:var(--theme-background-3, var(--default-theme-background-3));padding:2px 4px;border-radius:4px;margin-right:4px}.schema-example[data-v-d49d8496]{font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-2, var(--default-theme-color-2));font-weight:var(--theme-semibold, var(--default-theme-semibold))}.example-response-tab[data-v-d49d8496]{display:block;margin:6px}.scalar-card-container[data-v-d49d8496]{background:var(--theme-background-2, var(--default-theme-background-2))}.scalar-card-container[data-v-d49d8496] .cm-scroller{overflow:hidden}.rule-title[data-v-d49d8496]{font-family:var(--theme-font-code, var(--default-theme-font-code));color:var(--theme-color-1, var(--default-theme-color-1));display:inline-block;margin:12px 0 6px;border-radius:var(--theme-radius, var(--default-theme-radius))}.rule[data-v-d49d8496]{margin:0 12px;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.rule-items[data-v-d49d8496]{counter-reset:list-number;display:flex;flex-direction:column;gap:12px;border-left:1px solid var(--theme-border-color, var(--default-theme-border-color));padding:12px 0}.rule-item[data-v-d49d8496]{counter-increment:list-number;border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));overflow:hidden;margin-left:24px}.rule-item[data-v-d49d8496]:before{border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-top:0;border-right:0;content:" ";display:block;width:24px;height:6px;border-radius:0 0 0 var(--theme-radius-lg, var(--default-theme-radius-lg));margin-top:6px;color:var(--theme-color-2, var(--default-theme-color-2));transform:translate(-25px);color:var(--theme-color-1, var(--default-theme-color-1));position:absolute}.examples[data-v-8afe4f0f]{position:sticky;top:calc(var(--refs-header-height) + 24px)}.scalar-logo-animation[data-v-16147dd7]{width:38px;height:38px;position:relative;display:flex;align-items:center}.scalar-logo-animation .line[data-v-16147dd7]:before{content:"";width:100%;height:100%;background:#4c4316;display:block;position:absolute}.scalar-logo-animation .line[data-v-16147dd7]{position:absolute;width:100%;height:1px;overflow:hidden}.scalar-logo-animation .line-2[data-v-16147dd7]{transform:rotate(90deg)}.scalar-logo-animation .line-3[data-v-16147dd7]{transform:rotate(45deg)}.scalar-logo-animation .line-4[data-v-16147dd7]{transform:rotate(-45deg)}.scalar-logo-animation-load[data-v-16147dd7]{animation:rotate-16147dd7 2s linear infinite}@keyframes rotate-16147dd7{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.render-loading[data-v-f2471d33]{height:calc(var(--full-height) - var(--refs-header-height));display:flex;align-items:center;justify-content:center}.show-more[data-v-f2471d33]{background:var(--theme-background-1, var(--default-theme-background-1));-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;border:1px solid var(--theme-border-color, var(--default-theme-border-color));margin:-48px auto 48px;padding:8px 12px;border-radius:30px;color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-small, var(--default-theme-small));display:flex;align-items:center;justify-content:center;position:relative}.show-more[data-v-f2471d33]:hover{color:var(--theme-color-2, var(--default-theme-color-2));cursor:pointer}.show-more-icon[data-v-f2471d33]{width:14px;height:14px;margin-left:3px}.show-more[data-v-f2471d33]:active{box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color))}.references-narrow .show-more[data-v-f2471d33]{margin-top:-25px;margin-bottom:25px}@media (max-width: 1165px){.show-more[data-v-f2471d33]{margin-top:-24px;margin-bottom:24px}}.ref-search-input[data-v-525d8790]{width:100%;background:transparent;padding:12px;font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));outline:none;border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius, var(--default-theme-radius));color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-font-size-3, var(--default-theme-font-size-3));font-family:var(--theme-font, var(--default-theme-font));-webkit-appearance:none;-moz-appearance:none;appearance:none}.ref-search-input[data-v-525d8790]:focus{border-color:var(--theme-color-1, var(--default-theme-color-1))}.item-entry[data-v-525d8790]{-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;border:none;outline:none;padding:9px 12px;width:100%;color:var(--theme-color-3, var(--default-theme-color-3));text-align:left;border-radius:var(--theme-radius, var(--default-theme-radius));align-items:center;font-family:var(--theme-font);min-height:31px;display:flex;gap:6px;overflow:hidden}.item-entry-http-verb[data-v-525d8790]:empty{display:none}.ref-search-list[data-v-525d8790]{padding:0 0 12px 12px}.ref-search-container[data-v-525d8790]{padding:12px}.item-entry--active[data-v-525d8790]{background:var(--theme-background-2, var(--default-theme-background-2));cursor:pointer}.item-entry--tag .item-entry-description[data-v-525d8790]:before{content:"–";margin-right:6px}.item-entry-description[data-v-525d8790],.item-entry-title[data-v-525d8790]{font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.item-entry-title[data-v-525d8790]{min-width:fit-content}.item-entry-http-verb[data-v-525d8790],.item-entry-subtitle[data-v-525d8790]{display:flex;font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));font-family:var(--theme-font-code, var(--default-theme-font-code));min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.item-entry-http-verb[data-v-525d8790]{text-transform:uppercase;min-width:45px;position:relative;top:.5px}.item-entry-http-verb--post[data-v-525d8790]{color:var(--theme-color-green, var(--default-theme-color-green))}.item-entry-http-verb--patch[data-v-525d8790]{color:var(--theme-color-yellow, var(--default-theme-color-yellow))}.item-entry-http-verb--get[data-v-525d8790]{color:var(--theme-color-blue, var(--default-theme-color-blue))}.item-entry-http-verb--delete[data-v-525d8790]{color:var(--theme-color-red, var(--default-theme-color-red))}.item-entry-http-verb--delete[data-v-525d8790]{font-size:0}.item-entry-http-verb--delete[data-v-525d8790]:after{content:"DEL";font-size:var(--theme-font-size-4, var(--default-theme-font-size-4))}.item-entry-http-verb--put[data-v-525d8790]{color:var(--theme-color-orange, var(--default-theme-color-orange))}.item-entry-path[data-v-525d8790]{color:var(--theme-color-3, var(--default-theme-color-3));font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ref-search-meta[data-v-525d8790]{background:var(--theme-background-3, var(--default-theme-background-3));padding:6px 12px;font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));color:var(--theme-color-3, var(--default-theme-color-3));font-weight:var(--theme-semibold, var(--default-theme-semibold));display:flex;gap:12px}.scalar-api-reference[data-v-79c6a8ef]{--refs-sidebar-width: var(--theme-sidebar-width, 250px);--refs-header-height: var(--theme-header-height, 0px)}.references-layout[data-v-79c6a8ef]{height:100dvh;max-height:100%;width:100dvw;max-width:100%;flex:1;overflow-y:auto;overflow-x:hidden;--full-height: 100dvh;display:grid;grid-template-rows:var(--refs-header-height) repeat(2,auto);grid-template-columns:var(--refs-sidebar-width) 1fr;grid-template-areas:"header header" "navigation rendered" "footer footer";background:var(--theme-background-1, var(--default-theme-background-1))}.references-header[data-v-79c6a8ef]{grid-area:header;position:sticky;top:0;z-index:10;height:var(--refs-header-height)}.references-editor[data-v-79c6a8ef]{grid-area:editor;display:flex;min-width:0;background:var(--theme-background-1, var(--default-theme-background-1))}.references-navigation[data-v-79c6a8ef]{grid-area:navigation}.references-rendered[data-v-79c6a8ef]{position:relative;grid-area:rendered;min-width:0;background:var(--theme-background-1, var(--default-theme-background-1))}.references-navigation-list[data-v-79c6a8ef]{position:sticky;top:var(--refs-header-height);height:calc(var(--full-height) - var(--refs-header-height));background:var( --sidebar-background-1, var( --default-sidebar-background-1, var(--theme-background-1, var(--default-theme-background-1)) ) );overflow-y:auto;display:flex;flex-direction:column}.references-editor-textarea[data-v-79c6a8ef]{position:sticky;top:var(--refs-header-height);height:calc(var(--full-height) - var(--refs-header-height));display:flex;min-width:0;flex:1}.references-editable[data-v-79c6a8ef]{grid-template-columns:var(--refs-sidebar-width) 1fr 1fr;grid-template-areas:"header header header" "navigation editor rendered" "footer footer footer"}.references-footer[data-v-79c6a8ef]{grid-area:footer}@media (max-width: 1150px){.references-layout[data-v-79c6a8ef]{grid-template-columns:var(--refs-sidebar-width) 1fr 0px}}@media (max-width: 1000px){.references-layout[data-v-79c6a8ef]{grid-template-columns:auto;grid-template-rows:var(--refs-header-height) 0px auto auto;grid-template-areas:"header" "navigation" "rendered" "footer"}.references-editable[data-v-79c6a8ef]{grid-template-areas:"header" "navigation" "editor"}.references-navigation[data-v-79c6a8ef],.references-rendered[data-v-79c6a8ef]{position:static;max-height:unset}.references-navigation[data-v-79c6a8ef]{height:0px;z-index:10}.references-navigation-list[data-v-79c6a8ef]{position:absolute;top:calc(var(--refs-header-height) - 1px);height:calc(var(--full-height) - var(--refs-header-height) + 1px);width:100%;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color));display:flex;flex-direction:column}}.scalar-api-reference p,#headlessui-portal-root p{margin:0}.scalar-api-reference i,#headlessui-portal-root i{font-style:normal}.scalar-api-reference ul,.scalar-api-reference ol,#headlessui-portal-root ul,#headlessui-portal-root ol{margin:0;padding:0}.scalar-api-reference,#headlessui-portal-root{font-family:var(--theme-font, var(--default-theme-font));line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;box-sizing:border-box}.scalar-api-reference *,.scalar-api-reference *:before,.scalar-api-reference *:after,#headlessui-portal-root *,#headlessui-portal-root *:before,#headlessui-portal-root *:after{box-sizing:inherit}.scalar-api-reference *,#headlessui-portal-root *{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.scalar-api-reference input::placeholder,#headlessui-portal-root input::placeholder{color:var(--theme-color-3, var(--default-theme-color-3));font-family:var(--theme-font, var(--default-theme-font))}.scalar-api-reference input:-ms-input-placeholder,#headlessui-portal-root input:-ms-input-placeholder{color:var(--theme-color-3, var(--default-theme-color-3));font-family:var(--theme-font, var(--default-theme-font))}.scalar-api-reference input::-webkit-input-placeholder,#headlessui-portal-root input::-webkit-input-placeholder{color:var(--theme-color-3, var(--default-theme-color-3));font-family:var(--theme-font, var(--default-theme-font))}.scalar-api-reference .flex,#headlessui-portal-root .flex{display:flex}.scalar-api-reference .flex-col,#headlessui-portal-root .flex-col{display:flex;min-height:0;flex-direction:column}.scalar-api-reference .flex-mobile,#headlessui-portal-root .flex-mobile{display:flex;min-width:0}@media (max-width: 500px){.scalar-api-reference .flex-mobile,#headlessui-portal-root .flex-mobile{flex-direction:column}}.scalar-api-reference .gap-1,#headlessui-portal-root .gap-1{gap:12px}.scalar-api-reference .sr-only,#headlessui-portal-root .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.darklight[data-v-264b9b08]{border:none;border-top:1px solid var( --sidebar-border-color, var( --default-sidebar-border-color, var(--theme-border-color, var(--default-theme-border-color)) ) );color:var( --sidebar-color-2, var( --default-sidebar-color-2, var(--theme-color-2, var(--default-theme-color-2)) ) );font-size:var(--theme-mini, var(--default-theme-mini));font-weight:var(--theme-semibold, var(--default-theme-semibold));-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;outline:none;padding:18px 24px 0;display:flex;align-items:center;text-indent:9px;width:100%}.darklight-reference[data-v-264b9b08]{width:100%;margin-top:auto}.darklight[data-v-264b9b08]:hover{cursor:pointer;color:var( --sidebar-color-1, var( --default-sidebar-color-1, var(--theme-color-1, var(--default-theme-color-1)) ) )}.darklight svg[data-v-264b9b08]{stroke:currentColor;height:12px;width:12px}.darklight-reference-promo[data-v-264b9b08]{padding:6px 24px 12px;display:flex;align-items:center;font-size:var(--theme-mini, var(--default-theme-mini));text-decoration:none;color:var( --sidebar-color-2, var( --default-sidebar-color-2, var(--theme-color-2, var(--default-theme-color-2)) ) )}.darklight-reference-promo[data-v-264b9b08]:hover{text-decoration:underline}.references-mobile-header[data-v-135ccf3f]{display:flex;align-items:center;gap:12px;height:100%;width:100%;padding:0 8px;background:var(--theme-background-1, var(--default-theme-background-1));border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.references-mobile-breadcrumbs[data-v-135ccf3f]{flex:1;min-width:0;font-size:var(--theme-small, var(--default-theme-small));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-1, var(--default-theme-color-1));overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.sidebar-search[data-v-e0708451]{display:flex;align-items:center;position:relative;--default-margin-x: 12px;width:calc(100% - 2 * var(--margin-x, var(--default-margin-x)));margin:12px var(--margin-x, var(--default-margin-x)) 6px var(--margin-x, var(--default-margin-x));padding:0 3px 0 12px;background:var( --sidebar-search-background, var( --default-sidebar-search-background, var(--theme-background-1, var(--default-theme-background-1)) ) );color:var( --sidebar-color-2, var( --default-sidebar-color-2, var(--theme-color-2, var(--default-theme-color-2)) ) );outline:none;border-radius:var(--theme-radius, var(--default-theme-radius));box-shadow:0 0 0 1px var( --sidebar-search-border-color, var( --default-sidebar-search-border-color, var(--theme-border-color, var(--default-theme-border-color)) ) );cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none}.sidebar-search-input[data-v-e0708451]{font-size:var(--theme-mini, var(--default-theme-mini));font-weight:var(--theme-semibold, var(--default-theme-semibold));height:31px;-webkit-user-select:none;user-select:none;z-index:10;position:relative;display:flex;width:100%;justify-content:space-between;align-items:center}.sidebar-search-shortcut[data-v-e0708451]{text-transform:uppercase}.sidebar-search-key[data-v-e0708451]{background-color:var( --theme-background-2, var(--default-theme-background-2) );padding:3px 5px;margin:2px;border-radius:var(--theme-radius, var(--default-theme-radius));color:var( --sidebar-color-2, var(--default-sidebar-color-2), var(--theme-color-2, var(--default-theme-color-2)) )}.search-icon[data-v-e0708451]{padding:0;margin-right:9px;width:12px}@media (max-width: 1000px){:root{--theme-header-height: 50px}}')), document.head.appendChild(e3);
    }
  } catch (a3) {
    console.error("vite-plugin-css-injected-by-js", a3);
  }
})();
var H5 = Object.defineProperty;
var G5 = (t10, e3, r3) => e3 in t10 ? H5(t10, e3, { enumerable: true, configurable: true, writable: true, value: r3 }) : t10[e3] = r3;
var I1 = (t10, e3, r3) => (G5(t10, typeof e3 != "symbol" ? e3 + "" : e3, r3), r3);
function Mt(t10, e3, ...r3) {
  if (t10 in e3) {
    let i3 = e3[t10];
    return typeof i3 == "function" ? i3(...r3) : i3;
  }
  let n3 = new Error(`Tried to handle "${t10}" but there is no handler defined. Only defined handlers are: ${Object.keys(e3).map((i3) => `"${i3}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(n3, Mt), n3;
}
var Ei = ((t10) => (t10[t10.None = 0] = "None", t10[t10.RenderStrategy = 1] = "RenderStrategy", t10[t10.Static = 2] = "Static", t10))(Ei || {}), h3 = ((t10) => (t10[t10.Unmount = 0] = "Unmount", t10[t10.Hidden = 1] = "Hidden", t10))(h3 || {});
function Rt({ visible: t10 = true, features: e3 = 0, ourProps: r3, theirProps: n3, ...i3 }) {
  var o3;
  let s3 = Tw(n3, r3), a3 = Object.assign(i3, { props: s3 });
  if (t10 || e3 & 2 && s3.static)
    return rh(a3);
  if (e3 & 1) {
    let l3 = (o3 = s3.unmount) == null || o3 ? 0 : 1;
    return Mt(l3, { 0() {
      return null;
    }, 1() {
      return rh({ ...i3, props: { ...s3, hidden: true, style: { display: "none" } } });
    } });
  }
  return rh(a3);
}
function rh({ props: t10, attrs: e3, slots: r3, slot: n3, name: i3 }) {
  var o3, s3;
  let { as: a3, ...l3 } = tg(t10, ["unmount", "static"]), u3 = (o3 = r3.default) == null ? void 0 : o3.call(r3, n3), c3 = {};
  if (n3) {
    let f3 = false, d3 = [];
    for (let [p10, h10] of Object.entries(n3))
      typeof h10 == "boolean" && (f3 = true), h10 === true && d3.push(p10);
    f3 && (c3["data-headlessui-state"] = d3.join(" "));
  }
  if (a3 === "template") {
    if (u3 = Qw(u3 ?? []), Object.keys(l3).length > 0 || Object.keys(e3).length > 0) {
      let [f3, ...d3] = u3 ?? [];
      if (!O3(f3) || d3.length > 0)
        throw new Error(['Passing props on "template"!', "", `The current component <${i3} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(l3).concat(Object.keys(e3)).map((m10) => m10.trim()).filter((m10, O10, g) => g.indexOf(m10) === O10).sort((m10, O10) => m10.localeCompare(O10)).map((m10) => `  - ${m10}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map((m10) => `  - ${m10}`).join(`
`)].join(`
`));
      let p10 = Tw((s3 = f3.props) != null ? s3 : {}, l3), h10 = cloneVNode(f3, p10);
      for (let m10 in p10)
        m10.startsWith("on") && (h10.props || (h10.props = {}), h10.props[m10] = p10[m10]);
      return h10;
    }
    return Array.isArray(u3) && u3.length === 1 ? u3[0] : u3;
  }
  return h$3(a3, Object.assign({}, l3, c3), { default: () => u3 });
}
function Qw(t10) {
  return t10.flatMap((e3) => e3.type === Fragment ? Qw(e3.children) : [e3]);
}
function Tw(...t10) {
  if (t10.length === 0)
    return {};
  if (t10.length === 1)
    return t10[0];
  let e3 = {}, r3 = {};
  for (let n3 of t10)
    for (let i3 in n3)
      i3.startsWith("on") && typeof n3[i3] == "function" ? (r3[i3] != null || (r3[i3] = []), r3[i3].push(n3[i3])) : e3[i3] = n3[i3];
  if (e3.disabled || e3["aria-disabled"])
    return Object.assign(e3, Object.fromEntries(Object.keys(r3).map((n3) => [n3, void 0])));
  for (let n3 in r3)
    Object.assign(e3, { [n3](i3, ...o3) {
      let s3 = r3[n3];
      for (let a3 of s3) {
        if (i3 instanceof Event && i3.defaultPrevented)
          return;
        a3(i3, ...o3);
      }
    } });
  return e3;
}
function p3(t10) {
  let e3 = Object.assign({}, t10);
  for (let r3 in e3)
    e3[r3] === void 0 && delete e3[r3];
  return e3;
}
function tg(t10, e3 = []) {
  let r3 = Object.assign({}, t10);
  for (let n3 of e3)
    n3 in r3 && delete r3[n3];
  return r3;
}
function O3(t10) {
  return t10 == null ? false : typeof t10.type == "string" || typeof t10.type == "object" || typeof t10.type == "function";
}
let m3 = 0;
function g3() {
  return ++m3;
}
function Fr() {
  return g3();
}
var ot = ((t10) => (t10.Space = " ", t10.Enter = "Enter", t10.Escape = "Escape", t10.Backspace = "Backspace", t10.Delete = "Delete", t10.ArrowLeft = "ArrowLeft", t10.ArrowUp = "ArrowUp", t10.ArrowRight = "ArrowRight", t10.ArrowDown = "ArrowDown", t10.Home = "Home", t10.End = "End", t10.PageUp = "PageUp", t10.PageDown = "PageDown", t10.Tab = "Tab", t10))(ot || {});
function y3(t10) {
  throw new Error("Unexpected object: " + t10);
}
var Tr = ((t10) => (t10[t10.First = 0] = "First", t10[t10.Previous = 1] = "Previous", t10[t10.Next = 2] = "Next", t10[t10.Last = 3] = "Last", t10[t10.Specific = 4] = "Specific", t10[t10.Nothing = 5] = "Nothing", t10))(Tr || {});
function v3(t10, e3) {
  let r3 = e3.resolveItems();
  if (r3.length <= 0)
    return null;
  let n3 = e3.resolveActiveIndex(), i3 = n3 ?? -1, o3 = (() => {
    switch (t10.focus) {
      case 0:
        return r3.findIndex((s3) => !e3.resolveDisabled(s3));
      case 1: {
        let s3 = r3.slice().reverse().findIndex((a3, l3, u3) => i3 !== -1 && u3.length - l3 - 1 >= i3 ? false : !e3.resolveDisabled(a3));
        return s3 === -1 ? s3 : r3.length - 1 - s3;
      }
      case 2:
        return r3.findIndex((s3, a3) => a3 <= i3 ? false : !e3.resolveDisabled(s3));
      case 3: {
        let s3 = r3.slice().reverse().findIndex((a3) => !e3.resolveDisabled(a3));
        return s3 === -1 ? s3 : r3.length - 1 - s3;
      }
      case 4:
        return r3.findIndex((s3) => e3.resolveId(s3) === t10.id);
      case 5:
        return null;
      default:
        y3(t10);
    }
  })();
  return o3 === -1 ? n3 : o3;
}
function Te(t10) {
  var e3;
  return t10 == null || t10.value == null ? null : (e3 = t10.value.$el) != null ? e3 : t10.value;
}
let kw = Symbol("Context");
var Jr = ((t10) => (t10[t10.Open = 1] = "Open", t10[t10.Closed = 2] = "Closed", t10[t10.Closing = 4] = "Closing", t10[t10.Opening = 8] = "Opening", t10))(Jr || {});
function rg() {
  return inject(kw, null);
}
function Ew(t10) {
  provide(kw, t10);
}
function Z1(t10, e3) {
  if (t10)
    return t10;
  let r3 = e3 ?? "button";
  if (typeof r3 == "string" && r3.toLowerCase() === "button")
    return "button";
}
function ng(t10, e3) {
  let r3 = ref(Z1(t10.value.type, t10.value.as));
  return onMounted(() => {
    r3.value = Z1(t10.value.type, t10.value.as);
  }), watchEffect(() => {
    var n3;
    r3.value || Te(e3) && Te(e3) instanceof HTMLButtonElement && !((n3 = Te(e3)) != null && n3.hasAttribute("type")) && (r3.value = "button");
  }), r3;
}
var b3 = Object.defineProperty, S3 = (t10, e3, r3) => e3 in t10 ? b3(t10, e3, { enumerable: true, configurable: true, writable: true, value: r3 }) : t10[e3] = r3, M1 = (t10, e3, r3) => (S3(t10, typeof e3 != "symbol" ? e3 + "" : e3, r3), r3);
class $3 {
  constructor() {
    M1(this, "current", this.detect()), M1(this, "currentId", 0);
  }
  set(e3) {
    this.current !== e3 && (this.currentId = 0, this.current = e3);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
}
let Nf = new $3();
function ds(t10) {
  if (Nf.isServer)
    return null;
  if (t10 instanceof Node)
    return t10.ownerDocument;
  if (t10 != null && t10.hasOwnProperty("value")) {
    let e3 = Te(t10);
    if (e3)
      return e3.ownerDocument;
  }
  return document;
}
let Ep = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((t10) => `${t10}:not([tabindex='-1'])`).join(",");
var tr = ((t10) => (t10[t10.First = 1] = "First", t10[t10.Previous = 2] = "Previous", t10[t10.Next = 4] = "Next", t10[t10.Last = 8] = "Last", t10[t10.WrapAround = 16] = "WrapAround", t10[t10.NoScroll = 32] = "NoScroll", t10))(tr || {}), qs = ((t10) => (t10[t10.Error = 0] = "Error", t10[t10.Overflow = 1] = "Overflow", t10[t10.Success = 2] = "Success", t10[t10.Underflow = 3] = "Underflow", t10))(qs || {}), w3 = ((t10) => (t10[t10.Previous = -1] = "Previous", t10[t10.Next = 1] = "Next", t10))(w3 || {});
function P3(t10 = document.body) {
  return t10 == null ? [] : Array.from(t10.querySelectorAll(Ep)).sort((e3, r3) => Math.sign((e3.tabIndex || Number.MAX_SAFE_INTEGER) - (r3.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var ig = ((t10) => (t10[t10.Strict = 0] = "Strict", t10[t10.Loose = 1] = "Loose", t10))(ig || {});
function Cw(t10, e3 = 0) {
  var r3;
  return t10 === ((r3 = ds(t10)) == null ? void 0 : r3.body) ? false : Mt(e3, { 0() {
    return t10.matches(Ep);
  }, 1() {
    let n3 = t10;
    for (; n3 !== null; ) {
      if (n3.matches(Ep))
        return true;
      n3 = n3.parentElement;
    }
    return false;
  } });
}
var _3 = ((t10) => (t10[t10.Keyboard = 0] = "Keyboard", t10[t10.Mouse = 1] = "Mouse", t10))(_3 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (t10) => {
  t10.metaKey || t10.altKey || t10.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (t10) => {
  t10.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : t10.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function Lo(t10) {
  t10 == null || t10.focus({ preventScroll: true });
}
let x3 = ["textarea", "input"].join(",");
function Q3(t10) {
  var e3, r3;
  return (r3 = (e3 = t10 == null ? void 0 : t10.matches) == null ? void 0 : e3.call(t10, x3)) != null ? r3 : false;
}
function Co(t10, e3 = (r3) => r3) {
  return t10.slice().sort((r3, n3) => {
    let i3 = e3(r3), o3 = e3(n3);
    if (i3 === null || o3 === null)
      return 0;
    let s3 = i3.compareDocumentPosition(o3);
    return s3 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : s3 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function Wn(t10, e3, { sorted: r3 = true, relativeTo: n3 = null, skipElements: i3 = [] } = {}) {
  var o3;
  let s3 = (o3 = Array.isArray(t10) ? t10.length > 0 ? t10[0].ownerDocument : document : t10 == null ? void 0 : t10.ownerDocument) != null ? o3 : document, a3 = Array.isArray(t10) ? r3 ? Co(t10) : t10 : P3(t10);
  i3.length > 0 && a3.length > 1 && (a3 = a3.filter((h10) => !i3.includes(h10))), n3 = n3 ?? s3.activeElement;
  let l3 = (() => {
    if (e3 & 5)
      return 1;
    if (e3 & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), u3 = (() => {
    if (e3 & 1)
      return 0;
    if (e3 & 2)
      return Math.max(0, a3.indexOf(n3)) - 1;
    if (e3 & 4)
      return Math.max(0, a3.indexOf(n3)) + 1;
    if (e3 & 8)
      return a3.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), c3 = e3 & 32 ? { preventScroll: true } : {}, f3 = 0, d3 = a3.length, p10;
  do {
    if (f3 >= d3 || f3 + d3 <= 0)
      return 0;
    let h10 = u3 + f3;
    if (e3 & 16)
      h10 = (h10 + d3) % d3;
    else {
      if (h10 < 0)
        return 3;
      if (h10 >= d3)
        return 1;
    }
    p10 = a3[h10], p10 == null || p10.focus(c3), f3 += l3;
  } while (p10 !== s3.activeElement);
  return e3 & 6 && Q3(p10) && p10.select(), 2;
}
function Du(t10, e3, r3) {
  Nf.isServer || watchEffect((n3) => {
    document.addEventListener(t10, e3, r3), n3(() => document.removeEventListener(t10, e3, r3));
  });
}
function Rw(t10, e3, r3) {
  Nf.isServer || watchEffect((n3) => {
    window.addEventListener(t10, e3, r3), n3(() => window.removeEventListener(t10, e3, r3));
  });
}
function Aw(t10, e3, r3 = computed(() => true)) {
  function n3(o3, s3) {
    if (!r3.value || o3.defaultPrevented)
      return;
    let a3 = s3(o3);
    if (a3 === null || !a3.getRootNode().contains(a3))
      return;
    let l3 = function u3(c3) {
      return typeof c3 == "function" ? u3(c3()) : Array.isArray(c3) || c3 instanceof Set ? c3 : [c3];
    }(t10);
    for (let u3 of l3) {
      if (u3 === null)
        continue;
      let c3 = u3 instanceof HTMLElement ? u3 : Te(u3);
      if (c3 != null && c3.contains(a3) || o3.composed && o3.composedPath().includes(c3))
        return;
    }
    return !Cw(a3, ig.Loose) && a3.tabIndex !== -1 && o3.preventDefault(), e3(o3, a3);
  }
  let i3 = ref(null);
  Du("pointerdown", (o3) => {
    var s3, a3;
    r3.value && (i3.value = ((a3 = (s3 = o3.composedPath) == null ? void 0 : s3.call(o3)) == null ? void 0 : a3[0]) || o3.target);
  }, true), Du("mousedown", (o3) => {
    var s3, a3;
    r3.value && (i3.value = ((a3 = (s3 = o3.composedPath) == null ? void 0 : s3.call(o3)) == null ? void 0 : a3[0]) || o3.target);
  }, true), Du("click", (o3) => {
    i3.value && (n3(o3, () => i3.value), i3.value = null);
  }, true), Du("touchend", (o3) => n3(o3, () => o3.target instanceof HTMLElement ? o3.target : null), true), Rw("blur", (o3) => n3(o3, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}
var oa = ((t10) => (t10[t10.None = 1] = "None", t10[t10.Focusable = 2] = "Focusable", t10[t10.Hidden = 4] = "Hidden", t10))(oa || {});
let sa = defineComponent({ name: "Hidden", props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } }, setup(t10, { slots: e3, attrs: r3 }) {
  return () => {
    let { features: n3, ...i3 } = t10, o3 = { "aria-hidden": (n3 & 2) === 2 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(n3 & 4) === 4 && (n3 & 2) !== 2 && { display: "none" } } };
    return Rt({ ourProps: o3, theirProps: i3, slot: {}, attrs: r3, slots: e3, name: "Hidden" });
  };
} });
function Xw(t10 = {}, e3 = null, r3 = []) {
  for (let [n3, i3] of Object.entries(t10))
    Dw(r3, qw(e3, n3), i3);
  return r3;
}
function qw(t10, e3) {
  return t10 ? t10 + "[" + e3 + "]" : e3;
}
function Dw(t10, e3, r3) {
  if (Array.isArray(r3))
    for (let [n3, i3] of r3.entries())
      Dw(t10, qw(e3, n3.toString()), i3);
  else
    r3 instanceof Date ? t10.push([e3, r3.toISOString()]) : typeof r3 == "boolean" ? t10.push([e3, r3 ? "1" : "0"]) : typeof r3 == "string" ? t10.push([e3, r3]) : typeof r3 == "number" ? t10.push([e3, `${r3}`]) : r3 == null ? t10.push([e3, ""]) : Xw(r3, e3, t10);
}
function T3(t10, e3, r3) {
  let n3 = ref(r3 == null ? void 0 : r3.value), i3 = computed(() => t10.value !== void 0);
  return [computed(() => i3.value ? t10.value : n3.value), function(o3) {
    return i3.value || (n3.value = o3), e3 == null ? void 0 : e3(o3);
  }];
}
function N1(t10) {
  return [t10.screenX, t10.screenY];
}
function k3() {
  let t10 = ref([-1, -1]);
  return { wasMoved(e3) {
    let r3 = N1(e3);
    return t10.value[0] === r3[0] && t10.value[1] === r3[1] ? false : (t10.value = r3, true);
  }, update(e3) {
    t10.value = N1(e3);
  } };
}
function E3() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function Wf(t10) {
  typeof queueMicrotask == "function" ? queueMicrotask(t10) : Promise.resolve().then(t10).catch((e3) => setTimeout(() => {
    throw e3;
  }));
}
function og() {
  let t10 = [], e3 = { addEventListener(r3, n3, i3, o3) {
    return r3.addEventListener(n3, i3, o3), e3.add(() => r3.removeEventListener(n3, i3, o3));
  }, requestAnimationFrame(...r3) {
    let n3 = requestAnimationFrame(...r3);
    e3.add(() => cancelAnimationFrame(n3));
  }, nextFrame(...r3) {
    e3.requestAnimationFrame(() => {
      e3.requestAnimationFrame(...r3);
    });
  }, setTimeout(...r3) {
    let n3 = setTimeout(...r3);
    e3.add(() => clearTimeout(n3));
  }, microTask(...r3) {
    let n3 = { current: true };
    return Wf(() => {
      n3.current && r3[0]();
    }), e3.add(() => {
      n3.current = false;
    });
  }, style(r3, n3, i3) {
    let o3 = r3.style.getPropertyValue(n3);
    return Object.assign(r3.style, { [n3]: i3 }), this.add(() => {
      Object.assign(r3.style, { [n3]: o3 });
    });
  }, group(r3) {
    let n3 = og();
    return r3(n3), this.add(() => n3.dispose());
  }, add(r3) {
    return t10.push(r3), () => {
      let n3 = t10.indexOf(r3);
      if (n3 >= 0)
        for (let i3 of t10.splice(n3, 1))
          i3();
    };
  }, dispose() {
    for (let r3 of t10.splice(0))
      r3();
  } };
  return e3;
}
var nl = ((t10) => (t10[t10.Forwards = 0] = "Forwards", t10[t10.Backwards = 1] = "Backwards", t10))(nl || {});
function C3() {
  let t10 = ref(0);
  return Rw("keydown", (e3) => {
    e3.key === "Tab" && (t10.value = e3.shiftKey ? 1 : 0);
  }), t10;
}
function jw(t10, e3, r3, n3) {
  Nf.isServer || watchEffect((i3) => {
    t10 = t10 ?? window, t10.addEventListener(e3, r3, n3), i3(() => t10.removeEventListener(e3, r3, n3));
  });
}
function R3(t10) {
  function e3() {
    document.readyState !== "loading" && (t10(), document.removeEventListener("DOMContentLoaded", e3));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", e3), e3());
}
function Uw(t10) {
  if (!t10)
    return /* @__PURE__ */ new Set();
  if (typeof t10 == "function")
    return new Set(t10());
  let e3 = /* @__PURE__ */ new Set();
  for (let r3 of t10.value) {
    let n3 = Te(r3);
    n3 instanceof HTMLElement && e3.add(n3);
  }
  return e3;
}
var Iw = ((t10) => (t10[t10.None = 1] = "None", t10[t10.InitialFocus = 2] = "InitialFocus", t10[t10.TabLock = 4] = "TabLock", t10[t10.FocusLock = 8] = "FocusLock", t10[t10.RestoreFocus = 16] = "RestoreFocus", t10[t10.All = 30] = "All", t10))(Iw || {});
let Za = Object.assign(defineComponent({ name: "FocusTrap", props: { as: { type: [Object, String], default: "div" }, initialFocus: { type: Object, default: null }, features: { type: Number, default: 30 }, containers: { type: [Object, Function], default: ref(/* @__PURE__ */ new Set()) } }, inheritAttrs: false, setup(t10, { attrs: e3, slots: r3, expose: n3 }) {
  let i3 = ref(null);
  n3({ el: i3, $el: i3 });
  let o3 = computed(() => ds(i3)), s3 = ref(false);
  onMounted(() => s3.value = true), onUnmounted(() => s3.value = false), X3({ ownerDocument: o3 }, computed(() => s3.value && !!(t10.features & 16)));
  let a3 = q3({ ownerDocument: o3, container: i3, initialFocus: computed(() => t10.initialFocus) }, computed(() => s3.value && !!(t10.features & 2)));
  D3({ ownerDocument: o3, container: i3, containers: t10.containers, previousActiveElement: a3 }, computed(() => s3.value && !!(t10.features & 8)));
  let l3 = C3();
  function u3(p10) {
    let h10 = Te(i3);
    h10 && ((m10) => m10())(() => {
      Mt(l3.value, { [nl.Forwards]: () => {
        Wn(h10, tr.First, { skipElements: [p10.relatedTarget] });
      }, [nl.Backwards]: () => {
        Wn(h10, tr.Last, { skipElements: [p10.relatedTarget] });
      } });
    });
  }
  let c3 = ref(false);
  function f3(p10) {
    p10.key === "Tab" && (c3.value = true, requestAnimationFrame(() => {
      c3.value = false;
    }));
  }
  function d3(p10) {
    if (!s3.value)
      return;
    let h10 = Uw(t10.containers);
    Te(i3) instanceof HTMLElement && h10.add(Te(i3));
    let m10 = p10.relatedTarget;
    m10 instanceof HTMLElement && m10.dataset.headlessuiFocusGuard !== "true" && (Fw(h10, m10) || (c3.value ? Wn(Te(i3), Mt(l3.value, { [nl.Forwards]: () => tr.Next, [nl.Backwards]: () => tr.Previous }) | tr.WrapAround, { relativeTo: p10.target }) : p10.target instanceof HTMLElement && Lo(p10.target)));
  }
  return () => {
    let p10 = {}, h10 = { ref: i3, onKeydown: f3, onFocusout: d3 }, { features: m10, initialFocus: O10, containers: g, ...v10 } = t10;
    return h$3(Fragment, [!!(m10 & 4) && h$3(sa, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: u3, features: oa.Focusable }), Rt({ ourProps: h10, theirProps: { ...e3, ...v10 }, slot: p10, attrs: e3, slots: r3, name: "FocusTrap" }), !!(m10 & 4) && h$3(sa, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: u3, features: oa.Focusable })]);
  };
} }), { features: Iw }), Ro = [];
R3(() => {
  function t10(e3) {
    e3.target instanceof HTMLElement && e3.target !== document.body && Ro[0] !== e3.target && (Ro.unshift(e3.target), Ro = Ro.filter((r3) => r3 != null && r3.isConnected), Ro.splice(10));
  }
  window.addEventListener("click", t10, { capture: true }), window.addEventListener("mousedown", t10, { capture: true }), window.addEventListener("focus", t10, { capture: true }), document.body.addEventListener("click", t10, { capture: true }), document.body.addEventListener("mousedown", t10, { capture: true }), document.body.addEventListener("focus", t10, { capture: true });
});
function A3(t10) {
  let e3 = ref(Ro.slice());
  return watch([t10], ([r3], [n3]) => {
    n3 === true && r3 === false ? Wf(() => {
      e3.value.splice(0);
    }) : n3 === false && r3 === true && (e3.value = Ro.slice());
  }, { flush: "post" }), () => {
    var r3;
    return (r3 = e3.value.find((n3) => n3 != null && n3.isConnected)) != null ? r3 : null;
  };
}
function X3({ ownerDocument: t10 }, e3) {
  let r3 = A3(e3);
  onMounted(() => {
    watchEffect(() => {
      var n3, i3;
      e3.value || ((n3 = t10.value) == null ? void 0 : n3.activeElement) === ((i3 = t10.value) == null ? void 0 : i3.body) && Lo(r3());
    }, { flush: "post" });
  }), onUnmounted(() => {
    e3.value && Lo(r3());
  });
}
function q3({ ownerDocument: t10, container: e3, initialFocus: r3 }, n3) {
  let i3 = ref(null), o3 = ref(false);
  return onMounted(() => o3.value = true), onUnmounted(() => o3.value = false), onMounted(() => {
    watch([e3, r3, n3], (s3, a3) => {
      if (s3.every((u3, c3) => (a3 == null ? void 0 : a3[c3]) === u3) || !n3.value)
        return;
      let l3 = Te(e3);
      l3 && Wf(() => {
        var u3, c3;
        if (!o3.value)
          return;
        let f3 = Te(r3), d3 = (u3 = t10.value) == null ? void 0 : u3.activeElement;
        if (f3) {
          if (f3 === d3) {
            i3.value = d3;
            return;
          }
        } else if (l3.contains(d3)) {
          i3.value = d3;
          return;
        }
        f3 ? Lo(f3) : Wn(l3, tr.First | tr.NoScroll) === qs.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), i3.value = (c3 = t10.value) == null ? void 0 : c3.activeElement;
      });
    }, { immediate: true, flush: "post" });
  }), i3;
}
function D3({ ownerDocument: t10, container: e3, containers: r3, previousActiveElement: n3 }, i3) {
  var o3;
  jw((o3 = t10.value) == null ? void 0 : o3.defaultView, "focus", (s3) => {
    if (!i3.value)
      return;
    let a3 = Uw(r3);
    Te(e3) instanceof HTMLElement && a3.add(Te(e3));
    let l3 = n3.value;
    if (!l3)
      return;
    let u3 = s3.target;
    u3 && u3 instanceof HTMLElement ? Fw(a3, u3) ? (n3.value = u3, Lo(u3)) : (s3.preventDefault(), s3.stopPropagation(), Lo(l3)) : Lo(n3.value);
  }, true);
}
function Fw(t10, e3) {
  for (let r3 of t10)
    if (r3.contains(e3))
      return true;
  return false;
}
let nh = /* @__PURE__ */ new Map(), Ma = /* @__PURE__ */ new Map();
function W1(t10, e3 = ref(true)) {
  watchEffect((r3) => {
    var n3;
    if (!e3.value)
      return;
    let i3 = Te(t10);
    if (!i3)
      return;
    r3(function() {
      var s3;
      if (!i3)
        return;
      let a3 = (s3 = Ma.get(i3)) != null ? s3 : 1;
      if (a3 === 1 ? Ma.delete(i3) : Ma.set(i3, a3 - 1), a3 !== 1)
        return;
      let l3 = nh.get(i3);
      l3 && (l3["aria-hidden"] === null ? i3.removeAttribute("aria-hidden") : i3.setAttribute("aria-hidden", l3["aria-hidden"]), i3.inert = l3.inert, nh.delete(i3));
    });
    let o3 = (n3 = Ma.get(i3)) != null ? n3 : 0;
    Ma.set(i3, o3 + 1), o3 === 0 && (nh.set(i3, { "aria-hidden": i3.getAttribute("aria-hidden"), inert: i3.inert }), i3.setAttribute("aria-hidden", "true"), i3.inert = true);
  });
}
let Zw = Symbol("ForcePortalRootContext");
function j3() {
  return inject(Zw, false);
}
let Cp = defineComponent({ name: "ForcePortalRoot", props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: false } }, setup(t10, { slots: e3, attrs: r3 }) {
  return provide(Zw, t10.force), () => {
    let { force: n3, ...i3 } = t10;
    return Rt({ theirProps: i3, ourProps: {}, slot: {}, slots: e3, attrs: r3, name: "ForcePortalRoot" });
  };
} });
function U3(t10) {
  let e3 = ds(t10);
  if (!e3) {
    if (t10 === null)
      return null;
    throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${t10}`);
  }
  let r3 = e3.getElementById("headlessui-portal-root");
  if (r3)
    return r3;
  let n3 = e3.createElement("div");
  return n3.setAttribute("id", "headlessui-portal-root"), e3.body.appendChild(n3);
}
let Mw = defineComponent({ name: "Portal", props: { as: { type: [Object, String], default: "div" } }, setup(t10, { slots: e3, attrs: r3 }) {
  let n3 = ref(null), i3 = computed(() => ds(n3)), o3 = j3(), s3 = inject(Nw, null), a3 = ref(o3 === true || s3 == null ? U3(n3.value) : s3.resolveTarget());
  watchEffect(() => {
    o3 || s3 != null && (a3.value = s3.resolveTarget());
  });
  let l3 = inject(Rp, null);
  return onMounted(() => {
    let u3 = Te(n3);
    u3 && l3 && onUnmounted(l3.register(u3));
  }), onUnmounted(() => {
    var u3, c3;
    let f3 = (u3 = i3.value) == null ? void 0 : u3.getElementById("headlessui-portal-root");
    f3 && a3.value === f3 && a3.value.children.length <= 0 && ((c3 = a3.value.parentElement) == null || c3.removeChild(a3.value));
  }), () => {
    if (a3.value === null)
      return null;
    let u3 = { ref: n3, "data-headlessui-portal": "" };
    return h$3(Teleport, { to: a3.value }, Rt({ ourProps: u3, theirProps: t10, slot: {}, attrs: r3, slots: e3, name: "Portal" }));
  };
} }), Rp = Symbol("PortalParentContext");
function I3() {
  let t10 = inject(Rp, null), e3 = ref([]);
  function r3(o3) {
    return e3.value.push(o3), t10 && t10.register(o3), () => n3(o3);
  }
  function n3(o3) {
    let s3 = e3.value.indexOf(o3);
    s3 !== -1 && e3.value.splice(s3, 1), t10 && t10.unregister(o3);
  }
  let i3 = { register: r3, unregister: n3, portals: e3 };
  return [e3, defineComponent({ name: "PortalWrapper", setup(o3, { slots: s3 }) {
    return provide(Rp, i3), () => {
      var a3;
      return (a3 = s3.default) == null ? void 0 : a3.call(s3);
    };
  } })];
}
let Nw = Symbol("PortalGroupContext"), F3 = defineComponent({ name: "PortalGroup", props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } }, setup(t10, { attrs: e3, slots: r3 }) {
  let n3 = reactive({ resolveTarget() {
    return t10.target;
  } });
  return provide(Nw, n3), () => {
    let { target: i3, ...o3 } = t10;
    return Rt({ theirProps: o3, ourProps: {}, slot: {}, attrs: e3, slots: r3, name: "PortalGroup" });
  };
} }), Ww = Symbol("StackContext");
var Ap = ((t10) => (t10[t10.Add = 0] = "Add", t10[t10.Remove = 1] = "Remove", t10))(Ap || {});
function Z3() {
  return inject(Ww, () => {
  });
}
function M3({ type: t10, enabled: e3, element: r3, onUpdate: n3 }) {
  let i3 = Z3();
  function o3(...s3) {
    n3 == null || n3(...s3), i3(...s3);
  }
  onMounted(() => {
    watch(e3, (s3, a3) => {
      s3 ? o3(0, t10, r3) : a3 === true && o3(1, t10, r3);
    }, { immediate: true, flush: "sync" });
  }), onUnmounted(() => {
    e3.value && o3(1, t10, r3);
  }), provide(Ww, o3);
}
let Vw = Symbol("DescriptionContext");
function N3() {
  let t10 = inject(Vw, null);
  if (t10 === null)
    throw new Error("Missing parent");
  return t10;
}
function W3({ slot: t10 = ref({}), name: e3 = "Description", props: r3 = {} } = {}) {
  let n3 = ref([]);
  function i3(o3) {
    return n3.value.push(o3), () => {
      let s3 = n3.value.indexOf(o3);
      s3 !== -1 && n3.value.splice(s3, 1);
    };
  }
  return provide(Vw, { register: i3, slot: t10, name: e3, props: r3 }), computed(() => n3.value.length > 0 ? n3.value.join(" ") : void 0);
}
defineComponent({ name: "Description", props: { as: { type: [Object, String], default: "p" }, id: { type: String, default: () => `headlessui-description-${Fr()}` } }, setup(t10, { attrs: e3, slots: r3 }) {
  let n3 = N3();
  return onMounted(() => onUnmounted(n3.register(t10.id))), () => {
    let { name: i3 = "Description", slot: o3 = ref({}), props: s3 = {} } = n3, { id: a3, ...l3 } = t10, u3 = { ...Object.entries(s3).reduce((c3, [f3, d3]) => Object.assign(c3, { [f3]: unref(d3) }), {}), id: a3 };
    return Rt({ ourProps: u3, theirProps: l3, slot: o3.value, attrs: e3, slots: r3, name: i3 });
  };
} });
function Y3(t10) {
  let e3 = shallowRef(t10.getSnapshot());
  return onUnmounted(t10.subscribe(() => {
    e3.value = t10.getSnapshot();
  })), e3;
}
function L3(t10, e3) {
  let r3 = t10(), n3 = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return r3;
  }, subscribe(i3) {
    return n3.add(i3), () => n3.delete(i3);
  }, dispatch(i3, ...o3) {
    let s3 = e3[i3].call(r3, ...o3);
    s3 && (r3 = s3, n3.forEach((a3) => a3()));
  } };
}
function B3() {
  let t10;
  return { before({ doc: e3 }) {
    var r3;
    let n3 = e3.documentElement;
    t10 = ((r3 = e3.defaultView) != null ? r3 : window).innerWidth - n3.clientWidth;
  }, after({ doc: e3, d: r3 }) {
    let n3 = e3.documentElement, i3 = n3.clientWidth - n3.offsetWidth, o3 = t10 - i3;
    r3.style(n3, "paddingRight", `${o3}px`);
  } };
}
function z3() {
  if (!E3())
    return {};
  let t10;
  return { before() {
    t10 = window.pageYOffset;
  }, after({ doc: e3, d: r3, meta: n3 }) {
    function i3(s3) {
      return n3.containers.flatMap((a3) => a3()).some((a3) => a3.contains(s3));
    }
    if (window.getComputedStyle(e3.documentElement).scrollBehavior !== "auto") {
      let s3 = og();
      s3.style(e3.documentElement, "scroll-behavior", "auto"), r3.add(() => r3.microTask(() => s3.dispose()));
    }
    r3.style(e3.body, "marginTop", `-${t10}px`), window.scrollTo(0, 0);
    let o3 = null;
    r3.addEventListener(e3, "click", (s3) => {
      if (s3.target instanceof HTMLElement)
        try {
          let a3 = s3.target.closest("a");
          if (!a3)
            return;
          let { hash: l3 } = new URL(a3.href), u3 = e3.querySelector(l3);
          u3 && !i3(u3) && (o3 = u3);
        } catch {
        }
    }, true), r3.addEventListener(e3, "touchmove", (s3) => {
      s3.target instanceof HTMLElement && !i3(s3.target) && s3.preventDefault();
    }, { passive: false }), r3.add(() => {
      window.scrollTo(0, window.pageYOffset + t10), o3 && o3.isConnected && (o3.scrollIntoView({ block: "nearest" }), o3 = null);
    });
  } };
}
function H3() {
  return { before({ doc: t10, d: e3 }) {
    e3.style(t10.documentElement, "overflow", "hidden");
  } };
}
function G3(t10) {
  let e3 = {};
  for (let r3 of t10)
    Object.assign(e3, r3(e3));
  return e3;
}
let Io = L3(() => /* @__PURE__ */ new Map(), { PUSH(t10, e3) {
  var r3;
  let n3 = (r3 = this.get(t10)) != null ? r3 : { doc: t10, count: 0, d: og(), meta: /* @__PURE__ */ new Set() };
  return n3.count++, n3.meta.add(e3), this.set(t10, n3), this;
}, POP(t10, e3) {
  let r3 = this.get(t10);
  return r3 && (r3.count--, r3.meta.delete(e3)), this;
}, SCROLL_PREVENT({ doc: t10, d: e3, meta: r3 }) {
  let n3 = { doc: t10, d: e3, meta: G3(r3) }, i3 = [z3(), B3(), H3()];
  i3.forEach(({ before: o3 }) => o3 == null ? void 0 : o3(n3)), i3.forEach(({ after: o3 }) => o3 == null ? void 0 : o3(n3));
}, SCROLL_ALLOW({ d: t10 }) {
  t10.dispose();
}, TEARDOWN({ doc: t10 }) {
  this.delete(t10);
} });
Io.subscribe(() => {
  let t10 = Io.getSnapshot(), e3 = /* @__PURE__ */ new Map();
  for (let [r3] of t10)
    e3.set(r3, r3.documentElement.style.overflow);
  for (let r3 of t10.values()) {
    let n3 = e3.get(r3.doc) === "hidden", i3 = r3.count !== 0;
    (i3 && !n3 || !i3 && n3) && Io.dispatch(r3.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", r3), r3.count === 0 && Io.dispatch("TEARDOWN", r3);
  }
});
function K3(t10, e3, r3) {
  let n3 = Y3(Io), i3 = computed(() => {
    let o3 = t10.value ? n3.value.get(t10.value) : void 0;
    return o3 ? o3.count > 0 : false;
  });
  return watch([t10, e3], ([o3, s3], [a3], l3) => {
    if (!o3 || !s3)
      return;
    Io.dispatch("PUSH", o3, r3);
    let u3 = false;
    l3(() => {
      u3 || (Io.dispatch("POP", a3 ?? o3, r3), u3 = true);
    });
  }, { immediate: true }), i3;
}
function J3({ defaultContainers: t10 = [], portals: e3, mainTreeNodeRef: r3 } = {}) {
  let n3 = ref(null), i3 = ds(n3);
  function o3() {
    var s3;
    let a3 = [];
    for (let l3 of t10)
      l3 !== null && (l3 instanceof HTMLElement ? a3.push(l3) : "value" in l3 && l3.value instanceof HTMLElement && a3.push(l3.value));
    if (e3 != null && e3.value)
      for (let l3 of e3.value)
        a3.push(l3);
    for (let l3 of (s3 = i3 == null ? void 0 : i3.querySelectorAll("html > *, body > *")) != null ? s3 : [])
      l3 !== document.body && l3 !== document.head && l3 instanceof HTMLElement && l3.id !== "headlessui-portal-root" && (l3.contains(Te(n3)) || a3.some((u3) => l3.contains(u3)) || a3.push(l3));
    return a3;
  }
  return { resolveContainers: o3, contains(s3) {
    return o3().some((a3) => a3.contains(s3));
  }, mainTreeNodeRef: n3, MainTreeNode() {
    return r3 != null ? null : h$3(sa, { features: oa.Hidden, ref: n3 });
  } };
}
var eE = ((t10) => (t10[t10.Open = 0] = "Open", t10[t10.Closed = 1] = "Closed", t10))(eE || {});
let Xp = Symbol("DialogContext");
function iu(t10) {
  let e3 = inject(Xp, null);
  if (e3 === null) {
    let r3 = new Error(`<${t10} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r3, iu), r3;
  }
  return e3;
}
let ju = "DC8F892D-2EBD-447C-A4C8-A03058436FF4";
defineComponent({ name: "Dialog", inheritAttrs: false, props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true }, open: { type: [Boolean, String], default: ju }, initialFocus: { type: Object, default: null }, id: { type: String, default: () => `headlessui-dialog-${Fr()}` } }, emits: { close: (t10) => true }, setup(t10, { emit: e3, attrs: r3, slots: n3, expose: i3 }) {
  var o3;
  let s3 = ref(false);
  onMounted(() => {
    s3.value = true;
  });
  let a3 = ref(0), l3 = rg(), u3 = computed(() => t10.open === ju && l3 !== null ? (l3.value & Jr.Open) === Jr.Open : t10.open), c3 = ref(null), f3 = computed(() => ds(c3));
  if (i3({ el: c3, $el: c3 }), !(t10.open !== ju || l3 !== null))
    throw new Error("You forgot to provide an `open` prop to the `Dialog`.");
  if (typeof u3.value != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${u3.value === ju ? void 0 : t10.open}`);
  let d3 = computed(() => s3.value && u3.value ? 0 : 1), p10 = computed(() => d3.value === 0), h10 = computed(() => a3.value > 1), m10 = inject(Xp, null) !== null, [O10, g] = I3(), { resolveContainers: v10, mainTreeNodeRef: S10, MainTreeNode: $10 } = J3({ portals: O10, defaultContainers: [computed(() => {
    var _e;
    return (_e = fe.panelRef.value) != null ? _e : c3.value;
  })] }), _10 = computed(() => h10.value ? "parent" : "leaf"), P10 = computed(() => l3 !== null ? (l3.value & Jr.Closing) === Jr.Closing : false), q5 = computed(() => m10 || P10.value ? false : p10.value), N5 = computed(() => {
    var _e, Ie, je2;
    return (je2 = Array.from((Ie = (_e = f3.value) == null ? void 0 : _e.querySelectorAll("body > *")) != null ? Ie : []).find((G) => G.id === "headlessui-portal-root" ? false : G.contains(Te(S10)) && G instanceof HTMLElement)) != null ? je2 : null;
  });
  W1(N5, q5);
  let B5 = computed(() => h10.value ? true : p10.value), H10 = computed(() => {
    var _e, Ie, je2;
    return (je2 = Array.from((Ie = (_e = f3.value) == null ? void 0 : _e.querySelectorAll("[data-headlessui-portal]")) != null ? Ie : []).find((G) => G.contains(Te(S10)) && G instanceof HTMLElement)) != null ? je2 : null;
  });
  W1(H10, B5), M3({ type: "Dialog", enabled: computed(() => d3.value === 0), element: c3, onUpdate: (_e, Ie) => {
    if (Ie === "Dialog")
      return Mt(_e, { [Ap.Add]: () => a3.value += 1, [Ap.Remove]: () => a3.value -= 1 });
  } });
  let ne = W3({ name: "DialogDescription", slot: computed(() => ({ open: u3.value })) }), re2 = ref(null), fe = { titleId: re2, panelRef: ref(null), dialogState: d3, setTitleId(_e) {
    re2.value !== _e && (re2.value = _e);
  }, close() {
    e3("close", false);
  } };
  provide(Xp, fe);
  let pe = computed(() => !(!p10.value || h10.value));
  Aw(v10, (_e, Ie) => {
    fe.close(), nextTick(() => Ie == null ? void 0 : Ie.focus());
  }, pe);
  let Ee2 = computed(() => !(h10.value || d3.value !== 0));
  jw((o3 = f3.value) == null ? void 0 : o3.defaultView, "keydown", (_e) => {
    Ee2.value && (_e.defaultPrevented || _e.key === ot.Escape && (_e.preventDefault(), _e.stopPropagation(), fe.close()));
  });
  let qe = computed(() => !(P10.value || d3.value !== 0 || m10));
  return K3(f3, qe, (_e) => {
    var Ie;
    return { containers: [...(Ie = _e.containers) != null ? Ie : [], v10] };
  }), watchEffect((_e) => {
    if (d3.value !== 0)
      return;
    let Ie = Te(c3);
    if (!Ie)
      return;
    let je2 = new ResizeObserver((G) => {
      for (let Z of G) {
        let C10 = Z.target.getBoundingClientRect();
        C10.x === 0 && C10.y === 0 && C10.width === 0 && C10.height === 0 && fe.close();
      }
    });
    je2.observe(Ie), _e(() => je2.disconnect());
  }), () => {
    let { id: _e, open: Ie, initialFocus: je2, ...G } = t10, Z = { ...r3, ref: c3, id: _e, role: "dialog", "aria-modal": d3.value === 0 ? true : void 0, "aria-labelledby": re2.value, "aria-describedby": ne.value }, C10 = { open: d3.value === 0 };
    return h$3(Cp, { force: true }, () => [h$3(Mw, () => h$3(F3, { target: c3.value }, () => h$3(Cp, { force: false }, () => h$3(Za, { initialFocus: je2, containers: v10, features: p10.value ? Mt(_10.value, { parent: Za.features.RestoreFocus, leaf: Za.features.All & ~Za.features.FocusLock }) : Za.features.None }, () => h$3(g, {}, () => Rt({ ourProps: Z, theirProps: { ...G, ...r3 }, slot: C10, attrs: r3, slots: n3, visible: d3.value === 0, features: Ei.RenderStrategy | Ei.Static, name: "Dialog" })))))), h$3($10)]);
  };
} });
defineComponent({ name: "DialogOverlay", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: () => `headlessui-dialog-overlay-${Fr()}` } }, setup(t10, { attrs: e3, slots: r3 }) {
  let n3 = iu("DialogOverlay");
  function i3(o3) {
    o3.target === o3.currentTarget && (o3.preventDefault(), o3.stopPropagation(), n3.close());
  }
  return () => {
    let { id: o3, ...s3 } = t10;
    return Rt({ ourProps: { id: o3, "aria-hidden": true, onClick: i3 }, theirProps: s3, slot: { open: n3.dialogState.value === 0 }, attrs: e3, slots: r3, name: "DialogOverlay" });
  };
} });
defineComponent({ name: "DialogBackdrop", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: () => `headlessui-dialog-backdrop-${Fr()}` } }, inheritAttrs: false, setup(t10, { attrs: e3, slots: r3, expose: n3 }) {
  let i3 = iu("DialogBackdrop"), o3 = ref(null);
  return n3({ el: o3, $el: o3 }), onMounted(() => {
    if (i3.panelRef.value === null)
      throw new Error("A <DialogBackdrop /> component is being used, but a <DialogPanel /> component is missing.");
  }), () => {
    let { id: s3, ...a3 } = t10, l3 = { id: s3, ref: o3, "aria-hidden": true };
    return h$3(Cp, { force: true }, () => h$3(Mw, () => Rt({ ourProps: l3, theirProps: { ...e3, ...a3 }, slot: { open: i3.dialogState.value === 0 }, attrs: e3, slots: r3, name: "DialogBackdrop" })));
  };
} });
defineComponent({ name: "DialogPanel", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: () => `headlessui-dialog-panel-${Fr()}` } }, setup(t10, { attrs: e3, slots: r3, expose: n3 }) {
  let i3 = iu("DialogPanel");
  n3({ el: i3.panelRef, $el: i3.panelRef });
  function o3(s3) {
    s3.stopPropagation();
  }
  return () => {
    let { id: s3, ...a3 } = t10, l3 = { id: s3, ref: i3.panelRef, onClick: o3 };
    return Rt({ ourProps: l3, theirProps: a3, slot: { open: i3.dialogState.value === 0 }, attrs: e3, slots: r3, name: "DialogPanel" });
  };
} });
defineComponent({ name: "DialogTitle", props: { as: { type: [Object, String], default: "h2" }, id: { type: String, default: () => `headlessui-dialog-title-${Fr()}` } }, setup(t10, { attrs: e3, slots: r3 }) {
  let n3 = iu("DialogTitle");
  return onMounted(() => {
    n3.setTitleId(t10.id), onUnmounted(() => n3.setTitleId(null));
  }), () => {
    let { id: i3, ...o3 } = t10;
    return Rt({ ourProps: { id: i3 }, theirProps: o3, slot: { open: n3.dialogState.value === 0 }, attrs: e3, slots: r3, name: "DialogTitle" });
  };
} });
var oE = ((t10) => (t10[t10.Open = 0] = "Open", t10[t10.Closed = 1] = "Closed", t10))(oE || {});
let Yw = Symbol("DisclosureContext");
function sg(t10) {
  let e3 = inject(Yw, null);
  if (e3 === null) {
    let r3 = new Error(`<${t10} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r3, sg), r3;
  }
  return e3;
}
let Lw = Symbol("DisclosurePanelContext");
function sE() {
  return inject(Lw, null);
}
defineComponent({ name: "Disclosure", props: { as: { type: [Object, String], default: "template" }, defaultOpen: { type: [Boolean], default: false } }, setup(t10, { slots: e3, attrs: r3 }) {
  let n3 = ref(t10.defaultOpen ? 0 : 1), i3 = ref(null), o3 = ref(null), s3 = { buttonId: ref(`headlessui-disclosure-button-${Fr()}`), panelId: ref(`headlessui-disclosure-panel-${Fr()}`), disclosureState: n3, panel: i3, button: o3, toggleDisclosure() {
    n3.value = Mt(n3.value, { 0: 1, 1: 0 });
  }, closeDisclosure() {
    n3.value !== 1 && (n3.value = 1);
  }, close(a3) {
    s3.closeDisclosure();
    let l3 = (() => a3 ? a3 instanceof HTMLElement ? a3 : a3.value instanceof HTMLElement ? Te(a3) : Te(s3.button) : Te(s3.button))();
    l3 == null || l3.focus();
  } };
  return provide(Yw, s3), Ew(computed(() => Mt(n3.value, { 0: Jr.Open, 1: Jr.Closed }))), () => {
    let { defaultOpen: a3, ...l3 } = t10, u3 = { open: n3.value === 0, close: s3.close };
    return Rt({ theirProps: l3, ourProps: {}, slot: u3, slots: e3, attrs: r3, name: "Disclosure" });
  };
} });
defineComponent({ name: "DisclosureButton", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: false }, id: { type: String, default: null } }, setup(t10, { attrs: e3, slots: r3, expose: n3 }) {
  let i3 = sg("DisclosureButton"), o3 = sE(), s3 = computed(() => o3 === null ? false : o3.value === i3.panelId.value);
  onMounted(() => {
    s3.value || t10.id !== null && (i3.buttonId.value = t10.id);
  }), onUnmounted(() => {
    s3.value || (i3.buttonId.value = null);
  });
  let a3 = ref(null);
  n3({ el: a3, $el: a3 }), s3.value || watchEffect(() => {
    i3.button.value = a3.value;
  });
  let l3 = ng(computed(() => ({ as: t10.as, type: e3.type })), a3);
  function u3() {
    var d3;
    t10.disabled || (s3.value ? (i3.toggleDisclosure(), (d3 = Te(i3.button)) == null || d3.focus()) : i3.toggleDisclosure());
  }
  function c3(d3) {
    var p10;
    if (!t10.disabled)
      if (s3.value)
        switch (d3.key) {
          case ot.Space:
          case ot.Enter:
            d3.preventDefault(), d3.stopPropagation(), i3.toggleDisclosure(), (p10 = Te(i3.button)) == null || p10.focus();
            break;
        }
      else
        switch (d3.key) {
          case ot.Space:
          case ot.Enter:
            d3.preventDefault(), d3.stopPropagation(), i3.toggleDisclosure();
            break;
        }
  }
  function f3(d3) {
    switch (d3.key) {
      case ot.Space:
        d3.preventDefault();
        break;
    }
  }
  return () => {
    var d3;
    let p10 = { open: i3.disclosureState.value === 0 }, { id: h10, ...m10 } = t10, O10 = s3.value ? { ref: a3, type: l3.value, onClick: u3, onKeydown: c3 } : { id: (d3 = i3.buttonId.value) != null ? d3 : h10, ref: a3, type: l3.value, "aria-expanded": i3.disclosureState.value === 0, "aria-controls": i3.disclosureState.value === 0 || Te(i3.panel) ? i3.panelId.value : void 0, disabled: t10.disabled ? true : void 0, onClick: u3, onKeydown: c3, onKeyup: f3 };
    return Rt({ ourProps: O10, theirProps: m10, slot: p10, attrs: e3, slots: r3, name: "DisclosureButton" });
  };
} });
defineComponent({ name: "DisclosurePanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true }, id: { type: String, default: null } }, setup(t10, { attrs: e3, slots: r3, expose: n3 }) {
  let i3 = sg("DisclosurePanel");
  onMounted(() => {
    t10.id !== null && (i3.panelId.value = t10.id);
  }), onUnmounted(() => {
    i3.panelId.value = null;
  }), n3({ el: i3.panel, $el: i3.panel }), provide(Lw, i3.panelId);
  let o3 = rg(), s3 = computed(() => o3 !== null ? (o3.value & Jr.Open) === Jr.Open : i3.disclosureState.value === 0);
  return () => {
    var a3;
    let l3 = { open: i3.disclosureState.value === 0, close: i3.close }, { id: u3, ...c3 } = t10, f3 = { id: (a3 = i3.panelId.value) != null ? a3 : u3, ref: i3.panel };
    return Rt({ ourProps: f3, theirProps: c3, slot: l3, attrs: e3, slots: r3, features: Ei.RenderStrategy | Ei.Static, visible: s3.value, name: "DisclosurePanel" });
  };
} });
let V1 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function Y1(t10) {
  var e3, r3;
  let n3 = (e3 = t10.innerText) != null ? e3 : "", i3 = t10.cloneNode(true);
  if (!(i3 instanceof HTMLElement))
    return n3;
  let o3 = false;
  for (let a3 of i3.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
    a3.remove(), o3 = true;
  let s3 = o3 ? (r3 = i3.innerText) != null ? r3 : "" : n3;
  return V1.test(s3) && (s3 = s3.replace(V1, "")), s3;
}
function cE(t10) {
  let e3 = t10.getAttribute("aria-label");
  if (typeof e3 == "string")
    return e3.trim();
  let r3 = t10.getAttribute("aria-labelledby");
  if (r3) {
    let n3 = r3.split(" ").map((i3) => {
      let o3 = document.getElementById(i3);
      if (o3) {
        let s3 = o3.getAttribute("aria-label");
        return typeof s3 == "string" ? s3.trim() : Y1(o3).trim();
      }
      return null;
    }).filter(Boolean);
    if (n3.length > 0)
      return n3.join(", ");
  }
  return Y1(t10).trim();
}
function fE(t10) {
  let e3 = ref(""), r3 = ref("");
  return () => {
    let n3 = Te(t10);
    if (!n3)
      return "";
    let i3 = n3.innerText;
    if (e3.value === i3)
      return r3.value;
    let o3 = cE(n3).trim().toLowerCase();
    return e3.value = i3, r3.value = o3, o3;
  };
}
function dE(t10, e3) {
  return t10 === e3;
}
var hE = ((t10) => (t10[t10.Open = 0] = "Open", t10[t10.Closed = 1] = "Closed", t10))(hE || {}), pE = ((t10) => (t10[t10.Single = 0] = "Single", t10[t10.Multi = 1] = "Multi", t10))(pE || {}), OE = ((t10) => (t10[t10.Pointer = 0] = "Pointer", t10[t10.Other = 1] = "Other", t10))(OE || {});
function mE(t10) {
  requestAnimationFrame(() => requestAnimationFrame(t10));
}
let Bw = Symbol("ListboxContext");
function ou(t10) {
  let e3 = inject(Bw, null);
  if (e3 === null) {
    let r3 = new Error(`<${t10} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r3, ou), r3;
  }
  return e3;
}
let gE = defineComponent({ name: "Listbox", emits: { "update:modelValue": (t10) => true }, props: { as: { type: [Object, String], default: "template" }, disabled: { type: [Boolean], default: false }, by: { type: [String, Function], default: () => dE }, horizontal: { type: [Boolean], default: false }, modelValue: { type: [Object, String, Number, Boolean], default: void 0 }, defaultValue: { type: [Object, String, Number, Boolean], default: void 0 }, form: { type: String, optional: true }, name: { type: String, optional: true }, multiple: { type: [Boolean], default: false } }, inheritAttrs: false, setup(t10, { slots: e3, attrs: r3, emit: n3 }) {
  let i3 = ref(1), o3 = ref(null), s3 = ref(null), a3 = ref(null), l3 = ref([]), u3 = ref(""), c3 = ref(null), f3 = ref(1);
  function d3(S10 = ($10) => $10) {
    let $10 = c3.value !== null ? l3.value[c3.value] : null, _10 = Co(S10(l3.value.slice()), (q5) => Te(q5.dataRef.domRef)), P10 = $10 ? _10.indexOf($10) : null;
    return P10 === -1 && (P10 = null), { options: _10, activeOptionIndex: P10 };
  }
  let p10 = computed(() => t10.multiple ? 1 : 0), [h10, m10] = T3(computed(() => t10.modelValue), (S10) => n3("update:modelValue", S10), computed(() => t10.defaultValue)), O10 = computed(() => h10.value === void 0 ? Mt(p10.value, { 1: [], 0: void 0 }) : h10.value), g = { listboxState: i3, value: O10, mode: p10, compare(S10, $10) {
    if (typeof t10.by == "string") {
      let _10 = t10.by;
      return (S10 == null ? void 0 : S10[_10]) === ($10 == null ? void 0 : $10[_10]);
    }
    return t10.by(S10, $10);
  }, orientation: computed(() => t10.horizontal ? "horizontal" : "vertical"), labelRef: o3, buttonRef: s3, optionsRef: a3, disabled: computed(() => t10.disabled), options: l3, searchQuery: u3, activeOptionIndex: c3, activationTrigger: f3, closeListbox() {
    t10.disabled || i3.value !== 1 && (i3.value = 1, c3.value = null);
  }, openListbox() {
    t10.disabled || i3.value !== 0 && (i3.value = 0);
  }, goToOption(S10, $10, _10) {
    if (t10.disabled || i3.value === 1)
      return;
    let P10 = d3(), q5 = v3(S10 === Tr.Specific ? { focus: Tr.Specific, id: $10 } : { focus: S10 }, { resolveItems: () => P10.options, resolveActiveIndex: () => P10.activeOptionIndex, resolveId: (N5) => N5.id, resolveDisabled: (N5) => N5.dataRef.disabled });
    u3.value = "", c3.value = q5, f3.value = _10 ?? 1, l3.value = P10.options;
  }, search(S10) {
    if (t10.disabled || i3.value === 1)
      return;
    let $10 = u3.value !== "" ? 0 : 1;
    u3.value += S10.toLowerCase();
    let _10 = (c3.value !== null ? l3.value.slice(c3.value + $10).concat(l3.value.slice(0, c3.value + $10)) : l3.value).find((q5) => q5.dataRef.textValue.startsWith(u3.value) && !q5.dataRef.disabled), P10 = _10 ? l3.value.indexOf(_10) : -1;
    P10 === -1 || P10 === c3.value || (c3.value = P10, f3.value = 1);
  }, clearSearch() {
    t10.disabled || i3.value !== 1 && u3.value !== "" && (u3.value = "");
  }, registerOption(S10, $10) {
    let _10 = d3((P10) => [...P10, { id: S10, dataRef: $10 }]);
    l3.value = _10.options, c3.value = _10.activeOptionIndex;
  }, unregisterOption(S10) {
    let $10 = d3((_10) => {
      let P10 = _10.findIndex((q5) => q5.id === S10);
      return P10 !== -1 && _10.splice(P10, 1), _10;
    });
    l3.value = $10.options, c3.value = $10.activeOptionIndex, f3.value = 1;
  }, theirOnChange(S10) {
    t10.disabled || m10(S10);
  }, select(S10) {
    t10.disabled || m10(Mt(p10.value, { 0: () => S10, 1: () => {
      let $10 = toRaw(g.value.value).slice(), _10 = toRaw(S10), P10 = $10.findIndex((q5) => g.compare(_10, toRaw(q5)));
      return P10 === -1 ? $10.push(_10) : $10.splice(P10, 1), $10;
    } }));
  } };
  Aw([s3, a3], (S10, $10) => {
    var _10;
    g.closeListbox(), Cw($10, ig.Loose) || (S10.preventDefault(), (_10 = Te(s3)) == null || _10.focus());
  }, computed(() => i3.value === 0)), provide(Bw, g), Ew(computed(() => Mt(i3.value, { 0: Jr.Open, 1: Jr.Closed })));
  let v10 = computed(() => {
    var S10;
    return (S10 = Te(s3)) == null ? void 0 : S10.closest("form");
  });
  return onMounted(() => {
    watch([v10], () => {
      if (!v10.value || t10.defaultValue === void 0)
        return;
      function S10() {
        g.theirOnChange(t10.defaultValue);
      }
      return v10.value.addEventListener("reset", S10), () => {
        var $10;
        ($10 = v10.value) == null || $10.removeEventListener("reset", S10);
      };
    }, { immediate: true });
  }), () => {
    let { name: S10, modelValue: $10, disabled: _10, form: P10, ...q5 } = t10, N5 = { open: i3.value === 0, disabled: _10, value: O10.value };
    return h$3(Fragment, [...S10 != null && O10.value != null ? Xw({ [S10]: O10.value }).map(([B5, H10]) => h$3(sa, p3({ features: oa.Hidden, key: B5, as: "input", type: "hidden", hidden: true, readOnly: true, form: P10, name: B5, value: H10 }))) : [], Rt({ ourProps: {}, theirProps: { ...r3, ...tg(q5, ["defaultValue", "onUpdate:modelValue", "horizontal", "multiple", "by"]) }, slot: N5, slots: e3, attrs: r3, name: "Listbox" })]);
  };
} });
defineComponent({ name: "ListboxLabel", props: { as: { type: [Object, String], default: "label" }, id: { type: String, default: () => `headlessui-listbox-label-${Fr()}` } }, setup(t10, { attrs: e3, slots: r3 }) {
  let n3 = ou("ListboxLabel");
  function i3() {
    var o3;
    (o3 = Te(n3.buttonRef)) == null || o3.focus({ preventScroll: true });
  }
  return () => {
    let o3 = { open: n3.listboxState.value === 0, disabled: n3.disabled.value }, { id: s3, ...a3 } = t10, l3 = { id: s3, ref: n3.labelRef, onClick: i3 };
    return Rt({ ourProps: l3, theirProps: a3, slot: o3, attrs: e3, slots: r3, name: "ListboxLabel" });
  };
} });
let yE = defineComponent({ name: "ListboxButton", props: { as: { type: [Object, String], default: "button" }, id: { type: String, default: () => `headlessui-listbox-button-${Fr()}` } }, setup(t10, { attrs: e3, slots: r3, expose: n3 }) {
  let i3 = ou("ListboxButton");
  n3({ el: i3.buttonRef, $el: i3.buttonRef });
  function o3(u3) {
    switch (u3.key) {
      case ot.Space:
      case ot.Enter:
      case ot.ArrowDown:
        u3.preventDefault(), i3.openListbox(), nextTick(() => {
          var c3;
          (c3 = Te(i3.optionsRef)) == null || c3.focus({ preventScroll: true }), i3.value.value || i3.goToOption(Tr.First);
        });
        break;
      case ot.ArrowUp:
        u3.preventDefault(), i3.openListbox(), nextTick(() => {
          var c3;
          (c3 = Te(i3.optionsRef)) == null || c3.focus({ preventScroll: true }), i3.value.value || i3.goToOption(Tr.Last);
        });
        break;
    }
  }
  function s3(u3) {
    switch (u3.key) {
      case ot.Space:
        u3.preventDefault();
        break;
    }
  }
  function a3(u3) {
    i3.disabled.value || (i3.listboxState.value === 0 ? (i3.closeListbox(), nextTick(() => {
      var c3;
      return (c3 = Te(i3.buttonRef)) == null ? void 0 : c3.focus({ preventScroll: true });
    })) : (u3.preventDefault(), i3.openListbox(), mE(() => {
      var c3;
      return (c3 = Te(i3.optionsRef)) == null ? void 0 : c3.focus({ preventScroll: true });
    })));
  }
  let l3 = ng(computed(() => ({ as: t10.as, type: e3.type })), i3.buttonRef);
  return () => {
    var u3, c3;
    let f3 = { open: i3.listboxState.value === 0, disabled: i3.disabled.value, value: i3.value.value }, { id: d3, ...p10 } = t10, h10 = { ref: i3.buttonRef, id: d3, type: l3.value, "aria-haspopup": "listbox", "aria-controls": (u3 = Te(i3.optionsRef)) == null ? void 0 : u3.id, "aria-expanded": i3.listboxState.value === 0, "aria-labelledby": i3.labelRef.value ? [(c3 = Te(i3.labelRef)) == null ? void 0 : c3.id, d3].join(" ") : void 0, disabled: i3.disabled.value === true ? true : void 0, onKeydown: o3, onKeyup: s3, onClick: a3 };
    return Rt({ ourProps: h10, theirProps: p10, slot: f3, attrs: e3, slots: r3, name: "ListboxButton" });
  };
} }), vE = defineComponent({ name: "ListboxOptions", props: { as: { type: [Object, String], default: "ul" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true }, id: { type: String, default: () => `headlessui-listbox-options-${Fr()}` } }, setup(t10, { attrs: e3, slots: r3, expose: n3 }) {
  let i3 = ou("ListboxOptions"), o3 = ref(null);
  n3({ el: i3.optionsRef, $el: i3.optionsRef });
  function s3(u3) {
    switch (o3.value && clearTimeout(o3.value), u3.key) {
      case ot.Space:
        if (i3.searchQuery.value !== "")
          return u3.preventDefault(), u3.stopPropagation(), i3.search(u3.key);
      case ot.Enter:
        if (u3.preventDefault(), u3.stopPropagation(), i3.activeOptionIndex.value !== null) {
          let c3 = i3.options.value[i3.activeOptionIndex.value];
          i3.select(c3.dataRef.value);
        }
        i3.mode.value === 0 && (i3.closeListbox(), nextTick(() => {
          var c3;
          return (c3 = Te(i3.buttonRef)) == null ? void 0 : c3.focus({ preventScroll: true });
        }));
        break;
      case Mt(i3.orientation.value, { vertical: ot.ArrowDown, horizontal: ot.ArrowRight }):
        return u3.preventDefault(), u3.stopPropagation(), i3.goToOption(Tr.Next);
      case Mt(i3.orientation.value, { vertical: ot.ArrowUp, horizontal: ot.ArrowLeft }):
        return u3.preventDefault(), u3.stopPropagation(), i3.goToOption(Tr.Previous);
      case ot.Home:
      case ot.PageUp:
        return u3.preventDefault(), u3.stopPropagation(), i3.goToOption(Tr.First);
      case ot.End:
      case ot.PageDown:
        return u3.preventDefault(), u3.stopPropagation(), i3.goToOption(Tr.Last);
      case ot.Escape:
        u3.preventDefault(), u3.stopPropagation(), i3.closeListbox(), nextTick(() => {
          var c3;
          return (c3 = Te(i3.buttonRef)) == null ? void 0 : c3.focus({ preventScroll: true });
        });
        break;
      case ot.Tab:
        u3.preventDefault(), u3.stopPropagation();
        break;
      default:
        u3.key.length === 1 && (i3.search(u3.key), o3.value = setTimeout(() => i3.clearSearch(), 350));
        break;
    }
  }
  let a3 = rg(), l3 = computed(() => a3 !== null ? (a3.value & Jr.Open) === Jr.Open : i3.listboxState.value === 0);
  return () => {
    var u3, c3, f3, d3;
    let p10 = { open: i3.listboxState.value === 0 }, { id: h10, ...m10 } = t10, O10 = { "aria-activedescendant": i3.activeOptionIndex.value === null || (u3 = i3.options.value[i3.activeOptionIndex.value]) == null ? void 0 : u3.id, "aria-multiselectable": i3.mode.value === 1 ? true : void 0, "aria-labelledby": (d3 = (c3 = Te(i3.labelRef)) == null ? void 0 : c3.id) != null ? d3 : (f3 = Te(i3.buttonRef)) == null ? void 0 : f3.id, "aria-orientation": i3.orientation.value, id: h10, onKeydown: s3, role: "listbox", tabIndex: 0, ref: i3.optionsRef };
    return Rt({ ourProps: O10, theirProps: m10, slot: p10, attrs: e3, slots: r3, features: Ei.RenderStrategy | Ei.Static, visible: l3.value, name: "ListboxOptions" });
  };
} }), bE = defineComponent({ name: "ListboxOption", props: { as: { type: [Object, String], default: "li" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: false }, id: { type: String, default: () => `headlessui-listbox.option-${Fr()}` } }, setup(t10, { slots: e3, attrs: r3, expose: n3 }) {
  let i3 = ou("ListboxOption"), o3 = ref(null);
  n3({ el: o3, $el: o3 });
  let s3 = computed(() => i3.activeOptionIndex.value !== null ? i3.options.value[i3.activeOptionIndex.value].id === t10.id : false), a3 = computed(() => Mt(i3.mode.value, { 0: () => i3.compare(toRaw(i3.value.value), toRaw(t10.value)), 1: () => toRaw(i3.value.value).some((g) => i3.compare(toRaw(g), toRaw(t10.value))) })), l3 = computed(() => Mt(i3.mode.value, { 1: () => {
    var g;
    let v10 = toRaw(i3.value.value);
    return ((g = i3.options.value.find((S10) => v10.some(($10) => i3.compare(toRaw($10), toRaw(S10.dataRef.value))))) == null ? void 0 : g.id) === t10.id;
  }, 0: () => a3.value })), u3 = fE(o3), c3 = computed(() => ({ disabled: t10.disabled, value: t10.value, get textValue() {
    return u3();
  }, domRef: o3 }));
  onMounted(() => i3.registerOption(t10.id, c3)), onUnmounted(() => i3.unregisterOption(t10.id)), onMounted(() => {
    watch([i3.listboxState, a3], () => {
      i3.listboxState.value === 0 && a3.value && Mt(i3.mode.value, { 1: () => {
        l3.value && i3.goToOption(Tr.Specific, t10.id);
      }, 0: () => {
        i3.goToOption(Tr.Specific, t10.id);
      } });
    }, { immediate: true });
  }), watchEffect(() => {
    i3.listboxState.value === 0 && s3.value && i3.activationTrigger.value !== 0 && nextTick(() => {
      var g, v10;
      return (v10 = (g = Te(o3)) == null ? void 0 : g.scrollIntoView) == null ? void 0 : v10.call(g, { block: "nearest" });
    });
  });
  function f3(g) {
    if (t10.disabled)
      return g.preventDefault();
    i3.select(t10.value), i3.mode.value === 0 && (i3.closeListbox(), nextTick(() => {
      var v10;
      return (v10 = Te(i3.buttonRef)) == null ? void 0 : v10.focus({ preventScroll: true });
    }));
  }
  function d3() {
    if (t10.disabled)
      return i3.goToOption(Tr.Nothing);
    i3.goToOption(Tr.Specific, t10.id);
  }
  let p10 = k3();
  function h10(g) {
    p10.update(g);
  }
  function m10(g) {
    p10.wasMoved(g) && (t10.disabled || s3.value || i3.goToOption(Tr.Specific, t10.id, 0));
  }
  function O10(g) {
    p10.wasMoved(g) && (t10.disabled || s3.value && i3.goToOption(Tr.Nothing));
  }
  return () => {
    let { disabled: g } = t10, v10 = { active: s3.value, selected: a3.value, disabled: g }, { id: S10, value: $10, disabled: _10, ...P10 } = t10, q5 = { id: S10, ref: o3, role: "option", tabIndex: g === true ? void 0 : -1, "aria-disabled": g === true ? true : void 0, "aria-selected": a3.value, disabled: void 0, onClick: f3, onFocus: d3, onPointerenter: h10, onMouseenter: h10, onPointermove: m10, onMousemove: m10, onPointerleave: O10, onMouseleave: O10 };
    return Rt({ ourProps: q5, theirProps: P10, slot: v10, attrs: r3, slots: e3, name: "ListboxOption" });
  };
} }), SE = defineComponent({ props: { onFocus: { type: Function, required: true } }, setup(t10) {
  let e3 = ref(true);
  return () => e3.value ? h$3(sa, { as: "button", type: "button", features: oa.Focusable, onFocus(r3) {
    r3.preventDefault();
    let n3, i3 = 50;
    function o3() {
      var s3;
      if (i3-- <= 0) {
        n3 && cancelAnimationFrame(n3);
        return;
      }
      if ((s3 = t10.onFocus) != null && s3.call(t10)) {
        e3.value = false, cancelAnimationFrame(n3);
        return;
      }
      n3 = requestAnimationFrame(o3);
    }
    n3 = requestAnimationFrame(o3);
  } }) : null;
} });
var $E = ((t10) => (t10[t10.Forwards = 0] = "Forwards", t10[t10.Backwards = 1] = "Backwards", t10))($E || {}), wE = ((t10) => (t10[t10.Less = -1] = "Less", t10[t10.Equal = 0] = "Equal", t10[t10.Greater = 1] = "Greater", t10))(wE || {});
let zw = Symbol("TabsContext");
function su(t10) {
  let e3 = inject(zw, null);
  if (e3 === null) {
    let r3 = new Error(`<${t10} /> is missing a parent <TabGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r3, su), r3;
  }
  return e3;
}
let ag = Symbol("TabsSSRContext"), Hw = defineComponent({ name: "TabGroup", emits: { change: (t10) => true }, props: { as: { type: [Object, String], default: "template" }, selectedIndex: { type: [Number], default: null }, defaultIndex: { type: [Number], default: 0 }, vertical: { type: [Boolean], default: false }, manual: { type: [Boolean], default: false } }, inheritAttrs: false, setup(t10, { slots: e3, attrs: r3, emit: n3 }) {
  var i3;
  let o3 = ref((i3 = t10.selectedIndex) != null ? i3 : t10.defaultIndex), s3 = ref([]), a3 = ref([]), l3 = computed(() => t10.selectedIndex !== null), u3 = computed(() => l3.value ? t10.selectedIndex : o3.value);
  function c3(m10) {
    var O10;
    let g = Co(f3.tabs.value, Te), v10 = Co(f3.panels.value, Te), S10 = g.filter(($10) => {
      var _10;
      return !((_10 = Te($10)) != null && _10.hasAttribute("disabled"));
    });
    if (m10 < 0 || m10 > g.length - 1) {
      let $10 = Mt(o3.value === null ? 0 : Math.sign(m10 - o3.value), { [-1]: () => 1, 0: () => Mt(Math.sign(m10), { [-1]: () => 0, 0: () => 0, 1: () => 1 }), 1: () => 0 }), _10 = Mt($10, { 0: () => g.indexOf(S10[0]), 1: () => g.indexOf(S10[S10.length - 1]) });
      _10 !== -1 && (o3.value = _10), f3.tabs.value = g, f3.panels.value = v10;
    } else {
      let $10 = g.slice(0, m10), _10 = [...g.slice(m10), ...$10].find((q5) => S10.includes(q5));
      if (!_10)
        return;
      let P10 = (O10 = g.indexOf(_10)) != null ? O10 : f3.selectedIndex.value;
      P10 === -1 && (P10 = f3.selectedIndex.value), o3.value = P10, f3.tabs.value = g, f3.panels.value = v10;
    }
  }
  let f3 = { selectedIndex: computed(() => {
    var m10, O10;
    return (O10 = (m10 = o3.value) != null ? m10 : t10.defaultIndex) != null ? O10 : null;
  }), orientation: computed(() => t10.vertical ? "vertical" : "horizontal"), activation: computed(() => t10.manual ? "manual" : "auto"), tabs: s3, panels: a3, setSelectedIndex(m10) {
    u3.value !== m10 && n3("change", m10), l3.value || c3(m10);
  }, registerTab(m10) {
    var O10;
    if (s3.value.includes(m10))
      return;
    let g = s3.value[o3.value];
    s3.value.push(m10), s3.value = Co(s3.value, Te);
    let v10 = (O10 = s3.value.indexOf(g)) != null ? O10 : o3.value;
    v10 !== -1 && (o3.value = v10);
  }, unregisterTab(m10) {
    let O10 = s3.value.indexOf(m10);
    O10 !== -1 && s3.value.splice(O10, 1);
  }, registerPanel(m10) {
    a3.value.includes(m10) || (a3.value.push(m10), a3.value = Co(a3.value, Te));
  }, unregisterPanel(m10) {
    let O10 = a3.value.indexOf(m10);
    O10 !== -1 && a3.value.splice(O10, 1);
  } };
  provide(zw, f3);
  let d3 = ref({ tabs: [], panels: [] }), p10 = ref(false);
  onMounted(() => {
    p10.value = true;
  }), provide(ag, computed(() => p10.value ? null : d3.value));
  let h10 = computed(() => t10.selectedIndex);
  return onMounted(() => {
    watch([h10], () => {
      var m10;
      return c3((m10 = t10.selectedIndex) != null ? m10 : t10.defaultIndex);
    }, { immediate: true });
  }), watchEffect(() => {
    if (!l3.value || u3.value == null || f3.tabs.value.length <= 0)
      return;
    let m10 = Co(f3.tabs.value, Te);
    m10.some((O10, g) => Te(f3.tabs.value[g]) !== Te(O10)) && f3.setSelectedIndex(m10.findIndex((O10) => Te(O10) === Te(f3.tabs.value[u3.value])));
  }), () => {
    let m10 = { selectedIndex: o3.value };
    return h$3(Fragment, [s3.value.length <= 0 && h$3(SE, { onFocus: () => {
      for (let O10 of s3.value) {
        let g = Te(O10);
        if ((g == null ? void 0 : g.tabIndex) === 0)
          return g.focus(), true;
      }
      return false;
    } }), Rt({ theirProps: { ...r3, ...tg(t10, ["selectedIndex", "defaultIndex", "manual", "vertical", "onChange"]) }, ourProps: {}, slot: m10, slots: e3, attrs: r3, name: "TabGroup" })]);
  };
} }), Gw = defineComponent({ name: "TabList", props: { as: { type: [Object, String], default: "div" } }, setup(t10, { attrs: e3, slots: r3 }) {
  let n3 = su("TabList");
  return () => {
    let i3 = { selectedIndex: n3.selectedIndex.value }, o3 = { role: "tablist", "aria-orientation": n3.orientation.value };
    return Rt({ ourProps: o3, theirProps: t10, slot: i3, attrs: e3, slots: r3, name: "TabList" });
  };
} }), qp = defineComponent({ name: "Tab", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: false }, id: { type: String, default: () => `headlessui-tabs-tab-${Fr()}` } }, setup(t10, { attrs: e3, slots: r3, expose: n3 }) {
  let i3 = su("Tab"), o3 = ref(null);
  n3({ el: o3, $el: o3 }), onMounted(() => i3.registerTab(o3)), onUnmounted(() => i3.unregisterTab(o3));
  let s3 = inject(ag), a3 = computed(() => {
    if (s3.value) {
      let O10 = s3.value.tabs.indexOf(t10.id);
      return O10 === -1 ? s3.value.tabs.push(t10.id) - 1 : O10;
    }
    return -1;
  }), l3 = computed(() => {
    let O10 = i3.tabs.value.indexOf(o3);
    return O10 === -1 ? a3.value : O10;
  }), u3 = computed(() => l3.value === i3.selectedIndex.value);
  function c3(O10) {
    var g;
    let v10 = O10();
    if (v10 === qs.Success && i3.activation.value === "auto") {
      let S10 = (g = ds(o3)) == null ? void 0 : g.activeElement, $10 = i3.tabs.value.findIndex((_10) => Te(_10) === S10);
      $10 !== -1 && i3.setSelectedIndex($10);
    }
    return v10;
  }
  function f3(O10) {
    let g = i3.tabs.value.map((v10) => Te(v10)).filter(Boolean);
    if (O10.key === ot.Space || O10.key === ot.Enter) {
      O10.preventDefault(), O10.stopPropagation(), i3.setSelectedIndex(l3.value);
      return;
    }
    switch (O10.key) {
      case ot.Home:
      case ot.PageUp:
        return O10.preventDefault(), O10.stopPropagation(), c3(() => Wn(g, tr.First));
      case ot.End:
      case ot.PageDown:
        return O10.preventDefault(), O10.stopPropagation(), c3(() => Wn(g, tr.Last));
    }
    if (c3(() => Mt(i3.orientation.value, { vertical() {
      return O10.key === ot.ArrowUp ? Wn(g, tr.Previous | tr.WrapAround) : O10.key === ot.ArrowDown ? Wn(g, tr.Next | tr.WrapAround) : qs.Error;
    }, horizontal() {
      return O10.key === ot.ArrowLeft ? Wn(g, tr.Previous | tr.WrapAround) : O10.key === ot.ArrowRight ? Wn(g, tr.Next | tr.WrapAround) : qs.Error;
    } })) === qs.Success)
      return O10.preventDefault();
  }
  let d3 = ref(false);
  function p10() {
    var O10;
    d3.value || (d3.value = true, !t10.disabled && ((O10 = Te(o3)) == null || O10.focus({ preventScroll: true }), i3.setSelectedIndex(l3.value), Wf(() => {
      d3.value = false;
    })));
  }
  function h10(O10) {
    O10.preventDefault();
  }
  let m10 = ng(computed(() => ({ as: t10.as, type: e3.type })), o3);
  return () => {
    var O10;
    let g = { selected: u3.value }, { id: v10, ...S10 } = t10, $10 = { ref: o3, onKeydown: f3, onMousedown: h10, onClick: p10, id: v10, role: "tab", type: m10.value, "aria-controls": (O10 = Te(i3.panels.value[l3.value])) == null ? void 0 : O10.id, "aria-selected": u3.value, tabIndex: u3.value ? 0 : -1, disabled: t10.disabled ? true : void 0 };
    return Rt({ ourProps: $10, theirProps: S10, slot: g, attrs: e3, slots: r3, name: "Tab" });
  };
} });
defineComponent({ name: "TabPanels", props: { as: { type: [Object, String], default: "div" } }, setup(t10, { slots: e3, attrs: r3 }) {
  let n3 = su("TabPanels");
  return () => {
    let i3 = { selectedIndex: n3.selectedIndex.value };
    return Rt({ theirProps: t10, ourProps: {}, slot: i3, attrs: r3, slots: e3, name: "TabPanels" });
  };
} });
defineComponent({ name: "TabPanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true }, id: { type: String, default: () => `headlessui-tabs-panel-${Fr()}` }, tabIndex: { type: Number, default: 0 } }, setup(t10, { attrs: e3, slots: r3, expose: n3 }) {
  let i3 = su("TabPanel"), o3 = ref(null);
  n3({ el: o3, $el: o3 }), onMounted(() => i3.registerPanel(o3)), onUnmounted(() => i3.unregisterPanel(o3));
  let s3 = inject(ag), a3 = computed(() => {
    if (s3.value) {
      let c3 = s3.value.panels.indexOf(t10.id);
      return c3 === -1 ? s3.value.panels.push(t10.id) - 1 : c3;
    }
    return -1;
  }), l3 = computed(() => {
    let c3 = i3.panels.value.indexOf(o3);
    return c3 === -1 ? a3.value : c3;
  }), u3 = computed(() => l3.value === i3.selectedIndex.value);
  return () => {
    var c3;
    let f3 = { selected: u3.value }, { id: d3, tabIndex: p10, ...h10 } = t10, m10 = { ref: o3, id: d3, role: "tabpanel", "aria-labelledby": (c3 = Te(i3.tabs.value[l3.value])) == null ? void 0 : c3.id, tabIndex: u3.value ? p10 : -1 };
    return !u3.value && t10.unmount && !t10.static ? h$3(sa, { as: "span", ...m10 }) : Rt({ ourProps: m10, theirProps: h10, slot: f3, attrs: e3, slots: r3, features: Ei.Static | Ei.RenderStrategy, visible: u3.value, name: "TabPanel" });
  };
} });
var yt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function lg(t10) {
  return t10 && t10.__esModule && Object.prototype.hasOwnProperty.call(t10, "default") ? t10.default : t10;
}
function ug(t10) {
  if (t10.__esModule)
    return t10;
  var e3 = t10.default;
  if (typeof e3 == "function") {
    var r3 = function n3() {
      return this instanceof n3 ? Reflect.construct(e3, arguments, this.constructor) : e3.apply(this, arguments);
    };
    r3.prototype = e3.prototype;
  } else
    r3 = {};
  return Object.defineProperty(r3, "__esModule", { value: true }), Object.keys(t10).forEach(function(n3) {
    var i3 = Object.getOwnPropertyDescriptor(t10, n3);
    Object.defineProperty(r3, n3, i3.get ? i3 : {
      enumerable: true,
      get: function() {
        return t10[n3];
      }
    });
  }), r3;
}
var $e = {}, Pa = {}, Vf = {};
Vf.byteLength = AE;
Vf.toByteArray = qE;
Vf.fromByteArray = UE;
var Ln = [], an = [], CE = typeof Uint8Array < "u" ? Uint8Array : Array, ih = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var $s = 0, RE = ih.length; $s < RE; ++$s)
  Ln[$s] = ih[$s], an[ih.charCodeAt($s)] = $s;
an["-".charCodeAt(0)] = 62;
an["_".charCodeAt(0)] = 63;
function e2(t10) {
  var e3 = t10.length;
  if (e3 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r3 = t10.indexOf("=");
  r3 === -1 && (r3 = e3);
  var n3 = r3 === e3 ? 0 : 4 - r3 % 4;
  return [r3, n3];
}
function AE(t10) {
  var e3 = e2(t10), r3 = e3[0], n3 = e3[1];
  return (r3 + n3) * 3 / 4 - n3;
}
function XE(t10, e3, r3) {
  return (e3 + r3) * 3 / 4 - r3;
}
function qE(t10) {
  var e3, r3 = e2(t10), n3 = r3[0], i3 = r3[1], o3 = new CE(XE(t10, n3, i3)), s3 = 0, a3 = i3 > 0 ? n3 - 4 : n3, l3;
  for (l3 = 0; l3 < a3; l3 += 4)
    e3 = an[t10.charCodeAt(l3)] << 18 | an[t10.charCodeAt(l3 + 1)] << 12 | an[t10.charCodeAt(l3 + 2)] << 6 | an[t10.charCodeAt(l3 + 3)], o3[s3++] = e3 >> 16 & 255, o3[s3++] = e3 >> 8 & 255, o3[s3++] = e3 & 255;
  return i3 === 2 && (e3 = an[t10.charCodeAt(l3)] << 2 | an[t10.charCodeAt(l3 + 1)] >> 4, o3[s3++] = e3 & 255), i3 === 1 && (e3 = an[t10.charCodeAt(l3)] << 10 | an[t10.charCodeAt(l3 + 1)] << 4 | an[t10.charCodeAt(l3 + 2)] >> 2, o3[s3++] = e3 >> 8 & 255, o3[s3++] = e3 & 255), o3;
}
function DE(t10) {
  return Ln[t10 >> 18 & 63] + Ln[t10 >> 12 & 63] + Ln[t10 >> 6 & 63] + Ln[t10 & 63];
}
function jE(t10, e3, r3) {
  for (var n3, i3 = [], o3 = e3; o3 < r3; o3 += 3)
    n3 = (t10[o3] << 16 & 16711680) + (t10[o3 + 1] << 8 & 65280) + (t10[o3 + 2] & 255), i3.push(DE(n3));
  return i3.join("");
}
function UE(t10) {
  for (var e3, r3 = t10.length, n3 = r3 % 3, i3 = [], o3 = 16383, s3 = 0, a3 = r3 - n3; s3 < a3; s3 += o3)
    i3.push(jE(t10, s3, s3 + o3 > a3 ? a3 : s3 + o3));
  return n3 === 1 ? (e3 = t10[r3 - 1], i3.push(
    Ln[e3 >> 2] + Ln[e3 << 4 & 63] + "=="
  )) : n3 === 2 && (e3 = (t10[r3 - 2] << 8) + t10[r3 - 1], i3.push(
    Ln[e3 >> 10] + Ln[e3 >> 4 & 63] + Ln[e3 << 2 & 63] + "="
  )), i3.join("");
}
var cg = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
cg.read = function(t10, e3, r3, n3, i3) {
  var o3, s3, a3 = i3 * 8 - n3 - 1, l3 = (1 << a3) - 1, u3 = l3 >> 1, c3 = -7, f3 = r3 ? i3 - 1 : 0, d3 = r3 ? -1 : 1, p10 = t10[e3 + f3];
  for (f3 += d3, o3 = p10 & (1 << -c3) - 1, p10 >>= -c3, c3 += a3; c3 > 0; o3 = o3 * 256 + t10[e3 + f3], f3 += d3, c3 -= 8)
    ;
  for (s3 = o3 & (1 << -c3) - 1, o3 >>= -c3, c3 += n3; c3 > 0; s3 = s3 * 256 + t10[e3 + f3], f3 += d3, c3 -= 8)
    ;
  if (o3 === 0)
    o3 = 1 - u3;
  else {
    if (o3 === l3)
      return s3 ? NaN : (p10 ? -1 : 1) * (1 / 0);
    s3 = s3 + Math.pow(2, n3), o3 = o3 - u3;
  }
  return (p10 ? -1 : 1) * s3 * Math.pow(2, o3 - n3);
};
cg.write = function(t10, e3, r3, n3, i3, o3) {
  var s3, a3, l3, u3 = o3 * 8 - i3 - 1, c3 = (1 << u3) - 1, f3 = c3 >> 1, d3 = i3 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p10 = n3 ? 0 : o3 - 1, h10 = n3 ? 1 : -1, m10 = e3 < 0 || e3 === 0 && 1 / e3 < 0 ? 1 : 0;
  for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (a3 = isNaN(e3) ? 1 : 0, s3 = c3) : (s3 = Math.floor(Math.log(e3) / Math.LN2), e3 * (l3 = Math.pow(2, -s3)) < 1 && (s3--, l3 *= 2), s3 + f3 >= 1 ? e3 += d3 / l3 : e3 += d3 * Math.pow(2, 1 - f3), e3 * l3 >= 2 && (s3++, l3 /= 2), s3 + f3 >= c3 ? (a3 = 0, s3 = c3) : s3 + f3 >= 1 ? (a3 = (e3 * l3 - 1) * Math.pow(2, i3), s3 = s3 + f3) : (a3 = e3 * Math.pow(2, f3 - 1) * Math.pow(2, i3), s3 = 0)); i3 >= 8; t10[r3 + p10] = a3 & 255, p10 += h10, a3 /= 256, i3 -= 8)
    ;
  for (s3 = s3 << i3 | a3, u3 += i3; u3 > 0; t10[r3 + p10] = s3 & 255, p10 += h10, s3 /= 256, u3 -= 8)
    ;
  t10[r3 + p10 - h10] |= m10 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t10) {
  const e3 = Vf, r3 = cg, n3 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t10.Buffer = a3, t10.SlowBuffer = v10, t10.INSPECT_MAX_BYTES = 50;
  const i3 = 2147483647;
  t10.kMaxLength = i3, a3.TYPED_ARRAY_SUPPORT = o3(), !a3.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function o3() {
    try {
      const x10 = new Uint8Array(1), y10 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(y10, Uint8Array.prototype), Object.setPrototypeOf(x10, y10), x10.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(a3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (a3.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (a3.isBuffer(this))
        return this.byteOffset;
    }
  });
  function s3(x10) {
    if (x10 > i3)
      throw new RangeError('The value "' + x10 + '" is invalid for option "size"');
    const y10 = new Uint8Array(x10);
    return Object.setPrototypeOf(y10, a3.prototype), y10;
  }
  function a3(x10, y10, b10) {
    if (typeof x10 == "number") {
      if (typeof y10 == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return f3(x10);
    }
    return l3(x10, y10, b10);
  }
  a3.poolSize = 8192;
  function l3(x10, y10, b10) {
    if (typeof x10 == "string")
      return d3(x10, y10);
    if (ArrayBuffer.isView(x10))
      return h10(x10);
    if (x10 == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x10
      );
    if (Tt(x10, ArrayBuffer) || x10 && Tt(x10.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Tt(x10, SharedArrayBuffer) || x10 && Tt(x10.buffer, SharedArrayBuffer)))
      return m10(x10, y10, b10);
    if (typeof x10 == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const j10 = x10.valueOf && x10.valueOf();
    if (j10 != null && j10 !== x10)
      return a3.from(j10, y10, b10);
    const L5 = O10(x10);
    if (L5)
      return L5;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof x10[Symbol.toPrimitive] == "function")
      return a3.from(x10[Symbol.toPrimitive]("string"), y10, b10);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x10
    );
  }
  a3.from = function(x10, y10, b10) {
    return l3(x10, y10, b10);
  }, Object.setPrototypeOf(a3.prototype, Uint8Array.prototype), Object.setPrototypeOf(a3, Uint8Array);
  function u3(x10) {
    if (typeof x10 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (x10 < 0)
      throw new RangeError('The value "' + x10 + '" is invalid for option "size"');
  }
  function c3(x10, y10, b10) {
    return u3(x10), x10 <= 0 ? s3(x10) : y10 !== void 0 ? typeof b10 == "string" ? s3(x10).fill(y10, b10) : s3(x10).fill(y10) : s3(x10);
  }
  a3.alloc = function(x10, y10, b10) {
    return c3(x10, y10, b10);
  };
  function f3(x10) {
    return u3(x10), s3(x10 < 0 ? 0 : g(x10) | 0);
  }
  a3.allocUnsafe = function(x10) {
    return f3(x10);
  }, a3.allocUnsafeSlow = function(x10) {
    return f3(x10);
  };
  function d3(x10, y10) {
    if ((typeof y10 != "string" || y10 === "") && (y10 = "utf8"), !a3.isEncoding(y10))
      throw new TypeError("Unknown encoding: " + y10);
    const b10 = S10(x10, y10) | 0;
    let j10 = s3(b10);
    const L5 = j10.write(x10, y10);
    return L5 !== b10 && (j10 = j10.slice(0, L5)), j10;
  }
  function p10(x10) {
    const y10 = x10.length < 0 ? 0 : g(x10.length) | 0, b10 = s3(y10);
    for (let j10 = 0; j10 < y10; j10 += 1)
      b10[j10] = x10[j10] & 255;
    return b10;
  }
  function h10(x10) {
    if (Tt(x10, Uint8Array)) {
      const y10 = new Uint8Array(x10);
      return m10(y10.buffer, y10.byteOffset, y10.byteLength);
    }
    return p10(x10);
  }
  function m10(x10, y10, b10) {
    if (y10 < 0 || x10.byteLength < y10)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (x10.byteLength < y10 + (b10 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let j10;
    return y10 === void 0 && b10 === void 0 ? j10 = new Uint8Array(x10) : b10 === void 0 ? j10 = new Uint8Array(x10, y10) : j10 = new Uint8Array(x10, y10, b10), Object.setPrototypeOf(j10, a3.prototype), j10;
  }
  function O10(x10) {
    if (a3.isBuffer(x10)) {
      const y10 = g(x10.length) | 0, b10 = s3(y10);
      return b10.length === 0 || x10.copy(b10, 0, 0, y10), b10;
    }
    if (x10.length !== void 0)
      return typeof x10.length != "number" || Xt2(x10.length) ? s3(0) : p10(x10);
    if (x10.type === "Buffer" && Array.isArray(x10.data))
      return p10(x10.data);
  }
  function g(x10) {
    if (x10 >= i3)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i3.toString(16) + " bytes");
    return x10 | 0;
  }
  function v10(x10) {
    return +x10 != x10 && (x10 = 0), a3.alloc(+x10);
  }
  a3.isBuffer = function(y10) {
    return y10 != null && y10._isBuffer === true && y10 !== a3.prototype;
  }, a3.compare = function(y10, b10) {
    if (Tt(y10, Uint8Array) && (y10 = a3.from(y10, y10.offset, y10.byteLength)), Tt(b10, Uint8Array) && (b10 = a3.from(b10, b10.offset, b10.byteLength)), !a3.isBuffer(y10) || !a3.isBuffer(b10))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (y10 === b10)
      return 0;
    let j10 = y10.length, L5 = b10.length;
    for (let K = 0, ae = Math.min(j10, L5); K < ae; ++K)
      if (y10[K] !== b10[K]) {
        j10 = y10[K], L5 = b10[K];
        break;
      }
    return j10 < L5 ? -1 : L5 < j10 ? 1 : 0;
  }, a3.isEncoding = function(y10) {
    switch (String(y10).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, a3.concat = function(y10, b10) {
    if (!Array.isArray(y10))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (y10.length === 0)
      return a3.alloc(0);
    let j10;
    if (b10 === void 0)
      for (b10 = 0, j10 = 0; j10 < y10.length; ++j10)
        b10 += y10[j10].length;
    const L5 = a3.allocUnsafe(b10);
    let K = 0;
    for (j10 = 0; j10 < y10.length; ++j10) {
      let ae = y10[j10];
      if (Tt(ae, Uint8Array))
        K + ae.length > L5.length ? (a3.isBuffer(ae) || (ae = a3.from(ae)), ae.copy(L5, K)) : Uint8Array.prototype.set.call(
          L5,
          ae,
          K
        );
      else if (a3.isBuffer(ae))
        ae.copy(L5, K);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      K += ae.length;
    }
    return L5;
  };
  function S10(x10, y10) {
    if (a3.isBuffer(x10))
      return x10.length;
    if (ArrayBuffer.isView(x10) || Tt(x10, ArrayBuffer))
      return x10.byteLength;
    if (typeof x10 != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof x10
      );
    const b10 = x10.length, j10 = arguments.length > 2 && arguments[2] === true;
    if (!j10 && b10 === 0)
      return 0;
    let L5 = false;
    for (; ; )
      switch (y10) {
        case "ascii":
        case "latin1":
        case "binary":
          return b10;
        case "utf8":
        case "utf-8":
          return Ge(x10).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return b10 * 2;
        case "hex":
          return b10 >>> 1;
        case "base64":
          return qr(x10).length;
        default:
          if (L5)
            return j10 ? -1 : Ge(x10).length;
          y10 = ("" + y10).toLowerCase(), L5 = true;
      }
  }
  a3.byteLength = S10;
  function $10(x10, y10, b10) {
    let j10 = false;
    if ((y10 === void 0 || y10 < 0) && (y10 = 0), y10 > this.length || ((b10 === void 0 || b10 > this.length) && (b10 = this.length), b10 <= 0) || (b10 >>>= 0, y10 >>>= 0, b10 <= y10))
      return "";
    for (x10 || (x10 = "utf8"); ; )
      switch (x10) {
        case "hex":
          return je2(this, y10, b10);
        case "utf8":
        case "utf-8":
          return pe(this, y10, b10);
        case "ascii":
          return _e(this, y10, b10);
        case "latin1":
        case "binary":
          return Ie(this, y10, b10);
        case "base64":
          return fe(this, y10, b10);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return G(this, y10, b10);
        default:
          if (j10)
            throw new TypeError("Unknown encoding: " + x10);
          x10 = (x10 + "").toLowerCase(), j10 = true;
      }
  }
  a3.prototype._isBuffer = true;
  function _10(x10, y10, b10) {
    const j10 = x10[y10];
    x10[y10] = x10[b10], x10[b10] = j10;
  }
  a3.prototype.swap16 = function() {
    const y10 = this.length;
    if (y10 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let b10 = 0; b10 < y10; b10 += 2)
      _10(this, b10, b10 + 1);
    return this;
  }, a3.prototype.swap32 = function() {
    const y10 = this.length;
    if (y10 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let b10 = 0; b10 < y10; b10 += 4)
      _10(this, b10, b10 + 3), _10(this, b10 + 1, b10 + 2);
    return this;
  }, a3.prototype.swap64 = function() {
    const y10 = this.length;
    if (y10 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let b10 = 0; b10 < y10; b10 += 8)
      _10(this, b10, b10 + 7), _10(this, b10 + 1, b10 + 6), _10(this, b10 + 2, b10 + 5), _10(this, b10 + 3, b10 + 4);
    return this;
  }, a3.prototype.toString = function() {
    const y10 = this.length;
    return y10 === 0 ? "" : arguments.length === 0 ? pe(this, 0, y10) : $10.apply(this, arguments);
  }, a3.prototype.toLocaleString = a3.prototype.toString, a3.prototype.equals = function(y10) {
    if (!a3.isBuffer(y10))
      throw new TypeError("Argument must be a Buffer");
    return this === y10 ? true : a3.compare(this, y10) === 0;
  }, a3.prototype.inspect = function() {
    let y10 = "";
    const b10 = t10.INSPECT_MAX_BYTES;
    return y10 = this.toString("hex", 0, b10).replace(/(.{2})/g, "$1 ").trim(), this.length > b10 && (y10 += " ... "), "<Buffer " + y10 + ">";
  }, n3 && (a3.prototype[n3] = a3.prototype.inspect), a3.prototype.compare = function(y10, b10, j10, L5, K) {
    if (Tt(y10, Uint8Array) && (y10 = a3.from(y10, y10.offset, y10.byteLength)), !a3.isBuffer(y10))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof y10
      );
    if (b10 === void 0 && (b10 = 0), j10 === void 0 && (j10 = y10 ? y10.length : 0), L5 === void 0 && (L5 = 0), K === void 0 && (K = this.length), b10 < 0 || j10 > y10.length || L5 < 0 || K > this.length)
      throw new RangeError("out of range index");
    if (L5 >= K && b10 >= j10)
      return 0;
    if (L5 >= K)
      return -1;
    if (b10 >= j10)
      return 1;
    if (b10 >>>= 0, j10 >>>= 0, L5 >>>= 0, K >>>= 0, this === y10)
      return 0;
    let ae = K - L5, ze2 = j10 - b10;
    const kt = Math.min(ae, ze2), mt = this.slice(L5, K), at = y10.slice(b10, j10);
    for (let dt2 = 0; dt2 < kt; ++dt2)
      if (mt[dt2] !== at[dt2]) {
        ae = mt[dt2], ze2 = at[dt2];
        break;
      }
    return ae < ze2 ? -1 : ze2 < ae ? 1 : 0;
  };
  function P10(x10, y10, b10, j10, L5) {
    if (x10.length === 0)
      return -1;
    if (typeof b10 == "string" ? (j10 = b10, b10 = 0) : b10 > 2147483647 ? b10 = 2147483647 : b10 < -2147483648 && (b10 = -2147483648), b10 = +b10, Xt2(b10) && (b10 = L5 ? 0 : x10.length - 1), b10 < 0 && (b10 = x10.length + b10), b10 >= x10.length) {
      if (L5)
        return -1;
      b10 = x10.length - 1;
    } else if (b10 < 0)
      if (L5)
        b10 = 0;
      else
        return -1;
    if (typeof y10 == "string" && (y10 = a3.from(y10, j10)), a3.isBuffer(y10))
      return y10.length === 0 ? -1 : q5(x10, y10, b10, j10, L5);
    if (typeof y10 == "number")
      return y10 = y10 & 255, typeof Uint8Array.prototype.indexOf == "function" ? L5 ? Uint8Array.prototype.indexOf.call(x10, y10, b10) : Uint8Array.prototype.lastIndexOf.call(x10, y10, b10) : q5(x10, [y10], b10, j10, L5);
    throw new TypeError("val must be string, number or Buffer");
  }
  function q5(x10, y10, b10, j10, L5) {
    let K = 1, ae = x10.length, ze2 = y10.length;
    if (j10 !== void 0 && (j10 = String(j10).toLowerCase(), j10 === "ucs2" || j10 === "ucs-2" || j10 === "utf16le" || j10 === "utf-16le")) {
      if (x10.length < 2 || y10.length < 2)
        return -1;
      K = 2, ae /= 2, ze2 /= 2, b10 /= 2;
    }
    function kt(at, dt2) {
      return K === 1 ? at[dt2] : at.readUInt16BE(dt2 * K);
    }
    let mt;
    if (L5) {
      let at = -1;
      for (mt = b10; mt < ae; mt++)
        if (kt(x10, mt) === kt(y10, at === -1 ? 0 : mt - at)) {
          if (at === -1 && (at = mt), mt - at + 1 === ze2)
            return at * K;
        } else
          at !== -1 && (mt -= mt - at), at = -1;
    } else
      for (b10 + ze2 > ae && (b10 = ae - ze2), mt = b10; mt >= 0; mt--) {
        let at = true;
        for (let dt2 = 0; dt2 < ze2; dt2++)
          if (kt(x10, mt + dt2) !== kt(y10, dt2)) {
            at = false;
            break;
          }
        if (at)
          return mt;
      }
    return -1;
  }
  a3.prototype.includes = function(y10, b10, j10) {
    return this.indexOf(y10, b10, j10) !== -1;
  }, a3.prototype.indexOf = function(y10, b10, j10) {
    return P10(this, y10, b10, j10, true);
  }, a3.prototype.lastIndexOf = function(y10, b10, j10) {
    return P10(this, y10, b10, j10, false);
  };
  function N5(x10, y10, b10, j10) {
    b10 = Number(b10) || 0;
    const L5 = x10.length - b10;
    j10 ? (j10 = Number(j10), j10 > L5 && (j10 = L5)) : j10 = L5;
    const K = y10.length;
    j10 > K / 2 && (j10 = K / 2);
    let ae;
    for (ae = 0; ae < j10; ++ae) {
      const ze2 = parseInt(y10.substr(ae * 2, 2), 16);
      if (Xt2(ze2))
        return ae;
      x10[b10 + ae] = ze2;
    }
    return ae;
  }
  function B5(x10, y10, b10, j10) {
    return Vr2(Ge(y10, x10.length - b10), x10, b10, j10);
  }
  function H10(x10, y10, b10, j10) {
    return Vr2(or(y10), x10, b10, j10);
  }
  function ne(x10, y10, b10, j10) {
    return Vr2(qr(y10), x10, b10, j10);
  }
  function re2(x10, y10, b10, j10) {
    return Vr2(le(y10, x10.length - b10), x10, b10, j10);
  }
  a3.prototype.write = function(y10, b10, j10, L5) {
    if (b10 === void 0)
      L5 = "utf8", j10 = this.length, b10 = 0;
    else if (j10 === void 0 && typeof b10 == "string")
      L5 = b10, j10 = this.length, b10 = 0;
    else if (isFinite(b10))
      b10 = b10 >>> 0, isFinite(j10) ? (j10 = j10 >>> 0, L5 === void 0 && (L5 = "utf8")) : (L5 = j10, j10 = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const K = this.length - b10;
    if ((j10 === void 0 || j10 > K) && (j10 = K), y10.length > 0 && (j10 < 0 || b10 < 0) || b10 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    L5 || (L5 = "utf8");
    let ae = false;
    for (; ; )
      switch (L5) {
        case "hex":
          return N5(this, y10, b10, j10);
        case "utf8":
        case "utf-8":
          return B5(this, y10, b10, j10);
        case "ascii":
        case "latin1":
        case "binary":
          return H10(this, y10, b10, j10);
        case "base64":
          return ne(this, y10, b10, j10);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return re2(this, y10, b10, j10);
        default:
          if (ae)
            throw new TypeError("Unknown encoding: " + L5);
          L5 = ("" + L5).toLowerCase(), ae = true;
      }
  }, a3.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function fe(x10, y10, b10) {
    return y10 === 0 && b10 === x10.length ? e3.fromByteArray(x10) : e3.fromByteArray(x10.slice(y10, b10));
  }
  function pe(x10, y10, b10) {
    b10 = Math.min(x10.length, b10);
    const j10 = [];
    let L5 = y10;
    for (; L5 < b10; ) {
      const K = x10[L5];
      let ae = null, ze2 = K > 239 ? 4 : K > 223 ? 3 : K > 191 ? 2 : 1;
      if (L5 + ze2 <= b10) {
        let kt, mt, at, dt2;
        switch (ze2) {
          case 1:
            K < 128 && (ae = K);
            break;
          case 2:
            kt = x10[L5 + 1], (kt & 192) === 128 && (dt2 = (K & 31) << 6 | kt & 63, dt2 > 127 && (ae = dt2));
            break;
          case 3:
            kt = x10[L5 + 1], mt = x10[L5 + 2], (kt & 192) === 128 && (mt & 192) === 128 && (dt2 = (K & 15) << 12 | (kt & 63) << 6 | mt & 63, dt2 > 2047 && (dt2 < 55296 || dt2 > 57343) && (ae = dt2));
            break;
          case 4:
            kt = x10[L5 + 1], mt = x10[L5 + 2], at = x10[L5 + 3], (kt & 192) === 128 && (mt & 192) === 128 && (at & 192) === 128 && (dt2 = (K & 15) << 18 | (kt & 63) << 12 | (mt & 63) << 6 | at & 63, dt2 > 65535 && dt2 < 1114112 && (ae = dt2));
        }
      }
      ae === null ? (ae = 65533, ze2 = 1) : ae > 65535 && (ae -= 65536, j10.push(ae >>> 10 & 1023 | 55296), ae = 56320 | ae & 1023), j10.push(ae), L5 += ze2;
    }
    return qe(j10);
  }
  const Ee2 = 4096;
  function qe(x10) {
    const y10 = x10.length;
    if (y10 <= Ee2)
      return String.fromCharCode.apply(String, x10);
    let b10 = "", j10 = 0;
    for (; j10 < y10; )
      b10 += String.fromCharCode.apply(
        String,
        x10.slice(j10, j10 += Ee2)
      );
    return b10;
  }
  function _e(x10, y10, b10) {
    let j10 = "";
    b10 = Math.min(x10.length, b10);
    for (let L5 = y10; L5 < b10; ++L5)
      j10 += String.fromCharCode(x10[L5] & 127);
    return j10;
  }
  function Ie(x10, y10, b10) {
    let j10 = "";
    b10 = Math.min(x10.length, b10);
    for (let L5 = y10; L5 < b10; ++L5)
      j10 += String.fromCharCode(x10[L5]);
    return j10;
  }
  function je2(x10, y10, b10) {
    const j10 = x10.length;
    (!y10 || y10 < 0) && (y10 = 0), (!b10 || b10 < 0 || b10 > j10) && (b10 = j10);
    let L5 = "";
    for (let K = y10; K < b10; ++K)
      L5 += on[x10[K]];
    return L5;
  }
  function G(x10, y10, b10) {
    const j10 = x10.slice(y10, b10);
    let L5 = "";
    for (let K = 0; K < j10.length - 1; K += 2)
      L5 += String.fromCharCode(j10[K] + j10[K + 1] * 256);
    return L5;
  }
  a3.prototype.slice = function(y10, b10) {
    const j10 = this.length;
    y10 = ~~y10, b10 = b10 === void 0 ? j10 : ~~b10, y10 < 0 ? (y10 += j10, y10 < 0 && (y10 = 0)) : y10 > j10 && (y10 = j10), b10 < 0 ? (b10 += j10, b10 < 0 && (b10 = 0)) : b10 > j10 && (b10 = j10), b10 < y10 && (b10 = y10);
    const L5 = this.subarray(y10, b10);
    return Object.setPrototypeOf(L5, a3.prototype), L5;
  };
  function Z(x10, y10, b10) {
    if (x10 % 1 !== 0 || x10 < 0)
      throw new RangeError("offset is not uint");
    if (x10 + y10 > b10)
      throw new RangeError("Trying to access beyond buffer length");
  }
  a3.prototype.readUintLE = a3.prototype.readUIntLE = function(y10, b10, j10) {
    y10 = y10 >>> 0, b10 = b10 >>> 0, j10 || Z(y10, b10, this.length);
    let L5 = this[y10], K = 1, ae = 0;
    for (; ++ae < b10 && (K *= 256); )
      L5 += this[y10 + ae] * K;
    return L5;
  }, a3.prototype.readUintBE = a3.prototype.readUIntBE = function(y10, b10, j10) {
    y10 = y10 >>> 0, b10 = b10 >>> 0, j10 || Z(y10, b10, this.length);
    let L5 = this[y10 + --b10], K = 1;
    for (; b10 > 0 && (K *= 256); )
      L5 += this[y10 + --b10] * K;
    return L5;
  }, a3.prototype.readUint8 = a3.prototype.readUInt8 = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 1, this.length), this[y10];
  }, a3.prototype.readUint16LE = a3.prototype.readUInt16LE = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 2, this.length), this[y10] | this[y10 + 1] << 8;
  }, a3.prototype.readUint16BE = a3.prototype.readUInt16BE = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 2, this.length), this[y10] << 8 | this[y10 + 1];
  }, a3.prototype.readUint32LE = a3.prototype.readUInt32LE = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 4, this.length), (this[y10] | this[y10 + 1] << 8 | this[y10 + 2] << 16) + this[y10 + 3] * 16777216;
  }, a3.prototype.readUint32BE = a3.prototype.readUInt32BE = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 4, this.length), this[y10] * 16777216 + (this[y10 + 1] << 16 | this[y10 + 2] << 8 | this[y10 + 3]);
  }, a3.prototype.readBigUInt64LE = Jt2(function(y10) {
    y10 = y10 >>> 0, se(y10, "offset");
    const b10 = this[y10], j10 = this[y10 + 7];
    (b10 === void 0 || j10 === void 0) && ye(y10, this.length - 8);
    const L5 = b10 + this[++y10] * 2 ** 8 + this[++y10] * 2 ** 16 + this[++y10] * 2 ** 24, K = this[++y10] + this[++y10] * 2 ** 8 + this[++y10] * 2 ** 16 + j10 * 2 ** 24;
    return BigInt(L5) + (BigInt(K) << BigInt(32));
  }), a3.prototype.readBigUInt64BE = Jt2(function(y10) {
    y10 = y10 >>> 0, se(y10, "offset");
    const b10 = this[y10], j10 = this[y10 + 7];
    (b10 === void 0 || j10 === void 0) && ye(y10, this.length - 8);
    const L5 = b10 * 2 ** 24 + this[++y10] * 2 ** 16 + this[++y10] * 2 ** 8 + this[++y10], K = this[++y10] * 2 ** 24 + this[++y10] * 2 ** 16 + this[++y10] * 2 ** 8 + j10;
    return (BigInt(L5) << BigInt(32)) + BigInt(K);
  }), a3.prototype.readIntLE = function(y10, b10, j10) {
    y10 = y10 >>> 0, b10 = b10 >>> 0, j10 || Z(y10, b10, this.length);
    let L5 = this[y10], K = 1, ae = 0;
    for (; ++ae < b10 && (K *= 256); )
      L5 += this[y10 + ae] * K;
    return K *= 128, L5 >= K && (L5 -= Math.pow(2, 8 * b10)), L5;
  }, a3.prototype.readIntBE = function(y10, b10, j10) {
    y10 = y10 >>> 0, b10 = b10 >>> 0, j10 || Z(y10, b10, this.length);
    let L5 = b10, K = 1, ae = this[y10 + --L5];
    for (; L5 > 0 && (K *= 256); )
      ae += this[y10 + --L5] * K;
    return K *= 128, ae >= K && (ae -= Math.pow(2, 8 * b10)), ae;
  }, a3.prototype.readInt8 = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 1, this.length), this[y10] & 128 ? (255 - this[y10] + 1) * -1 : this[y10];
  }, a3.prototype.readInt16LE = function(y10, b10) {
    y10 = y10 >>> 0, b10 || Z(y10, 2, this.length);
    const j10 = this[y10] | this[y10 + 1] << 8;
    return j10 & 32768 ? j10 | 4294901760 : j10;
  }, a3.prototype.readInt16BE = function(y10, b10) {
    y10 = y10 >>> 0, b10 || Z(y10, 2, this.length);
    const j10 = this[y10 + 1] | this[y10] << 8;
    return j10 & 32768 ? j10 | 4294901760 : j10;
  }, a3.prototype.readInt32LE = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 4, this.length), this[y10] | this[y10 + 1] << 8 | this[y10 + 2] << 16 | this[y10 + 3] << 24;
  }, a3.prototype.readInt32BE = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 4, this.length), this[y10] << 24 | this[y10 + 1] << 16 | this[y10 + 2] << 8 | this[y10 + 3];
  }, a3.prototype.readBigInt64LE = Jt2(function(y10) {
    y10 = y10 >>> 0, se(y10, "offset");
    const b10 = this[y10], j10 = this[y10 + 7];
    (b10 === void 0 || j10 === void 0) && ye(y10, this.length - 8);
    const L5 = this[y10 + 4] + this[y10 + 5] * 2 ** 8 + this[y10 + 6] * 2 ** 16 + (j10 << 24);
    return (BigInt(L5) << BigInt(32)) + BigInt(b10 + this[++y10] * 2 ** 8 + this[++y10] * 2 ** 16 + this[++y10] * 2 ** 24);
  }), a3.prototype.readBigInt64BE = Jt2(function(y10) {
    y10 = y10 >>> 0, se(y10, "offset");
    const b10 = this[y10], j10 = this[y10 + 7];
    (b10 === void 0 || j10 === void 0) && ye(y10, this.length - 8);
    const L5 = (b10 << 24) + // Overflow
    this[++y10] * 2 ** 16 + this[++y10] * 2 ** 8 + this[++y10];
    return (BigInt(L5) << BigInt(32)) + BigInt(this[++y10] * 2 ** 24 + this[++y10] * 2 ** 16 + this[++y10] * 2 ** 8 + j10);
  }), a3.prototype.readFloatLE = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 4, this.length), r3.read(this, y10, true, 23, 4);
  }, a3.prototype.readFloatBE = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 4, this.length), r3.read(this, y10, false, 23, 4);
  }, a3.prototype.readDoubleLE = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 8, this.length), r3.read(this, y10, true, 52, 8);
  }, a3.prototype.readDoubleBE = function(y10, b10) {
    return y10 = y10 >>> 0, b10 || Z(y10, 8, this.length), r3.read(this, y10, false, 52, 8);
  };
  function C10(x10, y10, b10, j10, L5, K) {
    if (!a3.isBuffer(x10))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (y10 > L5 || y10 < K)
      throw new RangeError('"value" argument is out of bounds');
    if (b10 + j10 > x10.length)
      throw new RangeError("Index out of range");
  }
  a3.prototype.writeUintLE = a3.prototype.writeUIntLE = function(y10, b10, j10, L5) {
    if (y10 = +y10, b10 = b10 >>> 0, j10 = j10 >>> 0, !L5) {
      const ze2 = Math.pow(2, 8 * j10) - 1;
      C10(this, y10, b10, j10, ze2, 0);
    }
    let K = 1, ae = 0;
    for (this[b10] = y10 & 255; ++ae < j10 && (K *= 256); )
      this[b10 + ae] = y10 / K & 255;
    return b10 + j10;
  }, a3.prototype.writeUintBE = a3.prototype.writeUIntBE = function(y10, b10, j10, L5) {
    if (y10 = +y10, b10 = b10 >>> 0, j10 = j10 >>> 0, !L5) {
      const ze2 = Math.pow(2, 8 * j10) - 1;
      C10(this, y10, b10, j10, ze2, 0);
    }
    let K = j10 - 1, ae = 1;
    for (this[b10 + K] = y10 & 255; --K >= 0 && (ae *= 256); )
      this[b10 + K] = y10 / ae & 255;
    return b10 + j10;
  }, a3.prototype.writeUint8 = a3.prototype.writeUInt8 = function(y10, b10, j10) {
    return y10 = +y10, b10 = b10 >>> 0, j10 || C10(this, y10, b10, 1, 255, 0), this[b10] = y10 & 255, b10 + 1;
  }, a3.prototype.writeUint16LE = a3.prototype.writeUInt16LE = function(y10, b10, j10) {
    return y10 = +y10, b10 = b10 >>> 0, j10 || C10(this, y10, b10, 2, 65535, 0), this[b10] = y10 & 255, this[b10 + 1] = y10 >>> 8, b10 + 2;
  }, a3.prototype.writeUint16BE = a3.prototype.writeUInt16BE = function(y10, b10, j10) {
    return y10 = +y10, b10 = b10 >>> 0, j10 || C10(this, y10, b10, 2, 65535, 0), this[b10] = y10 >>> 8, this[b10 + 1] = y10 & 255, b10 + 2;
  }, a3.prototype.writeUint32LE = a3.prototype.writeUInt32LE = function(y10, b10, j10) {
    return y10 = +y10, b10 = b10 >>> 0, j10 || C10(this, y10, b10, 4, 4294967295, 0), this[b10 + 3] = y10 >>> 24, this[b10 + 2] = y10 >>> 16, this[b10 + 1] = y10 >>> 8, this[b10] = y10 & 255, b10 + 4;
  }, a3.prototype.writeUint32BE = a3.prototype.writeUInt32BE = function(y10, b10, j10) {
    return y10 = +y10, b10 = b10 >>> 0, j10 || C10(this, y10, b10, 4, 4294967295, 0), this[b10] = y10 >>> 24, this[b10 + 1] = y10 >>> 16, this[b10 + 2] = y10 >>> 8, this[b10 + 3] = y10 & 255, b10 + 4;
  };
  function X10(x10, y10, b10, j10, L5) {
    D5(y10, j10, L5, x10, b10, 7);
    let K = Number(y10 & BigInt(4294967295));
    x10[b10++] = K, K = K >> 8, x10[b10++] = K, K = K >> 8, x10[b10++] = K, K = K >> 8, x10[b10++] = K;
    let ae = Number(y10 >> BigInt(32) & BigInt(4294967295));
    return x10[b10++] = ae, ae = ae >> 8, x10[b10++] = ae, ae = ae >> 8, x10[b10++] = ae, ae = ae >> 8, x10[b10++] = ae, b10;
  }
  function w10(x10, y10, b10, j10, L5) {
    D5(y10, j10, L5, x10, b10, 7);
    let K = Number(y10 & BigInt(4294967295));
    x10[b10 + 7] = K, K = K >> 8, x10[b10 + 6] = K, K = K >> 8, x10[b10 + 5] = K, K = K >> 8, x10[b10 + 4] = K;
    let ae = Number(y10 >> BigInt(32) & BigInt(4294967295));
    return x10[b10 + 3] = ae, ae = ae >> 8, x10[b10 + 2] = ae, ae = ae >> 8, x10[b10 + 1] = ae, ae = ae >> 8, x10[b10] = ae, b10 + 8;
  }
  a3.prototype.writeBigUInt64LE = Jt2(function(y10, b10 = 0) {
    return X10(this, y10, b10, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a3.prototype.writeBigUInt64BE = Jt2(function(y10, b10 = 0) {
    return w10(this, y10, b10, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a3.prototype.writeIntLE = function(y10, b10, j10, L5) {
    if (y10 = +y10, b10 = b10 >>> 0, !L5) {
      const kt = Math.pow(2, 8 * j10 - 1);
      C10(this, y10, b10, j10, kt - 1, -kt);
    }
    let K = 0, ae = 1, ze2 = 0;
    for (this[b10] = y10 & 255; ++K < j10 && (ae *= 256); )
      y10 < 0 && ze2 === 0 && this[b10 + K - 1] !== 0 && (ze2 = 1), this[b10 + K] = (y10 / ae >> 0) - ze2 & 255;
    return b10 + j10;
  }, a3.prototype.writeIntBE = function(y10, b10, j10, L5) {
    if (y10 = +y10, b10 = b10 >>> 0, !L5) {
      const kt = Math.pow(2, 8 * j10 - 1);
      C10(this, y10, b10, j10, kt - 1, -kt);
    }
    let K = j10 - 1, ae = 1, ze2 = 0;
    for (this[b10 + K] = y10 & 255; --K >= 0 && (ae *= 256); )
      y10 < 0 && ze2 === 0 && this[b10 + K + 1] !== 0 && (ze2 = 1), this[b10 + K] = (y10 / ae >> 0) - ze2 & 255;
    return b10 + j10;
  }, a3.prototype.writeInt8 = function(y10, b10, j10) {
    return y10 = +y10, b10 = b10 >>> 0, j10 || C10(this, y10, b10, 1, 127, -128), y10 < 0 && (y10 = 255 + y10 + 1), this[b10] = y10 & 255, b10 + 1;
  }, a3.prototype.writeInt16LE = function(y10, b10, j10) {
    return y10 = +y10, b10 = b10 >>> 0, j10 || C10(this, y10, b10, 2, 32767, -32768), this[b10] = y10 & 255, this[b10 + 1] = y10 >>> 8, b10 + 2;
  }, a3.prototype.writeInt16BE = function(y10, b10, j10) {
    return y10 = +y10, b10 = b10 >>> 0, j10 || C10(this, y10, b10, 2, 32767, -32768), this[b10] = y10 >>> 8, this[b10 + 1] = y10 & 255, b10 + 2;
  }, a3.prototype.writeInt32LE = function(y10, b10, j10) {
    return y10 = +y10, b10 = b10 >>> 0, j10 || C10(this, y10, b10, 4, 2147483647, -2147483648), this[b10] = y10 & 255, this[b10 + 1] = y10 >>> 8, this[b10 + 2] = y10 >>> 16, this[b10 + 3] = y10 >>> 24, b10 + 4;
  }, a3.prototype.writeInt32BE = function(y10, b10, j10) {
    return y10 = +y10, b10 = b10 >>> 0, j10 || C10(this, y10, b10, 4, 2147483647, -2147483648), y10 < 0 && (y10 = 4294967295 + y10 + 1), this[b10] = y10 >>> 24, this[b10 + 1] = y10 >>> 16, this[b10 + 2] = y10 >>> 8, this[b10 + 3] = y10 & 255, b10 + 4;
  }, a3.prototype.writeBigInt64LE = Jt2(function(y10, b10 = 0) {
    return X10(this, y10, b10, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), a3.prototype.writeBigInt64BE = Jt2(function(y10, b10 = 0) {
    return w10(this, y10, b10, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function U10(x10, y10, b10, j10, L5, K) {
    if (b10 + j10 > x10.length)
      throw new RangeError("Index out of range");
    if (b10 < 0)
      throw new RangeError("Index out of range");
  }
  function T10(x10, y10, b10, j10, L5) {
    return y10 = +y10, b10 = b10 >>> 0, L5 || U10(x10, y10, b10, 4), r3.write(x10, y10, b10, j10, 23, 4), b10 + 4;
  }
  a3.prototype.writeFloatLE = function(y10, b10, j10) {
    return T10(this, y10, b10, true, j10);
  }, a3.prototype.writeFloatBE = function(y10, b10, j10) {
    return T10(this, y10, b10, false, j10);
  };
  function F5(x10, y10, b10, j10, L5) {
    return y10 = +y10, b10 = b10 >>> 0, L5 || U10(x10, y10, b10, 8), r3.write(x10, y10, b10, j10, 52, 8), b10 + 8;
  }
  a3.prototype.writeDoubleLE = function(y10, b10, j10) {
    return F5(this, y10, b10, true, j10);
  }, a3.prototype.writeDoubleBE = function(y10, b10, j10) {
    return F5(this, y10, b10, false, j10);
  }, a3.prototype.copy = function(y10, b10, j10, L5) {
    if (!a3.isBuffer(y10))
      throw new TypeError("argument should be a Buffer");
    if (j10 || (j10 = 0), !L5 && L5 !== 0 && (L5 = this.length), b10 >= y10.length && (b10 = y10.length), b10 || (b10 = 0), L5 > 0 && L5 < j10 && (L5 = j10), L5 === j10 || y10.length === 0 || this.length === 0)
      return 0;
    if (b10 < 0)
      throw new RangeError("targetStart out of bounds");
    if (j10 < 0 || j10 >= this.length)
      throw new RangeError("Index out of range");
    if (L5 < 0)
      throw new RangeError("sourceEnd out of bounds");
    L5 > this.length && (L5 = this.length), y10.length - b10 < L5 - j10 && (L5 = y10.length - b10 + j10);
    const K = L5 - j10;
    return this === y10 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(b10, j10, L5) : Uint8Array.prototype.set.call(
      y10,
      this.subarray(j10, L5),
      b10
    ), K;
  }, a3.prototype.fill = function(y10, b10, j10, L5) {
    if (typeof y10 == "string") {
      if (typeof b10 == "string" ? (L5 = b10, b10 = 0, j10 = this.length) : typeof j10 == "string" && (L5 = j10, j10 = this.length), L5 !== void 0 && typeof L5 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof L5 == "string" && !a3.isEncoding(L5))
        throw new TypeError("Unknown encoding: " + L5);
      if (y10.length === 1) {
        const ae = y10.charCodeAt(0);
        (L5 === "utf8" && ae < 128 || L5 === "latin1") && (y10 = ae);
      }
    } else
      typeof y10 == "number" ? y10 = y10 & 255 : typeof y10 == "boolean" && (y10 = Number(y10));
    if (b10 < 0 || this.length < b10 || this.length < j10)
      throw new RangeError("Out of range index");
    if (j10 <= b10)
      return this;
    b10 = b10 >>> 0, j10 = j10 === void 0 ? this.length : j10 >>> 0, y10 || (y10 = 0);
    let K;
    if (typeof y10 == "number")
      for (K = b10; K < j10; ++K)
        this[K] = y10;
    else {
      const ae = a3.isBuffer(y10) ? y10 : a3.from(y10, L5), ze2 = ae.length;
      if (ze2 === 0)
        throw new TypeError('The value "' + y10 + '" is invalid for argument "value"');
      for (K = 0; K < j10 - b10; ++K)
        this[K + b10] = ae[K % ze2];
    }
    return this;
  };
  const V3 = {};
  function ie2(x10, y10, b10) {
    V3[x10] = class extends b10 {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: y10.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${x10}]`, this.stack, delete this.name;
      }
      get code() {
        return x10;
      }
      set code(L5) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: L5,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${x10}]: ${this.message}`;
      }
    };
  }
  ie2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(x10) {
      return x10 ? `${x10} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ie2(
    "ERR_INVALID_ARG_TYPE",
    function(x10, y10) {
      return `The "${x10}" argument must be of type number. Received type ${typeof y10}`;
    },
    TypeError
  ), ie2(
    "ERR_OUT_OF_RANGE",
    function(x10, y10, b10) {
      let j10 = `The value of "${x10}" is out of range.`, L5 = b10;
      return Number.isInteger(b10) && Math.abs(b10) > 2 ** 32 ? L5 = ce2(String(b10)) : typeof b10 == "bigint" && (L5 = String(b10), (b10 > BigInt(2) ** BigInt(32) || b10 < -(BigInt(2) ** BigInt(32))) && (L5 = ce2(L5)), L5 += "n"), j10 += ` It must be ${y10}. Received ${L5}`, j10;
    },
    RangeError
  );
  function ce2(x10) {
    let y10 = "", b10 = x10.length;
    const j10 = x10[0] === "-" ? 1 : 0;
    for (; b10 >= j10 + 4; b10 -= 3)
      y10 = `_${x10.slice(b10 - 3, b10)}${y10}`;
    return `${x10.slice(0, b10)}${y10}`;
  }
  function E(x10, y10, b10) {
    se(y10, "offset"), (x10[y10] === void 0 || x10[y10 + b10] === void 0) && ye(y10, x10.length - (b10 + 1));
  }
  function D5(x10, y10, b10, j10, L5, K) {
    if (x10 > b10 || x10 < y10) {
      const ae = typeof y10 == "bigint" ? "n" : "";
      let ze2;
      throw K > 3 ? y10 === 0 || y10 === BigInt(0) ? ze2 = `>= 0${ae} and < 2${ae} ** ${(K + 1) * 8}${ae}` : ze2 = `>= -(2${ae} ** ${(K + 1) * 8 - 1}${ae}) and < 2 ** ${(K + 1) * 8 - 1}${ae}` : ze2 = `>= ${y10}${ae} and <= ${b10}${ae}`, new V3.ERR_OUT_OF_RANGE("value", ze2, x10);
    }
    E(j10, L5, K);
  }
  function se(x10, y10) {
    if (typeof x10 != "number")
      throw new V3.ERR_INVALID_ARG_TYPE(y10, "number", x10);
  }
  function ye(x10, y10, b10) {
    throw Math.floor(x10) !== x10 ? (se(x10, b10), new V3.ERR_OUT_OF_RANGE(b10 || "offset", "an integer", x10)) : y10 < 0 ? new V3.ERR_BUFFER_OUT_OF_BOUNDS() : new V3.ERR_OUT_OF_RANGE(
      b10 || "offset",
      `>= ${b10 ? 1 : 0} and <= ${y10}`,
      x10
    );
  }
  const Ye = /[^+/0-9A-Za-z-_]/g;
  function xe2(x10) {
    if (x10 = x10.split("=")[0], x10 = x10.trim().replace(Ye, ""), x10.length < 2)
      return "";
    for (; x10.length % 4 !== 0; )
      x10 = x10 + "=";
    return x10;
  }
  function Ge(x10, y10) {
    y10 = y10 || 1 / 0;
    let b10;
    const j10 = x10.length;
    let L5 = null;
    const K = [];
    for (let ae = 0; ae < j10; ++ae) {
      if (b10 = x10.charCodeAt(ae), b10 > 55295 && b10 < 57344) {
        if (!L5) {
          if (b10 > 56319) {
            (y10 -= 3) > -1 && K.push(239, 191, 189);
            continue;
          } else if (ae + 1 === j10) {
            (y10 -= 3) > -1 && K.push(239, 191, 189);
            continue;
          }
          L5 = b10;
          continue;
        }
        if (b10 < 56320) {
          (y10 -= 3) > -1 && K.push(239, 191, 189), L5 = b10;
          continue;
        }
        b10 = (L5 - 55296 << 10 | b10 - 56320) + 65536;
      } else
        L5 && (y10 -= 3) > -1 && K.push(239, 191, 189);
      if (L5 = null, b10 < 128) {
        if ((y10 -= 1) < 0)
          break;
        K.push(b10);
      } else if (b10 < 2048) {
        if ((y10 -= 2) < 0)
          break;
        K.push(
          b10 >> 6 | 192,
          b10 & 63 | 128
        );
      } else if (b10 < 65536) {
        if ((y10 -= 3) < 0)
          break;
        K.push(
          b10 >> 12 | 224,
          b10 >> 6 & 63 | 128,
          b10 & 63 | 128
        );
      } else if (b10 < 1114112) {
        if ((y10 -= 4) < 0)
          break;
        K.push(
          b10 >> 18 | 240,
          b10 >> 12 & 63 | 128,
          b10 >> 6 & 63 | 128,
          b10 & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return K;
  }
  function or(x10) {
    const y10 = [];
    for (let b10 = 0; b10 < x10.length; ++b10)
      y10.push(x10.charCodeAt(b10) & 255);
    return y10;
  }
  function le(x10, y10) {
    let b10, j10, L5;
    const K = [];
    for (let ae = 0; ae < x10.length && !((y10 -= 2) < 0); ++ae)
      b10 = x10.charCodeAt(ae), j10 = b10 >> 8, L5 = b10 % 256, K.push(L5), K.push(j10);
    return K;
  }
  function qr(x10) {
    return e3.toByteArray(xe2(x10));
  }
  function Vr2(x10, y10, b10, j10) {
    let L5;
    for (L5 = 0; L5 < j10 && !(L5 + b10 >= y10.length || L5 >= x10.length); ++L5)
      y10[L5 + b10] = x10[L5];
    return L5;
  }
  function Tt(x10, y10) {
    return x10 instanceof y10 || x10 != null && x10.constructor != null && x10.constructor.name != null && x10.constructor.name === y10.name;
  }
  function Xt2(x10) {
    return x10 !== x10;
  }
  const on = function() {
    const x10 = "0123456789abcdef", y10 = new Array(256);
    for (let b10 = 0; b10 < 16; ++b10) {
      const j10 = b10 * 16;
      for (let L5 = 0; L5 < 16; ++L5)
        y10[j10 + L5] = x10[b10] + x10[L5];
    }
    return y10;
  }();
  function Jt2(x10) {
    return typeof BigInt > "u" ? xr2 : x10;
  }
  function xr2() {
    throw new Error("BigInt not supported");
  }
})(Pa);
var t2 = { exports: {} }, Nt = t2.exports = {}, Mn, Nn;
function Dp() {
  throw new Error("setTimeout has not been defined");
}
function jp() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Mn = setTimeout : Mn = Dp;
  } catch {
    Mn = Dp;
  }
  try {
    typeof clearTimeout == "function" ? Nn = clearTimeout : Nn = jp;
  } catch {
    Nn = jp;
  }
})();
function r2(t10) {
  if (Mn === setTimeout)
    return setTimeout(t10, 0);
  if ((Mn === Dp || !Mn) && setTimeout)
    return Mn = setTimeout, setTimeout(t10, 0);
  try {
    return Mn(t10, 0);
  } catch {
    try {
      return Mn.call(null, t10, 0);
    } catch {
      return Mn.call(this, t10, 0);
    }
  }
}
function IE(t10) {
  if (Nn === clearTimeout)
    return clearTimeout(t10);
  if ((Nn === jp || !Nn) && clearTimeout)
    return Nn = clearTimeout, clearTimeout(t10);
  try {
    return Nn(t10);
  } catch {
    try {
      return Nn.call(null, t10);
    } catch {
      return Nn.call(this, t10);
    }
  }
}
var Si = [], Ys = false, Fo, hc = -1;
function FE() {
  !Ys || !Fo || (Ys = false, Fo.length ? Si = Fo.concat(Si) : hc = -1, Si.length && n2());
}
function n2() {
  if (!Ys) {
    var t10 = r2(FE);
    Ys = true;
    for (var e3 = Si.length; e3; ) {
      for (Fo = Si, Si = []; ++hc < e3; )
        Fo && Fo[hc].run();
      hc = -1, e3 = Si.length;
    }
    Fo = null, Ys = false, IE(t10);
  }
}
Nt.nextTick = function(t10) {
  var e3 = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r3 = 1; r3 < arguments.length; r3++)
      e3[r3 - 1] = arguments[r3];
  Si.push(new i2(t10, e3)), Si.length === 1 && !Ys && r2(n2);
};
function i2(t10, e3) {
  this.fun = t10, this.array = e3;
}
i2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Nt.title = "browser";
Nt.browser = true;
Nt.env = {};
Nt.argv = [];
Nt.version = "";
Nt.versions = {};
function Mi() {
}
Nt.on = Mi;
Nt.addListener = Mi;
Nt.once = Mi;
Nt.off = Mi;
Nt.removeListener = Mi;
Nt.removeAllListeners = Mi;
Nt.emit = Mi;
Nt.prependListener = Mi;
Nt.prependOnceListener = Mi;
Nt.listeners = function(t10) {
  return [];
};
Nt.binding = function(t10) {
  throw new Error("process.binding is not supported");
};
Nt.cwd = function() {
  return "/";
};
Nt.chdir = function(t10) {
  throw new Error("process.chdir is not supported");
};
Nt.umask = function() {
  return 0;
};
var ZE = t2.exports;
(function(t10) {
  Object.defineProperty(t10, Symbol.toStringTag, { value: "Module" });
  const e3 = Pa, r3 = ZE, n3 = (s3) => s3 && s3.__esModule ? s3 : { default: s3 }, i3 = n3(r3), o3 = globalThis || void 0 || self;
  Object.defineProperty(t10, "Buffer", { enumerable: true, get: () => e3.Buffer }), Object.defineProperty(t10, "process", { enumerable: true, get: () => i3.default }), t10.global = o3;
})($e);
function fg(t10) {
  return getCurrentScope() ? (onScopeDispose(t10), true) : false;
}
function Tl(t10) {
  return typeof t10 == "function" ? t10() : unref(t10);
}
const ME = typeof window < "u" && typeof document < "u", NE = (t10) => t10 != null, Ls = () => {
};
function LE(t10, e3, r3) {
  let n3;
  isRef(r3) ? n3 = {
    evaluating: r3
  } : n3 = r3 || {};
  const {
    lazy: i3 = false,
    evaluating: o3 = void 0,
    shallow: s3 = true,
    onError: a3 = Ls
  } = n3, l3 = ref(!i3), u3 = s3 ? shallowRef(e3) : ref(e3);
  let c3 = 0;
  return watchEffect(async (f3) => {
    if (!l3.value)
      return;
    c3++;
    const d3 = c3;
    let p10 = false;
    o3 && Promise.resolve().then(() => {
      o3.value = true;
    });
    try {
      const h10 = await t10((m10) => {
        f3(() => {
          o3 && (o3.value = false), p10 || m10();
        });
      });
      d3 === c3 && (u3.value = h10);
    } catch (h10) {
      a3(h10);
    } finally {
      o3 && d3 === c3 && (o3.value = false), p10 = true;
    }
  }), i3 ? computed(() => (l3.value = true, u3.value)) : u3;
}
function pl(t10) {
  var e3;
  const r3 = Tl(t10);
  return (e3 = r3 == null ? void 0 : r3.$el) != null ? e3 : r3;
}
const dg = ME ? window : void 0;
function BE() {
  const t10 = ref(false);
  return getCurrentInstance() && onMounted(() => {
    t10.value = true;
  }), t10;
}
function hg(t10) {
  const e3 = BE();
  return computed(() => (e3.value, !!t10()));
}
function au(t10, e3 = {}) {
  const { window: r3 = dg } = e3, n3 = hg(() => r3 && "matchMedia" in r3 && typeof r3.matchMedia == "function");
  let i3;
  const o3 = ref(false), s3 = (u3) => {
    o3.value = u3.matches;
  }, a3 = () => {
    i3 && ("removeEventListener" in i3 ? i3.removeEventListener("change", s3) : i3.removeListener(s3));
  }, l3 = watchEffect(() => {
    n3.value && (a3(), i3 = r3.matchMedia(Tl(t10)), "addEventListener" in i3 ? i3.addEventListener("change", s3) : i3.addListener(s3), o3.value = i3.matches);
  });
  return fg(() => {
    l3(), a3(), i3 = void 0;
  }), o3;
}
function pg(t10, e3, r3 = {}) {
  const { window: n3 = dg, ...i3 } = r3;
  let o3;
  const s3 = hg(() => n3 && "ResizeObserver" in n3), a3 = () => {
    o3 && (o3.disconnect(), o3 = void 0);
  }, l3 = computed(
    () => Array.isArray(t10) ? t10.map((f3) => pl(f3)) : [pl(t10)]
  ), u3 = watch(
    l3,
    (f3) => {
      if (a3(), s3.value && n3) {
        o3 = new ResizeObserver(e3);
        for (const d3 of f3)
          d3 && o3.observe(d3, i3);
      }
    },
    { immediate: true, flush: "post", deep: true }
  ), c3 = () => {
    a3(), u3();
  };
  return fg(c3), {
    isSupported: s3,
    stop: c3
  };
}
function zE(t10, e3, r3 = {}) {
  const {
    root: n3,
    rootMargin: i3 = "0px",
    threshold: o3 = 0.1,
    window: s3 = dg,
    immediate: a3 = true
  } = r3, l3 = hg(() => s3 && "IntersectionObserver" in s3), u3 = computed(() => {
    const h10 = Tl(t10);
    return (Array.isArray(h10) ? h10 : [h10]).map(pl).filter(NE);
  });
  let c3 = Ls;
  const f3 = ref(a3), d3 = l3.value ? watch(
    () => [u3.value, pl(n3), f3.value],
    ([h10, m10]) => {
      if (c3(), !f3.value || !h10.length)
        return;
      const O10 = new IntersectionObserver(
        e3,
        {
          root: pl(m10),
          rootMargin: i3,
          threshold: o3
        }
      );
      h10.forEach((g) => g && O10.observe(g)), c3 = () => {
        O10.disconnect(), c3 = Ls;
      };
    },
    { immediate: a3, flush: "post" }
  ) : Ls, p10 = () => {
    c3(), d3(), f3.value = false;
  };
  return fg(p10), {
    isSupported: l3,
    isActive: f3,
    pause() {
      c3(), f3.value = false;
    },
    resume() {
      f3.value = true;
    },
    stop: p10
  };
}
function HE() {
  return {
    showApiClient: false,
    activeApiClientEndpointId: "",
    activeItem: {},
    snippetType: "javascript",
    activeBreadcrumb: "",
    sidebarIdVisibility: {}
  };
}
const Kn = reactive(HE());
function GE(t10, e3 = false) {
  e3 ? Kn.showApiClient = true : Kn.showApiClient = !Kn.showApiClient, t10 && (Kn.activeItem = t10);
}
function KE() {
  Kn.showApiClient = false;
}
function JE(t10) {
  Kn.activeApiClientEndpointId = t10;
}
function e4(t10) {
  Kn.snippetType = t10;
}
function t4(t10) {
  Kn.activeBreadcrumb = t10;
}
function r4(t10, e3) {
  Kn.sidebarIdVisibility[t10] = e3;
}
const hs = () => ({
  state: readonly(Kn),
  toggleApiClient: GE,
  setActiveApiClientEndpointId: JE,
  setSnippetType: e4,
  setBreadcrumb: t4,
  setSidebarIdVisibility: r4,
  hideApiClient: KE
}), n4 = () => ({
  name: "",
  url: "",
  type: "GET",
  path: "",
  parameters: [],
  headers: [],
  query: [],
  body: "",
  formData: []
}), i4 = () => ({
  type: "none",
  basic: {
    username: "",
    password: "",
    active: true
  },
  oauthTwo: {
    generatedToken: "",
    discoveryURL: "",
    authURL: "",
    accessTokenURL: "",
    clientID: "",
    clientSecret: "",
    scope: "",
    active: true
  },
  bearer: {
    token: "",
    active: true
  },
  digest: {
    username: "",
    password: "",
    active: true
  }
}), o4 = reactive(i4()), Yf = reactive({}), o2 = ref([]), kl = ref(""), Og = reactive(n4()), s4 = (t10) => {
  Yf[t10.responseId] = t10, kl.value = t10.responseId, o2.value.unshift(t10.responseId);
}, a4 = (t10) => {
  kl.value = t10;
  const { request: e3 } = Yf[t10], r3 = JSON.parse(JSON.stringify(e3));
  r3.body = JSON.stringify(e3.body, null, 2), Object.assign(Og, r3);
}, l4 = computed(
  () => kl.value ? Yf[kl.value].response : null
), u4 = (t10) => {
  Object.assign(Og, t10);
}, c4 = ref(true), Nr = () => ({
  authState: o4,
  readOnly: c4,
  activeRequest: Og,
  activeResponse: l4,
  requestHistory: Yf,
  requestHistoryOrder: o2,
  activeRequestId: kl,
  setActiveResponse: a4,
  addRequestToHistory: s4,
  setActiveRequest: u4
}), s2 = 1024;
let f4 = 0, un = class {
  constructor(e3, r3) {
    this.from = e3, this.to = r3;
  }
};
class ut {
  /**
  Create a new node prop type.
  */
  constructor(e3 = {}) {
    this.id = f4++, this.perNode = !!e3.perNode, this.deserialize = e3.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e3) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e3 != "function" && (e3 = $r.match(e3)), (r3) => {
      let n3 = e3(r3);
      return n3 === void 0 ? null : [this, n3];
    };
  }
}
ut.closedBy = new ut({ deserialize: (t10) => t10.split(" ") });
ut.openedBy = new ut({ deserialize: (t10) => t10.split(" ") });
ut.group = new ut({ deserialize: (t10) => t10.split(" ") });
ut.contextHash = new ut({ perNode: true });
ut.lookAhead = new ut({ perNode: true });
ut.mounted = new ut({ perNode: true });
class El {
  constructor(e3, r3, n3) {
    this.tree = e3, this.overlay = r3, this.parser = n3;
  }
  /**
  @internal
  */
  static get(e3) {
    return e3 && e3.props && e3.props[ut.mounted.id];
  }
}
const d4 = /* @__PURE__ */ Object.create(null);
class $r {
  /**
  @internal
  */
  constructor(e3, r3, n3, i3 = 0) {
    this.name = e3, this.props = r3, this.id = n3, this.flags = i3;
  }
  /**
  Define a node type.
  */
  static define(e3) {
    let r3 = e3.props && e3.props.length ? /* @__PURE__ */ Object.create(null) : d4, n3 = (e3.top ? 1 : 0) | (e3.skipped ? 2 : 0) | (e3.error ? 4 : 0) | (e3.name == null ? 8 : 0), i3 = new $r(e3.name || "", r3, e3.id, n3);
    if (e3.props) {
      for (let o3 of e3.props)
        if (Array.isArray(o3) || (o3 = o3(i3)), o3) {
          if (o3[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          r3[o3[0].id] = o3[1];
        }
    }
    return i3;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e3) {
    return this.props[e3.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e3) {
    if (typeof e3 == "string") {
      if (this.name == e3)
        return true;
      let r3 = this.prop(ut.group);
      return r3 ? r3.indexOf(e3) > -1 : false;
    }
    return this.id == e3;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e3) {
    let r3 = /* @__PURE__ */ Object.create(null);
    for (let n3 in e3)
      for (let i3 of n3.split(" "))
        r3[i3] = e3[n3];
    return (n3) => {
      for (let i3 = n3.prop(ut.group), o3 = -1; o3 < (i3 ? i3.length : 0); o3++) {
        let s3 = r3[o3 < 0 ? n3.name : i3[o3]];
        if (s3)
          return s3;
      }
    };
  }
}
$r.none = new $r(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class Lf {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e3) {
    this.types = e3;
    for (let r3 = 0; r3 < e3.length; r3++)
      if (e3[r3].id != r3)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e3) {
    let r3 = [];
    for (let n3 of this.types) {
      let i3 = null;
      for (let o3 of e3) {
        let s3 = o3(n3);
        s3 && (i3 || (i3 = Object.assign({}, n3.props)), i3[s3[0].id] = s3[1]);
      }
      r3.push(i3 ? new $r(n3.name, i3, n3.id, n3.flags) : n3);
    }
    return new Lf(r3);
  }
}
const Uu = /* @__PURE__ */ new WeakMap(), B1 = /* @__PURE__ */ new WeakMap();
var vt;
(function(t10) {
  t10[t10.ExcludeBuffers = 1] = "ExcludeBuffers", t10[t10.IncludeAnonymous = 2] = "IncludeAnonymous", t10[t10.IgnoreMounts = 4] = "IgnoreMounts", t10[t10.IgnoreOverlays = 8] = "IgnoreOverlays";
})(vt || (vt = {}));
class ft {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e3, r3, n3, i3, o3) {
    if (this.type = e3, this.children = r3, this.positions = n3, this.length = i3, this.props = null, o3 && o3.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [s3, a3] of o3)
        this.props[typeof s3 == "number" ? s3 : s3.id] = a3;
    }
  }
  /**
  @internal
  */
  toString() {
    let e3 = El.get(this);
    if (e3 && !e3.overlay)
      return e3.tree.toString();
    let r3 = "";
    for (let n3 of this.children) {
      let i3 = n3.toString();
      i3 && (r3 && (r3 += ","), r3 += i3);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (r3.length ? "(" + r3 + ")" : "") : r3;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e3 = 0) {
    return new Wc(this.topNode, e3);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e3, r3 = 0, n3 = 0) {
    let i3 = Uu.get(this) || this.topNode, o3 = new Wc(i3);
    return o3.moveTo(e3, r3), Uu.set(this, o3._tree), o3;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Rr(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e3, r3 = 0) {
    let n3 = Cl(Uu.get(this) || this.topNode, e3, r3, false);
    return Uu.set(this, n3), n3;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e3, r3 = 0) {
    let n3 = Cl(B1.get(this) || this.topNode, e3, r3, true);
    return B1.set(this, n3), n3;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e3, r3 = 0) {
    return O4(this, e3, r3);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e3) {
    let { enter: r3, leave: n3, from: i3 = 0, to: o3 = this.length } = e3, s3 = e3.mode || 0, a3 = (s3 & vt.IncludeAnonymous) > 0;
    for (let l3 = this.cursor(s3 | vt.IncludeAnonymous); ; ) {
      let u3 = false;
      if (l3.from <= o3 && l3.to >= i3 && (!a3 && l3.type.isAnonymous || r3(l3) !== false)) {
        if (l3.firstChild())
          continue;
        u3 = true;
      }
      for (; u3 && n3 && (a3 || !l3.type.isAnonymous) && n3(l3), !l3.nextSibling(); ) {
        if (!l3.parent())
          return;
        u3 = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e3) {
    return e3.perNode ? this.props ? this.props[e3.id] : void 0 : this.type.prop(e3);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e3 = [];
    if (this.props)
      for (let r3 in this.props)
        e3.push([+r3, this.props[r3]]);
    return e3;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e3 = {}) {
    return this.children.length <= 8 ? this : yg($r.none, this.children, this.positions, 0, this.children.length, 0, this.length, (r3, n3, i3) => new ft(this.type, r3, n3, i3, this.propValues), e3.makeTree || ((r3, n3, i3) => new ft($r.none, r3, n3, i3)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e3) {
    return m4(e3);
  }
}
ft.empty = new ft($r.none, [], [], 0);
class mg {
  constructor(e3, r3) {
    this.buffer = e3, this.index = r3;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new mg(this.buffer, this.index);
  }
}
class ps {
  /**
  Create a tree buffer.
  */
  constructor(e3, r3, n3) {
    this.buffer = e3, this.length = r3, this.set = n3;
  }
  /**
  @internal
  */
  get type() {
    return $r.none;
  }
  /**
  @internal
  */
  toString() {
    let e3 = [];
    for (let r3 = 0; r3 < this.buffer.length; )
      e3.push(this.childString(r3)), r3 = this.buffer[r3 + 3];
    return e3.join(",");
  }
  /**
  @internal
  */
  childString(e3) {
    let r3 = this.buffer[e3], n3 = this.buffer[e3 + 3], i3 = this.set.types[r3], o3 = i3.name;
    if (/\W/.test(o3) && !i3.isError && (o3 = JSON.stringify(o3)), e3 += 4, n3 == e3)
      return o3;
    let s3 = [];
    for (; e3 < n3; )
      s3.push(this.childString(e3)), e3 = this.buffer[e3 + 3];
    return o3 + "(" + s3.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e3, r3, n3, i3, o3) {
    let { buffer: s3 } = this, a3 = -1;
    for (let l3 = e3; l3 != r3 && !(a2(o3, i3, s3[l3 + 1], s3[l3 + 2]) && (a3 = l3, n3 > 0)); l3 = s3[l3 + 3])
      ;
    return a3;
  }
  /**
  @internal
  */
  slice(e3, r3, n3) {
    let i3 = this.buffer, o3 = new Uint16Array(r3 - e3), s3 = 0;
    for (let a3 = e3, l3 = 0; a3 < r3; ) {
      o3[l3++] = i3[a3++], o3[l3++] = i3[a3++] - n3;
      let u3 = o3[l3++] = i3[a3++] - n3;
      o3[l3++] = i3[a3++] - e3, s3 = Math.max(s3, u3);
    }
    return new ps(o3, s3, this.set);
  }
}
function a2(t10, e3, r3, n3) {
  switch (t10) {
    case -2:
      return r3 < e3;
    case -1:
      return n3 >= e3 && r3 < e3;
    case 0:
      return r3 < e3 && n3 > e3;
    case 1:
      return r3 <= e3 && n3 > e3;
    case 2:
      return n3 > e3;
    case 4:
      return true;
  }
}
function Cl(t10, e3, r3, n3) {
  for (var i3; t10.from == t10.to || (r3 < 1 ? t10.from >= e3 : t10.from > e3) || (r3 > -1 ? t10.to <= e3 : t10.to < e3); ) {
    let s3 = !n3 && t10 instanceof Rr && t10.index < 0 ? null : t10.parent;
    if (!s3)
      return t10;
    t10 = s3;
  }
  let o3 = n3 ? 0 : vt.IgnoreOverlays;
  if (n3)
    for (let s3 = t10, a3 = s3.parent; a3; s3 = a3, a3 = s3.parent)
      s3 instanceof Rr && s3.index < 0 && ((i3 = a3.enter(e3, r3, o3)) === null || i3 === void 0 ? void 0 : i3.from) != s3.from && (t10 = a3);
  for (; ; ) {
    let s3 = t10.enter(e3, r3, o3);
    if (!s3)
      return t10;
    t10 = s3;
  }
}
class l2 {
  cursor(e3 = 0) {
    return new Wc(this, e3);
  }
  getChild(e3, r3 = null, n3 = null) {
    let i3 = z1(this, e3, r3, n3);
    return i3.length ? i3[0] : null;
  }
  getChildren(e3, r3 = null, n3 = null) {
    return z1(this, e3, r3, n3);
  }
  resolve(e3, r3 = 0) {
    return Cl(this, e3, r3, false);
  }
  resolveInner(e3, r3 = 0) {
    return Cl(this, e3, r3, true);
  }
  matchContext(e3) {
    return Up(this, e3);
  }
  enterUnfinishedNodesBefore(e3) {
    let r3 = this.childBefore(e3), n3 = this;
    for (; r3; ) {
      let i3 = r3.lastChild;
      if (!i3 || i3.to != r3.to)
        break;
      i3.type.isError && i3.from == i3.to ? (n3 = r3, r3 = i3.prevSibling) : r3 = i3;
    }
    return n3;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Rr extends l2 {
  constructor(e3, r3, n3, i3) {
    super(), this._tree = e3, this.from = r3, this.index = n3, this._parent = i3;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e3, r3, n3, i3, o3 = 0) {
    for (let s3 = this; ; ) {
      for (let { children: a3, positions: l3 } = s3._tree, u3 = r3 > 0 ? a3.length : -1; e3 != u3; e3 += r3) {
        let c3 = a3[e3], f3 = l3[e3] + s3.from;
        if (a2(i3, n3, f3, f3 + c3.length)) {
          if (c3 instanceof ps) {
            if (o3 & vt.ExcludeBuffers)
              continue;
            let d3 = c3.findChild(0, c3.buffer.length, r3, n3 - f3, i3);
            if (d3 > -1)
              return new Jn(new h4(s3, c3, e3, f3), null, d3);
          } else if (o3 & vt.IncludeAnonymous || !c3.type.isAnonymous || gg(c3)) {
            let d3;
            if (!(o3 & vt.IgnoreMounts) && (d3 = El.get(c3)) && !d3.overlay)
              return new Rr(d3.tree, f3, e3, s3);
            let p10 = new Rr(c3, f3, e3, s3);
            return o3 & vt.IncludeAnonymous || !p10.type.isAnonymous ? p10 : p10.nextChild(r3 < 0 ? c3.children.length - 1 : 0, r3, n3, i3);
          }
        }
      }
      if (o3 & vt.IncludeAnonymous || !s3.type.isAnonymous || (s3.index >= 0 ? e3 = s3.index + r3 : e3 = r3 < 0 ? -1 : s3._parent._tree.children.length, s3 = s3._parent, !s3))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e3) {
    return this.nextChild(
      0,
      1,
      e3,
      2
      /* Side.After */
    );
  }
  childBefore(e3) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e3,
      -2
      /* Side.Before */
    );
  }
  enter(e3, r3, n3 = 0) {
    let i3;
    if (!(n3 & vt.IgnoreOverlays) && (i3 = El.get(this._tree)) && i3.overlay) {
      let o3 = e3 - this.from;
      for (let { from: s3, to: a3 } of i3.overlay)
        if ((r3 > 0 ? s3 <= o3 : s3 < o3) && (r3 < 0 ? a3 >= o3 : a3 > o3))
          return new Rr(i3.tree, i3.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e3, r3, n3);
  }
  nextSignificantParent() {
    let e3 = this;
    for (; e3.type.isAnonymous && e3._parent; )
      e3 = e3._parent;
    return e3;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function z1(t10, e3, r3, n3) {
  let i3 = t10.cursor(), o3 = [];
  if (!i3.firstChild())
    return o3;
  if (r3 != null) {
    for (; !i3.type.is(r3); )
      if (!i3.nextSibling())
        return o3;
  }
  for (; ; ) {
    if (n3 != null && i3.type.is(n3))
      return o3;
    if (i3.type.is(e3) && o3.push(i3.node), !i3.nextSibling())
      return n3 == null ? o3 : [];
  }
}
function Up(t10, e3, r3 = e3.length - 1) {
  for (let n3 = t10.parent; r3 >= 0; n3 = n3.parent) {
    if (!n3)
      return false;
    if (!n3.type.isAnonymous) {
      if (e3[r3] && e3[r3] != n3.name)
        return false;
      r3--;
    }
  }
  return true;
}
class h4 {
  constructor(e3, r3, n3, i3) {
    this.parent = e3, this.buffer = r3, this.index = n3, this.start = i3;
  }
}
class Jn extends l2 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e3, r3, n3) {
    super(), this.context = e3, this._parent = r3, this.index = n3, this.type = e3.buffer.set.types[e3.buffer.buffer[n3]];
  }
  child(e3, r3, n3) {
    let { buffer: i3 } = this.context, o3 = i3.findChild(this.index + 4, i3.buffer[this.index + 3], e3, r3 - this.context.start, n3);
    return o3 < 0 ? null : new Jn(this.context, this, o3);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e3) {
    return this.child(
      1,
      e3,
      2
      /* Side.After */
    );
  }
  childBefore(e3) {
    return this.child(
      -1,
      e3,
      -2
      /* Side.Before */
    );
  }
  enter(e3, r3, n3 = 0) {
    if (n3 & vt.ExcludeBuffers)
      return null;
    let { buffer: i3 } = this.context, o3 = i3.findChild(this.index + 4, i3.buffer[this.index + 3], r3 > 0 ? 1 : -1, e3 - this.context.start, r3);
    return o3 < 0 ? null : new Jn(this.context, this, o3);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e3) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e3,
      e3,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e3 } = this.context, r3 = e3.buffer[this.index + 3];
    return r3 < (this._parent ? e3.buffer[this._parent.index + 3] : e3.buffer.length) ? new Jn(this.context, this._parent, r3) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e3 } = this.context, r3 = this._parent ? this._parent.index + 4 : 0;
    return this.index == r3 ? this.externalSibling(-1) : new Jn(this.context, this._parent, e3.findChild(
      r3,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e3 = [], r3 = [], { buffer: n3 } = this.context, i3 = this.index + 4, o3 = n3.buffer[this.index + 3];
    if (o3 > i3) {
      let s3 = n3.buffer[this.index + 1];
      e3.push(n3.slice(i3, o3, s3)), r3.push(0);
    }
    return new ft(this.type, e3, r3, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function u2(t10) {
  if (!t10.length)
    return null;
  if (t10.length == 1)
    return t10[0];
  let e3 = 0, r3 = t10[0];
  for (let o3 = 1; o3 < t10.length; o3++) {
    let s3 = t10[o3];
    (s3.from > r3.from || s3.to < r3.to) && (r3 = s3, e3 = o3);
  }
  let n3 = r3 instanceof Rr && r3.index < 0 ? null : r3.parent, i3 = t10.slice();
  return n3 ? i3[e3] = n3 : i3.splice(e3, 1), new p4(i3, r3);
}
class p4 {
  constructor(e3, r3) {
    this.heads = e3, this.node = r3;
  }
  get next() {
    return u2(this.heads);
  }
}
function O4(t10, e3, r3) {
  let n3 = t10.resolveInner(e3, r3), i3 = null;
  for (let o3 = n3 instanceof Rr ? n3 : n3.context.parent; o3; o3 = o3.parent)
    if (o3.index < 0) {
      let s3 = o3.parent;
      (i3 || (i3 = [n3])).push(s3.resolve(e3, r3)), o3 = s3;
    } else {
      let s3 = El.get(o3.tree);
      if (s3 && s3.overlay && s3.overlay[0].from <= e3 && s3.overlay[s3.overlay.length - 1].to >= e3) {
        let a3 = new Rr(s3.tree, s3.overlay[0].from + o3.from, 0, null);
        (i3 || (i3 = [n3])).push(Cl(a3, e3, r3, false));
      }
    }
  return i3 ? u2(i3) : n3;
}
class Wc {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e3, r3 = 0) {
    if (this.mode = r3, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e3 instanceof Rr)
      this.yieldNode(e3);
    else {
      this._tree = e3.context.parent, this.buffer = e3.context;
      for (let n3 = e3._parent; n3; n3 = n3._parent)
        this.stack.unshift(n3.index);
      this.bufferNode = e3, this.yieldBuf(e3.index);
    }
  }
  yieldNode(e3) {
    return e3 ? (this._tree = e3, this.type = e3.type, this.from = e3.from, this.to = e3.to, true) : false;
  }
  yieldBuf(e3, r3) {
    this.index = e3;
    let { start: n3, buffer: i3 } = this.buffer;
    return this.type = r3 || i3.set.types[i3.buffer[e3]], this.from = n3 + i3.buffer[e3 + 1], this.to = n3 + i3.buffer[e3 + 2], true;
  }
  yield(e3) {
    return e3 ? e3 instanceof Rr ? (this.buffer = null, this.yieldNode(e3)) : (this.buffer = e3.context, this.yieldBuf(e3.index, e3.type)) : false;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e3, r3, n3) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e3 < 0 ? this._tree._tree.children.length - 1 : 0, e3, r3, n3, this.mode));
    let { buffer: i3 } = this.buffer, o3 = i3.findChild(this.index + 4, i3.buffer[this.index + 3], e3, r3 - this.buffer.start, n3);
    return o3 < 0 ? false : (this.stack.push(this.index), this.yieldBuf(o3));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e3) {
    return this.enterChild(
      1,
      e3,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e3) {
    return this.enterChild(
      -1,
      e3,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e3, r3, n3 = this.mode) {
    return this.buffer ? n3 & vt.ExcludeBuffers ? false : this.enterChild(1, e3, r3) : this.yield(this._tree.enter(e3, r3, n3));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & vt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e3 = this.mode & vt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e3);
  }
  /**
  @internal
  */
  sibling(e3) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e3, e3, 0, 4, this.mode)) : false;
    let { buffer: r3 } = this.buffer, n3 = this.stack.length - 1;
    if (e3 < 0) {
      let i3 = n3 < 0 ? 0 : this.stack[n3] + 4;
      if (this.index != i3)
        return this.yieldBuf(r3.findChild(
          i3,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i3 = r3.buffer[this.index + 3];
      if (i3 < (n3 < 0 ? r3.buffer.length : r3.buffer[this.stack[n3] + 3]))
        return this.yieldBuf(i3);
    }
    return n3 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e3, e3, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e3) {
    let r3, n3, { buffer: i3 } = this;
    if (i3) {
      if (e3 > 0) {
        if (this.index < i3.buffer.buffer.length)
          return false;
      } else
        for (let o3 = 0; o3 < this.index; o3++)
          if (i3.buffer.buffer[o3 + 3] < this.index)
            return false;
      ({ index: r3, parent: n3 } = i3);
    } else
      ({ index: r3, _parent: n3 } = this._tree);
    for (; n3; { index: r3, _parent: n3 } = n3)
      if (r3 > -1)
        for (let o3 = r3 + e3, s3 = e3 < 0 ? -1 : n3._tree.children.length; o3 != s3; o3 += e3) {
          let a3 = n3._tree.children[o3];
          if (this.mode & vt.IncludeAnonymous || a3 instanceof ps || !a3.type.isAnonymous || gg(a3))
            return false;
        }
    return true;
  }
  move(e3, r3) {
    if (r3 && this.enterChild(
      e3,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(e3))
        return true;
      if (this.atLastNode(e3) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e3 = true) {
    return this.move(1, e3);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e3 = true) {
    return this.move(-1, e3);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e3, r3 = 0) {
    for (; (this.from == this.to || (r3 < 1 ? this.from >= e3 : this.from > e3) || (r3 > -1 ? this.to <= e3 : this.to < e3)) && this.parent(); )
      ;
    for (; this.enterChild(1, e3, r3); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e3 = this.bufferNode, r3 = null, n3 = 0;
    if (e3 && e3.context == this.buffer)
      e:
        for (let i3 = this.index, o3 = this.stack.length; o3 >= 0; ) {
          for (let s3 = e3; s3; s3 = s3._parent)
            if (s3.index == i3) {
              if (i3 == this.index)
                return s3;
              r3 = s3, n3 = o3 + 1;
              break e;
            }
          i3 = this.stack[--o3];
        }
    for (let i3 = n3; i3 < this.stack.length; i3++)
      r3 = new Jn(this.buffer, r3, this.stack[i3]);
    return this.bufferNode = new Jn(this.buffer, r3, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e3, r3) {
    for (let n3 = 0; ; ) {
      let i3 = false;
      if (this.type.isAnonymous || e3(this) !== false) {
        if (this.firstChild()) {
          n3++;
          continue;
        }
        this.type.isAnonymous || (i3 = true);
      }
      for (; i3 && r3 && r3(this), i3 = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!n3)
          return;
        this.parent(), n3--, i3 = true;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e3) {
    if (!this.buffer)
      return Up(this.node, e3);
    let { buffer: r3 } = this.buffer, { types: n3 } = r3.set;
    for (let i3 = e3.length - 1, o3 = this.stack.length - 1; i3 >= 0; o3--) {
      if (o3 < 0)
        return Up(this.node, e3, i3);
      let s3 = n3[r3.buffer[this.stack[o3]]];
      if (!s3.isAnonymous) {
        if (e3[i3] && e3[i3] != s3.name)
          return false;
        i3--;
      }
    }
    return true;
  }
}
function gg(t10) {
  return t10.children.some((e3) => e3 instanceof ps || !e3.type.isAnonymous || gg(e3));
}
function m4(t10) {
  var e3;
  let { buffer: r3, nodeSet: n3, maxBufferLength: i3 = s2, reused: o3 = [], minRepeatType: s3 = n3.types.length } = t10, a3 = Array.isArray(r3) ? new mg(r3, r3.length) : r3, l3 = n3.types, u3 = 0, c3 = 0;
  function f3($10, _10, P10, q5, N5) {
    let { id: B5, start: H10, end: ne, size: re2 } = a3, fe = c3;
    for (; re2 < 0; )
      if (a3.next(), re2 == -1) {
        let Ie = o3[B5];
        P10.push(Ie), q5.push(H10 - $10);
        return;
      } else if (re2 == -3) {
        u3 = B5;
        return;
      } else if (re2 == -4) {
        c3 = B5;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${re2}`);
    let pe = l3[B5], Ee2, qe, _e = H10 - $10;
    if (ne - H10 <= i3 && (qe = m10(a3.pos - _10, N5))) {
      let Ie = new Uint16Array(qe.size - qe.skip), je2 = a3.pos - qe.size, G = Ie.length;
      for (; a3.pos > je2; )
        G = O10(qe.start, Ie, G);
      Ee2 = new ps(Ie, ne - qe.start, n3), _e = qe.start - $10;
    } else {
      let Ie = a3.pos - re2;
      a3.next();
      let je2 = [], G = [], Z = B5 >= s3 ? B5 : -1, C10 = 0, X10 = ne;
      for (; a3.pos > Ie; )
        Z >= 0 && a3.id == Z && a3.size >= 0 ? (a3.end <= X10 - i3 && (p10(je2, G, H10, C10, a3.end, X10, Z, fe), C10 = je2.length, X10 = a3.end), a3.next()) : f3(H10, Ie, je2, G, Z);
      if (Z >= 0 && C10 > 0 && C10 < je2.length && p10(je2, G, H10, C10, H10, X10, Z, fe), je2.reverse(), G.reverse(), Z > -1 && C10 > 0) {
        let w10 = d3(pe);
        Ee2 = yg(pe, je2, G, 0, je2.length, 0, ne - H10, w10, w10);
      } else
        Ee2 = h10(pe, je2, G, ne - H10, fe - ne);
    }
    P10.push(Ee2), q5.push(_e);
  }
  function d3($10) {
    return (_10, P10, q5) => {
      let N5 = 0, B5 = _10.length - 1, H10, ne;
      if (B5 >= 0 && (H10 = _10[B5]) instanceof ft) {
        if (!B5 && H10.type == $10 && H10.length == q5)
          return H10;
        (ne = H10.prop(ut.lookAhead)) && (N5 = P10[B5] + H10.length + ne);
      }
      return h10($10, _10, P10, q5, N5);
    };
  }
  function p10($10, _10, P10, q5, N5, B5, H10, ne) {
    let re2 = [], fe = [];
    for (; $10.length > q5; )
      re2.push($10.pop()), fe.push(_10.pop() + P10 - N5);
    $10.push(h10(n3.types[H10], re2, fe, B5 - N5, ne - B5)), _10.push(N5 - P10);
  }
  function h10($10, _10, P10, q5, N5 = 0, B5) {
    if (u3) {
      let H10 = [ut.contextHash, u3];
      B5 = B5 ? [H10].concat(B5) : [H10];
    }
    if (N5 > 25) {
      let H10 = [ut.lookAhead, N5];
      B5 = B5 ? [H10].concat(B5) : [H10];
    }
    return new ft($10, _10, P10, q5, B5);
  }
  function m10($10, _10) {
    let P10 = a3.fork(), q5 = 0, N5 = 0, B5 = 0, H10 = P10.end - i3, ne = { size: 0, start: 0, skip: 0 };
    e:
      for (let re2 = P10.pos - $10; P10.pos > re2; ) {
        let fe = P10.size;
        if (P10.id == _10 && fe >= 0) {
          ne.size = q5, ne.start = N5, ne.skip = B5, B5 += 4, q5 += 4, P10.next();
          continue;
        }
        let pe = P10.pos - fe;
        if (fe < 0 || pe < re2 || P10.start < H10)
          break;
        let Ee2 = P10.id >= s3 ? 4 : 0, qe = P10.start;
        for (P10.next(); P10.pos > pe; ) {
          if (P10.size < 0)
            if (P10.size == -3)
              Ee2 += 4;
            else
              break e;
          else
            P10.id >= s3 && (Ee2 += 4);
          P10.next();
        }
        N5 = qe, q5 += fe, B5 += Ee2;
      }
    return (_10 < 0 || q5 == $10) && (ne.size = q5, ne.start = N5, ne.skip = B5), ne.size > 4 ? ne : void 0;
  }
  function O10($10, _10, P10) {
    let { id: q5, start: N5, end: B5, size: H10 } = a3;
    if (a3.next(), H10 >= 0 && q5 < s3) {
      let ne = P10;
      if (H10 > 4) {
        let re2 = a3.pos - (H10 - 4);
        for (; a3.pos > re2; )
          P10 = O10($10, _10, P10);
      }
      _10[--P10] = ne, _10[--P10] = B5 - $10, _10[--P10] = N5 - $10, _10[--P10] = q5;
    } else
      H10 == -3 ? u3 = q5 : H10 == -4 && (c3 = q5);
    return P10;
  }
  let g = [], v10 = [];
  for (; a3.pos > 0; )
    f3(t10.start || 0, t10.bufferStart || 0, g, v10, -1);
  let S10 = (e3 = t10.length) !== null && e3 !== void 0 ? e3 : g.length ? v10[0] + g[0].length : 0;
  return new ft(l3[t10.topID], g.reverse(), v10.reverse(), S10);
}
const H1 = /* @__PURE__ */ new WeakMap();
function pc(t10, e3) {
  if (!t10.isAnonymous || e3 instanceof ps || e3.type != t10)
    return 1;
  let r3 = H1.get(e3);
  if (r3 == null) {
    r3 = 1;
    for (let n3 of e3.children) {
      if (n3.type != t10 || !(n3 instanceof ft)) {
        r3 = 1;
        break;
      }
      r3 += pc(t10, n3);
    }
    H1.set(e3, r3);
  }
  return r3;
}
function yg(t10, e3, r3, n3, i3, o3, s3, a3, l3) {
  let u3 = 0;
  for (let h10 = n3; h10 < i3; h10++)
    u3 += pc(t10, e3[h10]);
  let c3 = Math.ceil(
    u3 * 1.5 / 8
    /* Balance.BranchFactor */
  ), f3 = [], d3 = [];
  function p10(h10, m10, O10, g, v10) {
    for (let S10 = O10; S10 < g; ) {
      let $10 = S10, _10 = m10[S10], P10 = pc(t10, h10[S10]);
      for (S10++; S10 < g; S10++) {
        let q5 = pc(t10, h10[S10]);
        if (P10 + q5 >= c3)
          break;
        P10 += q5;
      }
      if (S10 == $10 + 1) {
        if (P10 > c3) {
          let q5 = h10[$10];
          p10(q5.children, q5.positions, 0, q5.children.length, m10[$10] + v10);
          continue;
        }
        f3.push(h10[$10]);
      } else {
        let q5 = m10[S10 - 1] + h10[S10 - 1].length - _10;
        f3.push(yg(t10, h10, m10, $10, S10, _10, q5, null, l3));
      }
      d3.push(_10 + v10 - o3);
    }
  }
  return p10(e3, r3, n3, i3, 0), (a3 || l3)(f3, d3, s3);
}
class vg {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e3, r3, n3) {
    let i3 = this.map.get(e3);
    i3 || this.map.set(e3, i3 = /* @__PURE__ */ new Map()), i3.set(r3, n3);
  }
  getBuffer(e3, r3) {
    let n3 = this.map.get(e3);
    return n3 && n3.get(r3);
  }
  /**
  Set the value for this syntax node.
  */
  set(e3, r3) {
    e3 instanceof Jn ? this.setBuffer(e3.context.buffer, e3.index, r3) : e3 instanceof Rr && this.map.set(e3.tree, r3);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e3) {
    return e3 instanceof Jn ? this.getBuffer(e3.context.buffer, e3.index) : e3 instanceof Rr ? this.map.get(e3.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e3, r3) {
    e3.buffer ? this.setBuffer(e3.buffer.buffer, e3.index, r3) : this.map.set(e3.tree, r3);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e3) {
    return e3.buffer ? this.getBuffer(e3.buffer.buffer, e3.index) : this.map.get(e3.tree);
  }
}
class Pi {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e3, r3, n3, i3, o3 = false, s3 = false) {
    this.from = e3, this.to = r3, this.tree = n3, this.offset = i3, this.open = (o3 ? 1 : 0) | (s3 ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e3, r3 = [], n3 = false) {
    let i3 = [new Pi(0, e3.length, e3, 0, false, n3)];
    for (let o3 of r3)
      o3.to > e3.length && i3.push(o3);
    return i3;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e3, r3, n3 = 128) {
    if (!r3.length)
      return e3;
    let i3 = [], o3 = 1, s3 = e3.length ? e3[0] : null;
    for (let a3 = 0, l3 = 0, u3 = 0; ; a3++) {
      let c3 = a3 < r3.length ? r3[a3] : null, f3 = c3 ? c3.fromA : 1e9;
      if (f3 - l3 >= n3)
        for (; s3 && s3.from < f3; ) {
          let d3 = s3;
          if (l3 >= d3.from || f3 <= d3.to || u3) {
            let p10 = Math.max(d3.from, l3) - u3, h10 = Math.min(d3.to, f3) - u3;
            d3 = p10 >= h10 ? null : new Pi(p10, h10, d3.tree, d3.offset + u3, a3 > 0, !!c3);
          }
          if (d3 && i3.push(d3), s3.to > f3)
            break;
          s3 = o3 < e3.length ? e3[o3++] : null;
        }
      if (!c3)
        break;
      l3 = c3.toA, u3 = c3.toA - c3.toB;
    }
    return i3;
  }
}
class bg {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e3, r3, n3) {
    return typeof e3 == "string" && (e3 = new g4(e3)), n3 = n3 ? n3.length ? n3.map((i3) => new un(i3.from, i3.to)) : [new un(0, 0)] : [new un(0, e3.length)], this.createParse(e3, r3 || [], n3);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e3, r3, n3) {
    let i3 = this.startParse(e3, r3, n3);
    for (; ; ) {
      let o3 = i3.advance();
      if (o3)
        return o3;
    }
  }
}
class g4 {
  constructor(e3) {
    this.string = e3;
  }
  get length() {
    return this.string.length;
  }
  chunk(e3) {
    return this.string.slice(e3);
  }
  get lineChunks() {
    return false;
  }
  read(e3, r3) {
    return this.string.slice(e3, r3);
  }
}
function y4(t10) {
  return (e3, r3, n3, i3) => new b4(e3, t10, r3, n3, i3);
}
class G1 {
  constructor(e3, r3, n3, i3, o3) {
    if (this.parser = e3, this.parse = r3, this.overlay = n3, this.target = i3, this.ranges = o3, !o3.length || o3.some((s3) => s3.from >= s3.to))
      throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(o3));
  }
}
class v4 {
  constructor(e3, r3, n3, i3, o3, s3, a3) {
    this.parser = e3, this.predicate = r3, this.mounts = n3, this.index = i3, this.start = o3, this.target = s3, this.prev = a3, this.depth = 0, this.ranges = [];
  }
}
const Ip = new ut({ perNode: true });
class b4 {
  constructor(e3, r3, n3, i3, o3) {
    this.nest = r3, this.input = n3, this.fragments = i3, this.ranges = o3, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e3;
  }
  advance() {
    if (this.baseParse) {
      let n3 = this.baseParse.advance();
      if (!n3)
        return null;
      if (this.baseParse = null, this.baseTree = n3, this.startInner(), this.stoppedAt != null)
        for (let i3 of this.inner)
          i3.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let n3 = this.baseTree;
      return this.stoppedAt != null && (n3 = new ft(n3.type, n3.children, n3.positions, n3.length, n3.propValues.concat([[Ip, this.stoppedAt]]))), n3;
    }
    let e3 = this.inner[this.innerDone], r3 = e3.parse.advance();
    if (r3) {
      this.innerDone++;
      let n3 = Object.assign(/* @__PURE__ */ Object.create(null), e3.target.props);
      n3[ut.mounted.id] = new El(r3, e3.overlay, e3.parser), e3.target.props = n3;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e3 = this.input.length;
    for (let r3 = this.innerDone; r3 < this.inner.length; r3++)
      this.inner[r3].ranges[0].from < e3 && (e3 = Math.min(e3, this.inner[r3].parse.parsedPos));
    return e3;
  }
  stopAt(e3) {
    if (this.stoppedAt = e3, this.baseParse)
      this.baseParse.stopAt(e3);
    else
      for (let r3 = this.innerDone; r3 < this.inner.length; r3++)
        this.inner[r3].parse.stopAt(e3);
  }
  startInner() {
    let e3 = new w4(this.fragments), r3 = null, n3 = null, i3 = new Wc(new Rr(this.baseTree, this.ranges[0].from, 0, null), vt.IncludeAnonymous | vt.IgnoreMounts);
    e:
      for (let o3, s3; this.stoppedAt == null || i3.from < this.stoppedAt; ) {
        let a3 = true, l3;
        if (e3.hasNode(i3)) {
          if (r3) {
            let u3 = r3.mounts.find((c3) => c3.frag.from <= i3.from && c3.frag.to >= i3.to && c3.mount.overlay);
            if (u3)
              for (let c3 of u3.mount.overlay) {
                let f3 = c3.from + u3.pos, d3 = c3.to + u3.pos;
                f3 >= i3.from && d3 <= i3.to && !r3.ranges.some((p10) => p10.from < d3 && p10.to > f3) && r3.ranges.push({ from: f3, to: d3 });
              }
          }
          a3 = false;
        } else if (n3 && (s3 = S4(n3.ranges, i3.from, i3.to)))
          a3 = s3 != 2;
        else if (!i3.type.isAnonymous && i3.from < i3.to && (o3 = this.nest(i3, this.input))) {
          i3.tree || $4(i3);
          let u3 = e3.findMounts(i3.from, o3.parser);
          if (typeof o3.overlay == "function")
            r3 = new v4(o3.parser, o3.overlay, u3, this.inner.length, i3.from, i3.tree, r3);
          else {
            let c3 = ey(this.ranges, o3.overlay || [new un(i3.from, i3.to)]);
            c3.length && this.inner.push(new G1(o3.parser, o3.parser.startParse(this.input, ty(u3, c3), c3), o3.overlay ? o3.overlay.map((f3) => new un(f3.from - i3.from, f3.to - i3.from)) : null, i3.tree, c3)), o3.overlay ? c3.length && (n3 = { ranges: c3, depth: 0, prev: n3 }) : a3 = false;
          }
        } else
          r3 && (l3 = r3.predicate(i3)) && (l3 === true && (l3 = new un(i3.from, i3.to)), l3.from < l3.to && r3.ranges.push(l3));
        if (a3 && i3.firstChild())
          r3 && r3.depth++, n3 && n3.depth++;
        else
          for (; !i3.nextSibling(); ) {
            if (!i3.parent())
              break e;
            if (r3 && !--r3.depth) {
              let u3 = ey(this.ranges, r3.ranges);
              u3.length && this.inner.splice(r3.index, 0, new G1(r3.parser, r3.parser.startParse(this.input, ty(r3.mounts, u3), u3), r3.ranges.map((c3) => new un(c3.from - r3.start, c3.to - r3.start)), r3.target, u3)), r3 = r3.prev;
            }
            n3 && !--n3.depth && (n3 = n3.prev);
          }
      }
  }
}
function S4(t10, e3, r3) {
  for (let n3 of t10) {
    if (n3.from >= r3)
      break;
    if (n3.to > e3)
      return n3.from <= e3 && n3.to >= r3 ? 2 : 1;
  }
  return 0;
}
function K1(t10, e3, r3, n3, i3, o3) {
  if (e3 < r3) {
    let s3 = t10.buffer[e3 + 1];
    n3.push(t10.slice(e3, r3, s3)), i3.push(s3 - o3);
  }
}
function $4(t10) {
  let { node: e3 } = t10, r3 = 0;
  do
    t10.parent(), r3++;
  while (!t10.tree);
  let n3 = 0, i3 = t10.tree, o3 = 0;
  for (; o3 = i3.positions[n3] + t10.from, !(o3 <= e3.from && o3 + i3.children[n3].length >= e3.to); n3++)
    ;
  let s3 = i3.children[n3], a3 = s3.buffer;
  function l3(u3, c3, f3, d3, p10) {
    let h10 = u3;
    for (; a3[h10 + 2] + o3 <= e3.from; )
      h10 = a3[h10 + 3];
    let m10 = [], O10 = [];
    K1(s3, u3, h10, m10, O10, d3);
    let g = a3[h10 + 1], v10 = a3[h10 + 2], S10 = g + o3 == e3.from && v10 + o3 == e3.to && a3[h10] == e3.type.id;
    return m10.push(S10 ? e3.toTree() : l3(h10 + 4, a3[h10 + 3], s3.set.types[a3[h10]], g, v10 - g)), O10.push(g - d3), K1(s3, a3[h10 + 3], c3, m10, O10, d3), new ft(f3, m10, O10, p10);
  }
  i3.children[n3] = l3(0, a3.length, $r.none, 0, s3.length);
  for (let u3 = 0; u3 <= r3; u3++)
    t10.childAfter(e3.from);
}
class J1 {
  constructor(e3, r3) {
    this.offset = r3, this.done = false, this.cursor = e3.cursor(vt.IncludeAnonymous | vt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e3) {
    let { cursor: r3 } = this, n3 = e3 - this.offset;
    for (; !this.done && r3.from < n3; )
      r3.to >= e3 && r3.enter(n3, 1, vt.IgnoreOverlays | vt.ExcludeBuffers) || r3.next(false) || (this.done = true);
  }
  hasNode(e3) {
    if (this.moveTo(e3.from), !this.done && this.cursor.from + this.offset == e3.from && this.cursor.tree)
      for (let r3 = this.cursor.tree; ; ) {
        if (r3 == e3.tree)
          return true;
        if (r3.children.length && r3.positions[0] == 0 && r3.children[0] instanceof ft)
          r3 = r3.children[0];
        else
          break;
      }
    return false;
  }
}
let w4 = class {
  constructor(e3) {
    var r3;
    if (this.fragments = e3, this.curTo = 0, this.fragI = 0, e3.length) {
      let n3 = this.curFrag = e3[0];
      this.curTo = (r3 = n3.tree.prop(Ip)) !== null && r3 !== void 0 ? r3 : n3.to, this.inner = new J1(n3.tree, -n3.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e3) {
    for (; this.curFrag && e3.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e3.from && this.curTo >= e3.to && this.inner.hasNode(e3);
  }
  nextFrag() {
    var e3;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let r3 = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e3 = r3.tree.prop(Ip)) !== null && e3 !== void 0 ? e3 : r3.to, this.inner = new J1(r3.tree, -r3.offset);
    }
  }
  findMounts(e3, r3) {
    var n3;
    let i3 = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e3, 1);
      for (let o3 = this.inner.cursor.node; o3; o3 = o3.parent) {
        let s3 = (n3 = o3.tree) === null || n3 === void 0 ? void 0 : n3.prop(ut.mounted);
        if (s3 && s3.parser == r3)
          for (let a3 = this.fragI; a3 < this.fragments.length; a3++) {
            let l3 = this.fragments[a3];
            if (l3.from >= o3.to)
              break;
            l3.tree == this.curFrag.tree && i3.push({
              frag: l3,
              pos: o3.from - l3.offset,
              mount: s3
            });
          }
      }
    }
    return i3;
  }
};
function ey(t10, e3) {
  let r3 = null, n3 = e3;
  for (let i3 = 1, o3 = 0; i3 < t10.length; i3++) {
    let s3 = t10[i3 - 1].to, a3 = t10[i3].from;
    for (; o3 < n3.length; o3++) {
      let l3 = n3[o3];
      if (l3.from >= a3)
        break;
      l3.to <= s3 || (r3 || (n3 = r3 = e3.slice()), l3.from < s3 ? (r3[o3] = new un(l3.from, s3), l3.to > a3 && r3.splice(o3 + 1, 0, new un(a3, l3.to))) : l3.to > a3 ? r3[o3--] = new un(a3, l3.to) : r3.splice(o3--, 1));
    }
  }
  return n3;
}
function P4(t10, e3, r3, n3) {
  let i3 = 0, o3 = 0, s3 = false, a3 = false, l3 = -1e9, u3 = [];
  for (; ; ) {
    let c3 = i3 == t10.length ? 1e9 : s3 ? t10[i3].to : t10[i3].from, f3 = o3 == e3.length ? 1e9 : a3 ? e3[o3].to : e3[o3].from;
    if (s3 != a3) {
      let d3 = Math.max(l3, r3), p10 = Math.min(c3, f3, n3);
      d3 < p10 && u3.push(new un(d3, p10));
    }
    if (l3 = Math.min(c3, f3), l3 == 1e9)
      break;
    c3 == l3 && (s3 ? (s3 = false, i3++) : s3 = true), f3 == l3 && (a3 ? (a3 = false, o3++) : a3 = true);
  }
  return u3;
}
function ty(t10, e3) {
  let r3 = [];
  for (let { pos: n3, mount: i3, frag: o3 } of t10) {
    let s3 = n3 + (i3.overlay ? i3.overlay[0].from : 0), a3 = s3 + i3.tree.length, l3 = Math.max(o3.from, s3), u3 = Math.min(o3.to, a3);
    if (i3.overlay) {
      let c3 = i3.overlay.map((d3) => new un(d3.from + n3, d3.to + n3)), f3 = P4(e3, c3, l3, u3);
      for (let d3 = 0, p10 = l3; ; d3++) {
        let h10 = d3 == f3.length, m10 = h10 ? u3 : f3[d3].from;
        if (m10 > p10 && r3.push(new Pi(p10, m10, i3.tree, -s3, o3.from >= p10 || o3.openStart, o3.to <= m10 || o3.openEnd)), h10)
          break;
        p10 = f3[d3].to;
      }
    } else
      r3.push(new Pi(l3, u3, i3.tree, -s3, o3.from >= s3 || o3.openStart, o3.to <= a3 || o3.openEnd));
  }
  return r3;
}
class Vc {
  /**
  @internal
  */
  constructor(e3, r3, n3, i3, o3, s3, a3, l3, u3, c3 = 0, f3) {
    this.p = e3, this.stack = r3, this.state = n3, this.reducePos = i3, this.pos = o3, this.score = s3, this.buffer = a3, this.bufferBase = l3, this.curContext = u3, this.lookAhead = c3, this.parent = f3;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e3, r3) => r3 % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e3, r3, n3 = 0) {
    let i3 = e3.parser.context;
    return new Vc(e3, [], r3, n3, n3, 0, [], 0, i3 ? new ry(i3, i3.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e3, r3) {
    this.stack.push(this.state, r3, this.bufferBase + this.buffer.length), this.state = e3;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e3) {
    var r3;
    let n3 = e3 >> 19, i3 = e3 & 65535, { parser: o3 } = this.p, s3 = o3.dynamicPrecedence(i3);
    if (s3 && (this.score += s3), n3 == 0) {
      this.pushState(o3.getGoto(this.state, i3, true), this.reducePos), i3 < o3.minRepeatTerm && this.storeNode(i3, this.reducePos, this.reducePos, 4, true), this.reduceContext(i3, this.reducePos);
      return;
    }
    let a3 = this.stack.length - (n3 - 1) * 3 - (e3 & 262144 ? 6 : 0), l3 = a3 ? this.stack[a3 - 2] : this.p.ranges[0].from, u3 = this.reducePos - l3;
    u3 >= 2e3 && !(!((r3 = this.p.parser.nodeSet.types[i3]) === null || r3 === void 0) && r3.isAnonymous) && (l3 == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u3) : this.p.lastBigReductionSize < u3 && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l3, this.p.lastBigReductionSize = u3));
    let c3 = a3 ? this.stack[a3 - 1] : 0, f3 = this.bufferBase + this.buffer.length - c3;
    if (i3 < o3.minRepeatTerm || e3 & 131072) {
      let d3 = o3.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i3, l3, d3, f3 + 4, true);
    }
    if (e3 & 262144)
      this.state = this.stack[a3];
    else {
      let d3 = this.stack[a3 - 3];
      this.state = o3.getGoto(d3, i3, true);
    }
    for (; this.stack.length > a3; )
      this.stack.pop();
    this.reduceContext(i3, l3);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e3, r3, n3, i3 = 4, o3 = false) {
    if (e3 == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s3 = this, a3 = this.buffer.length;
      if (a3 == 0 && s3.parent && (a3 = s3.bufferBase - s3.parent.bufferBase, s3 = s3.parent), a3 > 0 && s3.buffer[a3 - 4] == 0 && s3.buffer[a3 - 1] > -1) {
        if (r3 == n3)
          return;
        if (s3.buffer[a3 - 2] >= r3) {
          s3.buffer[a3 - 2] = n3;
          return;
        }
      }
    }
    if (!o3 || this.pos == n3)
      this.buffer.push(e3, r3, n3, i3);
    else {
      let s3 = this.buffer.length;
      if (s3 > 0 && this.buffer[s3 - 4] != 0)
        for (; s3 > 0 && this.buffer[s3 - 2] > n3; )
          this.buffer[s3] = this.buffer[s3 - 4], this.buffer[s3 + 1] = this.buffer[s3 - 3], this.buffer[s3 + 2] = this.buffer[s3 - 2], this.buffer[s3 + 3] = this.buffer[s3 - 1], s3 -= 4, i3 > 4 && (i3 -= 4);
      this.buffer[s3] = e3, this.buffer[s3 + 1] = r3, this.buffer[s3 + 2] = n3, this.buffer[s3 + 3] = i3;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e3, r3, n3, i3) {
    if (e3 & 131072)
      this.pushState(e3 & 65535, this.pos);
    else if (e3 & 262144)
      this.pos = i3, this.shiftContext(r3, n3), r3 <= this.p.parser.maxNode && this.buffer.push(r3, n3, i3, 4);
    else {
      let o3 = e3, { parser: s3 } = this.p;
      (i3 > this.pos || r3 <= s3.maxNode) && (this.pos = i3, s3.stateFlag(
        o3,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i3)), this.pushState(o3, n3), this.shiftContext(r3, n3), r3 <= s3.maxNode && this.buffer.push(r3, n3, i3, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e3, r3, n3, i3) {
    e3 & 65536 ? this.reduce(e3) : this.shift(e3, r3, n3, i3);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e3, r3) {
    let n3 = this.p.reused.length - 1;
    (n3 < 0 || this.p.reused[n3] != e3) && (this.p.reused.push(e3), n3++);
    let i3 = this.pos;
    this.reducePos = this.pos = i3 + e3.length, this.pushState(r3, i3), this.buffer.push(
      n3,
      i3,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e3, this, this.p.stream.reset(this.pos - e3.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e3 = this, r3 = e3.buffer.length;
    for (; r3 > 0 && e3.buffer[r3 - 2] > e3.reducePos; )
      r3 -= 4;
    let n3 = e3.buffer.slice(r3), i3 = e3.bufferBase + r3;
    for (; e3 && i3 == e3.bufferBase; )
      e3 = e3.parent;
    return new Vc(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, n3, i3, this.curContext, this.lookAhead, e3);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e3, r3) {
    let n3 = e3 <= this.p.parser.maxNode;
    n3 && this.storeNode(e3, this.pos, r3, 4), this.storeNode(0, this.pos, r3, n3 ? 8 : 4), this.pos = this.reducePos = r3, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e3) {
    for (let r3 = new _4(this); ; ) {
      let n3 = this.p.parser.stateSlot(
        r3.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(r3.state, e3);
      if (n3 == 0)
        return false;
      if (!(n3 & 65536))
        return true;
      r3.reduce(n3);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e3) {
    if (this.stack.length >= 300)
      return [];
    let r3 = this.p.parser.nextStates(this.state);
    if (r3.length > 8 || this.stack.length >= 120) {
      let i3 = [];
      for (let o3 = 0, s3; o3 < r3.length; o3 += 2)
        (s3 = r3[o3 + 1]) != this.state && this.p.parser.hasAction(s3, e3) && i3.push(r3[o3], s3);
      if (this.stack.length < 120)
        for (let o3 = 0; i3.length < 8 && o3 < r3.length; o3 += 2) {
          let s3 = r3[o3 + 1];
          i3.some((a3, l3) => l3 & 1 && a3 == s3) || i3.push(r3[o3], s3);
        }
      r3 = i3;
    }
    let n3 = [];
    for (let i3 = 0; i3 < r3.length && n3.length < 4; i3 += 2) {
      let o3 = r3[i3 + 1];
      if (o3 == this.state)
        continue;
      let s3 = this.split();
      s3.pushState(o3, this.pos), s3.storeNode(0, s3.pos, s3.pos, 4, true), s3.shiftContext(r3[i3], this.pos), s3.score -= 200, n3.push(s3);
    }
    return n3;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e3 } = this.p, r3 = e3.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(r3 & 65536))
      return false;
    if (!e3.validAction(this.state, r3)) {
      let n3 = r3 >> 19, i3 = r3 & 65535, o3 = this.stack.length - n3 * 3;
      if (o3 < 0 || e3.getGoto(this.stack[o3], i3, false) < 0) {
        let s3 = this.findForcedReduction();
        if (s3 == null)
          return false;
        r3 = s3;
      }
      this.storeNode(0, this.pos, this.pos, 4, true), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(r3), true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e3 } = this.p, r3 = [], n3 = (i3, o3) => {
      if (!r3.includes(i3))
        return r3.push(i3), e3.allActions(i3, (s3) => {
          if (!(s3 & 393216))
            if (s3 & 65536) {
              let a3 = (s3 >> 19) - o3;
              if (a3 > 1) {
                let l3 = s3 & 65535, u3 = this.stack.length - a3 * 3;
                if (u3 >= 0 && e3.getGoto(this.stack[u3], l3, false) >= 0)
                  return a3 << 19 | 65536 | l3;
              }
            } else {
              let a3 = n3(s3, o3 + 1);
              if (a3 != null)
                return a3;
            }
        });
    };
    return n3(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: e3 } = this.p;
    return e3.data[e3.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e3.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e3) {
    if (this.state != e3.state || this.stack.length != e3.stack.length)
      return false;
    for (let r3 = 0; r3 < this.stack.length; r3 += 3)
      if (this.stack[r3] != e3.stack[r3])
        return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e3) {
    return this.p.parser.dialect.flags[e3];
  }
  shiftContext(e3, r3) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e3, this, this.p.stream.reset(r3)));
  }
  reduceContext(e3, r3) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e3, this, this.p.stream.reset(r3)));
  }
  /**
  @internal
  */
  emitContext() {
    let e3 = this.buffer.length - 1;
    (e3 < 0 || this.buffer[e3] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e3 = this.buffer.length - 1;
    (e3 < 0 || this.buffer[e3] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e3) {
    if (e3 != this.curContext.context) {
      let r3 = new ry(this.curContext.tracker, e3);
      r3.hash != this.curContext.hash && this.emitContext(), this.curContext = r3;
    }
  }
  /**
  @internal
  */
  setLookAhead(e3) {
    e3 > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e3);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class ry {
  constructor(e3, r3) {
    this.tracker = e3, this.context = r3, this.hash = e3.strict ? e3.hash(r3) : 0;
  }
}
class _4 {
  constructor(e3) {
    this.start = e3, this.state = e3.state, this.stack = e3.stack, this.base = this.stack.length;
  }
  reduce(e3) {
    let r3 = e3 & 65535, n3 = e3 >> 19;
    n3 == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (n3 - 1) * 3;
    let i3 = this.start.p.parser.getGoto(this.stack[this.base - 3], r3, true);
    this.state = i3;
  }
}
class Yc {
  constructor(e3, r3, n3) {
    this.stack = e3, this.pos = r3, this.index = n3, this.buffer = e3.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e3, r3 = e3.bufferBase + e3.buffer.length) {
    return new Yc(e3, r3, r3 - e3.bufferBase);
  }
  maybeNext() {
    let e3 = this.stack.parent;
    e3 != null && (this.index = this.stack.bufferBase - e3.bufferBase, this.stack = e3, this.buffer = e3.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Yc(this.stack, this.pos, this.index);
  }
}
function il(t10, e3 = Uint16Array) {
  if (typeof t10 != "string")
    return t10;
  let r3 = null;
  for (let n3 = 0, i3 = 0; n3 < t10.length; ) {
    let o3 = 0;
    for (; ; ) {
      let s3 = t10.charCodeAt(n3++), a3 = false;
      if (s3 == 126) {
        o3 = 65535;
        break;
      }
      s3 >= 92 && s3--, s3 >= 34 && s3--;
      let l3 = s3 - 32;
      if (l3 >= 46 && (l3 -= 46, a3 = true), o3 += l3, a3)
        break;
      o3 *= 46;
    }
    r3 ? r3[i3++] = o3 : r3 = new e3(o3);
  }
  return r3;
}
class Oc {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const ny = new Oc();
class x4 {
  /**
  @internal
  */
  constructor(e3, r3) {
    this.input = e3, this.ranges = r3, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = ny, this.rangeIndex = 0, this.pos = this.chunkPos = r3[0].from, this.range = r3[0], this.end = r3[r3.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e3, r3) {
    let n3 = this.range, i3 = this.rangeIndex, o3 = this.pos + e3;
    for (; o3 < n3.from; ) {
      if (!i3)
        return null;
      let s3 = this.ranges[--i3];
      o3 -= n3.from - s3.to, n3 = s3;
    }
    for (; r3 < 0 ? o3 > n3.to : o3 >= n3.to; ) {
      if (i3 == this.ranges.length - 1)
        return null;
      let s3 = this.ranges[++i3];
      o3 += s3.from - n3.to, n3 = s3;
    }
    return o3;
  }
  /**
  @internal
  */
  clipPos(e3) {
    if (e3 >= this.range.from && e3 < this.range.to)
      return e3;
    for (let r3 of this.ranges)
      if (r3.to > e3)
        return Math.max(e3, r3.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e3) {
    let r3 = this.chunkOff + e3, n3, i3;
    if (r3 >= 0 && r3 < this.chunk.length)
      n3 = this.pos + e3, i3 = this.chunk.charCodeAt(r3);
    else {
      let o3 = this.resolveOffset(e3, 1);
      if (o3 == null)
        return -1;
      if (n3 = o3, n3 >= this.chunk2Pos && n3 < this.chunk2Pos + this.chunk2.length)
        i3 = this.chunk2.charCodeAt(n3 - this.chunk2Pos);
      else {
        let s3 = this.rangeIndex, a3 = this.range;
        for (; a3.to <= n3; )
          a3 = this.ranges[++s3];
        this.chunk2 = this.input.chunk(this.chunk2Pos = n3), n3 + this.chunk2.length > a3.to && (this.chunk2 = this.chunk2.slice(0, a3.to - n3)), i3 = this.chunk2.charCodeAt(0);
      }
    }
    return n3 >= this.token.lookAhead && (this.token.lookAhead = n3 + 1), i3;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e3, r3 = 0) {
    let n3 = r3 ? this.resolveOffset(r3, -1) : this.pos;
    if (n3 == null || n3 < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e3, this.token.end = n3;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e3, chunkPos: r3 } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e3, this.chunk2Pos = r3, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e3 = this.input.chunk(this.pos), r3 = this.pos + e3.length;
      this.chunk = r3 > this.range.to ? e3.slice(0, this.range.to - this.pos) : e3, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e3 = 1) {
    for (this.chunkOff += e3; this.pos + e3 >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e3 -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e3, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e3, r3) {
    if (r3 ? (this.token = r3, r3.start = e3, r3.lookAhead = e3 + 1, r3.value = r3.extended = -1) : this.token = ny, this.pos != e3) {
      if (this.pos = e3, e3 == this.end)
        return this.setDone(), this;
      for (; e3 < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e3 >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e3 >= this.chunkPos && e3 < this.chunkPos + this.chunk.length ? this.chunkOff = e3 - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e3, r3) {
    if (e3 >= this.chunkPos && r3 <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e3 - this.chunkPos, r3 - this.chunkPos);
    if (e3 >= this.chunk2Pos && r3 <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e3 - this.chunk2Pos, r3 - this.chunk2Pos);
    if (e3 >= this.range.from && r3 <= this.range.to)
      return this.input.read(e3, r3);
    let n3 = "";
    for (let i3 of this.ranges) {
      if (i3.from >= r3)
        break;
      i3.to > e3 && (n3 += this.input.read(Math.max(i3.from, e3), Math.min(i3.to, r3)));
    }
    return n3;
  }
}
class Bs {
  constructor(e3, r3) {
    this.data = e3, this.id = r3;
  }
  token(e3, r3) {
    let { parser: n3 } = r3.p;
    c2(this.data, e3, r3, this.id, n3.data, n3.tokenPrecTable);
  }
}
Bs.prototype.contextual = Bs.prototype.fallback = Bs.prototype.extend = false;
class Lc {
  constructor(e3, r3, n3) {
    this.precTable = r3, this.elseToken = n3, this.data = typeof e3 == "string" ? il(e3) : e3;
  }
  token(e3, r3) {
    let n3 = e3.pos, i3 = 0;
    for (; ; ) {
      let o3 = e3.next < 0, s3 = e3.resolveOffset(1, 1);
      if (c2(this.data, e3, r3, 0, this.data, this.precTable), e3.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (o3 || i3++, s3 == null)
        break;
      e3.reset(s3, e3.token);
    }
    i3 && (e3.reset(n3, e3.token), e3.acceptToken(this.elseToken, i3));
  }
}
Lc.prototype.contextual = Bs.prototype.fallback = Bs.prototype.extend = false;
class Wr {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e3, r3 = {}) {
    this.token = e3, this.contextual = !!r3.contextual, this.fallback = !!r3.fallback, this.extend = !!r3.extend;
  }
}
function c2(t10, e3, r3, n3, i3, o3) {
  let s3 = 0, a3 = 1 << n3, { dialect: l3 } = r3.p.parser;
  e:
    for (; a3 & t10[s3]; ) {
      let u3 = t10[s3 + 1];
      for (let p10 = s3 + 3; p10 < u3; p10 += 2)
        if ((t10[p10 + 1] & a3) > 0) {
          let h10 = t10[p10];
          if (l3.allows(h10) && (e3.token.value == -1 || e3.token.value == h10 || Q4(h10, e3.token.value, i3, o3))) {
            e3.acceptToken(h10);
            break;
          }
        }
      let c3 = e3.next, f3 = 0, d3 = t10[s3 + 2];
      if (e3.next < 0 && d3 > f3 && t10[u3 + d3 * 3 - 3] == 65535 && t10[u3 + d3 * 3 - 3] == 65535) {
        s3 = t10[u3 + d3 * 3 - 1];
        continue e;
      }
      for (; f3 < d3; ) {
        let p10 = f3 + d3 >> 1, h10 = u3 + p10 + (p10 << 1), m10 = t10[h10], O10 = t10[h10 + 1] || 65536;
        if (c3 < m10)
          d3 = p10;
        else if (c3 >= O10)
          f3 = p10 + 1;
        else {
          s3 = t10[h10 + 2], e3.advance();
          continue e;
        }
      }
      break;
    }
}
function iy(t10, e3, r3) {
  for (let n3 = e3, i3; (i3 = t10[n3]) != 65535; n3++)
    if (i3 == r3)
      return n3 - e3;
  return -1;
}
function Q4(t10, e3, r3, n3) {
  let i3 = iy(r3, n3, e3);
  return i3 < 0 || iy(r3, n3, t10) < i3;
}
const Yr = typeof $e.process < "u" && $e.process.env && /\bparse\b/.test($e.process.env.LOG);
let oh = null;
function oy(t10, e3, r3) {
  let n3 = t10.cursor(vt.IncludeAnonymous);
  for (n3.moveTo(e3); ; )
    if (!(r3 < 0 ? n3.childBefore(e3) : n3.childAfter(e3)))
      for (; ; ) {
        if ((r3 < 0 ? n3.to < e3 : n3.from > e3) && !n3.type.isError)
          return r3 < 0 ? Math.max(0, Math.min(
            n3.to - 1,
            e3 - 25
            /* Safety.Margin */
          )) : Math.min(t10.length, Math.max(
            n3.from + 1,
            e3 + 25
            /* Safety.Margin */
          ));
        if (r3 < 0 ? n3.prevSibling() : n3.nextSibling())
          break;
        if (!n3.parent())
          return r3 < 0 ? 0 : t10.length;
      }
}
class T4 {
  constructor(e3, r3) {
    this.fragments = e3, this.nodeSet = r3, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e3 = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e3) {
      for (this.safeFrom = e3.openStart ? oy(e3.tree, e3.from + e3.offset, 1) - e3.offset : e3.from, this.safeTo = e3.openEnd ? oy(e3.tree, e3.to + e3.offset, -1) - e3.offset : e3.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e3.tree), this.start.push(-e3.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e3) {
    if (e3 < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e3; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let r3 = this.trees.length - 1;
      if (r3 < 0)
        return this.nextFragment(), null;
      let n3 = this.trees[r3], i3 = this.index[r3];
      if (i3 == n3.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let o3 = n3.children[i3], s3 = this.start[r3] + n3.positions[i3];
      if (s3 > e3)
        return this.nextStart = s3, null;
      if (o3 instanceof ft) {
        if (s3 == e3) {
          if (s3 < this.safeFrom)
            return null;
          let a3 = s3 + o3.length;
          if (a3 <= this.safeTo) {
            let l3 = o3.prop(ut.lookAhead);
            if (!l3 || a3 + l3 < this.fragment.to)
              return o3;
          }
        }
        this.index[r3]++, s3 + o3.length >= Math.max(this.safeFrom, e3) && (this.trees.push(o3), this.start.push(s3), this.index.push(0));
      } else
        this.index[r3]++, this.nextStart = s3 + o3.length;
    }
  }
}
class k4 {
  constructor(e3, r3) {
    this.stream = r3, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e3.tokenizers.map((n3) => new Oc());
  }
  getActions(e3) {
    let r3 = 0, n3 = null, { parser: i3 } = e3.p, { tokenizers: o3 } = i3, s3 = i3.stateSlot(
      e3.state,
      3
      /* ParseState.TokenizerMask */
    ), a3 = e3.curContext ? e3.curContext.hash : 0, l3 = 0;
    for (let u3 = 0; u3 < o3.length; u3++) {
      if (!(1 << u3 & s3))
        continue;
      let c3 = o3[u3], f3 = this.tokens[u3];
      if (!(n3 && !c3.fallback) && ((c3.contextual || f3.start != e3.pos || f3.mask != s3 || f3.context != a3) && (this.updateCachedToken(f3, c3, e3), f3.mask = s3, f3.context = a3), f3.lookAhead > f3.end + 25 && (l3 = Math.max(f3.lookAhead, l3)), f3.value != 0)) {
        let d3 = r3;
        if (f3.extended > -1 && (r3 = this.addActions(e3, f3.extended, f3.end, r3)), r3 = this.addActions(e3, f3.value, f3.end, r3), !c3.extend && (n3 = f3, r3 > d3))
          break;
      }
    }
    for (; this.actions.length > r3; )
      this.actions.pop();
    return l3 && e3.setLookAhead(l3), !n3 && e3.pos == this.stream.end && (n3 = new Oc(), n3.value = e3.p.parser.eofTerm, n3.start = n3.end = e3.pos, r3 = this.addActions(e3, n3.value, n3.end, r3)), this.mainToken = n3, this.actions;
  }
  getMainToken(e3) {
    if (this.mainToken)
      return this.mainToken;
    let r3 = new Oc(), { pos: n3, p: i3 } = e3;
    return r3.start = n3, r3.end = Math.min(n3 + 1, i3.stream.end), r3.value = n3 == i3.stream.end ? i3.parser.eofTerm : 0, r3;
  }
  updateCachedToken(e3, r3, n3) {
    let i3 = this.stream.clipPos(n3.pos);
    if (r3.token(this.stream.reset(i3, e3), n3), e3.value > -1) {
      let { parser: o3 } = n3.p;
      for (let s3 = 0; s3 < o3.specialized.length; s3++)
        if (o3.specialized[s3] == e3.value) {
          let a3 = o3.specializers[s3](this.stream.read(e3.start, e3.end), n3);
          if (a3 >= 0 && n3.p.parser.dialect.allows(a3 >> 1)) {
            a3 & 1 ? e3.extended = a3 >> 1 : e3.value = a3 >> 1;
            break;
          }
        }
    } else
      e3.value = 0, e3.end = this.stream.clipPos(i3 + 1);
  }
  putAction(e3, r3, n3, i3) {
    for (let o3 = 0; o3 < i3; o3 += 3)
      if (this.actions[o3] == e3)
        return i3;
    return this.actions[i3++] = e3, this.actions[i3++] = r3, this.actions[i3++] = n3, i3;
  }
  addActions(e3, r3, n3, i3) {
    let { state: o3 } = e3, { parser: s3 } = e3.p, { data: a3 } = s3;
    for (let l3 = 0; l3 < 2; l3++)
      for (let u3 = s3.stateSlot(
        o3,
        l3 ? 2 : 1
        /* ParseState.Actions */
      ); ; u3 += 3) {
        if (a3[u3] == 65535)
          if (a3[u3 + 1] == 1)
            u3 = yi(a3, u3 + 2);
          else {
            i3 == 0 && a3[u3 + 1] == 2 && (i3 = this.putAction(yi(a3, u3 + 2), r3, n3, i3));
            break;
          }
        a3[u3] == r3 && (i3 = this.putAction(yi(a3, u3 + 1), r3, n3, i3));
      }
    return i3;
  }
}
let E4 = class {
  constructor(e3, r3, n3, i3) {
    this.parser = e3, this.input = r3, this.ranges = i3, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new x4(r3, i3), this.tokens = new k4(e3, this.stream), this.topTerm = e3.top[1];
    let { from: o3 } = i3[0];
    this.stacks = [Vc.start(this, e3.top[0], o3)], this.fragments = n3.length && this.stream.end - o3 > e3.bufferLength * 4 ? new T4(n3, e3.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e3 = this.stacks, r3 = this.minStackPos, n3 = this.stacks = [], i3, o3;
    if (this.bigReductionCount > 300 && e3.length == 1) {
      let [s3] = e3;
      for (; s3.forceReduce() && s3.stack.length && s3.stack[s3.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s3 = 0; s3 < e3.length; s3++) {
      let a3 = e3[s3];
      for (; ; ) {
        if (this.tokens.mainToken = null, a3.pos > r3)
          n3.push(a3);
        else {
          if (this.advanceStack(a3, n3, e3))
            continue;
          {
            i3 || (i3 = [], o3 = []), i3.push(a3);
            let l3 = this.tokens.getMainToken(a3);
            o3.push(l3.value, l3.end);
          }
        }
        break;
      }
    }
    if (!n3.length) {
      let s3 = i3 && R4(i3);
      if (s3)
        return Yr && console.log("Finish with " + this.stackID(s3)), this.stackToTree(s3);
      if (this.parser.strict)
        throw Yr && i3 && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + r3);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i3) {
      let s3 = this.stoppedAt != null && i3[0].pos > this.stoppedAt ? i3[0] : this.runRecovery(i3, o3, n3);
      if (s3)
        return Yr && console.log("Force-finish " + this.stackID(s3)), this.stackToTree(s3.forceAll());
    }
    if (this.recovering) {
      let s3 = this.recovering == 1 ? 1 : this.recovering * 3;
      if (n3.length > s3)
        for (n3.sort((a3, l3) => l3.score - a3.score); n3.length > s3; )
          n3.pop();
      n3.some((a3) => a3.reducePos > r3) && this.recovering--;
    } else if (n3.length > 1) {
      e:
        for (let s3 = 0; s3 < n3.length - 1; s3++) {
          let a3 = n3[s3];
          for (let l3 = s3 + 1; l3 < n3.length; l3++) {
            let u3 = n3[l3];
            if (a3.sameState(u3) || a3.buffer.length > 500 && u3.buffer.length > 500)
              if ((a3.score - u3.score || a3.buffer.length - u3.buffer.length) > 0)
                n3.splice(l3--, 1);
              else {
                n3.splice(s3--, 1);
                continue e;
              }
          }
        }
      n3.length > 12 && n3.splice(
        12,
        n3.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = n3[0].pos;
    for (let s3 = 1; s3 < n3.length; s3++)
      n3[s3].pos < this.minStackPos && (this.minStackPos = n3[s3].pos);
    return null;
  }
  stopAt(e3) {
    if (this.stoppedAt != null && this.stoppedAt < e3)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e3;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e3, r3, n3) {
    let i3 = e3.pos, { parser: o3 } = this, s3 = Yr ? this.stackID(e3) + " -> " : "";
    if (this.stoppedAt != null && i3 > this.stoppedAt)
      return e3.forceReduce() ? e3 : null;
    if (this.fragments) {
      let u3 = e3.curContext && e3.curContext.tracker.strict, c3 = u3 ? e3.curContext.hash : 0;
      for (let f3 = this.fragments.nodeAt(i3); f3; ) {
        let d3 = this.parser.nodeSet.types[f3.type.id] == f3.type ? o3.getGoto(e3.state, f3.type.id) : -1;
        if (d3 > -1 && f3.length && (!u3 || (f3.prop(ut.contextHash) || 0) == c3))
          return e3.useNode(f3, d3), Yr && console.log(s3 + this.stackID(e3) + ` (via reuse of ${o3.getName(f3.type.id)})`), true;
        if (!(f3 instanceof ft) || f3.children.length == 0 || f3.positions[0] > 0)
          break;
        let p10 = f3.children[0];
        if (p10 instanceof ft && f3.positions[0] == 0)
          f3 = p10;
        else
          break;
      }
    }
    let a3 = o3.stateSlot(
      e3.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a3 > 0)
      return e3.reduce(a3), Yr && console.log(s3 + this.stackID(e3) + ` (via always-reduce ${o3.getName(
        a3 & 65535
        /* Action.ValueMask */
      )})`), true;
    if (e3.stack.length >= 15e3)
      for (; e3.stack.length > 9e3 && e3.forceReduce(); )
        ;
    let l3 = this.tokens.getActions(e3);
    for (let u3 = 0; u3 < l3.length; ) {
      let c3 = l3[u3++], f3 = l3[u3++], d3 = l3[u3++], p10 = u3 == l3.length || !n3, h10 = p10 ? e3 : e3.split(), m10 = this.tokens.mainToken;
      if (h10.apply(c3, f3, m10 ? m10.start : h10.pos, d3), Yr && console.log(s3 + this.stackID(h10) + ` (via ${c3 & 65536 ? `reduce of ${o3.getName(
        c3 & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${o3.getName(f3)} @ ${i3}${h10 == e3 ? "" : ", split"})`), p10)
        return true;
      h10.pos > i3 ? r3.push(h10) : n3.push(h10);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e3, r3) {
    let n3 = e3.pos;
    for (; ; ) {
      if (!this.advanceStack(e3, null, null))
        return false;
      if (e3.pos > n3)
        return sy(e3, r3), true;
    }
  }
  runRecovery(e3, r3, n3) {
    let i3 = null, o3 = false;
    for (let s3 = 0; s3 < e3.length; s3++) {
      let a3 = e3[s3], l3 = r3[s3 << 1], u3 = r3[(s3 << 1) + 1], c3 = Yr ? this.stackID(a3) + " -> " : "";
      if (a3.deadEnd && (o3 || (o3 = true, a3.restart(), Yr && console.log(c3 + this.stackID(a3) + " (restarted)"), this.advanceFully(a3, n3))))
        continue;
      let f3 = a3.split(), d3 = c3;
      for (let p10 = 0; f3.forceReduce() && p10 < 10 && (Yr && console.log(d3 + this.stackID(f3) + " (via force-reduce)"), !this.advanceFully(f3, n3)); p10++)
        Yr && (d3 = this.stackID(f3) + " -> ");
      for (let p10 of a3.recoverByInsert(l3))
        Yr && console.log(c3 + this.stackID(p10) + " (via recover-insert)"), this.advanceFully(p10, n3);
      this.stream.end > a3.pos ? (u3 == a3.pos && (u3++, l3 = 0), a3.recoverByDelete(l3, u3), Yr && console.log(c3 + this.stackID(a3) + ` (via recover-delete ${this.parser.getName(l3)})`), sy(a3, n3)) : (!i3 || i3.score < a3.score) && (i3 = a3);
    }
    return i3;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e3) {
    return e3.close(), ft.build({
      buffer: Yc.create(e3),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e3.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e3) {
    let r3 = (oh || (oh = /* @__PURE__ */ new WeakMap())).get(e3);
    return r3 || oh.set(e3, r3 = String.fromCodePoint(this.nextStackID++)), r3 + e3;
  }
};
function sy(t10, e3) {
  for (let r3 = 0; r3 < e3.length; r3++) {
    let n3 = e3[r3];
    if (n3.pos == t10.pos && n3.sameState(t10)) {
      e3[r3].score < t10.score && (e3[r3] = t10);
      return;
    }
  }
  e3.push(t10);
}
class C4 {
  constructor(e3, r3, n3) {
    this.source = e3, this.flags = r3, this.disabled = n3;
  }
  allows(e3) {
    return !this.disabled || this.disabled[e3] == 0;
  }
}
const sh = (t10) => t10;
class Sg {
  /**
  Define a context tracker.
  */
  constructor(e3) {
    this.start = e3.start, this.shift = e3.shift || sh, this.reduce = e3.reduce || sh, this.reuse = e3.reuse || sh, this.hash = e3.hash || (() => 0), this.strict = e3.strict !== false;
  }
}
class Ci extends bg {
  /**
  @internal
  */
  constructor(e3) {
    if (super(), this.wrappers = [], e3.version != 14)
      throw new RangeError(`Parser version (${e3.version}) doesn't match runtime version (14)`);
    let r3 = e3.nodeNames.split(" ");
    this.minRepeatTerm = r3.length;
    for (let a3 = 0; a3 < e3.repeatNodeCount; a3++)
      r3.push("");
    let n3 = Object.keys(e3.topRules).map((a3) => e3.topRules[a3][1]), i3 = [];
    for (let a3 = 0; a3 < r3.length; a3++)
      i3.push([]);
    function o3(a3, l3, u3) {
      i3[a3].push([l3, l3.deserialize(String(u3))]);
    }
    if (e3.nodeProps)
      for (let a3 of e3.nodeProps) {
        let l3 = a3[0];
        typeof l3 == "string" && (l3 = ut[l3]);
        for (let u3 = 1; u3 < a3.length; ) {
          let c3 = a3[u3++];
          if (c3 >= 0)
            o3(c3, l3, a3[u3++]);
          else {
            let f3 = a3[u3 + -c3];
            for (let d3 = -c3; d3 > 0; d3--)
              o3(a3[u3++], l3, f3);
            u3++;
          }
        }
      }
    this.nodeSet = new Lf(r3.map((a3, l3) => $r.define({
      name: l3 >= this.minRepeatTerm ? void 0 : a3,
      id: l3,
      props: i3[l3],
      top: n3.indexOf(l3) > -1,
      error: l3 == 0,
      skipped: e3.skippedNodes && e3.skippedNodes.indexOf(l3) > -1
    }))), e3.propSources && (this.nodeSet = this.nodeSet.extend(...e3.propSources)), this.strict = false, this.bufferLength = s2;
    let s3 = il(e3.tokenData);
    this.context = e3.context, this.specializerSpecs = e3.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a3 = 0; a3 < this.specializerSpecs.length; a3++)
      this.specialized[a3] = this.specializerSpecs[a3].term;
    this.specializers = this.specializerSpecs.map(ay), this.states = il(e3.states, Uint32Array), this.data = il(e3.stateData), this.goto = il(e3.goto), this.maxTerm = e3.maxTerm, this.tokenizers = e3.tokenizers.map((a3) => typeof a3 == "number" ? new Bs(s3, a3) : a3), this.topRules = e3.topRules, this.dialects = e3.dialects || {}, this.dynamicPrecedences = e3.dynamicPrecedences || null, this.tokenPrecTable = e3.tokenPrec, this.termNames = e3.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e3, r3, n3) {
    let i3 = new E4(this, e3, r3, n3);
    for (let o3 of this.wrappers)
      i3 = o3(i3, e3, r3, n3);
    return i3;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e3, r3, n3 = false) {
    let i3 = this.goto;
    if (r3 >= i3[0])
      return -1;
    for (let o3 = i3[r3 + 1]; ; ) {
      let s3 = i3[o3++], a3 = s3 & 1, l3 = i3[o3++];
      if (a3 && n3)
        return l3;
      for (let u3 = o3 + (s3 >> 1); o3 < u3; o3++)
        if (i3[o3] == e3)
          return l3;
      if (a3)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e3, r3) {
    let n3 = this.data;
    for (let i3 = 0; i3 < 2; i3++)
      for (let o3 = this.stateSlot(
        e3,
        i3 ? 2 : 1
        /* ParseState.Actions */
      ), s3; ; o3 += 3) {
        if ((s3 = n3[o3]) == 65535)
          if (n3[o3 + 1] == 1)
            s3 = n3[o3 = yi(n3, o3 + 2)];
          else {
            if (n3[o3 + 1] == 2)
              return yi(n3, o3 + 2);
            break;
          }
        if (s3 == r3 || s3 == 0)
          return yi(n3, o3 + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e3, r3) {
    return this.states[e3 * 6 + r3];
  }
  /**
  @internal
  */
  stateFlag(e3, r3) {
    return (this.stateSlot(
      e3,
      0
      /* ParseState.Flags */
    ) & r3) > 0;
  }
  /**
  @internal
  */
  validAction(e3, r3) {
    return !!this.allActions(e3, (n3) => n3 == r3 ? true : null);
  }
  /**
  @internal
  */
  allActions(e3, r3) {
    let n3 = this.stateSlot(
      e3,
      4
      /* ParseState.DefaultReduce */
    ), i3 = n3 ? r3(n3) : void 0;
    for (let o3 = this.stateSlot(
      e3,
      1
      /* ParseState.Actions */
    ); i3 == null; o3 += 3) {
      if (this.data[o3] == 65535)
        if (this.data[o3 + 1] == 1)
          o3 = yi(this.data, o3 + 2);
        else
          break;
      i3 = r3(yi(this.data, o3 + 1));
    }
    return i3;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e3) {
    let r3 = [];
    for (let n3 = this.stateSlot(
      e3,
      1
      /* ParseState.Actions */
    ); ; n3 += 3) {
      if (this.data[n3] == 65535)
        if (this.data[n3 + 1] == 1)
          n3 = yi(this.data, n3 + 2);
        else
          break;
      if (!(this.data[n3 + 2] & 1)) {
        let i3 = this.data[n3 + 1];
        r3.some((o3, s3) => s3 & 1 && o3 == i3) || r3.push(this.data[n3], i3);
      }
    }
    return r3;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e3) {
    let r3 = Object.assign(Object.create(Ci.prototype), this);
    if (e3.props && (r3.nodeSet = this.nodeSet.extend(...e3.props)), e3.top) {
      let n3 = this.topRules[e3.top];
      if (!n3)
        throw new RangeError(`Invalid top rule name ${e3.top}`);
      r3.top = n3;
    }
    return e3.tokenizers && (r3.tokenizers = this.tokenizers.map((n3) => {
      let i3 = e3.tokenizers.find((o3) => o3.from == n3);
      return i3 ? i3.to : n3;
    })), e3.specializers && (r3.specializers = this.specializers.slice(), r3.specializerSpecs = this.specializerSpecs.map((n3, i3) => {
      let o3 = e3.specializers.find((a3) => a3.from == n3.external);
      if (!o3)
        return n3;
      let s3 = Object.assign(Object.assign({}, n3), { external: o3.to });
      return r3.specializers[i3] = ay(s3), s3;
    })), e3.contextTracker && (r3.context = e3.contextTracker), e3.dialect && (r3.dialect = this.parseDialect(e3.dialect)), e3.strict != null && (r3.strict = e3.strict), e3.wrap && (r3.wrappers = r3.wrappers.concat(e3.wrap)), e3.bufferLength != null && (r3.bufferLength = e3.bufferLength), r3;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e3) {
    return this.termNames ? this.termNames[e3] : String(e3 <= this.maxNode && this.nodeSet.types[e3].name || e3);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e3) {
    let r3 = this.dynamicPrecedences;
    return r3 == null ? 0 : r3[e3] || 0;
  }
  /**
  @internal
  */
  parseDialect(e3) {
    let r3 = Object.keys(this.dialects), n3 = r3.map(() => false);
    if (e3)
      for (let o3 of e3.split(" ")) {
        let s3 = r3.indexOf(o3);
        s3 >= 0 && (n3[s3] = true);
      }
    let i3 = null;
    for (let o3 = 0; o3 < r3.length; o3++)
      if (!n3[o3])
        for (let s3 = this.dialects[r3[o3]], a3; (a3 = this.data[s3++]) != 65535; )
          (i3 || (i3 = new Uint8Array(this.maxTerm + 1)))[a3] = 1;
    return new C4(e3, n3, i3);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e3) {
    return new Ci(e3);
  }
}
function yi(t10, e3) {
  return t10[e3] | t10[e3 + 1] << 16;
}
function R4(t10) {
  let e3 = null;
  for (let r3 of t10) {
    let n3 = r3.p.stoppedAt;
    (r3.pos == r3.p.stream.end || n3 != null && r3.pos > n3) && r3.p.parser.stateFlag(
      r3.state,
      2
      /* StateFlag.Accepting */
    ) && (!e3 || e3.score < r3.score) && (e3 = r3);
  }
  return e3;
}
function ay(t10) {
  if (t10.external) {
    let e3 = t10.extend ? 1 : 0;
    return (r3, n3) => t10.external(r3, n3) << 1 | e3;
  }
  return t10.get;
}
let A4 = 0;
class Vn {
  /**
  @internal
  */
  constructor(e3, r3, n3) {
    this.set = e3, this.base = r3, this.modified = n3, this.id = A4++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e3) {
    if (e3 != null && e3.base)
      throw new Error("Can not derive from a modified tag");
    let r3 = new Vn([], null, []);
    if (r3.set.push(r3), e3)
      for (let n3 of e3.set)
        r3.set.push(n3);
    return r3;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e3 = new Bc();
    return (r3) => r3.modified.indexOf(e3) > -1 ? r3 : Bc.get(r3.base || r3, r3.modified.concat(e3).sort((n3, i3) => n3.id - i3.id));
  }
}
let X4 = 0;
class Bc {
  constructor() {
    this.instances = [], this.id = X4++;
  }
  static get(e3, r3) {
    if (!r3.length)
      return e3;
    let n3 = r3[0].instances.find((a3) => a3.base == e3 && q4(r3, a3.modified));
    if (n3)
      return n3;
    let i3 = [], o3 = new Vn(i3, e3, r3);
    for (let a3 of r3)
      a3.instances.push(o3);
    let s3 = D4(r3);
    for (let a3 of e3.set)
      if (!a3.modified.length)
        for (let l3 of s3)
          i3.push(Bc.get(a3, l3));
    return o3;
  }
}
function q4(t10, e3) {
  return t10.length == e3.length && t10.every((r3, n3) => r3 == e3[n3]);
}
function D4(t10) {
  let e3 = [[]];
  for (let r3 = 0; r3 < t10.length; r3++)
    for (let n3 = 0, i3 = e3.length; n3 < i3; n3++)
      e3.push(e3[n3].concat(t10[r3]));
  return e3.sort((r3, n3) => n3.length - r3.length);
}
function Os(t10) {
  let e3 = /* @__PURE__ */ Object.create(null);
  for (let r3 in t10) {
    let n3 = t10[r3];
    Array.isArray(n3) || (n3 = [n3]);
    for (let i3 of r3.split(" "))
      if (i3) {
        let o3 = [], s3 = 2, a3 = i3;
        for (let f3 = 0; ; ) {
          if (a3 == "..." && f3 > 0 && f3 + 3 == i3.length) {
            s3 = 1;
            break;
          }
          let d3 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a3);
          if (!d3)
            throw new RangeError("Invalid path: " + i3);
          if (o3.push(d3[0] == "*" ? "" : d3[0][0] == '"' ? JSON.parse(d3[0]) : d3[0]), f3 += d3[0].length, f3 == i3.length)
            break;
          let p10 = i3[f3++];
          if (f3 == i3.length && p10 == "!") {
            s3 = 0;
            break;
          }
          if (p10 != "/")
            throw new RangeError("Invalid path: " + i3);
          a3 = i3.slice(f3);
        }
        let l3 = o3.length - 1, u3 = o3[l3];
        if (!u3)
          throw new RangeError("Invalid path: " + i3);
        let c3 = new zc(n3, s3, l3 > 0 ? o3.slice(0, l3) : null);
        e3[u3] = c3.sort(e3[u3]);
      }
  }
  return f2.add(e3);
}
const f2 = new ut();
class zc {
  constructor(e3, r3, n3, i3) {
    this.tags = e3, this.mode = r3, this.context = n3, this.next = i3;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e3) {
    return !e3 || e3.depth < this.depth ? (this.next = e3, this) : (e3.next = this.sort(e3.next), e3);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
zc.empty = new zc([], 2, null);
function d2(t10, e3) {
  let r3 = /* @__PURE__ */ Object.create(null);
  for (let o3 of t10)
    if (!Array.isArray(o3.tag))
      r3[o3.tag.id] = o3.class;
    else
      for (let s3 of o3.tag)
        r3[s3.id] = o3.class;
  let { scope: n3, all: i3 = null } = e3 || {};
  return {
    style: (o3) => {
      let s3 = i3;
      for (let a3 of o3)
        for (let l3 of a3.set) {
          let u3 = r3[l3.id];
          if (u3) {
            s3 = s3 ? s3 + " " + u3 : u3;
            break;
          }
        }
      return s3;
    },
    scope: n3
  };
}
function j4(t10, e3) {
  let r3 = null;
  for (let n3 of t10) {
    let i3 = n3.style(e3);
    i3 && (r3 = r3 ? r3 + " " + i3 : i3);
  }
  return r3;
}
function U4(t10, e3, r3, n3 = 0, i3 = t10.length) {
  let o3 = new I4(n3, Array.isArray(e3) ? e3 : [e3], r3);
  o3.highlightRange(t10.cursor(), n3, i3, "", o3.highlighters), o3.flush(i3);
}
class I4 {
  constructor(e3, r3, n3) {
    this.at = e3, this.highlighters = r3, this.span = n3, this.class = "";
  }
  startSpan(e3, r3) {
    r3 != this.class && (this.flush(e3), e3 > this.at && (this.at = e3), this.class = r3);
  }
  flush(e3) {
    e3 > this.at && this.class && this.span(this.at, e3, this.class);
  }
  highlightRange(e3, r3, n3, i3, o3) {
    let { type: s3, from: a3, to: l3 } = e3;
    if (a3 >= n3 || l3 <= r3)
      return;
    s3.isTop && (o3 = this.highlighters.filter((p10) => !p10.scope || p10.scope(s3)));
    let u3 = i3, c3 = F4(e3) || zc.empty, f3 = j4(o3, c3.tags);
    if (f3 && (u3 && (u3 += " "), u3 += f3, c3.mode == 1 && (i3 += (i3 ? " " : "") + f3)), this.startSpan(Math.max(r3, a3), u3), c3.opaque)
      return;
    let d3 = e3.tree && e3.tree.prop(ut.mounted);
    if (d3 && d3.overlay) {
      let p10 = e3.node.enter(d3.overlay[0].from + a3, 1), h10 = this.highlighters.filter((O10) => !O10.scope || O10.scope(d3.tree.type)), m10 = e3.firstChild();
      for (let O10 = 0, g = a3; ; O10++) {
        let v10 = O10 < d3.overlay.length ? d3.overlay[O10] : null, S10 = v10 ? v10.from + a3 : l3, $10 = Math.max(r3, g), _10 = Math.min(n3, S10);
        if ($10 < _10 && m10)
          for (; e3.from < _10 && (this.highlightRange(e3, $10, _10, i3, o3), this.startSpan(Math.min(_10, e3.to), u3), !(e3.to >= S10 || !e3.nextSibling())); )
            ;
        if (!v10 || S10 > n3)
          break;
        g = v10.to + a3, g > r3 && (this.highlightRange(p10.cursor(), Math.max(r3, v10.from + a3), Math.min(n3, g), "", h10), this.startSpan(Math.min(n3, g), u3));
      }
      m10 && e3.parent();
    } else if (e3.firstChild()) {
      d3 && (i3 = "");
      do
        if (!(e3.to <= r3)) {
          if (e3.from >= n3)
            break;
          this.highlightRange(e3, r3, n3, i3, o3), this.startSpan(Math.min(n3, e3.to), u3);
        }
      while (e3.nextSibling());
      e3.parent();
    }
  }
}
function F4(t10) {
  let e3 = t10.type.prop(f2);
  for (; e3 && e3.context && !t10.matchContext(e3.context); )
    e3 = e3.next;
  return e3 || null;
}
const Se = Vn.define, Iu = Se(), Gi = Se(), ly = Se(Gi), uy = Se(Gi), Ki = Se(), Fu = Se(Ki), ah = Se(Ki), Zn = Se(), ko = Se(Zn), Un = Se(), In = Se(), Fp = Se(), Na = Se(Fp), Zu = Se(), R = {
  /**
  A comment.
  */
  comment: Iu,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: Se(Iu),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: Se(Iu),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: Se(Iu),
  /**
  Any kind of identifier.
  */
  name: Gi,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: Se(Gi),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: ly,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: Se(ly),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: uy,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: Se(uy),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: Se(Gi),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: Se(Gi),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: Se(Gi),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: Se(Gi),
  /**
  A literal value.
  */
  literal: Ki,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Fu,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: Se(Fu),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: Se(Fu),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: Se(Fu),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: ah,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: Se(ah),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: Se(ah),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: Se(Ki),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: Se(Ki),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: Se(Ki),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: Se(Ki),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: Se(Ki),
  /**
  A language keyword.
  */
  keyword: Un,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: Se(Un),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: Se(Un),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: Se(Un),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: Se(Un),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: Se(Un),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: Se(Un),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: Se(Un),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: Se(Un),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: Se(Un),
  /**
  An operator.
  */
  operator: In,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: Se(In),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: Se(In),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: Se(In),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: Se(In),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: Se(In),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: Se(In),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: Se(In),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: Se(In),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: Se(In),
  /**
  Program or markup punctuation.
  */
  punctuation: Fp,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: Se(Fp),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Na,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: Se(Na),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: Se(Na),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: Se(Na),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: Se(Na),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Zn,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: ko,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: Se(ko),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: Se(ko),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: Se(ko),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: Se(ko),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: Se(ko),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: Se(ko),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: Se(Zn),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: Se(Zn),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: Se(Zn),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: Se(Zn),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: Se(Zn),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: Se(Zn),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: Se(Zn),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: Se(Zn),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: Se(),
  /**
  Deleted text.
  */
  deleted: Se(),
  /**
  Changed text.
  */
  changed: Se(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: Se(),
  /**
  Metadata or meta-instruction.
  */
  meta: Zu,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: Se(Zu),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: Se(Zu),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: Se(Zu),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Vn.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Vn.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Vn.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Vn.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Vn.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Vn.defineModifier()
};
d2([
  { tag: R.link, class: "tok-link" },
  { tag: R.heading, class: "tok-heading" },
  { tag: R.emphasis, class: "tok-emphasis" },
  { tag: R.strong, class: "tok-strong" },
  { tag: R.keyword, class: "tok-keyword" },
  { tag: R.atom, class: "tok-atom" },
  { tag: R.bool, class: "tok-bool" },
  { tag: R.url, class: "tok-url" },
  { tag: R.labelName, class: "tok-labelName" },
  { tag: R.inserted, class: "tok-inserted" },
  { tag: R.deleted, class: "tok-deleted" },
  { tag: R.literal, class: "tok-literal" },
  { tag: R.string, class: "tok-string" },
  { tag: R.number, class: "tok-number" },
  { tag: [R.regexp, R.escape, R.special(R.string)], class: "tok-string2" },
  { tag: R.variableName, class: "tok-variableName" },
  { tag: R.local(R.variableName), class: "tok-variableName tok-local" },
  { tag: R.definition(R.variableName), class: "tok-variableName tok-definition" },
  { tag: R.special(R.variableName), class: "tok-variableName2" },
  { tag: R.definition(R.propertyName), class: "tok-propertyName tok-definition" },
  { tag: R.typeName, class: "tok-typeName" },
  { tag: R.namespace, class: "tok-namespace" },
  { tag: R.className, class: "tok-className" },
  { tag: R.macroName, class: "tok-macroName" },
  { tag: R.propertyName, class: "tok-propertyName" },
  { tag: R.operator, class: "tok-operator" },
  { tag: R.comment, class: "tok-comment" },
  { tag: R.meta, class: "tok-meta" },
  { tag: R.invalid, class: "tok-invalid" },
  { tag: R.punctuation, class: "tok-punctuation" }
]);
const Z4 = 54, M4 = 1, N4 = 55, W4 = 2, V4 = 56, Y4 = 3, cy = 4, L4 = 5, Hc = 6, h2 = 7, p2 = 8, O2 = 9, m2 = 10, B4 = 11, z4 = 12, H4 = 13, lh = 57, G4 = 14, fy = 58, g2 = 20, K4 = 22, y2 = 23, J4 = 24, Zp = 26, v2 = 27, eC = 28, tC = 31, rC = 34, nC = 36, iC = 37, oC = 0, sC = 1, aC = {
  area: true,
  base: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
  menuitem: true
}, lC = {
  dd: true,
  li: true,
  optgroup: true,
  option: true,
  p: true,
  rp: true,
  rt: true,
  tbody: true,
  td: true,
  tfoot: true,
  th: true,
  tr: true
}, dy = {
  dd: { dd: true, dt: true },
  dt: { dd: true, dt: true },
  li: { li: true },
  option: { option: true, optgroup: true },
  optgroup: { optgroup: true },
  p: {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    dir: true,
    div: true,
    dl: true,
    fieldset: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    menu: true,
    nav: true,
    ol: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    ul: true
  },
  rp: { rp: true, rt: true },
  rt: { rp: true, rt: true },
  tbody: { tbody: true, tfoot: true },
  td: { td: true, th: true },
  tfoot: { tbody: true },
  th: { td: true, th: true },
  thead: { tbody: true, tfoot: true },
  tr: { tr: true }
};
function uC(t10) {
  return t10 == 45 || t10 == 46 || t10 == 58 || t10 >= 65 && t10 <= 90 || t10 == 95 || t10 >= 97 && t10 <= 122 || t10 >= 161;
}
function b2(t10) {
  return t10 == 9 || t10 == 10 || t10 == 13 || t10 == 32;
}
let hy = null, py = null, Oy = 0;
function Mp(t10, e3) {
  let r3 = t10.pos + e3;
  if (Oy == r3 && py == t10)
    return hy;
  let n3 = t10.peek(e3);
  for (; b2(n3); )
    n3 = t10.peek(++e3);
  let i3 = "";
  for (; uC(n3); )
    i3 += String.fromCharCode(n3), n3 = t10.peek(++e3);
  return py = t10, Oy = r3, hy = i3 ? i3.toLowerCase() : n3 == cC || n3 == fC ? void 0 : null;
}
const S2 = 60, Gc = 62, $g = 47, cC = 63, fC = 33, dC = 45;
function my(t10, e3) {
  this.name = t10, this.parent = e3, this.hash = e3 ? e3.hash : 0;
  for (let r3 = 0; r3 < t10.length; r3++)
    this.hash += (this.hash << 4) + t10.charCodeAt(r3) + (t10.charCodeAt(r3) << 8);
}
const hC = [Hc, m2, h2, p2, O2], pC = new Sg({
  start: null,
  shift(t10, e3, r3, n3) {
    return hC.indexOf(e3) > -1 ? new my(Mp(n3, 1) || "", t10) : t10;
  },
  reduce(t10, e3) {
    return e3 == g2 && t10 ? t10.parent : t10;
  },
  reuse(t10, e3, r3, n3) {
    let i3 = e3.type.id;
    return i3 == Hc || i3 == nC ? new my(Mp(n3, 1) || "", t10) : t10;
  },
  hash(t10) {
    return t10 ? t10.hash : 0;
  },
  strict: false
}), OC = new Wr((t10, e3) => {
  if (t10.next != S2) {
    t10.next < 0 && e3.context && t10.acceptToken(lh);
    return;
  }
  t10.advance();
  let r3 = t10.next == $g;
  r3 && t10.advance();
  let n3 = Mp(t10, 0);
  if (n3 === void 0)
    return;
  if (!n3)
    return t10.acceptToken(r3 ? G4 : Hc);
  let i3 = e3.context ? e3.context.name : null;
  if (r3) {
    if (n3 == i3)
      return t10.acceptToken(B4);
    if (i3 && lC[i3])
      return t10.acceptToken(lh, -2);
    if (e3.dialectEnabled(oC))
      return t10.acceptToken(z4);
    for (let o3 = e3.context; o3; o3 = o3.parent)
      if (o3.name == n3)
        return;
    t10.acceptToken(H4);
  } else {
    if (n3 == "script")
      return t10.acceptToken(h2);
    if (n3 == "style")
      return t10.acceptToken(p2);
    if (n3 == "textarea")
      return t10.acceptToken(O2);
    if (aC.hasOwnProperty(n3))
      return t10.acceptToken(m2);
    i3 && dy[i3] && dy[i3][n3] ? t10.acceptToken(lh, -1) : t10.acceptToken(Hc);
  }
}, { contextual: true }), mC = new Wr((t10) => {
  for (let e3 = 0, r3 = 0; ; r3++) {
    if (t10.next < 0) {
      r3 && t10.acceptToken(fy);
      break;
    }
    if (t10.next == dC)
      e3++;
    else if (t10.next == Gc && e3 >= 2) {
      r3 > 3 && t10.acceptToken(fy, -2);
      break;
    } else
      e3 = 0;
    t10.advance();
  }
});
function gC(t10) {
  for (; t10; t10 = t10.parent)
    if (t10.name == "svg" || t10.name == "math")
      return true;
  return false;
}
const yC = new Wr((t10, e3) => {
  if (t10.next == $g && t10.peek(1) == Gc) {
    let r3 = e3.dialectEnabled(sC) || gC(e3.context);
    t10.acceptToken(r3 ? L4 : cy, 2);
  } else
    t10.next == Gc && t10.acceptToken(cy, 1);
});
function wg(t10, e3, r3) {
  let n3 = 2 + t10.length;
  return new Wr((i3) => {
    for (let o3 = 0, s3 = 0, a3 = 0; ; a3++) {
      if (i3.next < 0) {
        a3 && i3.acceptToken(e3);
        break;
      }
      if (o3 == 0 && i3.next == S2 || o3 == 1 && i3.next == $g || o3 >= 2 && o3 < n3 && i3.next == t10.charCodeAt(o3 - 2))
        o3++, s3++;
      else if ((o3 == 2 || o3 == n3) && b2(i3.next))
        s3++;
      else if (o3 == n3 && i3.next == Gc) {
        a3 > s3 ? i3.acceptToken(e3, -s3) : i3.acceptToken(r3, -(s3 - 2));
        break;
      } else if ((i3.next == 10 || i3.next == 13) && a3) {
        i3.acceptToken(e3, 1);
        break;
      } else
        o3 = s3 = 0;
      i3.advance();
    }
  });
}
const vC = wg("script", Z4, M4), bC = wg("style", N4, W4), SC = wg("textarea", V4, Y4), $C = Os({
  "Text RawText": R.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": R.angleBracket,
  TagName: R.tagName,
  "MismatchedCloseTag/TagName": [R.tagName, R.invalid],
  AttributeName: R.attributeName,
  "AttributeValue UnquotedAttributeValue": R.attributeValue,
  Is: R.definitionOperator,
  "EntityReference CharacterReference": R.character,
  Comment: R.blockComment,
  ProcessingInst: R.processingInstruction,
  DoctypeDecl: R.documentMeta
}), wC = Ci.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: pC,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"]
  ],
  propSources: [$C],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [vC, bC, SC, yC, OC, mC, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function $2(t10, e3) {
  let r3 = /* @__PURE__ */ Object.create(null);
  for (let n3 of t10.getChildren(y2)) {
    let i3 = n3.getChild(J4), o3 = n3.getChild(Zp) || n3.getChild(v2);
    i3 && (r3[e3.read(i3.from, i3.to)] = o3 ? o3.type.id == Zp ? e3.read(o3.from + 1, o3.to - 1) : e3.read(o3.from, o3.to) : "");
  }
  return r3;
}
function gy(t10, e3) {
  let r3 = t10.getChild(K4);
  return r3 ? e3.read(r3.from, r3.to) : " ";
}
function uh(t10, e3, r3) {
  let n3;
  for (let i3 of r3)
    if (!i3.attrs || i3.attrs(n3 || (n3 = $2(t10.node.parent.firstChild, e3))))
      return { parser: i3.parser };
  return null;
}
function w2(t10 = [], e3 = []) {
  let r3 = [], n3 = [], i3 = [], o3 = [];
  for (let a3 of t10)
    (a3.tag == "script" ? r3 : a3.tag == "style" ? n3 : a3.tag == "textarea" ? i3 : o3).push(a3);
  let s3 = e3.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a3 of e3)
    (s3[a3.name] || (s3[a3.name] = [])).push(a3);
  return y4((a3, l3) => {
    let u3 = a3.type.id;
    if (u3 == eC)
      return uh(a3, l3, r3);
    if (u3 == tC)
      return uh(a3, l3, n3);
    if (u3 == rC)
      return uh(a3, l3, i3);
    if (u3 == g2 && o3.length) {
      let c3 = a3.node, f3 = c3.firstChild, d3 = f3 && gy(f3, l3), p10;
      if (d3) {
        for (let h10 of o3)
          if (h10.tag == d3 && (!h10.attrs || h10.attrs(p10 || (p10 = $2(c3, l3))))) {
            let m10 = c3.lastChild;
            return { parser: h10.parser, overlay: [{ from: f3.to, to: m10.type.id == iC ? m10.from : c3.to }] };
          }
      }
    }
    if (s3 && u3 == y2) {
      let c3 = a3.node, f3;
      if (f3 = c3.firstChild) {
        let d3 = s3[l3.read(f3.from, f3.to)];
        if (d3)
          for (let p10 of d3) {
            if (p10.tagName && p10.tagName != gy(c3.parent, l3))
              continue;
            let h10 = c3.lastChild;
            if (h10.type.id == Zp) {
              let m10 = h10.from + 1, O10 = h10.lastChild, g = h10.to - (O10 && O10.isError ? 0 : 1);
              if (g > m10)
                return { parser: p10.parser, overlay: [{ from: m10, to: g }] };
            } else if (h10.type.id == v2)
              return { parser: p10.parser, overlay: [{ from: h10.from, to: h10.to }] };
          }
      }
    }
    return null;
  });
}
const PC = 96, yy = 1, _C = 97, xC = 98, vy = 2, P2 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], QC = 58, TC = 40, _2 = 95, kC = 91, mc = 45, EC = 46, CC = 35, RC = 37;
function Kc(t10) {
  return t10 >= 65 && t10 <= 90 || t10 >= 97 && t10 <= 122 || t10 >= 161;
}
function AC(t10) {
  return t10 >= 48 && t10 <= 57;
}
const XC = new Wr((t10, e3) => {
  for (let r3 = false, n3 = 0, i3 = 0; ; i3++) {
    let { next: o3 } = t10;
    if (Kc(o3) || o3 == mc || o3 == _2 || r3 && AC(o3))
      !r3 && (o3 != mc || i3 > 0) && (r3 = true), n3 === i3 && o3 == mc && n3++, t10.advance();
    else {
      r3 && t10.acceptToken(o3 == TC ? _C : n3 == 2 && e3.canShift(vy) ? vy : xC);
      break;
    }
  }
}), qC = new Wr((t10) => {
  if (P2.includes(t10.peek(-1))) {
    let { next: e3 } = t10;
    (Kc(e3) || e3 == _2 || e3 == CC || e3 == EC || e3 == kC || e3 == QC || e3 == mc) && t10.acceptToken(PC);
  }
}), DC = new Wr((t10) => {
  if (!P2.includes(t10.peek(-1))) {
    let { next: e3 } = t10;
    if (e3 == RC && (t10.advance(), t10.acceptToken(yy)), Kc(e3)) {
      do
        t10.advance();
      while (Kc(t10.next));
      t10.acceptToken(yy);
    }
  }
}), jC = Os({
  "AtKeyword import charset namespace keyframes media supports": R.definitionKeyword,
  "from to selector": R.keyword,
  NamespaceName: R.namespace,
  KeyframeName: R.labelName,
  KeyframeRangeName: R.operatorKeyword,
  TagName: R.tagName,
  ClassName: R.className,
  PseudoClassName: R.constant(R.className),
  IdName: R.labelName,
  "FeatureName PropertyName": R.propertyName,
  AttributeName: R.attributeName,
  NumberLiteral: R.number,
  KeywordQuery: R.keyword,
  UnaryQueryOp: R.operatorKeyword,
  "CallTag ValueName": R.atom,
  VariableName: R.variableName,
  Callee: R.operatorKeyword,
  Unit: R.unit,
  "UniversalSelector NestingSelector": R.definitionOperator,
  MatchOp: R.compareOperator,
  "ChildOp SiblingOp, LogicOp": R.logicOperator,
  BinOp: R.arithmeticOperator,
  Important: R.modifier,
  Comment: R.blockComment,
  ColorLiteral: R.color,
  "ParenthesizedContent StringLiteral": R.string,
  ":": R.punctuation,
  "PseudoOp #": R.derefOperator,
  "; ,": R.separator,
  "( )": R.paren,
  "[ ]": R.squareBracket,
  "{ }": R.brace
}), UC = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 }, IC = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 }, FC = { __proto__: null, not: 128, only: 128 }, ZC = Ci.deserialize({
  version: 14,
  states: "9bQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DPO$vQ[O'#DTOOQP'#Ej'#EjO${QdO'#DeO%gQ[O'#DrO${QdO'#DtO%xQ[O'#DvO&TQ[O'#DyO&]Q[O'#EPO&kQ[O'#EROOQS'#Ei'#EiOOQS'#EU'#EUQYQ[OOO&rQXO'#CdO'gQWO'#DaO'lQWO'#EpO'wQ[O'#EpQOQWOOP(RO#tO'#C_POOO)C@X)C@XOOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(^Q[O'#EXO(xQWO,58{O)QQ[O,59SO$qQ[O,59kO$vQ[O,59oO(^Q[O,59sO(^Q[O,59uO(^Q[O,59vO)]Q[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)dQWO,59SO)iQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)nQ`O,59oOOQS'#Cp'#CpO${QdO'#CqO)vQvO'#CsO+TQtO,5:POOQO'#Cx'#CxO)iQWO'#CwO+iQWO'#CyOOQS'#Em'#EmOOQO'#Dh'#DhO+nQ[O'#DoO+|QWO'#EqO&]Q[O'#DmO,[QWO'#DpOOQO'#Er'#ErO({QWO,5:^O,aQpO,5:`OOQS'#Dx'#DxO,iQWO,5:bO,nQ[O,5:bOOQO'#D{'#D{O,vQWO,5:eO,{QWO,5:kO-TQWO,5:mOOQS-E8S-E8SO${QdO,59{O-]Q[O'#EZO-jQWO,5;[O-jQWO,5;[POOO'#ET'#ETP-uO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.lQXO,5:sOOQO-E8V-E8VOOQS1G.g1G.gOOQP1G.n1G.nO)dQWO1G.nO)iQWO1G.nOOQP1G/V1G/VO.yQ`O1G/ZO/dQXO1G/_O/zQXO1G/aO0bQXO1G/bO0xQWO,59zO0}Q[O'#DOO1UQdO'#CoOOQP1G/Z1G/ZO${QdO1G/ZO1]QpO,59]OOQS,59_,59_O${QdO,59aO1eQWO1G/kOOQS,59c,59cO1jQ!bO,59eO1rQWO'#DhO1}QWO,5:TO2SQWO,5:ZO&]Q[O,5:VO&]Q[O'#E[O2[QWO,5;]O2gQWO,5:XO(^Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2xQWO1G/|O2}QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO3YQtO1G/gOOQO,5:u,5:uO3pQ[O,5:uOOQO-E8X-E8XO3}QWO1G0vPOOO-E8R-E8RPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$u7+$uO${QdO7+$uOOQS1G/f1G/fO4YQXO'#EoO4aQWO,59jO4fQtO'#EVO5ZQdO'#ElO5eQWO,59ZO5jQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5rQWO1G/PO${QdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5wQWO,5:vOOQO-E8Y-E8YO6VQXO1G/vOOQS7+%h7+%hO6^QYO'#CsOOQO'#EO'#EOO6iQ`O'#D}OOQO'#D}'#D}O6tQWO'#E]O6|QdO,5:hOOQS,5:h,5:hO7XQtO'#EYO${QdO'#EYO8VQdO7+%ROOQO7+%R7+%ROOQO1G0a1G0aO8jQpO<<HaO8rQWO,5;ZOOQP1G/U1G/UOOQS-E8T-E8TO${QdO'#EWO8zQWO,5;WOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO9SQdO7+%ZOOQO7+%b7+%bOOQO,5:i,5:iO3QQdO'#E^O6tQWO,5:wOOQS,5:w,5:wOOQS-E8Z-E8ZOOQS1G0S1G0SO9ZQtO,5:tOOQS-E8W-E8WOOQO<<Hm<<HmOOQPAN={AN={O:XQdO,5:rOOQO-E8U-E8UOOQO<<Hu<<HuOOQO,5:x,5:xOOQO-E8[-E8[OOQS1G0c1G0c",
  stateData: ":k~O#WOS#XQQ~OUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#URO#_TO~OQfOUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#UeO#_TO~O#R#dP~P!ZO#XjO~O#UlO~O]qO^qOpoOtrOxsO|tO!PvO#SuO#_nO~O!RwO~P#pO`}O#TzO#UyO~O#U!OO~O#U!QO~OQ!ZOb!TOf!ZOh!ZOn!YO#T!WO#U!SO#b!UO~Ob!]O!b!_O!e!`O#U![O!R#eP~Oh!eOn!YO#U!dO~Oh!gO#U!gO~Ob!]O!b!_O!e!`O#U![O~O!W#eP~P%gO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#SWX#_WX~O]!lO~O!W!mO#R#dX!Q#dX~O#R#dX!Q#dX~P!ZO#Y!pO#Z!pO#[!rO~OUYOXYO]VO^VOtWOxXO#URO#_TO~OpoO!RwO~O`!yO#TzO#UyO~O!Q#dP~P!ZOb#QO~Ob#RO~Ov#SOz#TO~OP#VObgXjgX!WgX!bgX!egX#UgXagXQgXfgXhgXngXpgX!VgX#RgX#TgX#bgXvgX!QgX~Ob!]Oj#WO!b!_O!e!`O#U![O!W#eP~Ob#ZO~Ob!]O!b!_O!e!`O#U#[O~Op#`O!`#_O!R#eX!W#eX~Ob#cO~Oj#WO!W#eO~O!W#fO~Oh#gOn!YO~O!R#hO~O!RwO!`#_O~O!RwO!W#kO~O!W!}X#R!}X!Q!}X~P!ZO!W!mO#R#da!Q#da~O#Y!pO#Z!pO#[#rO~O]qO^qOtrOxsO|tO!PvO#SuO#_nO~Op!{a!R!{aa!{a~P.QOv#tOz#uO~O]qO^qOtrOxsO#_nO~Op{i|{i!P{i!R{i#S{ia{i~P/ROp}i|}i!P}i!R}i#S}ia}i~P/ROp!Oi|!Oi!P!Oi!R!Oi#S!Oia!Oi~P/RO!Q#vO~Oa#cP~P(^Oa#`P~P${Oa#}Oj#WO~O!W$PO~Oh$QOo$QO~O]!^Xa![X!`![X~O]$RO~Oa$SO!`#_O~Op#`O!R#ea!W#ea~O!`#_Op!aa!R!aa!W!aaa!aa~O!W$XO~O!Q$`O#U$ZO#b$YO~Oj#WOp$bO!V$dO!W!Ti#R!Ti!Q!Ti~P${O!W!}a#R!}a!Q!}a~P!ZO!W!mO#R#di!Q#di~Oa#cX~P#pOa$hO~Oj#WOQ!yXa!yXb!yXf!yXh!yXn!yXp!yX#T!yX#U!yX#b!yX~Op$jOa#`X~P${Oa$lO~Oj#WOv$mO~Oa$nO~O!`#_Op#Oa!R#Oa!W#Oa~Oa$pO~P.QOP#VOpgX!RgX~O#b$YOp!qX!R!qX~Op$rO!RwO~O!Q$vO#U$ZO#b$YO~Oj#WOQ!|Xb!|Xf!|Xh!|Xn!|Xp!|X!V!|X!W!|X#R!|X#T!|X#U!|X#b!|X!Q!|X~Op$bO!V$yO!W!Tq#R!Tq!Q!Tq~P${Oj#WOv$zO~OpoOa#ca~Op$jOa#`a~Oa$}O~P${Oj#WOQ!|ab!|af!|ah!|an!|ap!|a!V!|a!W!|a#R!|a#T!|a#U!|a#b!|a!Q!|a~Oa!zap!za~P${O#Wo#X#bj!P#b~",
  goto: "-Y#gPPP#hP#kP#t$TP#t$d#tPP$jPPP$p$y$yP%]P$yP$y%w&ZPPP&s&y#tP'PP#tP'VP#tP#t#tPPP']'r(PPP#kPP(W(W(b(WP(WP(W(WP#kP#kP#kP(e#kP(h(k(n(u#kP#kP(z)Q)a)o)u*P*V*a*g*mPPPPPPPPPP*s*|P+i+lP,b,e,k,tRkQ_bOPdhw!m#nkYOPdhotuvw!m#Q#c#nkSOPdhotuvw!m#Q#c#nQmTR!snQ{VR!wqQ!w}Q#Y!XR#s!yq!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${U$]#h$_$rR$q$[q!XZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${Q!e^R#g!fQ|VR!xqQ!w|R#s!xQ!PWR!zrQ!RXR!{sQxUQ!vpQ#d!bQ#j!iQ#k!jQ$t$^R%Q$sSgPwQ!ohQ#m!mR$e#nZfPhw!m#na!a[`a!V!]!_#_#`R#]!]R!f^R!h_R#i!hS$^#h$_R%O$rV$[#h$_$rQ!qjR#q!qQdOShPwU!kdh#nR#n!mQ#z#RU$i#z$o${Q$o$RR${$jQ$k#zR$|$kQpUS!up$gR$g#wQ$c#lR$x$cQ!ngS#o!n#pR#p!oQ#a!^R$V#aQ$_#hR$u$_Q$s$^R%P$s_cOPdhw!m#n^UOPdhw!m#nQ!toQ!|tQ!}uQ#OvQ#w#QR$W#cR#{#RQ!VZQ!c]Q#U!TQ#l!l[#y#R#z$R$j$o${Q#|#TQ$O#WS$a#l$cQ$f#uR$w$bR#x#QQiPR#PwQ!b[Q!jaR#X!VU!^[a!VQ!i`Q#^!]Q#b!_Q$T#_R$U#`",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 114,
  nodeProps: [
    ["openedBy", 17, "(", 48, "{"],
    ["closedBy", 18, ")", 49, "}"]
  ],
  propSources: [jC],
  skippedNodes: [0, 3, 85],
  repeatNodeCount: 10,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#W~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#W~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!V[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYtQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QSzSo`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!PQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#b[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#b[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSp^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#_QOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#X~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!W^Oy%^z;'S%^;'S;=`%o<%lO%^dCoSzSOy%^z;'S%^;'S;=`%o<%lO%^bDQU|QOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS|Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[!YQo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bFfSxQOy%^z;'S%^;'S;=`%o<%lO%^lFwSv[Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!`Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!RUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!Q^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!PQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [qC, DC, XC, 1, 2, 3, 4, new Lc("m~RRYZ[z{a~~g~aO#Z~~dP!P!Qg~lO#[~~", 28, 102)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 84] },
  specialized: [{ term: 97, get: (t10) => UC[t10] || -1 }, { term: 56, get: (t10) => IC[t10] || -1 }, { term: 98, get: (t10) => FC[t10] || -1 }],
  tokenPrec: 1169
});
class ct {
  /**
  Get the line description around the given position.
  */
  lineAt(e3) {
    if (e3 < 0 || e3 > this.length)
      throw new RangeError(`Invalid position ${e3} in document of length ${this.length}`);
    return this.lineInner(e3, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e3) {
    if (e3 < 1 || e3 > this.lines)
      throw new RangeError(`Invalid line number ${e3} in ${this.lines}-line document`);
    return this.lineInner(e3, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e3, r3, n3) {
    let i3 = [];
    return this.decompose(
      0,
      e3,
      i3,
      2
      /* Open.To */
    ), n3.length && n3.decompose(
      0,
      n3.length,
      i3,
      3
      /* Open.To */
    ), this.decompose(
      r3,
      this.length,
      i3,
      1
      /* Open.From */
    ), Bn.from(i3, this.length - (r3 - e3) + n3.length);
  }
  /**
  Append another document to this one.
  */
  append(e3) {
    return this.replace(this.length, this.length, e3);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e3, r3 = this.length) {
    let n3 = [];
    return this.decompose(e3, r3, n3, 0), Bn.from(n3, r3 - e3);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e3) {
    if (e3 == this)
      return true;
    if (e3.length != this.length || e3.lines != this.lines)
      return false;
    let r3 = this.scanIdentical(e3, 1), n3 = this.length - this.scanIdentical(e3, -1), i3 = new Ol(this), o3 = new Ol(e3);
    for (let s3 = r3, a3 = r3; ; ) {
      if (i3.next(s3), o3.next(s3), s3 = 0, i3.lineBreak != o3.lineBreak || i3.done != o3.done || i3.value != o3.value)
        return false;
      if (a3 += i3.value.length, i3.done || a3 >= n3)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e3 = 1) {
    return new Ol(this, e3);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e3, r3 = this.length) {
    return new x2(this, e3, r3);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e3, r3) {
    let n3;
    if (e3 == null)
      n3 = this.iter();
    else {
      r3 == null && (r3 = this.lines + 1);
      let i3 = this.line(e3).from;
      n3 = this.iterRange(i3, Math.max(i3, r3 == this.lines + 1 ? this.length : r3 <= 1 ? 0 : this.line(r3 - 1).to));
    }
    return new Q2(n3);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e3 = [];
    return this.flatten(e3), e3;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e3) {
    if (e3.length == 0)
      throw new RangeError("A document must have at least one line");
    return e3.length == 1 && !e3[0] ? ct.empty : e3.length <= 32 ? new Zt(e3) : Bn.from(Zt.split(e3, []));
  }
}
class Zt extends ct {
  constructor(e3, r3 = MC(e3)) {
    super(), this.text = e3, this.length = r3;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e3, r3, n3, i3) {
    for (let o3 = 0; ; o3++) {
      let s3 = this.text[o3], a3 = i3 + s3.length;
      if ((r3 ? n3 : a3) >= e3)
        return new NC(i3, a3, n3, s3);
      i3 = a3 + 1, n3++;
    }
  }
  decompose(e3, r3, n3, i3) {
    let o3 = e3 <= 0 && r3 >= this.length ? this : new Zt(by(this.text, e3, r3), Math.min(r3, this.length) - Math.max(0, e3));
    if (i3 & 1) {
      let s3 = n3.pop(), a3 = gc(o3.text, s3.text.slice(), 0, o3.length);
      if (a3.length <= 32)
        n3.push(new Zt(a3, s3.length + o3.length));
      else {
        let l3 = a3.length >> 1;
        n3.push(new Zt(a3.slice(0, l3)), new Zt(a3.slice(l3)));
      }
    } else
      n3.push(o3);
  }
  replace(e3, r3, n3) {
    if (!(n3 instanceof Zt))
      return super.replace(e3, r3, n3);
    let i3 = gc(this.text, gc(n3.text, by(this.text, 0, e3)), r3), o3 = this.length + n3.length - (r3 - e3);
    return i3.length <= 32 ? new Zt(i3, o3) : Bn.from(Zt.split(i3, []), o3);
  }
  sliceString(e3, r3 = this.length, n3 = `
`) {
    let i3 = "";
    for (let o3 = 0, s3 = 0; o3 <= r3 && s3 < this.text.length; s3++) {
      let a3 = this.text[s3], l3 = o3 + a3.length;
      o3 > e3 && s3 && (i3 += n3), e3 < l3 && r3 > o3 && (i3 += a3.slice(Math.max(0, e3 - o3), r3 - o3)), o3 = l3 + 1;
    }
    return i3;
  }
  flatten(e3) {
    for (let r3 of this.text)
      e3.push(r3);
  }
  scanIdentical() {
    return 0;
  }
  static split(e3, r3) {
    let n3 = [], i3 = -1;
    for (let o3 of e3)
      n3.push(o3), i3 += o3.length + 1, n3.length == 32 && (r3.push(new Zt(n3, i3)), n3 = [], i3 = -1);
    return i3 > -1 && r3.push(new Zt(n3, i3)), r3;
  }
}
class Bn extends ct {
  constructor(e3, r3) {
    super(), this.children = e3, this.length = r3, this.lines = 0;
    for (let n3 of e3)
      this.lines += n3.lines;
  }
  lineInner(e3, r3, n3, i3) {
    for (let o3 = 0; ; o3++) {
      let s3 = this.children[o3], a3 = i3 + s3.length, l3 = n3 + s3.lines - 1;
      if ((r3 ? l3 : a3) >= e3)
        return s3.lineInner(e3, r3, n3, i3);
      i3 = a3 + 1, n3 = l3 + 1;
    }
  }
  decompose(e3, r3, n3, i3) {
    for (let o3 = 0, s3 = 0; s3 <= r3 && o3 < this.children.length; o3++) {
      let a3 = this.children[o3], l3 = s3 + a3.length;
      if (e3 <= l3 && r3 >= s3) {
        let u3 = i3 & ((s3 <= e3 ? 1 : 0) | (l3 >= r3 ? 2 : 0));
        s3 >= e3 && l3 <= r3 && !u3 ? n3.push(a3) : a3.decompose(e3 - s3, r3 - s3, n3, u3);
      }
      s3 = l3 + 1;
    }
  }
  replace(e3, r3, n3) {
    if (n3.lines < this.lines)
      for (let i3 = 0, o3 = 0; i3 < this.children.length; i3++) {
        let s3 = this.children[i3], a3 = o3 + s3.length;
        if (e3 >= o3 && r3 <= a3) {
          let l3 = s3.replace(e3 - o3, r3 - o3, n3), u3 = this.lines - s3.lines + l3.lines;
          if (l3.lines < u3 >> 5 - 1 && l3.lines > u3 >> 5 + 1) {
            let c3 = this.children.slice();
            return c3[i3] = l3, new Bn(c3, this.length - (r3 - e3) + n3.length);
          }
          return super.replace(o3, a3, l3);
        }
        o3 = a3 + 1;
      }
    return super.replace(e3, r3, n3);
  }
  sliceString(e3, r3 = this.length, n3 = `
`) {
    let i3 = "";
    for (let o3 = 0, s3 = 0; o3 < this.children.length && s3 <= r3; o3++) {
      let a3 = this.children[o3], l3 = s3 + a3.length;
      s3 > e3 && o3 && (i3 += n3), e3 < l3 && r3 > s3 && (i3 += a3.sliceString(e3 - s3, r3 - s3, n3)), s3 = l3 + 1;
    }
    return i3;
  }
  flatten(e3) {
    for (let r3 of this.children)
      r3.flatten(e3);
  }
  scanIdentical(e3, r3) {
    if (!(e3 instanceof Bn))
      return 0;
    let n3 = 0, [i3, o3, s3, a3] = r3 > 0 ? [0, 0, this.children.length, e3.children.length] : [this.children.length - 1, e3.children.length - 1, -1, -1];
    for (; ; i3 += r3, o3 += r3) {
      if (i3 == s3 || o3 == a3)
        return n3;
      let l3 = this.children[i3], u3 = e3.children[o3];
      if (l3 != u3)
        return n3 + l3.scanIdentical(u3, r3);
      n3 += l3.length + 1;
    }
  }
  static from(e3, r3 = e3.reduce((n3, i3) => n3 + i3.length + 1, -1)) {
    let n3 = 0;
    for (let p10 of e3)
      n3 += p10.lines;
    if (n3 < 32) {
      let p10 = [];
      for (let h10 of e3)
        h10.flatten(p10);
      return new Zt(p10, r3);
    }
    let i3 = Math.max(
      32,
      n3 >> 5
      /* Tree.BranchShift */
    ), o3 = i3 << 1, s3 = i3 >> 1, a3 = [], l3 = 0, u3 = -1, c3 = [];
    function f3(p10) {
      let h10;
      if (p10.lines > o3 && p10 instanceof Bn)
        for (let m10 of p10.children)
          f3(m10);
      else
        p10.lines > s3 && (l3 > s3 || !l3) ? (d3(), a3.push(p10)) : p10 instanceof Zt && l3 && (h10 = c3[c3.length - 1]) instanceof Zt && p10.lines + h10.lines <= 32 ? (l3 += p10.lines, u3 += p10.length + 1, c3[c3.length - 1] = new Zt(h10.text.concat(p10.text), h10.length + 1 + p10.length)) : (l3 + p10.lines > i3 && d3(), l3 += p10.lines, u3 += p10.length + 1, c3.push(p10));
    }
    function d3() {
      l3 != 0 && (a3.push(c3.length == 1 ? c3[0] : Bn.from(c3, u3)), u3 = -1, l3 = c3.length = 0);
    }
    for (let p10 of e3)
      f3(p10);
    return d3(), a3.length == 1 ? a3[0] : new Bn(a3, r3);
  }
}
ct.empty = /* @__PURE__ */ new Zt([""], 0);
function MC(t10) {
  let e3 = -1;
  for (let r3 of t10)
    e3 += r3.length + 1;
  return e3;
}
function gc(t10, e3, r3 = 0, n3 = 1e9) {
  for (let i3 = 0, o3 = 0, s3 = true; o3 < t10.length && i3 <= n3; o3++) {
    let a3 = t10[o3], l3 = i3 + a3.length;
    l3 >= r3 && (l3 > n3 && (a3 = a3.slice(0, n3 - i3)), i3 < r3 && (a3 = a3.slice(r3 - i3)), s3 ? (e3[e3.length - 1] += a3, s3 = false) : e3.push(a3)), i3 = l3 + 1;
  }
  return e3;
}
function by(t10, e3, r3) {
  return gc(t10, [""], e3, r3);
}
class Ol {
  constructor(e3, r3 = 1) {
    this.dir = r3, this.done = false, this.lineBreak = false, this.value = "", this.nodes = [e3], this.offsets = [r3 > 0 ? 1 : (e3 instanceof Zt ? e3.text.length : e3.children.length) << 1];
  }
  nextInner(e3, r3) {
    for (this.done = this.lineBreak = false; ; ) {
      let n3 = this.nodes.length - 1, i3 = this.nodes[n3], o3 = this.offsets[n3], s3 = o3 >> 1, a3 = i3 instanceof Zt ? i3.text.length : i3.children.length;
      if (s3 == (r3 > 0 ? a3 : 0)) {
        if (n3 == 0)
          return this.done = true, this.value = "", this;
        r3 > 0 && this.offsets[n3 - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((o3 & 1) == (r3 > 0 ? 0 : 1)) {
        if (this.offsets[n3] += r3, e3 == 0)
          return this.lineBreak = true, this.value = `
`, this;
        e3--;
      } else if (i3 instanceof Zt) {
        let l3 = i3.text[s3 + (r3 < 0 ? -1 : 0)];
        if (this.offsets[n3] += r3, l3.length > Math.max(0, e3))
          return this.value = e3 == 0 ? l3 : r3 > 0 ? l3.slice(e3) : l3.slice(0, l3.length - e3), this;
        e3 -= l3.length;
      } else {
        let l3 = i3.children[s3 + (r3 < 0 ? -1 : 0)];
        e3 > l3.length ? (e3 -= l3.length, this.offsets[n3] += r3) : (r3 < 0 && this.offsets[n3]--, this.nodes.push(l3), this.offsets.push(r3 > 0 ? 1 : (l3 instanceof Zt ? l3.text.length : l3.children.length) << 1));
      }
    }
  }
  next(e3 = 0) {
    return e3 < 0 && (this.nextInner(-e3, -this.dir), e3 = this.value.length), this.nextInner(e3, this.dir);
  }
}
class x2 {
  constructor(e3, r3, n3) {
    this.value = "", this.done = false, this.cursor = new Ol(e3, r3 > n3 ? -1 : 1), this.pos = r3 > n3 ? e3.length : 0, this.from = Math.min(r3, n3), this.to = Math.max(r3, n3);
  }
  nextInner(e3, r3) {
    if (r3 < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = true, this;
    e3 += Math.max(0, r3 < 0 ? this.pos - this.to : this.from - this.pos);
    let n3 = r3 < 0 ? this.pos - this.from : this.to - this.pos;
    e3 > n3 && (e3 = n3), n3 -= e3;
    let { value: i3 } = this.cursor.next(e3);
    return this.pos += (i3.length + e3) * r3, this.value = i3.length <= n3 ? i3 : r3 < 0 ? i3.slice(i3.length - n3) : i3.slice(0, n3), this.done = !this.value, this;
  }
  next(e3 = 0) {
    return e3 < 0 ? e3 = Math.max(e3, this.from - this.pos) : e3 > 0 && (e3 = Math.min(e3, this.to - this.pos)), this.nextInner(e3, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class Q2 {
  constructor(e3) {
    this.inner = e3, this.afterBreak = true, this.value = "", this.done = false;
  }
  next(e3 = 0) {
    let { done: r3, lineBreak: n3, value: i3 } = this.inner.next(e3);
    return r3 ? (this.done = true, this.value = "") : n3 ? this.afterBreak ? this.value = "" : (this.afterBreak = true, this.next()) : (this.value = i3, this.afterBreak = false), this;
  }
  get lineBreak() {
    return false;
  }
}
typeof Symbol < "u" && (ct.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Ol.prototype[Symbol.iterator] = x2.prototype[Symbol.iterator] = Q2.prototype[Symbol.iterator] = function() {
  return this;
});
class NC {
  /**
  @internal
  */
  constructor(e3, r3, n3, i3) {
    this.from = e3, this.to = r3, this.number = n3, this.text = i3;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
let zs = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t10) => t10 ? parseInt(t10, 36) : 1);
for (let t10 = 1; t10 < zs.length; t10++)
  zs[t10] += zs[t10 - 1];
function WC(t10) {
  for (let e3 = 1; e3 < zs.length; e3 += 2)
    if (zs[e3] > t10)
      return zs[e3 - 1] <= t10;
  return false;
}
function Sy(t10) {
  return t10 >= 127462 && t10 <= 127487;
}
const $y = 8205;
function $i(t10, e3, r3 = true, n3 = true) {
  return (r3 ? T2 : VC)(t10, e3, n3);
}
function T2(t10, e3, r3) {
  if (e3 == t10.length)
    return e3;
  e3 && k2(t10.charCodeAt(e3)) && E2(t10.charCodeAt(e3 - 1)) && e3--;
  let n3 = yc(t10, e3);
  for (e3 += Np(n3); e3 < t10.length; ) {
    let i3 = yc(t10, e3);
    if (n3 == $y || i3 == $y || r3 && WC(i3))
      e3 += Np(i3), n3 = i3;
    else if (Sy(i3)) {
      let o3 = 0, s3 = e3 - 2;
      for (; s3 >= 0 && Sy(yc(t10, s3)); )
        o3++, s3 -= 2;
      if (o3 % 2 == 0)
        break;
      e3 += 2;
    } else
      break;
  }
  return e3;
}
function VC(t10, e3, r3) {
  for (; e3 > 0; ) {
    let n3 = T2(t10, e3 - 2, r3);
    if (n3 < e3)
      return n3;
    e3--;
  }
  return 0;
}
function k2(t10) {
  return t10 >= 56320 && t10 < 57344;
}
function E2(t10) {
  return t10 >= 55296 && t10 < 56320;
}
function yc(t10, e3) {
  let r3 = t10.charCodeAt(e3);
  if (!E2(r3) || e3 + 1 == t10.length)
    return r3;
  let n3 = t10.charCodeAt(e3 + 1);
  return k2(n3) ? (r3 - 55296 << 10) + (n3 - 56320) + 65536 : r3;
}
function Np(t10) {
  return t10 < 65536 ? 1 : 2;
}
const Wp = /\r\n?|\n/;
var kr = /* @__PURE__ */ function(t10) {
  return t10[t10.Simple = 0] = "Simple", t10[t10.TrackDel = 1] = "TrackDel", t10[t10.TrackBefore = 2] = "TrackBefore", t10[t10.TrackAfter = 3] = "TrackAfter", t10;
}(kr || (kr = {}));
class _i {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e3) {
    this.sections = e3;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e3 = 0;
    for (let r3 = 0; r3 < this.sections.length; r3 += 2)
      e3 += this.sections[r3];
    return e3;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e3 = 0;
    for (let r3 = 0; r3 < this.sections.length; r3 += 2) {
      let n3 = this.sections[r3 + 1];
      e3 += n3 < 0 ? this.sections[r3] : n3;
    }
    return e3;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e3) {
    for (let r3 = 0, n3 = 0, i3 = 0; r3 < this.sections.length; ) {
      let o3 = this.sections[r3++], s3 = this.sections[r3++];
      s3 < 0 ? (e3(n3, i3, o3), i3 += o3) : i3 += s3, n3 += o3;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e3, r3 = false) {
    Vp(this, e3, r3);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e3 = [];
    for (let r3 = 0; r3 < this.sections.length; ) {
      let n3 = this.sections[r3++], i3 = this.sections[r3++];
      i3 < 0 ? e3.push(n3, i3) : e3.push(i3, n3);
    }
    return new _i(e3);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e3) {
    return this.empty ? e3 : e3.empty ? this : C2(this, e3);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e3, r3 = false) {
    return e3.empty ? this : Yp(this, e3, r3);
  }
  mapPos(e3, r3 = -1, n3 = kr.Simple) {
    let i3 = 0, o3 = 0;
    for (let s3 = 0; s3 < this.sections.length; ) {
      let a3 = this.sections[s3++], l3 = this.sections[s3++], u3 = i3 + a3;
      if (l3 < 0) {
        if (u3 > e3)
          return o3 + (e3 - i3);
        o3 += a3;
      } else {
        if (n3 != kr.Simple && u3 >= e3 && (n3 == kr.TrackDel && i3 < e3 && u3 > e3 || n3 == kr.TrackBefore && i3 < e3 || n3 == kr.TrackAfter && u3 > e3))
          return null;
        if (u3 > e3 || u3 == e3 && r3 < 0 && !a3)
          return e3 == i3 || r3 < 0 ? o3 : o3 + l3;
        o3 += l3;
      }
      i3 = u3;
    }
    if (e3 > i3)
      throw new RangeError(`Position ${e3} is out of range for changeset of length ${i3}`);
    return o3;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e3, r3 = e3) {
    for (let n3 = 0, i3 = 0; n3 < this.sections.length && i3 <= r3; ) {
      let o3 = this.sections[n3++], s3 = this.sections[n3++], a3 = i3 + o3;
      if (s3 >= 0 && i3 <= r3 && a3 >= e3)
        return i3 < e3 && a3 > r3 ? "cover" : true;
      i3 = a3;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let e3 = "";
    for (let r3 = 0; r3 < this.sections.length; ) {
      let n3 = this.sections[r3++], i3 = this.sections[r3++];
      e3 += (e3 ? " " : "") + n3 + (i3 >= 0 ? ":" + i3 : "");
    }
    return e3;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e3) {
    if (!Array.isArray(e3) || e3.length % 2 || e3.some((r3) => typeof r3 != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new _i(e3);
  }
  /**
  @internal
  */
  static create(e3) {
    return new _i(e3);
  }
}
class rr extends _i {
  constructor(e3, r3) {
    super(e3), this.inserted = r3;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e3) {
    if (this.length != e3.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Vp(this, (r3, n3, i3, o3, s3) => e3 = e3.replace(i3, i3 + (n3 - r3), s3), false), e3;
  }
  mapDesc(e3, r3 = false) {
    return Yp(this, e3, r3, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e3) {
    let r3 = this.sections.slice(), n3 = [];
    for (let i3 = 0, o3 = 0; i3 < r3.length; i3 += 2) {
      let s3 = r3[i3], a3 = r3[i3 + 1];
      if (a3 >= 0) {
        r3[i3] = a3, r3[i3 + 1] = s3;
        let l3 = i3 >> 1;
        for (; n3.length < l3; )
          n3.push(ct.empty);
        n3.push(s3 ? e3.slice(o3, o3 + s3) : ct.empty);
      }
      o3 += s3;
    }
    return new rr(r3, n3);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e3) {
    return this.empty ? e3 : e3.empty ? this : C2(this, e3, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e3, r3 = false) {
    return e3.empty ? this : Yp(this, e3, r3, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e3, r3 = false) {
    Vp(this, e3, r3);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return _i.create(this.sections);
  }
  /**
  @internal
  */
  filter(e3) {
    let r3 = [], n3 = [], i3 = [], o3 = new Rl(this);
    e:
      for (let s3 = 0, a3 = 0; ; ) {
        let l3 = s3 == e3.length ? 1e9 : e3[s3++];
        for (; a3 < l3 || a3 == l3 && o3.len == 0; ) {
          if (o3.done)
            break e;
          let c3 = Math.min(o3.len, l3 - a3);
          mr(i3, c3, -1);
          let f3 = o3.ins == -1 ? -1 : o3.off == 0 ? o3.ins : 0;
          mr(r3, c3, f3), f3 > 0 && eo(n3, r3, o3.text), o3.forward(c3), a3 += c3;
        }
        let u3 = e3[s3++];
        for (; a3 < u3; ) {
          if (o3.done)
            break e;
          let c3 = Math.min(o3.len, u3 - a3);
          mr(r3, c3, -1), mr(i3, c3, o3.ins == -1 ? -1 : o3.off == 0 ? o3.ins : 0), o3.forward(c3), a3 += c3;
        }
      }
    return {
      changes: new rr(r3, n3),
      filtered: _i.create(i3)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e3 = [];
    for (let r3 = 0; r3 < this.sections.length; r3 += 2) {
      let n3 = this.sections[r3], i3 = this.sections[r3 + 1];
      i3 < 0 ? e3.push(n3) : i3 == 0 ? e3.push([n3]) : e3.push([n3].concat(this.inserted[r3 >> 1].toJSON()));
    }
    return e3;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e3, r3, n3) {
    let i3 = [], o3 = [], s3 = 0, a3 = null;
    function l3(c3 = false) {
      if (!c3 && !i3.length)
        return;
      s3 < r3 && mr(i3, r3 - s3, -1);
      let f3 = new rr(i3, o3);
      a3 = a3 ? a3.compose(f3.map(a3)) : f3, i3 = [], o3 = [], s3 = 0;
    }
    function u3(c3) {
      if (Array.isArray(c3))
        for (let f3 of c3)
          u3(f3);
      else if (c3 instanceof rr) {
        if (c3.length != r3)
          throw new RangeError(`Mismatched change set length (got ${c3.length}, expected ${r3})`);
        l3(), a3 = a3 ? a3.compose(c3.map(a3)) : c3;
      } else {
        let { from: f3, to: d3 = f3, insert: p10 } = c3;
        if (f3 > d3 || f3 < 0 || d3 > r3)
          throw new RangeError(`Invalid change range ${f3} to ${d3} (in doc of length ${r3})`);
        let h10 = p10 ? typeof p10 == "string" ? ct.of(p10.split(n3 || Wp)) : p10 : ct.empty, m10 = h10.length;
        if (f3 == d3 && m10 == 0)
          return;
        f3 < s3 && l3(), f3 > s3 && mr(i3, f3 - s3, -1), mr(i3, d3 - f3, m10), eo(o3, i3, h10), s3 = d3;
      }
    }
    return u3(e3), l3(!a3), a3;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e3) {
    return new rr(e3 ? [e3, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e3) {
    if (!Array.isArray(e3))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let r3 = [], n3 = [];
    for (let i3 = 0; i3 < e3.length; i3++) {
      let o3 = e3[i3];
      if (typeof o3 == "number")
        r3.push(o3, -1);
      else {
        if (!Array.isArray(o3) || typeof o3[0] != "number" || o3.some((s3, a3) => a3 && typeof s3 != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (o3.length == 1)
          r3.push(o3[0], 0);
        else {
          for (; n3.length < i3; )
            n3.push(ct.empty);
          n3[i3] = ct.of(o3.slice(1)), r3.push(o3[0], n3[i3].length);
        }
      }
    }
    return new rr(r3, n3);
  }
  /**
  @internal
  */
  static createSet(e3, r3) {
    return new rr(e3, r3);
  }
}
function mr(t10, e3, r3, n3 = false) {
  if (e3 == 0 && r3 <= 0)
    return;
  let i3 = t10.length - 2;
  i3 >= 0 && r3 <= 0 && r3 == t10[i3 + 1] ? t10[i3] += e3 : e3 == 0 && t10[i3] == 0 ? t10[i3 + 1] += r3 : n3 ? (t10[i3] += e3, t10[i3 + 1] += r3) : t10.push(e3, r3);
}
function eo(t10, e3, r3) {
  if (r3.length == 0)
    return;
  let n3 = e3.length - 2 >> 1;
  if (n3 < t10.length)
    t10[t10.length - 1] = t10[t10.length - 1].append(r3);
  else {
    for (; t10.length < n3; )
      t10.push(ct.empty);
    t10.push(r3);
  }
}
function Vp(t10, e3, r3) {
  let n3 = t10.inserted;
  for (let i3 = 0, o3 = 0, s3 = 0; s3 < t10.sections.length; ) {
    let a3 = t10.sections[s3++], l3 = t10.sections[s3++];
    if (l3 < 0)
      i3 += a3, o3 += a3;
    else {
      let u3 = i3, c3 = o3, f3 = ct.empty;
      for (; u3 += a3, c3 += l3, l3 && n3 && (f3 = f3.append(n3[s3 - 2 >> 1])), !(r3 || s3 == t10.sections.length || t10.sections[s3 + 1] < 0); )
        a3 = t10.sections[s3++], l3 = t10.sections[s3++];
      e3(i3, u3, o3, c3, f3), i3 = u3, o3 = c3;
    }
  }
}
function Yp(t10, e3, r3, n3 = false) {
  let i3 = [], o3 = n3 ? [] : null, s3 = new Rl(t10), a3 = new Rl(e3);
  for (let l3 = -1; ; )
    if (s3.ins == -1 && a3.ins == -1) {
      let u3 = Math.min(s3.len, a3.len);
      mr(i3, u3, -1), s3.forward(u3), a3.forward(u3);
    } else if (a3.ins >= 0 && (s3.ins < 0 || l3 == s3.i || s3.off == 0 && (a3.len < s3.len || a3.len == s3.len && !r3))) {
      let u3 = a3.len;
      for (mr(i3, a3.ins, -1); u3; ) {
        let c3 = Math.min(s3.len, u3);
        s3.ins >= 0 && l3 < s3.i && s3.len <= c3 && (mr(i3, 0, s3.ins), o3 && eo(o3, i3, s3.text), l3 = s3.i), s3.forward(c3), u3 -= c3;
      }
      a3.next();
    } else if (s3.ins >= 0) {
      let u3 = 0, c3 = s3.len;
      for (; c3; )
        if (a3.ins == -1) {
          let f3 = Math.min(c3, a3.len);
          u3 += f3, c3 -= f3, a3.forward(f3);
        } else if (a3.ins == 0 && a3.len < c3)
          c3 -= a3.len, a3.next();
        else
          break;
      mr(i3, u3, l3 < s3.i ? s3.ins : 0), o3 && l3 < s3.i && eo(o3, i3, s3.text), l3 = s3.i, s3.forward(s3.len - c3);
    } else {
      if (s3.done && a3.done)
        return o3 ? rr.createSet(i3, o3) : _i.create(i3);
      throw new Error("Mismatched change set lengths");
    }
}
function C2(t10, e3, r3 = false) {
  let n3 = [], i3 = r3 ? [] : null, o3 = new Rl(t10), s3 = new Rl(e3);
  for (let a3 = false; ; ) {
    if (o3.done && s3.done)
      return i3 ? rr.createSet(n3, i3) : _i.create(n3);
    if (o3.ins == 0)
      mr(n3, o3.len, 0, a3), o3.next();
    else if (s3.len == 0 && !s3.done)
      mr(n3, 0, s3.ins, a3), i3 && eo(i3, n3, s3.text), s3.next();
    else {
      if (o3.done || s3.done)
        throw new Error("Mismatched change set lengths");
      {
        let l3 = Math.min(o3.len2, s3.len), u3 = n3.length;
        if (o3.ins == -1) {
          let c3 = s3.ins == -1 ? -1 : s3.off ? 0 : s3.ins;
          mr(n3, l3, c3, a3), i3 && c3 && eo(i3, n3, s3.text);
        } else
          s3.ins == -1 ? (mr(n3, o3.off ? 0 : o3.len, l3, a3), i3 && eo(i3, n3, o3.textBit(l3))) : (mr(n3, o3.off ? 0 : o3.len, s3.off ? 0 : s3.ins, a3), i3 && !s3.off && eo(i3, n3, s3.text));
        a3 = (o3.ins > l3 || s3.ins >= 0 && s3.len > l3) && (a3 || n3.length > u3), o3.forward2(l3), s3.forward(l3);
      }
    }
  }
}
class Rl {
  constructor(e3) {
    this.set = e3, this.i = 0, this.next();
  }
  next() {
    let { sections: e3 } = this.set;
    this.i < e3.length ? (this.len = e3[this.i++], this.ins = e3[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e3 } = this.set, r3 = this.i - 2 >> 1;
    return r3 >= e3.length ? ct.empty : e3[r3];
  }
  textBit(e3) {
    let { inserted: r3 } = this.set, n3 = this.i - 2 >> 1;
    return n3 >= r3.length && !e3 ? ct.empty : r3[n3].slice(this.off, e3 == null ? void 0 : this.off + e3);
  }
  forward(e3) {
    e3 == this.len ? this.next() : (this.len -= e3, this.off += e3);
  }
  forward2(e3) {
    this.ins == -1 ? this.forward(e3) : e3 == this.ins ? this.next() : (this.ins -= e3, this.off += e3);
  }
}
class Zo {
  constructor(e3, r3, n3) {
    this.from = e3, this.to = r3, this.flags = n3;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e3 = this.flags & 3;
    return e3 == 3 ? null : e3;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e3 = this.flags >> 5;
    return e3 == 33554431 ? void 0 : e3;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e3, r3 = -1) {
    let n3, i3;
    return this.empty ? n3 = i3 = e3.mapPos(this.from, r3) : (n3 = e3.mapPos(this.from, 1), i3 = e3.mapPos(this.to, -1)), n3 == this.from && i3 == this.to ? this : new Zo(n3, i3, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e3, r3 = e3) {
    if (e3 <= this.anchor && r3 >= this.anchor)
      return Pe.range(e3, r3);
    let n3 = Math.abs(e3 - this.anchor) > Math.abs(r3 - this.anchor) ? e3 : r3;
    return Pe.range(this.anchor, n3);
  }
  /**
  Compare this range to another range.
  */
  eq(e3) {
    return this.anchor == e3.anchor && this.head == e3.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e3) {
    if (!e3 || typeof e3.anchor != "number" || typeof e3.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return Pe.range(e3.anchor, e3.head);
  }
  /**
  @internal
  */
  static create(e3, r3, n3) {
    return new Zo(e3, r3, n3);
  }
}
class Pe {
  constructor(e3, r3) {
    this.ranges = e3, this.mainIndex = r3;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e3, r3 = -1) {
    return e3.empty ? this : Pe.create(this.ranges.map((n3) => n3.map(e3, r3)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */
  eq(e3) {
    if (this.ranges.length != e3.ranges.length || this.mainIndex != e3.mainIndex)
      return false;
    for (let r3 = 0; r3 < this.ranges.length; r3++)
      if (!this.ranges[r3].eq(e3.ranges[r3]))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new Pe([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e3, r3 = true) {
    return Pe.create([e3].concat(this.ranges), r3 ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e3, r3 = this.mainIndex) {
    let n3 = this.ranges.slice();
    return n3[r3] = e3, Pe.create(n3, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e3) => e3.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e3) {
    if (!e3 || !Array.isArray(e3.ranges) || typeof e3.main != "number" || e3.main >= e3.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new Pe(e3.ranges.map((r3) => Zo.fromJSON(r3)), e3.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e3, r3 = e3) {
    return new Pe([Pe.range(e3, r3)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e3, r3 = 0) {
    if (e3.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let n3 = 0, i3 = 0; i3 < e3.length; i3++) {
      let o3 = e3[i3];
      if (o3.empty ? o3.from <= n3 : o3.from < n3)
        return Pe.normalized(e3.slice(), r3);
      n3 = o3.to;
    }
    return new Pe(e3, r3);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e3, r3 = 0, n3, i3) {
    return Zo.create(e3, e3, (r3 == 0 ? 0 : r3 < 0 ? 4 : 8) | (n3 == null ? 3 : Math.min(2, n3)) | (i3 ?? 33554431) << 5);
  }
  /**
  Create a selection range.
  */
  static range(e3, r3, n3, i3) {
    let o3 = (n3 ?? 33554431) << 5 | (i3 == null ? 3 : Math.min(2, i3));
    return r3 < e3 ? Zo.create(r3, e3, 24 | o3) : Zo.create(e3, r3, (r3 > e3 ? 4 : 0) | o3);
  }
  /**
  @internal
  */
  static normalized(e3, r3 = 0) {
    let n3 = e3[r3];
    e3.sort((i3, o3) => i3.from - o3.from), r3 = e3.indexOf(n3);
    for (let i3 = 1; i3 < e3.length; i3++) {
      let o3 = e3[i3], s3 = e3[i3 - 1];
      if (o3.empty ? o3.from <= s3.to : o3.from < s3.to) {
        let a3 = s3.from, l3 = Math.max(o3.to, s3.to);
        i3 <= r3 && r3--, e3.splice(--i3, 2, o3.anchor > o3.head ? Pe.range(l3, a3) : Pe.range(a3, l3));
      }
    }
    return new Pe(e3, r3);
  }
}
function R2(t10, e3) {
  for (let r3 of t10.ranges)
    if (r3.to > e3)
      throw new RangeError("Selection points outside of document");
}
let Pg = 0;
class Me {
  constructor(e3, r3, n3, i3, o3) {
    this.combine = e3, this.compareInput = r3, this.compare = n3, this.isStatic = i3, this.id = Pg++, this.default = e3([]), this.extensions = typeof o3 == "function" ? o3(this) : o3;
  }
  /**
  Define a new facet.
  */
  static define(e3 = {}) {
    return new Me(e3.combine || ((r3) => r3), e3.compareInput || ((r3, n3) => r3 === n3), e3.compare || (e3.combine ? (r3, n3) => r3 === n3 : _g), !!e3.static, e3.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e3) {
    return new vc([], this, 0, e3);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e3, r3) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new vc(e3, this, 1, r3);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e3, r3) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new vc(e3, this, 2, r3);
  }
  from(e3, r3) {
    return r3 || (r3 = (n3) => n3), this.compute([e3], (n3) => r3(n3.field(e3)));
  }
}
function _g(t10, e3) {
  return t10 == e3 || t10.length == e3.length && t10.every((r3, n3) => r3 === e3[n3]);
}
class vc {
  constructor(e3, r3, n3, i3) {
    this.dependencies = e3, this.facet = r3, this.type = n3, this.value = i3, this.id = Pg++;
  }
  dynamicSlot(e3) {
    var r3;
    let n3 = this.value, i3 = this.facet.compareInput, o3 = this.id, s3 = e3[o3] >> 1, a3 = this.type == 2, l3 = false, u3 = false, c3 = [];
    for (let f3 of this.dependencies)
      f3 == "doc" ? l3 = true : f3 == "selection" ? u3 = true : ((r3 = e3[f3.id]) !== null && r3 !== void 0 ? r3 : 1) & 1 || c3.push(e3[f3.id]);
    return {
      create(f3) {
        return f3.values[s3] = n3(f3), 1;
      },
      update(f3, d3) {
        if (l3 && d3.docChanged || u3 && (d3.docChanged || d3.selection) || Lp(f3, c3)) {
          let p10 = n3(f3);
          if (a3 ? !wy(p10, f3.values[s3], i3) : !i3(p10, f3.values[s3]))
            return f3.values[s3] = p10, 1;
        }
        return 0;
      },
      reconfigure: (f3, d3) => {
        let p10, h10 = d3.config.address[o3];
        if (h10 != null) {
          let m10 = ef(d3, h10);
          if (this.dependencies.every((O10) => O10 instanceof Me ? d3.facet(O10) === f3.facet(O10) : O10 instanceof vo ? d3.field(O10, false) == f3.field(O10, false) : true) || (a3 ? wy(p10 = n3(f3), m10, i3) : i3(p10 = n3(f3), m10)))
            return f3.values[s3] = m10, 0;
        } else
          p10 = n3(f3);
        return f3.values[s3] = p10, 1;
      }
    };
  }
}
function wy(t10, e3, r3) {
  if (t10.length != e3.length)
    return false;
  for (let n3 = 0; n3 < t10.length; n3++)
    if (!r3(t10[n3], e3[n3]))
      return false;
  return true;
}
function Lp(t10, e3) {
  let r3 = false;
  for (let n3 of e3)
    ml(t10, n3) & 1 && (r3 = true);
  return r3;
}
function YC(t10, e3, r3) {
  let n3 = r3.map((l3) => t10[l3.id]), i3 = r3.map((l3) => l3.type), o3 = n3.filter((l3) => !(l3 & 1)), s3 = t10[e3.id] >> 1;
  function a3(l3) {
    let u3 = [];
    for (let c3 = 0; c3 < n3.length; c3++) {
      let f3 = ef(l3, n3[c3]);
      if (i3[c3] == 2)
        for (let d3 of f3)
          u3.push(d3);
      else
        u3.push(f3);
    }
    return e3.combine(u3);
  }
  return {
    create(l3) {
      for (let u3 of n3)
        ml(l3, u3);
      return l3.values[s3] = a3(l3), 1;
    },
    update(l3, u3) {
      if (!Lp(l3, o3))
        return 0;
      let c3 = a3(l3);
      return e3.compare(c3, l3.values[s3]) ? 0 : (l3.values[s3] = c3, 1);
    },
    reconfigure(l3, u3) {
      let c3 = Lp(l3, n3), f3 = u3.config.facets[e3.id], d3 = u3.facet(e3);
      if (f3 && !c3 && _g(r3, f3))
        return l3.values[s3] = d3, 0;
      let p10 = a3(l3);
      return e3.compare(p10, d3) ? (l3.values[s3] = d3, 0) : (l3.values[s3] = p10, 1);
    }
  };
}
const Py = /* @__PURE__ */ Me.define({ static: true });
class vo {
  constructor(e3, r3, n3, i3, o3) {
    this.id = e3, this.createF = r3, this.updateF = n3, this.compareF = i3, this.spec = o3, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e3) {
    let r3 = new vo(Pg++, e3.create, e3.update, e3.compare || ((n3, i3) => n3 === i3), e3);
    return e3.provide && (r3.provides = e3.provide(r3)), r3;
  }
  create(e3) {
    let r3 = e3.facet(Py).find((n3) => n3.field == this);
    return ((r3 == null ? void 0 : r3.create) || this.createF)(e3);
  }
  /**
  @internal
  */
  slot(e3) {
    let r3 = e3[this.id] >> 1;
    return {
      create: (n3) => (n3.values[r3] = this.create(n3), 1),
      update: (n3, i3) => {
        let o3 = n3.values[r3], s3 = this.updateF(o3, i3);
        return this.compareF(o3, s3) ? 0 : (n3.values[r3] = s3, 1);
      },
      reconfigure: (n3, i3) => i3.config.address[this.id] != null ? (n3.values[r3] = i3.field(this), 0) : (n3.values[r3] = this.create(n3), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e3) {
    return [this, Py.of({ field: this, create: e3 })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Ao = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Wa(t10) {
  return (e3) => new A2(e3, t10);
}
const Bf = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Wa(Ao.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Wa(Ao.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Wa(Ao.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Wa(Ao.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Wa(Ao.lowest)
};
class A2 {
  constructor(e3, r3) {
    this.inner = e3, this.prec = r3;
  }
}
class zf {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e3) {
    return new Bp(this, e3);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e3) {
    return zf.reconfigure.of({ compartment: this, extension: e3 });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e3) {
    return e3.config.compartments.get(this);
  }
}
class Bp {
  constructor(e3, r3) {
    this.compartment = e3, this.inner = r3;
  }
}
class Jc {
  constructor(e3, r3, n3, i3, o3, s3) {
    for (this.base = e3, this.compartments = r3, this.dynamicSlots = n3, this.address = i3, this.staticValues = o3, this.facets = s3, this.statusTemplate = []; this.statusTemplate.length < n3.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e3) {
    let r3 = this.address[e3.id];
    return r3 == null ? e3.default : this.staticValues[r3 >> 1];
  }
  static resolve(e3, r3, n3) {
    let i3 = [], o3 = /* @__PURE__ */ Object.create(null), s3 = /* @__PURE__ */ new Map();
    for (let d3 of LC(e3, r3, s3))
      d3 instanceof vo ? i3.push(d3) : (o3[d3.facet.id] || (o3[d3.facet.id] = [])).push(d3);
    let a3 = /* @__PURE__ */ Object.create(null), l3 = [], u3 = [];
    for (let d3 of i3)
      a3[d3.id] = u3.length << 1, u3.push((p10) => d3.slot(p10));
    let c3 = n3 == null ? void 0 : n3.config.facets;
    for (let d3 in o3) {
      let p10 = o3[d3], h10 = p10[0].facet, m10 = c3 && c3[d3] || [];
      if (p10.every(
        (O10) => O10.type == 0
        /* Provider.Static */
      ))
        if (a3[h10.id] = l3.length << 1 | 1, _g(m10, p10))
          l3.push(n3.facet(h10));
        else {
          let O10 = h10.combine(p10.map((g) => g.value));
          l3.push(n3 && h10.compare(O10, n3.facet(h10)) ? n3.facet(h10) : O10);
        }
      else {
        for (let O10 of p10)
          O10.type == 0 ? (a3[O10.id] = l3.length << 1 | 1, l3.push(O10.value)) : (a3[O10.id] = u3.length << 1, u3.push((g) => O10.dynamicSlot(g)));
        a3[h10.id] = u3.length << 1, u3.push((O10) => YC(O10, h10, p10));
      }
    }
    let f3 = u3.map((d3) => d3(a3));
    return new Jc(e3, s3, f3, a3, l3, o3);
  }
}
function LC(t10, e3, r3) {
  let n3 = [[], [], [], [], []], i3 = /* @__PURE__ */ new Map();
  function o3(s3, a3) {
    let l3 = i3.get(s3);
    if (l3 != null) {
      if (l3 <= a3)
        return;
      let u3 = n3[l3].indexOf(s3);
      u3 > -1 && n3[l3].splice(u3, 1), s3 instanceof Bp && r3.delete(s3.compartment);
    }
    if (i3.set(s3, a3), Array.isArray(s3))
      for (let u3 of s3)
        o3(u3, a3);
    else if (s3 instanceof Bp) {
      if (r3.has(s3.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u3 = e3.get(s3.compartment) || s3.inner;
      r3.set(s3.compartment, u3), o3(u3, a3);
    } else if (s3 instanceof A2)
      o3(s3.inner, s3.prec);
    else if (s3 instanceof vo)
      n3[a3].push(s3), s3.provides && o3(s3.provides, a3);
    else if (s3 instanceof vc)
      n3[a3].push(s3), s3.facet.extensions && o3(s3.facet.extensions, Ao.default);
    else {
      let u3 = s3.extension;
      if (!u3)
        throw new Error(`Unrecognized extension value in extension set (${s3}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      o3(u3, a3);
    }
  }
  return o3(t10, Ao.default), n3.reduce((s3, a3) => s3.concat(a3));
}
function ml(t10, e3) {
  if (e3 & 1)
    return 2;
  let r3 = e3 >> 1, n3 = t10.status[r3];
  if (n3 == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (n3 & 2)
    return n3;
  t10.status[r3] = 4;
  let i3 = t10.computeSlot(t10, t10.config.dynamicSlots[r3]);
  return t10.status[r3] = 2 | i3;
}
function ef(t10, e3) {
  return e3 & 1 ? t10.config.staticValues[e3 >> 1] : t10.values[e3 >> 1];
}
const X2 = /* @__PURE__ */ Me.define(), q2 = /* @__PURE__ */ Me.define({
  combine: (t10) => t10.some((e3) => e3),
  static: true
}), D2 = /* @__PURE__ */ Me.define({
  combine: (t10) => t10.length ? t10[0] : void 0,
  static: true
}), j2 = /* @__PURE__ */ Me.define(), U2 = /* @__PURE__ */ Me.define(), I2 = /* @__PURE__ */ Me.define(), F2 = /* @__PURE__ */ Me.define({
  combine: (t10) => t10.length ? t10[0] : false
});
class ms {
  /**
  @internal
  */
  constructor(e3, r3) {
    this.type = e3, this.value = r3;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new BC();
  }
}
class BC {
  /**
  Create an instance of this annotation.
  */
  of(e3) {
    return new ms(this, e3);
  }
}
class zC {
  /**
  @internal
  */
  constructor(e3) {
    this.map = e3;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e3) {
    return new Dt(this, e3);
  }
}
class Dt {
  /**
  @internal
  */
  constructor(e3, r3) {
    this.type = e3, this.value = r3;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e3) {
    let r3 = this.type.map(this.value, e3);
    return r3 === void 0 ? void 0 : r3 == this.value ? this : new Dt(this.type, r3);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e3) {
    return this.type == e3;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e3 = {}) {
    return new zC(e3.map || ((r3) => r3));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e3, r3) {
    if (!e3.length)
      return e3;
    let n3 = [];
    for (let i3 of e3) {
      let o3 = i3.map(r3);
      o3 && n3.push(o3);
    }
    return n3;
  }
}
Dt.reconfigure = /* @__PURE__ */ Dt.define();
Dt.appendConfig = /* @__PURE__ */ Dt.define();
class vr {
  constructor(e3, r3, n3, i3, o3, s3) {
    this.startState = e3, this.changes = r3, this.selection = n3, this.effects = i3, this.annotations = o3, this.scrollIntoView = s3, this._doc = null, this._state = null, n3 && R2(n3, r3.newLength), o3.some((a3) => a3.type == vr.time) || (this.annotations = o3.concat(vr.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e3, r3, n3, i3, o3, s3) {
    return new vr(e3, r3, n3, i3, o3, s3);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e3) {
    for (let r3 of this.annotations)
      if (r3.type == e3)
        return r3.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e3) {
    let r3 = this.annotation(vr.userEvent);
    return !!(r3 && (r3 == e3 || r3.length > e3.length && r3.slice(0, e3.length) == e3 && r3[e3.length] == "."));
  }
}
vr.time = /* @__PURE__ */ ms.define();
vr.userEvent = /* @__PURE__ */ ms.define();
vr.addToHistory = /* @__PURE__ */ ms.define();
vr.remote = /* @__PURE__ */ ms.define();
function HC(t10, e3) {
  let r3 = [];
  for (let n3 = 0, i3 = 0; ; ) {
    let o3, s3;
    if (n3 < t10.length && (i3 == e3.length || e3[i3] >= t10[n3]))
      o3 = t10[n3++], s3 = t10[n3++];
    else if (i3 < e3.length)
      o3 = e3[i3++], s3 = e3[i3++];
    else
      return r3;
    !r3.length || r3[r3.length - 1] < o3 ? r3.push(o3, s3) : r3[r3.length - 1] < s3 && (r3[r3.length - 1] = s3);
  }
}
function Z2(t10, e3, r3) {
  var n3;
  let i3, o3, s3;
  return r3 ? (i3 = e3.changes, o3 = rr.empty(e3.changes.length), s3 = t10.changes.compose(e3.changes)) : (i3 = e3.changes.map(t10.changes), o3 = t10.changes.mapDesc(e3.changes, true), s3 = t10.changes.compose(i3)), {
    changes: s3,
    selection: e3.selection ? e3.selection.map(o3) : (n3 = t10.selection) === null || n3 === void 0 ? void 0 : n3.map(i3),
    effects: Dt.mapEffects(t10.effects, i3).concat(Dt.mapEffects(e3.effects, o3)),
    annotations: t10.annotations.length ? t10.annotations.concat(e3.annotations) : e3.annotations,
    scrollIntoView: t10.scrollIntoView || e3.scrollIntoView
  };
}
function zp(t10, e3, r3) {
  let n3 = e3.selection, i3 = Hs(e3.annotations);
  return e3.userEvent && (i3 = i3.concat(vr.userEvent.of(e3.userEvent))), {
    changes: e3.changes instanceof rr ? e3.changes : rr.of(e3.changes || [], r3, t10.facet(D2)),
    selection: n3 && (n3 instanceof Pe ? n3 : Pe.single(n3.anchor, n3.head)),
    effects: Hs(e3.effects),
    annotations: i3,
    scrollIntoView: !!e3.scrollIntoView
  };
}
function M2(t10, e3, r3) {
  let n3 = zp(t10, e3.length ? e3[0] : {}, t10.doc.length);
  e3.length && e3[0].filter === false && (r3 = false);
  for (let o3 = 1; o3 < e3.length; o3++) {
    e3[o3].filter === false && (r3 = false);
    let s3 = !!e3[o3].sequential;
    n3 = Z2(n3, zp(t10, e3[o3], s3 ? n3.changes.newLength : t10.doc.length), s3);
  }
  let i3 = vr.create(t10, n3.changes, n3.selection, n3.effects, n3.annotations, n3.scrollIntoView);
  return KC(r3 ? GC(i3) : i3);
}
function GC(t10) {
  let e3 = t10.startState, r3 = true;
  for (let i3 of e3.facet(j2)) {
    let o3 = i3(t10);
    if (o3 === false) {
      r3 = false;
      break;
    }
    Array.isArray(o3) && (r3 = r3 === true ? o3 : HC(r3, o3));
  }
  if (r3 !== true) {
    let i3, o3;
    if (r3 === false)
      o3 = t10.changes.invertedDesc, i3 = rr.empty(e3.doc.length);
    else {
      let s3 = t10.changes.filter(r3);
      i3 = s3.changes, o3 = s3.filtered.mapDesc(s3.changes).invertedDesc;
    }
    t10 = vr.create(e3, i3, t10.selection && t10.selection.map(o3), Dt.mapEffects(t10.effects, o3), t10.annotations, t10.scrollIntoView);
  }
  let n3 = e3.facet(U2);
  for (let i3 = n3.length - 1; i3 >= 0; i3--) {
    let o3 = n3[i3](t10);
    o3 instanceof vr ? t10 = o3 : Array.isArray(o3) && o3.length == 1 && o3[0] instanceof vr ? t10 = o3[0] : t10 = M2(e3, Hs(o3), false);
  }
  return t10;
}
function KC(t10) {
  let e3 = t10.startState, r3 = e3.facet(I2), n3 = t10;
  for (let i3 = r3.length - 1; i3 >= 0; i3--) {
    let o3 = r3[i3](t10);
    o3 && Object.keys(o3).length && (n3 = Z2(n3, zp(e3, o3, t10.changes.newLength), true));
  }
  return n3 == t10 ? t10 : vr.create(e3, t10.changes, t10.selection, n3.effects, n3.annotations, n3.scrollIntoView);
}
const JC = [];
function Hs(t10) {
  return t10 == null ? JC : Array.isArray(t10) ? t10 : [t10];
}
var wi = /* @__PURE__ */ function(t10) {
  return t10[t10.Word = 0] = "Word", t10[t10.Space = 1] = "Space", t10[t10.Other = 2] = "Other", t10;
}(wi || (wi = {}));
const eR = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Hp;
try {
  Hp = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function tR(t10) {
  if (Hp)
    return Hp.test(t10);
  for (let e3 = 0; e3 < t10.length; e3++) {
    let r3 = t10[e3];
    if (/\w/.test(r3) || r3 > "" && (r3.toUpperCase() != r3.toLowerCase() || eR.test(r3)))
      return true;
  }
  return false;
}
function rR(t10) {
  return (e3) => {
    if (!/\S/.test(e3))
      return wi.Space;
    if (tR(e3))
      return wi.Word;
    for (let r3 = 0; r3 < t10.length; r3++)
      if (e3.indexOf(t10[r3]) > -1)
        return wi.Word;
    return wi.Other;
  };
}
class pt {
  constructor(e3, r3, n3, i3, o3, s3) {
    this.config = e3, this.doc = r3, this.selection = n3, this.values = i3, this.status = e3.statusTemplate.slice(), this.computeSlot = o3, s3 && (s3._state = this);
    for (let a3 = 0; a3 < this.config.dynamicSlots.length; a3++)
      ml(this, a3 << 1);
    this.computeSlot = null;
  }
  field(e3, r3 = true) {
    let n3 = this.config.address[e3.id];
    if (n3 == null) {
      if (r3)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return ml(this, n3), ef(this, n3);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e3) {
    return M2(this, e3, true);
  }
  /**
  @internal
  */
  applyTransaction(e3) {
    let r3 = this.config, { base: n3, compartments: i3 } = r3;
    for (let s3 of e3.effects)
      s3.is(zf.reconfigure) ? (r3 && (i3 = /* @__PURE__ */ new Map(), r3.compartments.forEach((a3, l3) => i3.set(l3, a3)), r3 = null), i3.set(s3.value.compartment, s3.value.extension)) : s3.is(Dt.reconfigure) ? (r3 = null, n3 = s3.value) : s3.is(Dt.appendConfig) && (r3 = null, n3 = Hs(n3).concat(s3.value));
    let o3;
    r3 ? o3 = e3.startState.values.slice() : (r3 = Jc.resolve(n3, i3, this), o3 = new pt(r3, this.doc, this.selection, r3.dynamicSlots.map(() => null), (a3, l3) => l3.reconfigure(a3, this), null).values), new pt(r3, e3.newDoc, e3.newSelection, o3, (s3, a3) => a3.update(s3, e3), e3);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e3) {
    return typeof e3 == "string" && (e3 = this.toText(e3)), this.changeByRange((r3) => ({
      changes: { from: r3.from, to: r3.to, insert: e3 },
      range: Pe.cursor(r3.from + e3.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e3) {
    let r3 = this.selection, n3 = e3(r3.ranges[0]), i3 = this.changes(n3.changes), o3 = [n3.range], s3 = Hs(n3.effects);
    for (let a3 = 1; a3 < r3.ranges.length; a3++) {
      let l3 = e3(r3.ranges[a3]), u3 = this.changes(l3.changes), c3 = u3.map(i3);
      for (let d3 = 0; d3 < a3; d3++)
        o3[d3] = o3[d3].map(c3);
      let f3 = i3.mapDesc(u3, true);
      o3.push(l3.range.map(f3)), i3 = i3.compose(c3), s3 = Dt.mapEffects(s3, c3).concat(Dt.mapEffects(Hs(l3.effects), f3));
    }
    return {
      changes: i3,
      selection: Pe.create(o3, r3.mainIndex),
      effects: s3
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e3 = []) {
    return e3 instanceof rr ? e3 : rr.of(e3, this.doc.length, this.facet(pt.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e3) {
    return ct.of(e3.split(this.facet(pt.lineSeparator) || Wp));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e3 = 0, r3 = this.doc.length) {
    return this.doc.sliceString(e3, r3, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e3) {
    let r3 = this.config.address[e3.id];
    return r3 == null ? e3.default : (ml(this, r3), ef(this, r3));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e3) {
    let r3 = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e3)
      for (let n3 in e3) {
        let i3 = e3[n3];
        i3 instanceof vo && this.config.address[i3.id] != null && (r3[n3] = i3.spec.toJSON(this.field(e3[n3]), this));
      }
    return r3;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e3, r3 = {}, n3) {
    if (!e3 || typeof e3.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i3 = [];
    if (n3) {
      for (let o3 in n3)
        if (Object.prototype.hasOwnProperty.call(e3, o3)) {
          let s3 = n3[o3], a3 = e3[o3];
          i3.push(s3.init((l3) => s3.spec.fromJSON(a3, l3)));
        }
    }
    return pt.create({
      doc: e3.doc,
      selection: Pe.fromJSON(e3.selection),
      extensions: r3.extensions ? i3.concat([r3.extensions]) : i3
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e3 = {}) {
    let r3 = Jc.resolve(e3.extensions || [], /* @__PURE__ */ new Map()), n3 = e3.doc instanceof ct ? e3.doc : ct.of((e3.doc || "").split(r3.staticFacet(pt.lineSeparator) || Wp)), i3 = e3.selection ? e3.selection instanceof Pe ? e3.selection : Pe.single(e3.selection.anchor, e3.selection.head) : Pe.single(0);
    return R2(i3, n3.length), r3.staticFacet(q2) || (i3 = i3.asSingle()), new pt(r3, n3, i3, r3.dynamicSlots.map(() => null), (o3, s3) => s3.create(o3), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(pt.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(pt.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(F2);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e3, ...r3) {
    for (let n3 of this.facet(pt.phrases))
      if (Object.prototype.hasOwnProperty.call(n3, e3)) {
        e3 = n3[e3];
        break;
      }
    return r3.length && (e3 = e3.replace(/\$(\$|\d*)/g, (n3, i3) => {
      if (i3 == "$")
        return "$";
      let o3 = +(i3 || 1);
      return !o3 || o3 > r3.length ? n3 : r3[o3 - 1];
    })), e3;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e3, r3, n3 = -1) {
    let i3 = [];
    for (let o3 of this.facet(X2))
      for (let s3 of o3(this, r3, n3))
        Object.prototype.hasOwnProperty.call(s3, e3) && i3.push(s3[e3]);
    return i3;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e3) {
    return rR(this.languageDataAt("wordChars", e3).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e3) {
    let { text: r3, from: n3, length: i3 } = this.doc.lineAt(e3), o3 = this.charCategorizer(e3), s3 = e3 - n3, a3 = e3 - n3;
    for (; s3 > 0; ) {
      let l3 = $i(r3, s3, false);
      if (o3(r3.slice(l3, s3)) != wi.Word)
        break;
      s3 = l3;
    }
    for (; a3 < i3; ) {
      let l3 = $i(r3, a3);
      if (o3(r3.slice(a3, l3)) != wi.Word)
        break;
      a3 = l3;
    }
    return s3 == a3 ? null : Pe.range(s3 + n3, a3 + n3);
  }
}
pt.allowMultipleSelections = q2;
pt.tabSize = /* @__PURE__ */ Me.define({
  combine: (t10) => t10.length ? t10[0] : 4
});
pt.lineSeparator = D2;
pt.readOnly = F2;
pt.phrases = /* @__PURE__ */ Me.define({
  compare(t10, e3) {
    let r3 = Object.keys(t10), n3 = Object.keys(e3);
    return r3.length == n3.length && r3.every((i3) => t10[i3] == e3[i3]);
  }
});
pt.languageData = X2;
pt.changeFilter = j2;
pt.transactionFilter = U2;
pt.transactionExtender = I2;
zf.reconfigure = /* @__PURE__ */ Dt.define();
function nR(t10, e3, r3 = {}) {
  let n3 = {};
  for (let i3 of t10)
    for (let o3 of Object.keys(i3)) {
      let s3 = i3[o3], a3 = n3[o3];
      if (a3 === void 0)
        n3[o3] = s3;
      else if (!(a3 === s3 || s3 === void 0))
        if (Object.hasOwnProperty.call(r3, o3))
          n3[o3] = r3[o3](a3, s3);
        else
          throw new Error("Config merge conflict for field " + o3);
    }
  for (let i3 in e3)
    n3[i3] === void 0 && (n3[i3] = e3[i3]);
  return n3;
}
class rs {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e3) {
    return this == e3;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e3, r3 = e3) {
    return Al.create(e3, r3, this);
  }
}
rs.prototype.startSide = rs.prototype.endSide = 0;
rs.prototype.point = false;
rs.prototype.mapMode = kr.TrackDel;
class Al {
  constructor(e3, r3, n3) {
    this.from = e3, this.to = r3, this.value = n3;
  }
  /**
  @internal
  */
  static create(e3, r3, n3) {
    return new Al(e3, r3, n3);
  }
}
function Gp(t10, e3) {
  return t10.from - e3.from || t10.value.startSide - e3.value.startSide;
}
class xg {
  constructor(e3, r3, n3, i3) {
    this.from = e3, this.to = r3, this.value = n3, this.maxPoint = i3;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e3, r3, n3, i3 = 0) {
    let o3 = n3 ? this.to : this.from;
    for (let s3 = i3, a3 = o3.length; ; ) {
      if (s3 == a3)
        return s3;
      let l3 = s3 + a3 >> 1, u3 = o3[l3] - e3 || (n3 ? this.value[l3].endSide : this.value[l3].startSide) - r3;
      if (l3 == s3)
        return u3 >= 0 ? s3 : a3;
      u3 >= 0 ? a3 = l3 : s3 = l3 + 1;
    }
  }
  between(e3, r3, n3, i3) {
    for (let o3 = this.findIndex(r3, -1e9, true), s3 = this.findIndex(n3, 1e9, false, o3); o3 < s3; o3++)
      if (i3(this.from[o3] + e3, this.to[o3] + e3, this.value[o3]) === false)
        return false;
  }
  map(e3, r3) {
    let n3 = [], i3 = [], o3 = [], s3 = -1, a3 = -1;
    for (let l3 = 0; l3 < this.value.length; l3++) {
      let u3 = this.value[l3], c3 = this.from[l3] + e3, f3 = this.to[l3] + e3, d3, p10;
      if (c3 == f3) {
        let h10 = r3.mapPos(c3, u3.startSide, u3.mapMode);
        if (h10 == null || (d3 = p10 = h10, u3.startSide != u3.endSide && (p10 = r3.mapPos(c3, u3.endSide), p10 < d3)))
          continue;
      } else if (d3 = r3.mapPos(c3, u3.startSide), p10 = r3.mapPos(f3, u3.endSide), d3 > p10 || d3 == p10 && u3.startSide > 0 && u3.endSide <= 0)
        continue;
      (p10 - d3 || u3.endSide - u3.startSide) < 0 || (s3 < 0 && (s3 = d3), u3.point && (a3 = Math.max(a3, p10 - d3)), n3.push(u3), i3.push(d3 - s3), o3.push(p10 - s3));
    }
    return { mapped: n3.length ? new xg(i3, o3, n3, a3) : null, pos: s3 };
  }
}
class xt {
  constructor(e3, r3, n3, i3) {
    this.chunkPos = e3, this.chunk = r3, this.nextLayer = n3, this.maxPoint = i3;
  }
  /**
  @internal
  */
  static create(e3, r3, n3, i3) {
    return new xt(e3, r3, n3, i3);
  }
  /**
  @internal
  */
  get length() {
    let e3 = this.chunk.length - 1;
    return e3 < 0 ? 0 : Math.max(this.chunkEnd(e3), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e3 = this.nextLayer.size;
    for (let r3 of this.chunk)
      e3 += r3.value.length;
    return e3;
  }
  /**
  @internal
  */
  chunkEnd(e3) {
    return this.chunkPos[e3] + this.chunk[e3].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e3) {
    let { add: r3 = [], sort: n3 = false, filterFrom: i3 = 0, filterTo: o3 = this.length } = e3, s3 = e3.filter;
    if (r3.length == 0 && !s3)
      return this;
    if (n3 && (r3 = r3.slice().sort(Gp)), this.isEmpty)
      return r3.length ? xt.of(r3) : this;
    let a3 = new N2(this, null, -1).goto(0), l3 = 0, u3 = [], c3 = new aa();
    for (; a3.value || l3 < r3.length; )
      if (l3 < r3.length && (a3.from - r3[l3].from || a3.startSide - r3[l3].value.startSide) >= 0) {
        let f3 = r3[l3++];
        c3.addInner(f3.from, f3.to, f3.value) || u3.push(f3);
      } else
        a3.rangeIndex == 1 && a3.chunkIndex < this.chunk.length && (l3 == r3.length || this.chunkEnd(a3.chunkIndex) < r3[l3].from) && (!s3 || i3 > this.chunkEnd(a3.chunkIndex) || o3 < this.chunkPos[a3.chunkIndex]) && c3.addChunk(this.chunkPos[a3.chunkIndex], this.chunk[a3.chunkIndex]) ? a3.nextChunk() : ((!s3 || i3 > a3.to || o3 < a3.from || s3(a3.from, a3.to, a3.value)) && (c3.addInner(a3.from, a3.to, a3.value) || u3.push(Al.create(a3.from, a3.to, a3.value))), a3.next());
    return c3.finishInner(this.nextLayer.isEmpty && !u3.length ? xt.empty : this.nextLayer.update({ add: u3, filter: s3, filterFrom: i3, filterTo: o3 }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e3) {
    if (e3.empty || this.isEmpty)
      return this;
    let r3 = [], n3 = [], i3 = -1;
    for (let s3 = 0; s3 < this.chunk.length; s3++) {
      let a3 = this.chunkPos[s3], l3 = this.chunk[s3], u3 = e3.touchesRange(a3, a3 + l3.length);
      if (u3 === false)
        i3 = Math.max(i3, l3.maxPoint), r3.push(l3), n3.push(e3.mapPos(a3));
      else if (u3 === true) {
        let { mapped: c3, pos: f3 } = l3.map(a3, e3);
        c3 && (i3 = Math.max(i3, c3.maxPoint), r3.push(c3), n3.push(f3));
      }
    }
    let o3 = this.nextLayer.map(e3);
    return r3.length == 0 ? o3 : new xt(n3, r3, o3 || xt.empty, i3);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e3, r3, n3) {
    if (!this.isEmpty) {
      for (let i3 = 0; i3 < this.chunk.length; i3++) {
        let o3 = this.chunkPos[i3], s3 = this.chunk[i3];
        if (r3 >= o3 && e3 <= o3 + s3.length && s3.between(o3, e3 - o3, r3 - o3, n3) === false)
          return;
      }
      this.nextLayer.between(e3, r3, n3);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e3 = 0) {
    return Xl.from([this]).goto(e3);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e3, r3 = 0) {
    return Xl.from(e3).goto(r3);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e3, r3, n3, i3, o3 = -1) {
    let s3 = e3.filter((f3) => f3.maxPoint > 0 || !f3.isEmpty && f3.maxPoint >= o3), a3 = r3.filter((f3) => f3.maxPoint > 0 || !f3.isEmpty && f3.maxPoint >= o3), l3 = _y(s3, a3, n3), u3 = new Va(s3, l3, o3), c3 = new Va(a3, l3, o3);
    n3.iterGaps((f3, d3, p10) => xy(u3, f3, c3, d3, p10, i3)), n3.empty && n3.length == 0 && xy(u3, 0, c3, 0, 0, i3);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e3, r3, n3 = 0, i3) {
    i3 == null && (i3 = 1e9 - 1);
    let o3 = e3.filter((c3) => !c3.isEmpty && r3.indexOf(c3) < 0), s3 = r3.filter((c3) => !c3.isEmpty && e3.indexOf(c3) < 0);
    if (o3.length != s3.length)
      return false;
    if (!o3.length)
      return true;
    let a3 = _y(o3, s3), l3 = new Va(o3, a3, 0).goto(n3), u3 = new Va(s3, a3, 0).goto(n3);
    for (; ; ) {
      if (l3.to != u3.to || !Kp(l3.active, u3.active) || l3.point && (!u3.point || !l3.point.eq(u3.point)))
        return false;
      if (l3.to > i3)
        return true;
      l3.next(), u3.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e3, r3, n3, i3, o3 = -1) {
    let s3 = new Va(e3, null, o3).goto(r3), a3 = r3, l3 = s3.openStart;
    for (; ; ) {
      let u3 = Math.min(s3.to, n3);
      if (s3.point) {
        let c3 = s3.activeForPoint(s3.to), f3 = s3.pointFrom < r3 ? c3.length + 1 : Math.min(c3.length, l3);
        i3.point(a3, u3, s3.point, c3, f3, s3.pointRank), l3 = Math.min(s3.openEnd(u3), c3.length);
      } else
        u3 > a3 && (i3.span(a3, u3, s3.active, l3), l3 = s3.openEnd(u3));
      if (s3.to > n3)
        return l3 + (s3.point && s3.to > n3 ? 1 : 0);
      a3 = s3.to, s3.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e3, r3 = false) {
    let n3 = new aa();
    for (let i3 of e3 instanceof Al ? [e3] : r3 ? iR(e3) : e3)
      n3.add(i3.from, i3.to, i3.value);
    return n3.finish();
  }
}
xt.empty = /* @__PURE__ */ new xt([], [], null, -1);
function iR(t10) {
  if (t10.length > 1)
    for (let e3 = t10[0], r3 = 1; r3 < t10.length; r3++) {
      let n3 = t10[r3];
      if (Gp(e3, n3) > 0)
        return t10.slice().sort(Gp);
      e3 = n3;
    }
  return t10;
}
xt.empty.nextLayer = xt.empty;
class aa {
  finishChunk(e3) {
    this.chunks.push(new xg(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e3 && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e3, r3, n3) {
    this.addInner(e3, r3, n3) || (this.nextLayer || (this.nextLayer = new aa())).add(e3, r3, n3);
  }
  /**
  @internal
  */
  addInner(e3, r3, n3) {
    let i3 = e3 - this.lastTo || n3.startSide - this.last.endSide;
    if (i3 <= 0 && (e3 - this.lastFrom || n3.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i3 < 0 ? false : (this.from.length == 250 && this.finishChunk(true), this.chunkStart < 0 && (this.chunkStart = e3), this.from.push(e3 - this.chunkStart), this.to.push(r3 - this.chunkStart), this.last = n3, this.lastFrom = e3, this.lastTo = r3, this.value.push(n3), n3.point && (this.maxPoint = Math.max(this.maxPoint, r3 - e3)), true);
  }
  /**
  @internal
  */
  addChunk(e3, r3) {
    if ((e3 - this.lastTo || r3.value[0].startSide - this.last.endSide) < 0)
      return false;
    this.from.length && this.finishChunk(true), this.setMaxPoint = Math.max(this.setMaxPoint, r3.maxPoint), this.chunks.push(r3), this.chunkPos.push(e3);
    let n3 = r3.value.length - 1;
    return this.last = r3.value[n3], this.lastFrom = r3.from[n3] + e3, this.lastTo = r3.to[n3] + e3, true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(xt.empty);
  }
  /**
  @internal
  */
  finishInner(e3) {
    if (this.from.length && this.finishChunk(false), this.chunks.length == 0)
      return e3;
    let r3 = xt.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e3) : e3, this.setMaxPoint);
    return this.from = null, r3;
  }
}
function _y(t10, e3, r3) {
  let n3 = /* @__PURE__ */ new Map();
  for (let o3 of t10)
    for (let s3 = 0; s3 < o3.chunk.length; s3++)
      o3.chunk[s3].maxPoint <= 0 && n3.set(o3.chunk[s3], o3.chunkPos[s3]);
  let i3 = /* @__PURE__ */ new Set();
  for (let o3 of e3)
    for (let s3 = 0; s3 < o3.chunk.length; s3++) {
      let a3 = n3.get(o3.chunk[s3]);
      a3 != null && (r3 ? r3.mapPos(a3) : a3) == o3.chunkPos[s3] && !(r3 != null && r3.touchesRange(a3, a3 + o3.chunk[s3].length)) && i3.add(o3.chunk[s3]);
    }
  return i3;
}
class N2 {
  constructor(e3, r3, n3, i3 = 0) {
    this.layer = e3, this.skip = r3, this.minPoint = n3, this.rank = i3;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e3, r3 = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e3, r3, false), this;
  }
  gotoInner(e3, r3, n3) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i3 = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i3) || this.layer.chunkEnd(this.chunkIndex) < e3 || i3.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, n3 = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i3 = this.layer.chunk[this.chunkIndex].findIndex(e3 - this.layer.chunkPos[this.chunkIndex], r3, true);
      (!n3 || this.rangeIndex < i3) && this.setRangeIndex(i3);
    }
    this.next();
  }
  forward(e3, r3) {
    (this.to - e3 || this.endSide - r3) < 0 && this.gotoInner(e3, r3, true);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e3 = this.layer.chunkPos[this.chunkIndex], r3 = this.layer.chunk[this.chunkIndex], n3 = e3 + r3.from[this.rangeIndex];
        if (this.from = n3, this.to = e3 + r3.to[this.rangeIndex], this.value = r3.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e3) {
    if (e3 == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e3;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e3) {
    return this.from - e3.from || this.startSide - e3.startSide || this.rank - e3.rank || this.to - e3.to || this.endSide - e3.endSide;
  }
}
class Xl {
  constructor(e3) {
    this.heap = e3;
  }
  static from(e3, r3 = null, n3 = -1) {
    let i3 = [];
    for (let o3 = 0; o3 < e3.length; o3++)
      for (let s3 = e3[o3]; !s3.isEmpty; s3 = s3.nextLayer)
        s3.maxPoint >= n3 && i3.push(new N2(s3, r3, n3, o3));
    return i3.length == 1 ? i3[0] : new Xl(i3);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e3, r3 = -1e9) {
    for (let n3 of this.heap)
      n3.goto(e3, r3);
    for (let n3 = this.heap.length >> 1; n3 >= 0; n3--)
      ch(this.heap, n3);
    return this.next(), this;
  }
  forward(e3, r3) {
    for (let n3 of this.heap)
      n3.forward(e3, r3);
    for (let n3 = this.heap.length >> 1; n3 >= 0; n3--)
      ch(this.heap, n3);
    (this.to - e3 || this.value.endSide - r3) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e3 = this.heap[0];
      this.from = e3.from, this.to = e3.to, this.value = e3.value, this.rank = e3.rank, e3.value && e3.next(), ch(this.heap, 0);
    }
  }
}
function ch(t10, e3) {
  for (let r3 = t10[e3]; ; ) {
    let n3 = (e3 << 1) + 1;
    if (n3 >= t10.length)
      break;
    let i3 = t10[n3];
    if (n3 + 1 < t10.length && i3.compare(t10[n3 + 1]) >= 0 && (i3 = t10[n3 + 1], n3++), r3.compare(i3) < 0)
      break;
    t10[n3] = r3, t10[e3] = i3, e3 = n3;
  }
}
class Va {
  constructor(e3, r3, n3) {
    this.minPoint = n3, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Xl.from(e3, r3, n3);
  }
  goto(e3, r3 = -1e9) {
    return this.cursor.goto(e3, r3), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e3, this.endSide = r3, this.openStart = -1, this.next(), this;
  }
  forward(e3, r3) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e3 || this.active[this.minActive].endSide - r3) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e3, r3);
  }
  removeActive(e3) {
    Mu(this.active, e3), Mu(this.activeTo, e3), Mu(this.activeRank, e3), this.minActive = Qy(this.active, this.activeTo);
  }
  addActive(e3) {
    let r3 = 0, { value: n3, to: i3, rank: o3 } = this.cursor;
    for (; r3 < this.activeRank.length && this.activeRank[r3] <= o3; )
      r3++;
    Nu(this.active, r3, n3), Nu(this.activeTo, r3, i3), Nu(this.activeRank, r3, o3), e3 && Nu(e3, r3, this.cursor.from), this.minActive = Qy(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e3 = this.to, r3 = this.point;
    this.point = null;
    let n3 = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i3 = this.minActive;
      if (i3 > -1 && (this.activeTo[i3] - this.cursor.from || this.active[i3].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i3] > e3) {
          this.to = this.activeTo[i3], this.endSide = this.active[i3].endSide;
          break;
        }
        this.removeActive(i3), n3 && Mu(n3, i3);
      } else if (this.cursor.value)
        if (this.cursor.from > e3) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o3 = this.cursor.value;
          if (!o3.point)
            this.addActive(n3), this.cursor.next();
          else if (r3 && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = o3, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o3.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (n3) {
      this.openStart = 0;
      for (let i3 = n3.length - 1; i3 >= 0 && n3[i3] < e3; i3--)
        this.openStart++;
    }
  }
  activeForPoint(e3) {
    if (!this.active.length)
      return this.active;
    let r3 = [];
    for (let n3 = this.active.length - 1; n3 >= 0 && !(this.activeRank[n3] < this.pointRank); n3--)
      (this.activeTo[n3] > e3 || this.activeTo[n3] == e3 && this.active[n3].endSide >= this.point.endSide) && r3.push(this.active[n3]);
    return r3.reverse();
  }
  openEnd(e3) {
    let r3 = 0;
    for (let n3 = this.activeTo.length - 1; n3 >= 0 && this.activeTo[n3] > e3; n3--)
      r3++;
    return r3;
  }
}
function xy(t10, e3, r3, n3, i3, o3) {
  t10.goto(e3), r3.goto(n3);
  let s3 = n3 + i3, a3 = n3, l3 = n3 - e3;
  for (; ; ) {
    let u3 = t10.to + l3 - r3.to || t10.endSide - r3.endSide, c3 = u3 < 0 ? t10.to + l3 : r3.to, f3 = Math.min(c3, s3);
    if (t10.point || r3.point ? t10.point && r3.point && (t10.point == r3.point || t10.point.eq(r3.point)) && Kp(t10.activeForPoint(t10.to), r3.activeForPoint(r3.to)) || o3.comparePoint(a3, f3, t10.point, r3.point) : f3 > a3 && !Kp(t10.active, r3.active) && o3.compareRange(a3, f3, t10.active, r3.active), c3 > s3)
      break;
    a3 = c3, u3 <= 0 && t10.next(), u3 >= 0 && r3.next();
  }
}
function Kp(t10, e3) {
  if (t10.length != e3.length)
    return false;
  for (let r3 = 0; r3 < t10.length; r3++)
    if (t10[r3] != e3[r3] && !t10[r3].eq(e3[r3]))
      return false;
  return true;
}
function Mu(t10, e3) {
  for (let r3 = e3, n3 = t10.length - 1; r3 < n3; r3++)
    t10[r3] = t10[r3 + 1];
  t10.pop();
}
function Nu(t10, e3, r3) {
  for (let n3 = t10.length - 1; n3 >= e3; n3--)
    t10[n3 + 1] = t10[n3];
  t10[e3] = r3;
}
function Qy(t10, e3) {
  let r3 = -1, n3 = 1e9;
  for (let i3 = 0; i3 < e3.length; i3++)
    (e3[i3] - n3 || t10[i3].endSide - t10[r3].endSide) < 0 && (r3 = i3, n3 = e3[i3]);
  return r3;
}
function oR(t10, e3, r3, n3) {
  for (let i3 = 0, o3 = 0; ; ) {
    if (o3 >= e3)
      return i3;
    if (i3 == t10.length)
      break;
    o3 += t10.charCodeAt(i3) == 9 ? r3 - o3 % r3 : 1, i3 = $i(t10, i3);
  }
  return n3 === true ? -1 : t10.length;
}
const Jp = "ͼ", Ty = typeof Symbol > "u" ? "__" + Jp : Symbol.for(Jp), eO = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), ky = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class uo {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e3, r3) {
    this.rules = [];
    let { finish: n3 } = r3 || {};
    function i3(s3) {
      return /^@/.test(s3) ? [s3] : s3.split(/,\s*/);
    }
    function o3(s3, a3, l3, u3) {
      let c3 = [], f3 = /^@(\w+)\b/.exec(s3[0]), d3 = f3 && f3[1] == "keyframes";
      if (f3 && a3 == null)
        return l3.push(s3[0] + ";");
      for (let p10 in a3) {
        let h10 = a3[p10];
        if (/&/.test(p10))
          o3(
            p10.split(/,\s*/).map((m10) => s3.map((O10) => m10.replace(/&/, O10))).reduce((m10, O10) => m10.concat(O10)),
            h10,
            l3
          );
        else if (h10 && typeof h10 == "object") {
          if (!f3)
            throw new RangeError("The value of a property (" + p10 + ") should be a primitive value.");
          o3(i3(p10), h10, c3, d3);
        } else
          h10 != null && c3.push(p10.replace(/_.*/, "").replace(/[A-Z]/g, (m10) => "-" + m10.toLowerCase()) + ": " + h10 + ";");
      }
      (c3.length || d3) && l3.push((n3 && !f3 && !u3 ? s3.map(n3) : s3).join(", ") + " {" + c3.join(" ") + "}");
    }
    for (let s3 in e3)
      o3(i3(s3), e3[s3], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e3 = ky[Ty] || 1;
    return ky[Ty] = e3 + 1, Jp + e3.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e3, r3, n3) {
    let i3 = e3[eO], o3 = n3 && n3.nonce;
    i3 ? o3 && i3.setNonce(o3) : i3 = new sR(e3, o3), i3.mount(Array.isArray(r3) ? r3 : [r3]);
  }
}
let Ey = /* @__PURE__ */ new Map();
class sR {
  constructor(e3, r3) {
    let n3 = e3.ownerDocument || e3, i3 = n3.defaultView;
    if (!e3.head && e3.adoptedStyleSheets && i3.CSSStyleSheet) {
      let o3 = Ey.get(n3);
      if (o3)
        return e3.adoptedStyleSheets = [o3.sheet, ...e3.adoptedStyleSheets], e3[eO] = o3;
      this.sheet = new i3.CSSStyleSheet(), e3.adoptedStyleSheets = [this.sheet, ...e3.adoptedStyleSheets], Ey.set(n3, this);
    } else {
      this.styleTag = n3.createElement("style"), r3 && this.styleTag.setAttribute("nonce", r3);
      let o3 = e3.head || e3;
      o3.insertBefore(this.styleTag, o3.firstChild);
    }
    this.modules = [], e3[eO] = this;
  }
  mount(e3) {
    let r3 = this.sheet, n3 = 0, i3 = 0;
    for (let o3 = 0; o3 < e3.length; o3++) {
      let s3 = e3[o3], a3 = this.modules.indexOf(s3);
      if (a3 < i3 && a3 > -1 && (this.modules.splice(a3, 1), i3--, a3 = -1), a3 == -1) {
        if (this.modules.splice(i3++, 0, s3), r3)
          for (let l3 = 0; l3 < s3.rules.length; l3++)
            r3.insertRule(s3.rules[l3], n3++);
      } else {
        for (; i3 < a3; )
          n3 += this.modules[i3++].rules.length;
        n3 += s3.rules.length, i3++;
      }
    }
    if (!r3) {
      let o3 = "";
      for (let s3 = 0; s3 < this.modules.length; s3++)
        o3 += this.modules[s3].getRules() + `
`;
      this.styleTag.textContent = o3;
    }
  }
  setNonce(e3) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e3 && this.styleTag.setAttribute("nonce", e3);
  }
}
var co = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, ql = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, aR = typeof navigator < "u" && /Mac/.test(navigator.platform), lR = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var ur = 0; ur < 10; ur++)
  co[48 + ur] = co[96 + ur] = String(ur);
for (var ur = 1; ur <= 24; ur++)
  co[ur + 111] = "F" + ur;
for (var ur = 65; ur <= 90; ur++)
  co[ur] = String.fromCharCode(ur + 32), ql[ur] = String.fromCharCode(ur);
for (var fh in co)
  ql.hasOwnProperty(fh) || (ql[fh] = co[fh]);
function uR(t10) {
  var e3 = aR && t10.metaKey && t10.shiftKey && !t10.ctrlKey && !t10.altKey || lR && t10.shiftKey && t10.key && t10.key.length == 1 || t10.key == "Unidentified", r3 = !e3 && t10.key || (t10.shiftKey ? ql : co)[t10.keyCode] || t10.key || "Unidentified";
  return r3 == "Esc" && (r3 = "Escape"), r3 == "Del" && (r3 = "Delete"), r3 == "Left" && (r3 = "ArrowLeft"), r3 == "Up" && (r3 = "ArrowUp"), r3 == "Right" && (r3 = "ArrowRight"), r3 == "Down" && (r3 = "ArrowDown"), r3;
}
function tf(t10) {
  let e3;
  return t10.nodeType == 11 ? e3 = t10.getSelection ? t10 : t10.ownerDocument : e3 = t10, e3.getSelection();
}
function tO(t10, e3) {
  return e3 ? t10 == e3 || t10.contains(e3.nodeType != 1 ? e3.parentNode : e3) : false;
}
function cR(t10) {
  let e3 = t10.activeElement;
  for (; e3 && e3.shadowRoot; )
    e3 = e3.shadowRoot.activeElement;
  return e3;
}
function bc(t10, e3) {
  if (!e3.anchorNode)
    return false;
  try {
    return tO(t10, e3.anchorNode);
  } catch {
    return false;
  }
}
function Dl(t10) {
  return t10.nodeType == 3 ? ns(t10, 0, t10.nodeValue.length).getClientRects() : t10.nodeType == 1 ? t10.getClientRects() : [];
}
function rf(t10, e3, r3, n3) {
  return r3 ? Cy(t10, e3, r3, n3, -1) || Cy(t10, e3, r3, n3, 1) : false;
}
function nf(t10) {
  for (var e3 = 0; ; e3++)
    if (t10 = t10.previousSibling, !t10)
      return e3;
}
function Cy(t10, e3, r3, n3, i3) {
  for (; ; ) {
    if (t10 == r3 && e3 == n3)
      return true;
    if (e3 == (i3 < 0 ? 0 : fo(t10))) {
      if (t10.nodeName == "DIV")
        return false;
      let o3 = t10.parentNode;
      if (!o3 || o3.nodeType != 1)
        return false;
      e3 = nf(t10) + (i3 < 0 ? 0 : 1), t10 = o3;
    } else if (t10.nodeType == 1) {
      if (t10 = t10.childNodes[e3 + (i3 < 0 ? -1 : 0)], t10.nodeType == 1 && t10.contentEditable == "false")
        return false;
      e3 = i3 < 0 ? fo(t10) : 0;
    } else
      return false;
  }
}
function fo(t10) {
  return t10.nodeType == 3 ? t10.nodeValue.length : t10.childNodes.length;
}
function Qg(t10, e3) {
  let r3 = e3 ? t10.left : t10.right;
  return { left: r3, right: r3, top: t10.top, bottom: t10.bottom };
}
function fR(t10) {
  return {
    left: 0,
    right: t10.innerWidth,
    top: 0,
    bottom: t10.innerHeight
  };
}
function dR(t10, e3, r3, n3, i3, o3, s3, a3) {
  let l3 = t10.ownerDocument, u3 = l3.defaultView || window;
  for (let c3 = t10, f3 = false; c3 && !f3; )
    if (c3.nodeType == 1) {
      let d3, p10 = c3 == l3.body, h10 = 1, m10 = 1;
      if (p10)
        d3 = fR(u3);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(c3).position) && (f3 = true), c3.scrollHeight <= c3.clientHeight && c3.scrollWidth <= c3.clientWidth) {
          c3 = c3.assignedSlot || c3.parentNode;
          continue;
        }
        let v10 = c3.getBoundingClientRect();
        h10 = v10.width / c3.offsetWidth, m10 = v10.height / c3.offsetHeight, d3 = {
          left: v10.left,
          right: v10.left + c3.clientWidth * h10,
          top: v10.top,
          bottom: v10.top + c3.clientHeight * m10
        };
      }
      let O10 = 0, g = 0;
      if (i3 == "nearest")
        e3.top < d3.top ? (g = -(d3.top - e3.top + s3), r3 > 0 && e3.bottom > d3.bottom + g && (g = e3.bottom - d3.bottom + g + s3)) : e3.bottom > d3.bottom && (g = e3.bottom - d3.bottom + s3, r3 < 0 && e3.top - g < d3.top && (g = -(d3.top + g - e3.top + s3)));
      else {
        let v10 = e3.bottom - e3.top, S10 = d3.bottom - d3.top;
        g = (i3 == "center" && v10 <= S10 ? e3.top + v10 / 2 - S10 / 2 : i3 == "start" || i3 == "center" && r3 < 0 ? e3.top - s3 : e3.bottom - S10 + s3) - d3.top;
      }
      if (n3 == "nearest" ? e3.left < d3.left ? (O10 = -(d3.left - e3.left + o3), r3 > 0 && e3.right > d3.right + O10 && (O10 = e3.right - d3.right + O10 + o3)) : e3.right > d3.right && (O10 = e3.right - d3.right + o3, r3 < 0 && e3.left < d3.left + O10 && (O10 = -(d3.left + O10 - e3.left + o3))) : O10 = (n3 == "center" ? e3.left + (e3.right - e3.left) / 2 - (d3.right - d3.left) / 2 : n3 == "start" == a3 ? e3.left - o3 : e3.right - (d3.right - d3.left) + o3) - d3.left, O10 || g)
        if (p10)
          u3.scrollBy(O10, g);
        else {
          let v10 = 0, S10 = 0;
          if (g) {
            let $10 = c3.scrollTop;
            c3.scrollTop += g / m10, S10 = (c3.scrollTop - $10) * m10;
          }
          if (O10) {
            let $10 = c3.scrollLeft;
            c3.scrollLeft += O10 / h10, v10 = (c3.scrollLeft - $10) * h10;
          }
          e3 = {
            left: e3.left - v10,
            top: e3.top - S10,
            right: e3.right - v10,
            bottom: e3.bottom - S10
          }, v10 && Math.abs(v10 - O10) < 1 && (n3 = "nearest"), S10 && Math.abs(S10 - g) < 1 && (i3 = "nearest");
        }
      if (p10)
        break;
      c3 = c3.assignedSlot || c3.parentNode;
    } else if (c3.nodeType == 11)
      c3 = c3.host;
    else
      break;
}
function hR(t10) {
  let e3 = t10.ownerDocument;
  for (let r3 = t10.parentNode; r3 && r3 != e3.body; )
    if (r3.nodeType == 1) {
      if (r3.scrollHeight > r3.clientHeight || r3.scrollWidth > r3.clientWidth)
        return r3;
      r3 = r3.assignedSlot || r3.parentNode;
    } else if (r3.nodeType == 11)
      r3 = r3.host;
    else
      break;
  return null;
}
class pR {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e3) {
    return this.anchorNode == e3.anchorNode && this.anchorOffset == e3.anchorOffset && this.focusNode == e3.focusNode && this.focusOffset == e3.focusOffset;
  }
  setRange(e3) {
    let { anchorNode: r3, focusNode: n3 } = e3;
    this.set(r3, Math.min(e3.anchorOffset, r3 ? fo(r3) : 0), n3, Math.min(e3.focusOffset, n3 ? fo(n3) : 0));
  }
  set(e3, r3, n3, i3) {
    this.anchorNode = e3, this.anchorOffset = r3, this.focusNode = n3, this.focusOffset = i3;
  }
}
let ws = null;
function W2(t10) {
  if (t10.setActive)
    return t10.setActive();
  if (ws)
    return t10.focus(ws);
  let e3 = [];
  for (let r3 = t10; r3 && (e3.push(r3, r3.scrollTop, r3.scrollLeft), r3 != r3.ownerDocument); r3 = r3.parentNode)
    ;
  if (t10.focus(ws == null ? {
    get preventScroll() {
      return ws = { preventScroll: true }, true;
    }
  } : void 0), !ws) {
    ws = false;
    for (let r3 = 0; r3 < e3.length; ) {
      let n3 = e3[r3++], i3 = e3[r3++], o3 = e3[r3++];
      n3.scrollTop != i3 && (n3.scrollTop = i3), n3.scrollLeft != o3 && (n3.scrollLeft = o3);
    }
  }
}
let Ry;
function ns(t10, e3, r3 = e3) {
  let n3 = Ry || (Ry = document.createRange());
  return n3.setEnd(t10, r3), n3.setStart(t10, e3), n3;
}
function Gs(t10, e3, r3) {
  let n3 = { key: e3, code: e3, keyCode: r3, which: r3, cancelable: true }, i3 = new KeyboardEvent("keydown", n3);
  i3.synthetic = true, t10.dispatchEvent(i3);
  let o3 = new KeyboardEvent("keyup", n3);
  return o3.synthetic = true, t10.dispatchEvent(o3), i3.defaultPrevented || o3.defaultPrevented;
}
function OR(t10) {
  for (; t10; ) {
    if (t10 && (t10.nodeType == 9 || t10.nodeType == 11 && t10.host))
      return t10;
    t10 = t10.assignedSlot || t10.parentNode;
  }
  return null;
}
function V2(t10) {
  for (; t10.attributes.length; )
    t10.removeAttributeNode(t10.attributes[0]);
}
function mR(t10, e3) {
  let r3 = e3.focusNode, n3 = e3.focusOffset;
  if (!r3 || e3.anchorNode != r3 || e3.anchorOffset != n3)
    return false;
  for (n3 = Math.min(n3, fo(r3)); ; )
    if (n3) {
      if (r3.nodeType != 1)
        return false;
      let i3 = r3.childNodes[n3 - 1];
      i3.contentEditable == "false" ? n3-- : (r3 = i3, n3 = fo(r3));
    } else {
      if (r3 == t10)
        return true;
      n3 = nf(r3), r3 = r3.parentNode;
    }
}
function Y2(t10) {
  return t10.scrollTop > Math.max(1, t10.scrollHeight - t10.clientHeight - 4);
}
class gr {
  constructor(e3, r3, n3 = true) {
    this.node = e3, this.offset = r3, this.precise = n3;
  }
  static before(e3, r3) {
    return new gr(e3.parentNode, nf(e3), r3);
  }
  static after(e3, r3) {
    return new gr(e3.parentNode, nf(e3) + 1, r3);
  }
}
const Tg = [];
class Qt {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e3) {
    let r3 = this.posAtStart;
    for (let n3 of this.children) {
      if (n3 == e3)
        return r3;
      r3 += n3.length + n3.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e3) {
    return this.posBefore(e3) + e3.length;
  }
  sync(e3, r3) {
    if (this.flags & 2) {
      let n3 = this.dom, i3 = null, o3;
      for (let s3 of this.children) {
        if (s3.flags & 7) {
          if (!s3.dom && (o3 = i3 ? i3.nextSibling : n3.firstChild)) {
            let a3 = Qt.get(o3);
            (!a3 || !a3.parent && a3.canReuseDOM(s3)) && s3.reuseDOM(o3);
          }
          s3.sync(e3, r3), s3.flags &= -8;
        }
        if (o3 = i3 ? i3.nextSibling : n3.firstChild, r3 && !r3.written && r3.node == n3 && o3 != s3.dom && (r3.written = true), s3.dom.parentNode == n3)
          for (; o3 && o3 != s3.dom; )
            o3 = Ay(o3);
        else
          n3.insertBefore(s3.dom, o3);
        i3 = s3.dom;
      }
      for (o3 = i3 ? i3.nextSibling : n3.firstChild, o3 && r3 && r3.node == n3 && (r3.written = true); o3; )
        o3 = Ay(o3);
    } else if (this.flags & 1)
      for (let n3 of this.children)
        n3.flags & 7 && (n3.sync(e3, r3), n3.flags &= -8);
  }
  reuseDOM(e3) {
  }
  localPosFromDOM(e3, r3) {
    let n3;
    if (e3 == this.dom)
      n3 = this.dom.childNodes[r3];
    else {
      let i3 = fo(e3) == 0 ? 0 : r3 == 0 ? -1 : 1;
      for (; ; ) {
        let o3 = e3.parentNode;
        if (o3 == this.dom)
          break;
        i3 == 0 && o3.firstChild != o3.lastChild && (e3 == o3.firstChild ? i3 = -1 : i3 = 1), e3 = o3;
      }
      i3 < 0 ? n3 = e3 : n3 = e3.nextSibling;
    }
    if (n3 == this.dom.firstChild)
      return 0;
    for (; n3 && !Qt.get(n3); )
      n3 = n3.nextSibling;
    if (!n3)
      return this.length;
    for (let i3 = 0, o3 = 0; ; i3++) {
      let s3 = this.children[i3];
      if (s3.dom == n3)
        return o3;
      o3 += s3.length + s3.breakAfter;
    }
  }
  domBoundsAround(e3, r3, n3 = 0) {
    let i3 = -1, o3 = -1, s3 = -1, a3 = -1;
    for (let l3 = 0, u3 = n3, c3 = n3; l3 < this.children.length; l3++) {
      let f3 = this.children[l3], d3 = u3 + f3.length;
      if (u3 < e3 && d3 > r3)
        return f3.domBoundsAround(e3, r3, u3);
      if (d3 >= e3 && i3 == -1 && (i3 = l3, o3 = u3), u3 > r3 && f3.dom.parentNode == this.dom) {
        s3 = l3, a3 = c3;
        break;
      }
      c3 = d3, u3 = d3 + f3.breakAfter;
    }
    return {
      from: o3,
      to: a3 < 0 ? n3 + this.length : a3,
      startDOM: (i3 ? this.children[i3 - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: s3 < this.children.length && s3 >= 0 ? this.children[s3].dom : null
    };
  }
  markDirty(e3 = false) {
    this.flags |= 2, this.markParentsDirty(e3);
  }
  markParentsDirty(e3) {
    for (let r3 = this.parent; r3; r3 = r3.parent) {
      if (e3 && (r3.flags |= 2), r3.flags & 1)
        return;
      r3.flags |= 1, e3 = false;
    }
  }
  setParent(e3) {
    this.parent != e3 && (this.parent = e3, this.flags & 7 && this.markParentsDirty(true));
  }
  setDOM(e3) {
    this.dom != e3 && (this.dom && (this.dom.cmView = null), this.dom = e3, e3.cmView = this);
  }
  get rootView() {
    for (let e3 = this; ; ) {
      let r3 = e3.parent;
      if (!r3)
        return e3;
      e3 = r3;
    }
  }
  replaceChildren(e3, r3, n3 = Tg) {
    this.markDirty();
    for (let i3 = e3; i3 < r3; i3++) {
      let o3 = this.children[i3];
      o3.parent == this && o3.destroy();
    }
    this.children.splice(e3, r3 - e3, ...n3);
    for (let i3 = 0; i3 < n3.length; i3++)
      n3[i3].setParent(this);
  }
  ignoreMutation(e3) {
    return false;
  }
  ignoreEvent(e3) {
    return false;
  }
  childCursor(e3 = this.length) {
    return new L2(this.children, e3, this.children.length);
  }
  childPos(e3, r3 = 1) {
    return this.childCursor().findPos(e3, r3);
  }
  toString() {
    let e3 = this.constructor.name.replace("View", "");
    return e3 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e3 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e3) {
    return e3.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(e3, r3, n3, i3, o3, s3) {
    return false;
  }
  become(e3) {
    return false;
  }
  canReuseDOM(e3) {
    return e3.constructor == this.constructor && !((this.flags | e3.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
Qt.prototype.breakAfter = 0;
function Ay(t10) {
  let e3 = t10.nextSibling;
  return t10.parentNode.removeChild(t10), e3;
}
class L2 {
  constructor(e3, r3, n3) {
    this.children = e3, this.pos = r3, this.i = n3, this.off = 0;
  }
  findPos(e3, r3 = 1) {
    for (; ; ) {
      if (e3 > this.pos || e3 == this.pos && (r3 > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e3 - this.pos, this;
      let n3 = this.children[--this.i];
      this.pos -= n3.length + n3.breakAfter;
    }
  }
}
function B2(t10, e3, r3, n3, i3, o3, s3, a3, l3) {
  let { children: u3 } = t10, c3 = u3.length ? u3[e3] : null, f3 = o3.length ? o3[o3.length - 1] : null, d3 = f3 ? f3.breakAfter : s3;
  if (!(e3 == n3 && c3 && !s3 && !d3 && o3.length < 2 && c3.merge(r3, i3, o3.length ? f3 : null, r3 == 0, a3, l3))) {
    if (n3 < u3.length) {
      let p10 = u3[n3];
      p10 && (i3 < p10.length || p10.breakAfter && (f3 != null && f3.breakAfter)) ? (e3 == n3 && (p10 = p10.split(i3), i3 = 0), !d3 && f3 && p10.merge(0, i3, f3, true, 0, l3) ? o3[o3.length - 1] = p10 : (i3 && p10.merge(0, i3, null, false, 0, l3), o3.push(p10))) : p10 != null && p10.breakAfter && (f3 ? f3.breakAfter = 1 : s3 = 1), n3++;
    }
    for (c3 && (c3.breakAfter = s3, r3 > 0 && (!s3 && o3.length && c3.merge(r3, c3.length, o3[0], false, a3, 0) ? c3.breakAfter = o3.shift().breakAfter : (r3 < c3.length || c3.children.length && c3.children[c3.children.length - 1].length == 0) && c3.merge(r3, c3.length, null, false, a3, 0), e3++)); e3 < n3 && o3.length; )
      if (u3[n3 - 1].become(o3[o3.length - 1]))
        n3--, o3.pop(), l3 = o3.length ? 0 : a3;
      else if (u3[e3].become(o3[0]))
        e3++, o3.shift(), a3 = o3.length ? 0 : l3;
      else
        break;
    !o3.length && e3 && n3 < u3.length && !u3[e3 - 1].breakAfter && u3[n3].merge(0, 0, u3[e3 - 1], false, a3, l3) && e3--, (e3 < n3 || o3.length) && t10.replaceChildren(e3, n3, o3);
  }
}
function z2(t10, e3, r3, n3, i3, o3) {
  let s3 = t10.childCursor(), { i: a3, off: l3 } = s3.findPos(r3, 1), { i: u3, off: c3 } = s3.findPos(e3, -1), f3 = e3 - r3;
  for (let d3 of n3)
    f3 += d3.length;
  t10.length += f3, B2(t10, u3, c3, a3, l3, n3, 0, i3, o3);
}
let Kr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, rO = typeof document < "u" ? document : { documentElement: { style: {} } };
const nO = /* @__PURE__ */ /Edge\/(\d+)/.exec(Kr.userAgent), H2 = /* @__PURE__ */ /MSIE \d/.test(Kr.userAgent), iO = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Kr.userAgent), Hf = !!(H2 || iO || nO), Xy = !Hf && /* @__PURE__ */ /gecko\/(\d+)/i.test(Kr.userAgent), dh = !Hf && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Kr.userAgent), qy = "webkitFontSmoothing" in rO.documentElement.style, G2 = !Hf && /* @__PURE__ */ /Apple Computer/.test(Kr.vendor), Dy = G2 && (/* @__PURE__ */ /Mobile\/\w+/.test(Kr.userAgent) || Kr.maxTouchPoints > 2);
var ke = {
  mac: Dy || /* @__PURE__ */ /Mac/.test(Kr.platform),
  windows: /* @__PURE__ */ /Win/.test(Kr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Kr.platform),
  ie: Hf,
  ie_version: H2 ? rO.documentMode || 6 : iO ? +iO[1] : nO ? +nO[1] : 0,
  gecko: Xy,
  gecko_version: Xy ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Kr.userAgent) || [0, 0])[1] : 0,
  chrome: !!dh,
  chrome_version: dh ? +dh[1] : 0,
  ios: Dy,
  android: /* @__PURE__ */ /Android\b/.test(Kr.userAgent),
  webkit: qy,
  safari: G2,
  webkit_version: qy ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: rO.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const gR = 256;
class Ri extends Qt {
  constructor(e3) {
    super(), this.text = e3;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e3) {
    this.setDOM(e3 || document.createTextNode(this.text));
  }
  sync(e3, r3) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (r3 && r3.node == this.dom && (r3.written = true), this.dom.nodeValue = this.text);
  }
  reuseDOM(e3) {
    e3.nodeType == 3 && this.createDOM(e3);
  }
  merge(e3, r3, n3) {
    return this.flags & 8 || n3 && (!(n3 instanceof Ri) || this.length - (r3 - e3) + n3.length > gR || n3.flags & 8) ? false : (this.text = this.text.slice(0, e3) + (n3 ? n3.text : "") + this.text.slice(r3), this.markDirty(), true);
  }
  split(e3) {
    let r3 = new Ri(this.text.slice(e3));
    return this.text = this.text.slice(0, e3), this.markDirty(), r3.flags |= this.flags & 8, r3;
  }
  localPosFromDOM(e3, r3) {
    return e3 == this.dom ? r3 : r3 ? this.text.length : 0;
  }
  domAtPos(e3) {
    return new gr(this.dom, e3);
  }
  domBoundsAround(e3, r3, n3) {
    return { from: n3, to: n3 + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e3, r3) {
    return yR(this.dom, e3, r3);
  }
}
class Ai extends Qt {
  constructor(e3, r3 = [], n3 = 0) {
    super(), this.mark = e3, this.children = r3, this.length = n3;
    for (let i3 of r3)
      i3.setParent(this);
  }
  setAttrs(e3) {
    if (V2(e3), this.mark.class && (e3.className = this.mark.class), this.mark.attrs)
      for (let r3 in this.mark.attrs)
        e3.setAttribute(r3, this.mark.attrs[r3]);
    return e3;
  }
  canReuseDOM(e3) {
    return super.canReuseDOM(e3) && !((this.flags | e3.flags) & 8);
  }
  reuseDOM(e3) {
    e3.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e3), this.flags |= 6);
  }
  sync(e3, r3) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e3, r3);
  }
  merge(e3, r3, n3, i3, o3, s3) {
    return n3 && (!(n3 instanceof Ai && n3.mark.eq(this.mark)) || e3 && o3 <= 0 || r3 < this.length && s3 <= 0) ? false : (z2(this, e3, r3, n3 ? n3.children : [], o3 - 1, s3 - 1), this.markDirty(), true);
  }
  split(e3) {
    let r3 = [], n3 = 0, i3 = -1, o3 = 0;
    for (let a3 of this.children) {
      let l3 = n3 + a3.length;
      l3 > e3 && r3.push(n3 < e3 ? a3.split(e3 - n3) : a3), i3 < 0 && n3 >= e3 && (i3 = o3), n3 = l3, o3++;
    }
    let s3 = this.length - e3;
    return this.length = e3, i3 > -1 && (this.children.length = i3, this.markDirty()), new Ai(this.mark, r3, s3);
  }
  domAtPos(e3) {
    return K2(this, e3);
  }
  coordsAt(e3, r3) {
    return eP(this, e3, r3);
  }
}
function yR(t10, e3, r3) {
  let n3 = t10.nodeValue.length;
  e3 > n3 && (e3 = n3);
  let i3 = e3, o3 = e3, s3 = 0;
  e3 == 0 && r3 < 0 || e3 == n3 && r3 >= 0 ? ke.chrome || ke.gecko || (e3 ? (i3--, s3 = 1) : o3 < n3 && (o3++, s3 = -1)) : r3 < 0 ? i3-- : o3 < n3 && o3++;
  let a3 = ns(t10, i3, o3).getClientRects();
  if (!a3.length)
    return null;
  let l3 = a3[(s3 ? s3 < 0 : r3 >= 0) ? 0 : a3.length - 1];
  return ke.safari && !s3 && l3.width == 0 && (l3 = Array.prototype.find.call(a3, (u3) => u3.width) || l3), s3 ? Qg(l3, s3 < 0) : l3 || null;
}
class Mo extends Qt {
  static create(e3, r3, n3) {
    return new Mo(e3, r3, n3);
  }
  constructor(e3, r3, n3) {
    super(), this.widget = e3, this.length = r3, this.side = n3, this.prevWidget = null;
  }
  split(e3) {
    let r3 = Mo.create(this.widget, this.length - e3, this.side);
    return this.length -= e3, r3;
  }
  sync(e3) {
    (!this.dom || !this.widget.updateDOM(this.dom, e3)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e3)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e3, r3, n3, i3, o3, s3) {
    return n3 && (!(n3 instanceof Mo) || !this.widget.compare(n3.widget) || e3 > 0 && o3 <= 0 || r3 < this.length && s3 <= 0) ? false : (this.length = e3 + (n3 ? n3.length : 0) + (this.length - r3), true);
  }
  become(e3) {
    return e3 instanceof Mo && e3.side == this.side && this.widget.constructor == e3.widget.constructor ? (this.widget.compare(e3.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e3.widget, this.length = e3.length, true) : false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(e3) {
    return this.widget.ignoreEvent(e3);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return ct.empty;
    let e3 = this;
    for (; e3.parent; )
      e3 = e3.parent;
    let { view: r3 } = e3, n3 = r3 && r3.state.doc, i3 = this.posAtStart;
    return n3 ? n3.slice(i3, i3 + this.length) : ct.empty;
  }
  domAtPos(e3) {
    return (this.length ? e3 == 0 : this.side > 0) ? gr.before(this.dom) : gr.after(this.dom, e3 == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e3, r3) {
    let n3 = this.widget.coordsAt(this.dom, e3, r3);
    if (n3)
      return n3;
    let i3 = this.dom.getClientRects(), o3 = null;
    if (!i3.length)
      return null;
    let s3 = this.side ? this.side < 0 : e3 > 0;
    for (let a3 = s3 ? i3.length - 1 : 0; o3 = i3[a3], !(e3 > 0 ? a3 == 0 : a3 == i3.length - 1 || o3.top < o3.bottom); a3 += s3 ? -1 : 1)
      ;
    return Qg(o3, !s3);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class la extends Qt {
  constructor(e3) {
    super(), this.side = e3;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(e3) {
    return e3 instanceof la && e3.side == this.side;
  }
  split() {
    return new la(this.side);
  }
  sync() {
    if (!this.dom) {
      let e3 = document.createElement("img");
      e3.className = "cm-widgetBuffer", e3.setAttribute("aria-hidden", "true"), this.setDOM(e3);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e3) {
    return this.side > 0 ? gr.before(this.dom) : gr.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e3) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return ct.empty;
  }
  get isHidden() {
    return true;
  }
}
Ri.prototype.children = Mo.prototype.children = la.prototype.children = Tg;
function K2(t10, e3) {
  let r3 = t10.dom, { children: n3 } = t10, i3 = 0;
  for (let o3 = 0; i3 < n3.length; i3++) {
    let s3 = n3[i3], a3 = o3 + s3.length;
    if (!(a3 == o3 && s3.getSide() <= 0)) {
      if (e3 > o3 && e3 < a3 && s3.dom.parentNode == r3)
        return s3.domAtPos(e3 - o3);
      if (e3 <= o3)
        break;
      o3 = a3;
    }
  }
  for (let o3 = i3; o3 > 0; o3--) {
    let s3 = n3[o3 - 1];
    if (s3.dom.parentNode == r3)
      return s3.domAtPos(s3.length);
  }
  for (let o3 = i3; o3 < n3.length; o3++) {
    let s3 = n3[o3];
    if (s3.dom.parentNode == r3)
      return s3.domAtPos(0);
  }
  return new gr(r3, 0);
}
function J2(t10, e3, r3) {
  let n3, { children: i3 } = t10;
  r3 > 0 && e3 instanceof Ai && i3.length && (n3 = i3[i3.length - 1]) instanceof Ai && n3.mark.eq(e3.mark) ? J2(n3, e3.children[0], r3 - 1) : (i3.push(e3), e3.setParent(t10)), t10.length += e3.length;
}
function eP(t10, e3, r3) {
  let n3 = null, i3 = -1, o3 = null, s3 = -1;
  function a3(u3, c3) {
    for (let f3 = 0, d3 = 0; f3 < u3.children.length && d3 <= c3; f3++) {
      let p10 = u3.children[f3], h10 = d3 + p10.length;
      h10 >= c3 && (p10.children.length ? a3(p10, c3 - d3) : (!o3 || o3.isHidden && r3 > 0) && (h10 > c3 || d3 == h10 && p10.getSide() > 0) ? (o3 = p10, s3 = c3 - d3) : (d3 < c3 || d3 == h10 && p10.getSide() < 0 && !p10.isHidden) && (n3 = p10, i3 = c3 - d3)), d3 = h10;
    }
  }
  a3(t10, e3);
  let l3 = (r3 < 0 ? n3 : o3) || n3 || o3;
  return l3 ? l3.coordsAt(Math.max(0, l3 == n3 ? i3 : s3), r3) : vR(t10);
}
function vR(t10) {
  let e3 = t10.dom.lastChild;
  if (!e3)
    return t10.dom.getBoundingClientRect();
  let r3 = Dl(e3);
  return r3[r3.length - 1] || null;
}
function oO(t10, e3) {
  for (let r3 in t10)
    r3 == "class" && e3.class ? e3.class += " " + t10.class : r3 == "style" && e3.style ? e3.style += ";" + t10.style : e3[r3] = t10[r3];
  return e3;
}
const jy = /* @__PURE__ */ Object.create(null);
function kg(t10, e3, r3) {
  if (t10 == e3)
    return true;
  t10 || (t10 = jy), e3 || (e3 = jy);
  let n3 = Object.keys(t10), i3 = Object.keys(e3);
  if (n3.length - (r3 && n3.indexOf(r3) > -1 ? 1 : 0) != i3.length - (r3 && i3.indexOf(r3) > -1 ? 1 : 0))
    return false;
  for (let o3 of n3)
    if (o3 != r3 && (i3.indexOf(o3) == -1 || t10[o3] !== e3[o3]))
      return false;
  return true;
}
function sO(t10, e3, r3) {
  let n3 = false;
  if (e3)
    for (let i3 in e3)
      r3 && i3 in r3 || (n3 = true, i3 == "style" ? t10.style.cssText = "" : t10.removeAttribute(i3));
  if (r3)
    for (let i3 in r3)
      e3 && e3[i3] == r3[i3] || (n3 = true, i3 == "style" ? t10.style.cssText = r3[i3] : t10.setAttribute(i3, r3[i3]));
  return n3;
}
function bR(t10) {
  let e3 = /* @__PURE__ */ Object.create(null);
  for (let r3 = 0; r3 < t10.attributes.length; r3++) {
    let n3 = t10.attributes[r3];
    e3[n3.name] = n3.value;
  }
  return e3;
}
class Gt extends Qt {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e3, r3, n3, i3, o3, s3) {
    if (n3) {
      if (!(n3 instanceof Gt))
        return false;
      this.dom || n3.transferDOM(this);
    }
    return i3 && this.setDeco(n3 ? n3.attrs : null), z2(this, e3, r3, n3 ? n3.children : [], o3, s3), true;
  }
  split(e3) {
    let r3 = new Gt();
    if (r3.breakAfter = this.breakAfter, this.length == 0)
      return r3;
    let { i: n3, off: i3 } = this.childPos(e3);
    i3 && (r3.append(this.children[n3].split(i3), 0), this.children[n3].merge(i3, this.children[n3].length, null, false, 0, 0), n3++);
    for (let o3 = n3; o3 < this.children.length; o3++)
      r3.append(this.children[o3], 0);
    for (; n3 > 0 && this.children[n3 - 1].length == 0; )
      this.children[--n3].destroy();
    return this.children.length = n3, this.markDirty(), this.length = e3, r3;
  }
  transferDOM(e3) {
    this.dom && (this.markDirty(), e3.setDOM(this.dom), e3.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e3) {
    kg(this.attrs, e3) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e3);
  }
  append(e3, r3) {
    J2(this, e3, r3);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e3) {
    let r3 = e3.spec.attributes, n3 = e3.spec.class;
    r3 && (this.attrs = oO(r3, this.attrs || {})), n3 && (this.attrs = oO({ class: n3 }, this.attrs || {}));
  }
  domAtPos(e3) {
    return K2(this, e3);
  }
  reuseDOM(e3) {
    e3.nodeName == "DIV" && (this.setDOM(e3), this.flags |= 6);
  }
  sync(e3, r3) {
    var n3;
    this.dom ? this.flags & 4 && (V2(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (sO(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e3, r3);
    let i3 = this.dom.lastChild;
    for (; i3 && Qt.get(i3) instanceof Ai; )
      i3 = i3.lastChild;
    if (!i3 || !this.length || i3.nodeName != "BR" && ((n3 = Qt.get(i3)) === null || n3 === void 0 ? void 0 : n3.isEditable) == false && (!ke.ios || !this.children.some((o3) => o3 instanceof Ri))) {
      let o3 = document.createElement("BR");
      o3.cmIgnore = true, this.dom.appendChild(o3);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e3 = 0, r3;
    for (let n3 of this.children) {
      if (!(n3 instanceof Ri) || /[^ -~]/.test(n3.text))
        return null;
      let i3 = Dl(n3.dom);
      if (i3.length != 1)
        return null;
      e3 += i3[0].width, r3 = i3[0].height;
    }
    return e3 ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e3 / this.length,
      textHeight: r3
    } : null;
  }
  coordsAt(e3, r3) {
    let n3 = eP(this, e3, r3);
    if (!this.children.length && n3 && this.parent) {
      let { heightOracle: i3 } = this.parent.view.viewState, o3 = n3.bottom - n3.top;
      if (Math.abs(o3 - i3.lineHeight) < 2 && i3.textHeight < o3) {
        let s3 = (o3 - i3.textHeight) / 2;
        return { top: n3.top + s3, bottom: n3.bottom - s3, left: n3.left, right: n3.left };
      }
    }
    return n3;
  }
  become(e3) {
    return false;
  }
  covers() {
    return true;
  }
  static find(e3, r3) {
    for (let n3 = 0, i3 = 0; n3 < e3.children.length; n3++) {
      let o3 = e3.children[n3], s3 = i3 + o3.length;
      if (s3 >= r3) {
        if (o3 instanceof Gt)
          return o3;
        if (s3 > r3)
          break;
      }
      i3 = s3 + o3.breakAfter;
    }
    return null;
  }
}
class Bo extends Qt {
  constructor(e3, r3, n3) {
    super(), this.widget = e3, this.length = r3, this.deco = n3, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e3, r3, n3, i3, o3, s3) {
    return n3 && (!(n3 instanceof Bo) || !this.widget.compare(n3.widget) || e3 > 0 && o3 <= 0 || r3 < this.length && s3 <= 0) ? false : (this.length = e3 + (n3 ? n3.length : 0) + (this.length - r3), true);
  }
  domAtPos(e3) {
    return e3 == 0 ? gr.before(this.dom) : gr.after(this.dom, e3 == this.length);
  }
  split(e3) {
    let r3 = this.length - e3;
    this.length = e3;
    let n3 = new Bo(this.widget, r3, this.deco);
    return n3.breakAfter = this.breakAfter, n3;
  }
  get children() {
    return Tg;
  }
  sync(e3) {
    (!this.dom || !this.widget.updateDOM(this.dom, e3)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e3)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : ct.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e3) {
    return e3 instanceof Bo && e3.widget.constructor == this.widget.constructor ? (e3.widget.compare(this.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e3.widget, this.length = e3.length, this.deco = e3.deco, this.breakAfter = e3.breakAfter, true) : false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(e3) {
    return this.widget.ignoreEvent(e3);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(e3, r3) {
    return this.widget.coordsAt(this.dom, e3, r3);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e3) {
    let { startSide: r3, endSide: n3 } = this.deco;
    return r3 == n3 ? false : e3 < 0 ? r3 < 0 : n3 > 0;
  }
}
class Gf {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e3) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e3, r3) {
    return false;
  }
  /**
  @internal
  */
  compare(e3) {
    return this == e3 || this.constructor == e3.constructor && this.eq(e3);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e3) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e3, r3, n3) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e3) {
  }
}
var Qn = /* @__PURE__ */ function(t10) {
  return t10[t10.Text = 0] = "Text", t10[t10.WidgetBefore = 1] = "WidgetBefore", t10[t10.WidgetAfter = 2] = "WidgetAfter", t10[t10.WidgetRange = 3] = "WidgetRange", t10;
}(Qn || (Qn = {}));
class nr extends rs {
  constructor(e3, r3, n3, i3) {
    super(), this.startSide = e3, this.endSide = r3, this.widget = n3, this.spec = i3;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e3) {
    return new lu(e3);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e3) {
    let r3 = Math.max(-1e4, Math.min(1e4, e3.side || 0)), n3 = !!e3.block;
    return r3 += n3 && !e3.inlineOrder ? r3 > 0 ? 3e8 : -4e8 : r3 > 0 ? 1e8 : -1e8, new ho(e3, r3, r3, n3, e3.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e3) {
    let r3 = !!e3.block, n3, i3;
    if (e3.isBlockGap)
      n3 = -5e8, i3 = 4e8;
    else {
      let { start: o3, end: s3 } = tP(e3, r3);
      n3 = (o3 ? r3 ? -3e8 : -1 : 5e8) - 1, i3 = (s3 ? r3 ? 2e8 : 1 : -6e8) + 1;
    }
    return new ho(e3, n3, i3, r3, e3.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e3) {
    return new uu(e3);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e3, r3 = false) {
    return xt.of(e3, r3);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
}
nr.none = xt.empty;
class lu extends nr {
  constructor(e3) {
    let { start: r3, end: n3 } = tP(e3);
    super(r3 ? -1 : 5e8, n3 ? 1 : -6e8, null, e3), this.tagName = e3.tagName || "span", this.class = e3.class || "", this.attrs = e3.attributes || null;
  }
  eq(e3) {
    var r3, n3;
    return this == e3 || e3 instanceof lu && this.tagName == e3.tagName && (this.class || ((r3 = this.attrs) === null || r3 === void 0 ? void 0 : r3.class)) == (e3.class || ((n3 = e3.attrs) === null || n3 === void 0 ? void 0 : n3.class)) && kg(this.attrs, e3.attrs, "class");
  }
  range(e3, r3 = e3) {
    if (e3 >= r3)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e3, r3);
  }
}
lu.prototype.point = false;
class uu extends nr {
  constructor(e3) {
    super(-2e8, -2e8, null, e3);
  }
  eq(e3) {
    return e3 instanceof uu && this.spec.class == e3.spec.class && kg(this.spec.attributes, e3.spec.attributes);
  }
  range(e3, r3 = e3) {
    if (r3 != e3)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e3, r3);
  }
}
uu.prototype.mapMode = kr.TrackBefore;
uu.prototype.point = true;
class ho extends nr {
  constructor(e3, r3, n3, i3, o3, s3) {
    super(r3, n3, o3, e3), this.block = i3, this.isReplace = s3, this.mapMode = i3 ? r3 <= 0 ? kr.TrackBefore : kr.TrackAfter : kr.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Qn.WidgetRange : this.startSide <= 0 ? Qn.WidgetBefore : Qn.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e3) {
    return e3 instanceof ho && SR(this.widget, e3.widget) && this.block == e3.block && this.startSide == e3.startSide && this.endSide == e3.endSide;
  }
  range(e3, r3 = e3) {
    if (this.isReplace && (e3 > r3 || e3 == r3 && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && r3 != e3)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e3, r3);
  }
}
ho.prototype.point = true;
function tP(t10, e3 = false) {
  let { inclusiveStart: r3, inclusiveEnd: n3 } = t10;
  return r3 == null && (r3 = t10.inclusive), n3 == null && (n3 = t10.inclusive), { start: r3 ?? e3, end: n3 ?? e3 };
}
function SR(t10, e3) {
  return t10 == e3 || !!(t10 && e3 && t10.compare(e3));
}
function aO(t10, e3, r3, n3 = 0) {
  let i3 = r3.length - 1;
  i3 >= 0 && r3[i3] + n3 >= t10 ? r3[i3] = Math.max(r3[i3], e3) : r3.push(t10, e3);
}
class gl {
  constructor(e3, r3, n3, i3) {
    this.doc = e3, this.pos = r3, this.end = n3, this.disallowBlockEffectsFor = i3, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = true, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e3.iter(), this.skip = r3;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e3 = this.content[this.content.length - 1];
    return !(e3.breakAfter || e3 instanceof Bo && e3.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Gt()), this.atCursorPos = true), this.curLine;
  }
  flushBuffer(e3 = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Wu(new la(-1), e3), e3.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e3) {
    this.flushBuffer(), this.curLine = null, this.content.push(e3);
  }
  finish(e3) {
    this.pendingBuffer && e3 <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !e3 && !this.posCovered() && this.getLine();
  }
  buildText(e3, r3, n3) {
    for (; e3 > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o3, lineBreak: s3, done: a3 } = this.cursor.next(this.skip);
        if (this.skip = 0, a3)
          throw new Error("Ran out of text content when drawing inline views");
        if (s3) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = true, e3--;
          continue;
        } else
          this.text = o3, this.textOff = 0;
      }
      let i3 = Math.min(
        this.text.length - this.textOff,
        e3,
        512
        /* T.Chunk */
      );
      this.flushBuffer(r3.slice(r3.length - n3)), this.getLine().append(Wu(new Ri(this.text.slice(this.textOff, this.textOff + i3)), r3), n3), this.atCursorPos = true, this.textOff += i3, e3 -= i3, n3 = 0;
    }
  }
  span(e3, r3, n3, i3) {
    this.buildText(r3 - e3, n3, i3), this.pos = r3, this.openStart < 0 && (this.openStart = i3);
  }
  point(e3, r3, n3, i3, o3, s3) {
    if (this.disallowBlockEffectsFor[s3] && n3 instanceof ho) {
      if (n3.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (r3 > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a3 = r3 - e3;
    if (n3 instanceof ho)
      if (n3.block)
        n3.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Bo(n3.widget || new Uy("div"), a3, n3));
      else {
        let l3 = Mo.create(n3.widget || new Uy("span"), a3, a3 ? 0 : n3.startSide), u3 = this.atCursorPos && !l3.isEditable && o3 <= i3.length && (e3 < r3 || n3.startSide > 0), c3 = !l3.isEditable && (e3 < r3 || o3 > i3.length || n3.startSide <= 0), f3 = this.getLine();
        this.pendingBuffer == 2 && !u3 && !l3.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i3), u3 && (f3.append(Wu(new la(1), i3), o3), o3 = i3.length + Math.max(0, o3 - i3.length)), f3.append(Wu(l3, i3), o3), this.atCursorPos = c3, this.pendingBuffer = c3 ? e3 < r3 || o3 > i3.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i3.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n3);
    a3 && (this.textOff + a3 <= this.text.length ? this.textOff += a3 : (this.skip += a3 - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = r3), this.openStart < 0 && (this.openStart = o3);
  }
  static build(e3, r3, n3, i3, o3) {
    let s3 = new gl(e3, r3, n3, o3);
    return s3.openEnd = xt.spans(i3, r3, n3, s3), s3.openStart < 0 && (s3.openStart = s3.openEnd), s3.finish(s3.openEnd), s3;
  }
}
function Wu(t10, e3) {
  for (let r3 of e3)
    t10 = new Ai(r3, [t10], t10.length);
  return t10;
}
class Uy extends Gf {
  constructor(e3) {
    super(), this.tag = e3;
  }
  eq(e3) {
    return e3.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e3) {
    return e3.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
}
const rP = /* @__PURE__ */ Me.define(), nP = /* @__PURE__ */ Me.define(), iP = /* @__PURE__ */ Me.define(), oP = /* @__PURE__ */ Me.define(), lO = /* @__PURE__ */ Me.define(), sP = /* @__PURE__ */ Me.define(), aP = /* @__PURE__ */ Me.define(), lP = /* @__PURE__ */ Me.define({
  combine: (t10) => t10.some((e3) => e3)
}), $R = /* @__PURE__ */ Me.define({
  combine: (t10) => t10.some((e3) => e3)
});
class of {
  constructor(e3, r3 = "nearest", n3 = "nearest", i3 = 5, o3 = 5) {
    this.range = e3, this.y = r3, this.x = n3, this.yMargin = i3, this.xMargin = o3;
  }
  map(e3) {
    return e3.empty ? this : new of(this.range.map(e3), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const Iy = /* @__PURE__ */ Dt.define({ map: (t10, e3) => t10.map(e3) });
function zo(t10, e3, r3) {
  let n3 = t10.facet(oP);
  n3.length ? n3[0](e3) : window.onerror ? window.onerror(String(e3), r3, void 0, void 0, e3) : r3 ? console.error(r3 + ":", e3) : console.error(e3);
}
const Kf = /* @__PURE__ */ Me.define({ combine: (t10) => t10.length ? t10[0] : true });
let wR = 0;
const ol = /* @__PURE__ */ Me.define();
class Xi {
  constructor(e3, r3, n3, i3, o3) {
    this.id = e3, this.create = r3, this.domEventHandlers = n3, this.domEventObservers = i3, this.extension = o3(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e3, r3) {
    const { eventHandlers: n3, eventObservers: i3, provide: o3, decorations: s3 } = r3 || {};
    return new Xi(wR++, e3, n3, i3, (a3) => {
      let l3 = [ol.of(a3)];
      return s3 && l3.push(jl.of((u3) => {
        let c3 = u3.plugin(a3);
        return c3 ? s3(c3) : nr.none;
      })), o3 && l3.push(o3(a3)), l3;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e3, r3) {
    return Xi.define((n3) => new e3(n3), r3);
  }
}
class hh {
  constructor(e3) {
    this.spec = e3, this.mustUpdate = null, this.value = null;
  }
  update(e3) {
    if (this.value) {
      if (this.mustUpdate) {
        let r3 = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(r3);
          } catch (n3) {
            if (zo(r3.state, n3, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e3);
      } catch (r3) {
        zo(e3.state, r3, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e3) {
    var r3;
    if (!((r3 = this.value) === null || r3 === void 0) && r3.destroy)
      try {
        this.value.destroy();
      } catch (n3) {
        zo(e3.state, n3, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const uP = /* @__PURE__ */ Me.define(), Eg = /* @__PURE__ */ Me.define(), jl = /* @__PURE__ */ Me.define(), Cg = /* @__PURE__ */ Me.define(), cP = /* @__PURE__ */ Me.define();
function Fy(t10, e3, r3) {
  let n3 = t10.state.facet(cP);
  if (!n3.length)
    return n3;
  let i3 = n3.map((s3) => s3 instanceof Function ? s3(t10) : s3), o3 = [];
  return xt.spans(i3, e3, r3, {
    point() {
    },
    span(s3, a3, l3, u3) {
      let c3 = o3;
      for (let f3 = l3.length - 1; f3 >= 0; f3--, u3--) {
        let d3 = l3[f3].spec.bidiIsolate, p10;
        if (d3 != null)
          if (u3 > 0 && c3.length && (p10 = c3[c3.length - 1]).to == s3 && p10.direction == d3)
            p10.to = a3, c3 = p10.inner;
          else {
            let h10 = { from: s3, to: a3, direction: d3, inner: [] };
            c3.push(h10), c3 = h10.inner;
          }
      }
    }
  }), o3;
}
const fP = /* @__PURE__ */ Me.define();
function dP(t10) {
  let e3 = 0, r3 = 0, n3 = 0, i3 = 0;
  for (let o3 of t10.state.facet(fP)) {
    let s3 = o3(t10);
    s3 && (s3.left != null && (e3 = Math.max(e3, s3.left)), s3.right != null && (r3 = Math.max(r3, s3.right)), s3.top != null && (n3 = Math.max(n3, s3.top)), s3.bottom != null && (i3 = Math.max(i3, s3.bottom)));
  }
  return { left: e3, right: r3, top: n3, bottom: i3 };
}
const sl = /* @__PURE__ */ Me.define();
class fn {
  constructor(e3, r3, n3, i3) {
    this.fromA = e3, this.toA = r3, this.fromB = n3, this.toB = i3;
  }
  join(e3) {
    return new fn(Math.min(this.fromA, e3.fromA), Math.max(this.toA, e3.toA), Math.min(this.fromB, e3.fromB), Math.max(this.toB, e3.toB));
  }
  addToSet(e3) {
    let r3 = e3.length, n3 = this;
    for (; r3 > 0; r3--) {
      let i3 = e3[r3 - 1];
      if (!(i3.fromA > n3.toA)) {
        if (i3.toA < n3.fromA)
          break;
        n3 = n3.join(i3), e3.splice(r3 - 1, 1);
      }
    }
    return e3.splice(r3, 0, n3), e3;
  }
  static extendWithRanges(e3, r3) {
    if (r3.length == 0)
      return e3;
    let n3 = [];
    for (let i3 = 0, o3 = 0, s3 = 0, a3 = 0; ; i3++) {
      let l3 = i3 == e3.length ? null : e3[i3], u3 = s3 - a3, c3 = l3 ? l3.fromB : 1e9;
      for (; o3 < r3.length && r3[o3] < c3; ) {
        let f3 = r3[o3], d3 = r3[o3 + 1], p10 = Math.max(a3, f3), h10 = Math.min(c3, d3);
        if (p10 <= h10 && new fn(p10 + u3, h10 + u3, p10, h10).addToSet(n3), d3 > c3)
          break;
        o3 += 2;
      }
      if (!l3)
        return n3;
      new fn(l3.fromA, l3.toA, l3.fromB, l3.toB).addToSet(n3), s3 = l3.toA, a3 = l3.toB;
    }
  }
}
class sf {
  constructor(e3, r3, n3) {
    this.view = e3, this.state = r3, this.transactions = n3, this.flags = 0, this.startState = e3.state, this.changes = rr.empty(this.startState.doc.length);
    for (let o3 of n3)
      this.changes = this.changes.compose(o3.changes);
    let i3 = [];
    this.changes.iterChangedRanges((o3, s3, a3, l3) => i3.push(new fn(o3, s3, a3, l3))), this.changedRanges = i3;
  }
  /**
  @internal
  */
  static create(e3, r3, n3) {
    return new sf(e3, r3, n3);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e3) => e3.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var br = /* @__PURE__ */ function(t10) {
  return t10[t10.LTR = 0] = "LTR", t10[t10.RTL = 1] = "RTL", t10;
}(br || (br = {}));
const Ul = br.LTR, hP = br.RTL;
function pP(t10) {
  let e3 = [];
  for (let r3 = 0; r3 < t10.length; r3++)
    e3.push(1 << +t10[r3]);
  return e3;
}
const PR = /* @__PURE__ */ pP("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), _R = /* @__PURE__ */ pP("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), uO = /* @__PURE__ */ Object.create(null), Fn = [];
for (let t10 of ["()", "[]", "{}"]) {
  let e3 = /* @__PURE__ */ t10.charCodeAt(0), r3 = /* @__PURE__ */ t10.charCodeAt(1);
  uO[e3] = r3, uO[r3] = -e3;
}
function xR(t10) {
  return t10 <= 247 ? PR[t10] : 1424 <= t10 && t10 <= 1524 ? 2 : 1536 <= t10 && t10 <= 1785 ? _R[t10 - 1536] : 1774 <= t10 && t10 <= 2220 ? 4 : 8192 <= t10 && t10 <= 8203 ? 256 : 64336 <= t10 && t10 <= 65023 ? 4 : t10 == 8204 ? 256 : 1;
}
const QR = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class to {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? hP : Ul;
  }
  /**
  @internal
  */
  constructor(e3, r3, n3) {
    this.from = e3, this.to = r3, this.level = n3;
  }
  /**
  @internal
  */
  side(e3, r3) {
    return this.dir == r3 == e3 ? this.to : this.from;
  }
  /**
  @internal
  */
  static find(e3, r3, n3, i3) {
    let o3 = -1;
    for (let s3 = 0; s3 < e3.length; s3++) {
      let a3 = e3[s3];
      if (a3.from <= r3 && a3.to >= r3) {
        if (a3.level == n3)
          return s3;
        (o3 < 0 || (i3 != 0 ? i3 < 0 ? a3.from < r3 : a3.to > r3 : e3[o3].level > a3.level)) && (o3 = s3);
      }
    }
    if (o3 < 0)
      throw new RangeError("Index out of range");
    return o3;
  }
}
function OP(t10, e3) {
  if (t10.length != e3.length)
    return false;
  for (let r3 = 0; r3 < t10.length; r3++) {
    let n3 = t10[r3], i3 = e3[r3];
    if (n3.from != i3.from || n3.to != i3.to || n3.direction != i3.direction || !OP(n3.inner, i3.inner))
      return false;
  }
  return true;
}
const gt = [];
function TR(t10, e3, r3, n3, i3) {
  for (let o3 = 0; o3 <= n3.length; o3++) {
    let s3 = o3 ? n3[o3 - 1].to : e3, a3 = o3 < n3.length ? n3[o3].from : r3, l3 = o3 ? 256 : i3;
    for (let u3 = s3, c3 = l3, f3 = l3; u3 < a3; u3++) {
      let d3 = xR(t10.charCodeAt(u3));
      d3 == 512 ? d3 = c3 : d3 == 8 && f3 == 4 && (d3 = 16), gt[u3] = d3 == 4 ? 2 : d3, d3 & 7 && (f3 = d3), c3 = d3;
    }
    for (let u3 = s3, c3 = l3, f3 = l3; u3 < a3; u3++) {
      let d3 = gt[u3];
      if (d3 == 128)
        u3 < a3 - 1 && c3 == gt[u3 + 1] && c3 & 24 ? d3 = gt[u3] = c3 : gt[u3] = 256;
      else if (d3 == 64) {
        let p10 = u3 + 1;
        for (; p10 < a3 && gt[p10] == 64; )
          p10++;
        let h10 = u3 && c3 == 8 || p10 < r3 && gt[p10] == 8 ? f3 == 1 ? 1 : 8 : 256;
        for (let m10 = u3; m10 < p10; m10++)
          gt[m10] = h10;
        u3 = p10 - 1;
      } else
        d3 == 8 && f3 == 1 && (gt[u3] = 1);
      c3 = d3, d3 & 7 && (f3 = d3);
    }
  }
}
function kR(t10, e3, r3, n3, i3) {
  let o3 = i3 == 1 ? 2 : 1;
  for (let s3 = 0, a3 = 0, l3 = 0; s3 <= n3.length; s3++) {
    let u3 = s3 ? n3[s3 - 1].to : e3, c3 = s3 < n3.length ? n3[s3].from : r3;
    for (let f3 = u3, d3, p10, h10; f3 < c3; f3++)
      if (p10 = uO[d3 = t10.charCodeAt(f3)])
        if (p10 < 0) {
          for (let m10 = a3 - 3; m10 >= 0; m10 -= 3)
            if (Fn[m10 + 1] == -p10) {
              let O10 = Fn[m10 + 2], g = O10 & 2 ? i3 : O10 & 4 ? O10 & 1 ? o3 : i3 : 0;
              g && (gt[f3] = gt[Fn[m10]] = g), a3 = m10;
              break;
            }
        } else {
          if (Fn.length == 189)
            break;
          Fn[a3++] = f3, Fn[a3++] = d3, Fn[a3++] = l3;
        }
      else if ((h10 = gt[f3]) == 2 || h10 == 1) {
        let m10 = h10 == i3;
        l3 = m10 ? 0 : 1;
        for (let O10 = a3 - 3; O10 >= 0; O10 -= 3) {
          let g = Fn[O10 + 2];
          if (g & 2)
            break;
          if (m10)
            Fn[O10 + 2] |= 2;
          else {
            if (g & 4)
              break;
            Fn[O10 + 2] |= 4;
          }
        }
      }
  }
}
function ER(t10, e3, r3, n3) {
  for (let i3 = 0, o3 = n3; i3 <= r3.length; i3++) {
    let s3 = i3 ? r3[i3 - 1].to : t10, a3 = i3 < r3.length ? r3[i3].from : e3;
    for (let l3 = s3; l3 < a3; ) {
      let u3 = gt[l3];
      if (u3 == 256) {
        let c3 = l3 + 1;
        for (; ; )
          if (c3 == a3) {
            if (i3 == r3.length)
              break;
            c3 = r3[i3++].to, a3 = i3 < r3.length ? r3[i3].from : e3;
          } else if (gt[c3] == 256)
            c3++;
          else
            break;
        let f3 = o3 == 1, d3 = (c3 < e3 ? gt[c3] : n3) == 1, p10 = f3 == d3 ? f3 ? 1 : 2 : n3;
        for (let h10 = c3, m10 = i3, O10 = m10 ? r3[m10 - 1].to : t10; h10 > l3; )
          h10 == O10 && (h10 = r3[--m10].from, O10 = m10 ? r3[m10 - 1].to : t10), gt[--h10] = p10;
        l3 = c3;
      } else
        o3 = u3, l3++;
    }
  }
}
function cO(t10, e3, r3, n3, i3, o3, s3) {
  let a3 = n3 % 2 ? 2 : 1;
  if (n3 % 2 == i3 % 2)
    for (let l3 = e3, u3 = 0; l3 < r3; ) {
      let c3 = true, f3 = false;
      if (u3 == o3.length || l3 < o3[u3].from) {
        let m10 = gt[l3];
        m10 != a3 && (c3 = false, f3 = m10 == 16);
      }
      let d3 = !c3 && a3 == 1 ? [] : null, p10 = c3 ? n3 : n3 + 1, h10 = l3;
      e:
        for (; ; )
          if (u3 < o3.length && h10 == o3[u3].from) {
            if (f3)
              break e;
            let m10 = o3[u3];
            if (!c3)
              for (let O10 = m10.to, g = u3 + 1; ; ) {
                if (O10 == r3)
                  break e;
                if (g < o3.length && o3[g].from == O10)
                  O10 = o3[g++].to;
                else {
                  if (gt[O10] == a3)
                    break e;
                  break;
                }
              }
            if (u3++, d3)
              d3.push(m10);
            else {
              m10.from > l3 && s3.push(new to(l3, m10.from, p10));
              let O10 = m10.direction == Ul != !(p10 % 2);
              fO(t10, O10 ? n3 + 1 : n3, i3, m10.inner, m10.from, m10.to, s3), l3 = m10.to;
            }
            h10 = m10.to;
          } else {
            if (h10 == r3 || (c3 ? gt[h10] != a3 : gt[h10] == a3))
              break;
            h10++;
          }
      d3 ? cO(t10, l3, h10, n3 + 1, i3, d3, s3) : l3 < h10 && s3.push(new to(l3, h10, p10)), l3 = h10;
    }
  else
    for (let l3 = r3, u3 = o3.length; l3 > e3; ) {
      let c3 = true, f3 = false;
      if (!u3 || l3 > o3[u3 - 1].to) {
        let m10 = gt[l3 - 1];
        m10 != a3 && (c3 = false, f3 = m10 == 16);
      }
      let d3 = !c3 && a3 == 1 ? [] : null, p10 = c3 ? n3 : n3 + 1, h10 = l3;
      e:
        for (; ; )
          if (u3 && h10 == o3[u3 - 1].to) {
            if (f3)
              break e;
            let m10 = o3[--u3];
            if (!c3)
              for (let O10 = m10.from, g = u3; ; ) {
                if (O10 == e3)
                  break e;
                if (g && o3[g - 1].to == O10)
                  O10 = o3[--g].from;
                else {
                  if (gt[O10 - 1] == a3)
                    break e;
                  break;
                }
              }
            if (d3)
              d3.push(m10);
            else {
              m10.to < l3 && s3.push(new to(m10.to, l3, p10));
              let O10 = m10.direction == Ul != !(p10 % 2);
              fO(t10, O10 ? n3 + 1 : n3, i3, m10.inner, m10.from, m10.to, s3), l3 = m10.from;
            }
            h10 = m10.from;
          } else {
            if (h10 == e3 || (c3 ? gt[h10 - 1] != a3 : gt[h10 - 1] == a3))
              break;
            h10--;
          }
      d3 ? cO(t10, h10, l3, n3 + 1, i3, d3, s3) : h10 < l3 && s3.push(new to(h10, l3, p10)), l3 = h10;
    }
}
function fO(t10, e3, r3, n3, i3, o3, s3) {
  let a3 = e3 % 2 ? 2 : 1;
  TR(t10, i3, o3, n3, a3), kR(t10, i3, o3, n3, a3), ER(i3, o3, n3, a3), cO(t10, i3, o3, e3, r3, n3, s3);
}
function CR(t10, e3, r3) {
  if (!t10)
    return [new to(0, 0, e3 == hP ? 1 : 0)];
  if (e3 == Ul && !r3.length && !QR.test(t10))
    return mP(t10.length);
  if (r3.length)
    for (; t10.length > gt.length; )
      gt[gt.length] = 256;
  let n3 = [], i3 = e3 == Ul ? 0 : 1;
  return fO(t10, i3, i3, r3, 0, t10.length, n3), n3;
}
function mP(t10) {
  return [new to(0, t10, 0)];
}
let gP = "";
function RR(t10, e3, r3, n3, i3) {
  var o3;
  let s3 = n3.head - t10.from, a3 = -1;
  if (s3 == 0) {
    if (!i3 || !t10.length)
      return null;
    e3[0].level != r3 && (s3 = e3[0].side(false, r3), a3 = 0);
  } else if (s3 == t10.length) {
    if (i3)
      return null;
    let d3 = e3[e3.length - 1];
    d3.level != r3 && (s3 = d3.side(true, r3), a3 = e3.length - 1);
  }
  a3 < 0 && (a3 = to.find(e3, s3, (o3 = n3.bidiLevel) !== null && o3 !== void 0 ? o3 : -1, n3.assoc));
  let l3 = e3[a3];
  s3 == l3.side(i3, r3) && (l3 = e3[a3 += i3 ? 1 : -1], s3 = l3.side(!i3, r3));
  let u3 = i3 == (l3.dir == r3), c3 = $i(t10.text, s3, u3);
  if (gP = t10.text.slice(Math.min(s3, c3), Math.max(s3, c3)), c3 != l3.side(i3, r3))
    return Pe.cursor(c3 + t10.from, u3 ? -1 : 1, l3.level);
  let f3 = a3 == (i3 ? e3.length - 1 : 0) ? null : e3[a3 + (i3 ? 1 : -1)];
  return !f3 && l3.level != r3 ? Pe.cursor(i3 ? t10.to : t10.from, i3 ? -1 : 1, r3) : f3 && f3.level < l3.level ? Pe.cursor(f3.side(!i3, r3) + t10.from, i3 ? 1 : -1, f3.level) : Pe.cursor(c3 + t10.from, i3 ? -1 : 1, l3.level);
}
class Zy extends Qt {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e3) {
    super(), this.view = e3, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.setDOM(e3.contentDOM), this.children = [new Gt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new fn(0, 0, 0, e3.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e3) {
    var r3;
    let n3 = e3.changedRanges;
    this.minWidth > 0 && n3.length && (n3.every(({ fromA: u3, toA: c3 }) => c3 < this.minWidthFrom || u3 > this.minWidthTo) ? (this.minWidthFrom = e3.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e3.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i3 = -1;
    this.view.inputState.composing >= 0 && (!((r3 = this.domChanged) === null || r3 === void 0) && r3.newSel ? i3 = this.domChanged.newSel.head : !IR(e3.changes, this.hasComposition) && !e3.selectionSet && (i3 = e3.state.selection.main.head));
    let o3 = i3 > -1 ? XR(this.view, e3.changes, i3) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: u3, to: c3 } = this.hasComposition;
      n3 = new fn(u3, c3, e3.changes.mapPos(u3, -1), e3.changes.mapPos(c3, 1)).addToSet(n3.slice());
    }
    this.hasComposition = o3 ? { from: o3.range.fromB, to: o3.range.toB } : null, (ke.ie || ke.chrome) && !o3 && e3 && e3.state.doc.lines != e3.startState.doc.lines && (this.forceSelection = true);
    let s3 = this.decorations, a3 = this.updateDeco(), l3 = jR(s3, a3, e3.changes);
    return n3 = fn.extendWithRanges(n3, l3), !(this.flags & 7) && n3.length == 0 ? false : (this.updateInner(n3, e3.startState.doc.length, o3), e3.transactions.length && (this.lastUpdate = Date.now()), true);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e3, r3, n3) {
    this.view.viewState.mustMeasureContent = true, this.updateChildren(e3, r3, n3);
    let { observer: i3 } = this.view;
    i3.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let s3 = ke.chrome || ke.ios ? { node: i3.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, s3), this.flags &= -8, s3 && (s3.written || i3.selectionRange.focusNode != s3.node) && (this.forceSelection = true), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (s3) => s3.flags &= -9
      /* ViewFlag.Composition */
    );
    let o3 = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let s3 of this.children)
        s3 instanceof Bo && s3.widget instanceof My && o3.push(s3.dom);
    i3.updateGaps(o3);
  }
  updateChildren(e3, r3, n3) {
    let i3 = n3 ? n3.range.addToSet(e3.slice()) : e3, o3 = this.childCursor(r3);
    for (let s3 = i3.length - 1; ; s3--) {
      let a3 = s3 >= 0 ? i3[s3] : null;
      if (!a3)
        break;
      let { fromA: l3, toA: u3, fromB: c3, toB: f3 } = a3, d3, p10, h10, m10;
      if (n3 && n3.range.fromB < f3 && n3.range.toB > c3) {
        let $10 = gl.build(this.view.state.doc, c3, n3.range.fromB, this.decorations, this.dynamicDecorationMap), _10 = gl.build(this.view.state.doc, n3.range.toB, f3, this.decorations, this.dynamicDecorationMap);
        p10 = $10.breakAtStart, h10 = $10.openStart, m10 = _10.openEnd;
        let P10 = this.compositionView(n3);
        _10.breakAtStart ? P10.breakAfter = 1 : _10.content.length && P10.merge(P10.length, P10.length, _10.content[0], false, _10.openStart, 0) && (P10.breakAfter = _10.content[0].breakAfter, _10.content.shift()), $10.content.length && P10.merge(0, 0, $10.content[$10.content.length - 1], true, 0, $10.openEnd) && $10.content.pop(), d3 = $10.content.concat(P10).concat(_10.content);
      } else
        ({ content: d3, breakAtStart: p10, openStart: h10, openEnd: m10 } = gl.build(this.view.state.doc, c3, f3, this.decorations, this.dynamicDecorationMap));
      let { i: O10, off: g } = o3.findPos(u3, 1), { i: v10, off: S10 } = o3.findPos(l3, -1);
      B2(this, v10, S10, O10, g, d3, p10, h10, m10);
    }
    n3 && this.fixCompositionDOM(n3);
  }
  compositionView(e3) {
    let r3 = new Ri(e3.text.nodeValue);
    r3.flags |= 8;
    for (let { deco: i3 } of e3.marks)
      r3 = new Ai(i3, [r3], r3.length);
    let n3 = new Gt();
    return n3.append(r3, 0), n3;
  }
  fixCompositionDOM(e3) {
    let r3 = (o3, s3) => {
      s3.flags |= 8 | (s3.children.some(
        (l3) => l3.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(s3);
      let a3 = Qt.get(o3);
      a3 && a3 != s3 && (a3.dom = null), s3.setDOM(o3);
    }, n3 = this.childPos(e3.range.fromB, 1), i3 = this.children[n3.i];
    r3(e3.line, i3);
    for (let o3 = e3.marks.length - 1; o3 >= -1; o3--)
      n3 = i3.childPos(n3.off, 1), i3 = i3.children[n3.i], r3(o3 >= 0 ? e3.marks[o3].node : e3.text, i3);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e3 = false, r3 = false) {
    (e3 || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let n3 = this.view.root.activeElement, i3 = n3 == this.dom, o3 = !i3 && bc(this.dom, this.view.observer.selectionRange) && !(n3 && this.dom.contains(n3));
    if (!(i3 || r3 || o3))
      return;
    let s3 = this.forceSelection;
    this.forceSelection = false;
    let a3 = this.view.state.selection.main, l3 = this.moveToLine(this.domAtPos(a3.anchor)), u3 = a3.empty ? l3 : this.moveToLine(this.domAtPos(a3.head));
    if (ke.gecko && a3.empty && !this.hasComposition && AR(l3)) {
      let f3 = document.createTextNode("");
      this.view.observer.ignore(() => l3.node.insertBefore(f3, l3.node.childNodes[l3.offset] || null)), l3 = u3 = new gr(f3, 0), s3 = true;
    }
    let c3 = this.view.observer.selectionRange;
    (s3 || !c3.focusNode || !rf(l3.node, l3.offset, c3.anchorNode, c3.anchorOffset) || !rf(u3.node, u3.offset, c3.focusNode, c3.focusOffset)) && (this.view.observer.ignore(() => {
      ke.android && ke.chrome && this.dom.contains(c3.focusNode) && UR(c3.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: true }));
      let f3 = tf(this.view.root);
      if (f3)
        if (a3.empty) {
          if (ke.gecko) {
            let d3 = qR(l3.node, l3.offset);
            if (d3 && d3 != 3) {
              let p10 = vP(l3.node, l3.offset, d3 == 1 ? 1 : -1);
              p10 && (l3 = new gr(p10.node, p10.offset));
            }
          }
          f3.collapse(l3.node, l3.offset), a3.bidiLevel != null && f3.caretBidiLevel !== void 0 && (f3.caretBidiLevel = a3.bidiLevel);
        } else if (f3.extend) {
          f3.collapse(l3.node, l3.offset);
          try {
            f3.extend(u3.node, u3.offset);
          } catch {
          }
        } else {
          let d3 = document.createRange();
          a3.anchor > a3.head && ([l3, u3] = [u3, l3]), d3.setEnd(u3.node, u3.offset), d3.setStart(l3.node, l3.offset), f3.removeAllRanges(), f3.addRange(d3);
        }
      o3 && this.view.root.activeElement == this.dom && (this.dom.blur(), n3 && n3.focus());
    }), this.view.observer.setSelectionRange(l3, u3)), this.impreciseAnchor = l3.precise ? null : new gr(c3.anchorNode, c3.anchorOffset), this.impreciseHead = u3.precise ? null : new gr(c3.focusNode, c3.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e3 } = this, r3 = e3.state.selection.main, n3 = tf(e3.root), { anchorNode: i3, anchorOffset: o3 } = e3.observer.selectionRange;
    if (!n3 || !r3.empty || !r3.assoc || !n3.modify)
      return;
    let s3 = Gt.find(this, r3.head);
    if (!s3)
      return;
    let a3 = s3.posAtStart;
    if (r3.head == a3 || r3.head == a3 + s3.length)
      return;
    let l3 = this.coordsAt(r3.head, -1), u3 = this.coordsAt(r3.head, 1);
    if (!l3 || !u3 || l3.bottom > u3.top)
      return;
    let c3 = this.domAtPos(r3.head + r3.assoc);
    n3.collapse(c3.node, c3.offset), n3.modify("move", r3.assoc < 0 ? "forward" : "backward", "lineboundary"), e3.observer.readSelectionRange();
    let f3 = e3.observer.selectionRange;
    e3.docView.posFromDOM(f3.anchorNode, f3.anchorOffset) != r3.from && n3.collapse(i3, o3);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e3) {
    let r3 = this.dom, n3;
    if (e3.node != r3)
      return e3;
    for (let i3 = e3.offset; !n3 && i3 < r3.childNodes.length; i3++) {
      let o3 = Qt.get(r3.childNodes[i3]);
      o3 instanceof Gt && (n3 = o3.domAtPos(0));
    }
    for (let i3 = e3.offset - 1; !n3 && i3 >= 0; i3--) {
      let o3 = Qt.get(r3.childNodes[i3]);
      o3 instanceof Gt && (n3 = o3.domAtPos(o3.length));
    }
    return n3 ? new gr(n3.node, n3.offset, true) : e3;
  }
  nearest(e3) {
    for (let r3 = e3; r3; ) {
      let n3 = Qt.get(r3);
      if (n3 && n3.rootView == this)
        return n3;
      r3 = r3.parentNode;
    }
    return null;
  }
  posFromDOM(e3, r3) {
    let n3 = this.nearest(e3);
    if (!n3)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return n3.localPosFromDOM(e3, r3) + n3.posAtStart;
  }
  domAtPos(e3) {
    let { i: r3, off: n3 } = this.childCursor().findPos(e3, -1);
    for (; r3 < this.children.length - 1; ) {
      let i3 = this.children[r3];
      if (n3 < i3.length || i3 instanceof Gt)
        break;
      r3++, n3 = 0;
    }
    return this.children[r3].domAtPos(n3);
  }
  coordsAt(e3, r3) {
    let n3 = null, i3 = 0;
    for (let o3 = this.length, s3 = this.children.length - 1; s3 >= 0; s3--) {
      let a3 = this.children[s3], l3 = o3 - a3.breakAfter, u3 = l3 - a3.length;
      if (l3 < e3)
        break;
      u3 <= e3 && (u3 < e3 || a3.covers(-1)) && (l3 > e3 || a3.covers(1)) && (!n3 || a3 instanceof Gt && !(n3 instanceof Gt && r3 >= 0)) && (n3 = a3, i3 = u3), o3 = u3;
    }
    return n3 ? n3.coordsAt(e3 - i3, r3) : null;
  }
  coordsForChar(e3) {
    let { i: r3, off: n3 } = this.childPos(e3, 1), i3 = this.children[r3];
    if (!(i3 instanceof Gt))
      return null;
    for (; i3.children.length; ) {
      let { i: a3, off: l3 } = i3.childPos(n3, 1);
      for (; ; a3++) {
        if (a3 == i3.children.length)
          return null;
        if ((i3 = i3.children[a3]).length)
          break;
      }
      n3 = l3;
    }
    if (!(i3 instanceof Ri))
      return null;
    let o3 = $i(i3.text, n3);
    if (o3 == n3)
      return null;
    let s3 = ns(i3.dom, n3, o3).getClientRects();
    return !s3.length || s3[0].top >= s3[0].bottom ? null : s3[0];
  }
  measureVisibleLineHeights(e3) {
    let r3 = [], { from: n3, to: i3 } = e3, o3 = this.view.contentDOM.clientWidth, s3 = o3 > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a3 = -1, l3 = this.view.textDirection == br.LTR;
    for (let u3 = 0, c3 = 0; c3 < this.children.length; c3++) {
      let f3 = this.children[c3], d3 = u3 + f3.length;
      if (d3 > i3)
        break;
      if (u3 >= n3) {
        let p10 = f3.dom.getBoundingClientRect();
        if (r3.push(p10.height), s3) {
          let h10 = f3.dom.lastChild, m10 = h10 ? Dl(h10) : [];
          if (m10.length) {
            let O10 = m10[m10.length - 1], g = l3 ? O10.right - p10.left : p10.right - O10.left;
            g > a3 && (a3 = g, this.minWidth = o3, this.minWidthFrom = u3, this.minWidthTo = d3);
          }
        }
      }
      u3 = d3 + f3.breakAfter;
    }
    return r3;
  }
  textDirectionAt(e3) {
    let { i: r3 } = this.childPos(e3, 1);
    return getComputedStyle(this.children[r3].dom).direction == "rtl" ? br.RTL : br.LTR;
  }
  measureTextSize() {
    for (let o3 of this.children)
      if (o3 instanceof Gt) {
        let s3 = o3.measureTextSize();
        if (s3)
          return s3;
      }
    let e3 = document.createElement("div"), r3, n3, i3;
    return e3.className = "cm-line", e3.style.width = "99999px", e3.style.position = "absolute", e3.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e3);
      let o3 = Dl(e3.firstChild)[0];
      r3 = e3.getBoundingClientRect().height, n3 = o3 ? o3.width / 27 : 7, i3 = o3 ? o3.height : r3, e3.remove();
    }), { lineHeight: r3, charWidth: n3, textHeight: i3 };
  }
  childCursor(e3 = this.length) {
    let r3 = this.children.length;
    return r3 && (e3 -= this.children[--r3].length), new L2(this.children, e3, r3);
  }
  computeBlockGapDeco() {
    let e3 = [], r3 = this.view.viewState;
    for (let n3 = 0, i3 = 0; ; i3++) {
      let o3 = i3 == r3.viewports.length ? null : r3.viewports[i3], s3 = o3 ? o3.from - 1 : this.length;
      if (s3 > n3) {
        let a3 = (r3.lineBlockAt(s3).bottom - r3.lineBlockAt(n3).top) / this.view.scaleY;
        e3.push(nr.replace({
          widget: new My(a3),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(n3, s3));
      }
      if (!o3)
        break;
      n3 = o3.to + 1;
    }
    return nr.set(e3);
  }
  updateDeco() {
    let e3 = this.view.state.facet(jl).map((r3, n3) => (this.dynamicDecorationMap[n3] = typeof r3 == "function") ? r3(this.view) : r3);
    for (let r3 = e3.length; r3 < e3.length + 3; r3++)
      this.dynamicDecorationMap[r3] = false;
    return this.decorations = [
      ...e3,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e3) {
    let { range: r3 } = e3, n3 = this.coordsAt(r3.head, r3.empty ? r3.assoc : r3.head > r3.anchor ? -1 : 1), i3;
    if (!n3)
      return;
    !r3.empty && (i3 = this.coordsAt(r3.anchor, r3.anchor > r3.head ? -1 : 1)) && (n3 = {
      left: Math.min(n3.left, i3.left),
      top: Math.min(n3.top, i3.top),
      right: Math.max(n3.right, i3.right),
      bottom: Math.max(n3.bottom, i3.bottom)
    });
    let o3 = dP(this.view), s3 = {
      left: n3.left - o3.left,
      top: n3.top - o3.top,
      right: n3.right + o3.right,
      bottom: n3.bottom + o3.bottom
    };
    dR(this.view.scrollDOM, s3, r3.head < r3.anchor ? -1 : 1, e3.x, e3.y, e3.xMargin, e3.yMargin, this.view.textDirection == br.LTR);
  }
}
function AR(t10) {
  return t10.node.nodeType == 1 && t10.node.firstChild && (t10.offset == 0 || t10.node.childNodes[t10.offset - 1].contentEditable == "false") && (t10.offset == t10.node.childNodes.length || t10.node.childNodes[t10.offset].contentEditable == "false");
}
class My extends Gf {
  constructor(e3) {
    super(), this.height = e3;
  }
  toDOM() {
    let e3 = document.createElement("div");
    return this.updateDOM(e3), e3;
  }
  eq(e3) {
    return e3.height == this.height;
  }
  updateDOM(e3) {
    return e3.style.height = this.height + "px", true;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function yP(t10, e3) {
  let r3 = t10.observer.selectionRange, n3 = r3.focusNode && vP(r3.focusNode, r3.focusOffset, 0);
  if (!n3)
    return null;
  let i3 = e3 - n3.offset;
  return { from: i3, to: i3 + n3.node.nodeValue.length, node: n3.node };
}
function XR(t10, e3, r3) {
  let n3 = yP(t10, r3);
  if (!n3)
    return null;
  let { node: i3, from: o3, to: s3 } = n3, a3 = i3.nodeValue;
  if (/[\n\r]/.test(a3) || t10.state.doc.sliceString(n3.from, n3.to) != a3)
    return null;
  let l3 = e3.invertedDesc, u3 = new fn(l3.mapPos(o3), l3.mapPos(s3), o3, s3), c3 = [];
  for (let f3 = i3.parentNode; ; f3 = f3.parentNode) {
    let d3 = Qt.get(f3);
    if (d3 instanceof Ai)
      c3.push({ node: f3, deco: d3.mark });
    else {
      if (d3 instanceof Gt || f3.nodeName == "DIV" && f3.parentNode == t10.contentDOM)
        return { range: u3, text: i3, marks: c3, line: f3 };
      if (f3 != t10.contentDOM)
        c3.push({ node: f3, deco: new lu({
          inclusive: true,
          attributes: bR(f3),
          tagName: f3.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function vP(t10, e3, r3) {
  if (r3 <= 0)
    for (let n3 = t10, i3 = e3; ; ) {
      if (n3.nodeType == 3)
        return { node: n3, offset: i3 };
      if (n3.nodeType == 1 && i3 > 0)
        n3 = n3.childNodes[i3 - 1], i3 = fo(n3);
      else
        break;
    }
  if (r3 >= 0)
    for (let n3 = t10, i3 = e3; ; ) {
      if (n3.nodeType == 3)
        return { node: n3, offset: i3 };
      if (n3.nodeType == 1 && i3 < n3.childNodes.length && r3 >= 0)
        n3 = n3.childNodes[i3], i3 = 0;
      else
        break;
    }
  return null;
}
function qR(t10, e3) {
  return t10.nodeType != 1 ? 0 : (e3 && t10.childNodes[e3 - 1].contentEditable == "false" ? 1 : 0) | (e3 < t10.childNodes.length && t10.childNodes[e3].contentEditable == "false" ? 2 : 0);
}
let DR = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e3, r3) {
    aO(e3, r3, this.changes);
  }
  comparePoint(e3, r3) {
    aO(e3, r3, this.changes);
  }
};
function jR(t10, e3, r3) {
  let n3 = new DR();
  return xt.compare(t10, e3, r3, n3), n3.changes;
}
function UR(t10, e3) {
  for (let r3 = t10; r3 && r3 != e3; r3 = r3.assignedSlot || r3.parentNode)
    if (r3.nodeType == 1 && r3.contentEditable == "false")
      return true;
  return false;
}
function IR(t10, e3) {
  let r3 = false;
  return e3 && t10.iterChangedRanges((n3, i3) => {
    n3 < e3.to && i3 > e3.from && (r3 = true);
  }), r3;
}
function FR(t10, e3, r3 = 1) {
  let n3 = t10.charCategorizer(e3), i3 = t10.doc.lineAt(e3), o3 = e3 - i3.from;
  if (i3.length == 0)
    return Pe.cursor(e3);
  o3 == 0 ? r3 = 1 : o3 == i3.length && (r3 = -1);
  let s3 = o3, a3 = o3;
  r3 < 0 ? s3 = $i(i3.text, o3, false) : a3 = $i(i3.text, o3);
  let l3 = n3(i3.text.slice(s3, a3));
  for (; s3 > 0; ) {
    let u3 = $i(i3.text, s3, false);
    if (n3(i3.text.slice(u3, s3)) != l3)
      break;
    s3 = u3;
  }
  for (; a3 < i3.length; ) {
    let u3 = $i(i3.text, a3);
    if (n3(i3.text.slice(a3, u3)) != l3)
      break;
    a3 = u3;
  }
  return Pe.range(s3 + i3.from, a3 + i3.from);
}
function ZR(t10, e3) {
  return e3.left > t10 ? e3.left - t10 : Math.max(0, t10 - e3.right);
}
function MR(t10, e3) {
  return e3.top > t10 ? e3.top - t10 : Math.max(0, t10 - e3.bottom);
}
function ph(t10, e3) {
  return t10.top < e3.bottom - 1 && t10.bottom > e3.top + 1;
}
function Ny(t10, e3) {
  return e3 < t10.top ? { top: e3, left: t10.left, right: t10.right, bottom: t10.bottom } : t10;
}
function Wy(t10, e3) {
  return e3 > t10.bottom ? { top: t10.top, left: t10.left, right: t10.right, bottom: e3 } : t10;
}
function dO(t10, e3, r3) {
  let n3, i3, o3, s3, a3 = false, l3, u3, c3, f3;
  for (let h10 = t10.firstChild; h10; h10 = h10.nextSibling) {
    let m10 = Dl(h10);
    for (let O10 = 0; O10 < m10.length; O10++) {
      let g = m10[O10];
      i3 && ph(i3, g) && (g = Ny(Wy(g, i3.bottom), i3.top));
      let v10 = ZR(e3, g), S10 = MR(r3, g);
      if (v10 == 0 && S10 == 0)
        return h10.nodeType == 3 ? Vy(h10, e3, r3) : dO(h10, e3, r3);
      if (!n3 || s3 > S10 || s3 == S10 && o3 > v10) {
        n3 = h10, i3 = g, o3 = v10, s3 = S10;
        let $10 = S10 ? r3 < g.top ? -1 : 1 : v10 ? e3 < g.left ? -1 : 1 : 0;
        a3 = !$10 || ($10 > 0 ? O10 < m10.length - 1 : O10 > 0);
      }
      v10 == 0 ? r3 > g.bottom && (!c3 || c3.bottom < g.bottom) ? (l3 = h10, c3 = g) : r3 < g.top && (!f3 || f3.top > g.top) && (u3 = h10, f3 = g) : c3 && ph(c3, g) ? c3 = Wy(c3, g.bottom) : f3 && ph(f3, g) && (f3 = Ny(f3, g.top));
    }
  }
  if (c3 && c3.bottom >= r3 ? (n3 = l3, i3 = c3) : f3 && f3.top <= r3 && (n3 = u3, i3 = f3), !n3)
    return { node: t10, offset: 0 };
  let d3 = Math.max(i3.left, Math.min(i3.right, e3));
  if (n3.nodeType == 3)
    return Vy(n3, d3, r3);
  if (a3 && n3.contentEditable != "false")
    return dO(n3, d3, r3);
  let p10 = Array.prototype.indexOf.call(t10.childNodes, n3) + (e3 >= (i3.left + i3.right) / 2 ? 1 : 0);
  return { node: t10, offset: p10 };
}
function Vy(t10, e3, r3) {
  let n3 = t10.nodeValue.length, i3 = -1, o3 = 1e9, s3 = 0;
  for (let a3 = 0; a3 < n3; a3++) {
    let l3 = ns(t10, a3, a3 + 1).getClientRects();
    for (let u3 = 0; u3 < l3.length; u3++) {
      let c3 = l3[u3];
      if (c3.top == c3.bottom)
        continue;
      s3 || (s3 = e3 - c3.left);
      let f3 = (c3.top > r3 ? c3.top - r3 : r3 - c3.bottom) - 1;
      if (c3.left - 1 <= e3 && c3.right + 1 >= e3 && f3 < o3) {
        let d3 = e3 >= (c3.left + c3.right) / 2, p10 = d3;
        if ((ke.chrome || ke.gecko) && ns(t10, a3).getBoundingClientRect().left == c3.right && (p10 = !d3), f3 <= 0)
          return { node: t10, offset: a3 + (p10 ? 1 : 0) };
        i3 = a3 + (p10 ? 1 : 0), o3 = f3;
      }
    }
  }
  return { node: t10, offset: i3 > -1 ? i3 : s3 > 0 ? t10.nodeValue.length : 0 };
}
function bP(t10, e3, r3, n3 = -1) {
  var i3, o3;
  let s3 = t10.contentDOM.getBoundingClientRect(), a3 = s3.top + t10.viewState.paddingTop, l3, { docHeight: u3 } = t10.viewState, { x: c3, y: f3 } = e3, d3 = f3 - a3;
  if (d3 < 0)
    return 0;
  if (d3 > u3)
    return t10.state.doc.length;
  for (let $10 = t10.viewState.heightOracle.textHeight / 2, _10 = false; l3 = t10.elementAtHeight(d3), l3.type != Qn.Text; )
    for (; d3 = n3 > 0 ? l3.bottom + $10 : l3.top - $10, !(d3 >= 0 && d3 <= u3); ) {
      if (_10)
        return r3 ? null : 0;
      _10 = true, n3 = -n3;
    }
  f3 = a3 + d3;
  let p10 = l3.from;
  if (p10 < t10.viewport.from)
    return t10.viewport.from == 0 ? 0 : r3 ? null : Yy(t10, s3, l3, c3, f3);
  if (p10 > t10.viewport.to)
    return t10.viewport.to == t10.state.doc.length ? t10.state.doc.length : r3 ? null : Yy(t10, s3, l3, c3, f3);
  let h10 = t10.dom.ownerDocument, m10 = t10.root.elementFromPoint ? t10.root : h10, O10 = m10.elementFromPoint(c3, f3);
  O10 && !t10.contentDOM.contains(O10) && (O10 = null), O10 || (c3 = Math.max(s3.left + 1, Math.min(s3.right - 1, c3)), O10 = m10.elementFromPoint(c3, f3), O10 && !t10.contentDOM.contains(O10) && (O10 = null));
  let g, v10 = -1;
  if (O10 && ((i3 = t10.docView.nearest(O10)) === null || i3 === void 0 ? void 0 : i3.isEditable) != false) {
    if (h10.caretPositionFromPoint) {
      let $10 = h10.caretPositionFromPoint(c3, f3);
      $10 && ({ offsetNode: g, offset: v10 } = $10);
    } else if (h10.caretRangeFromPoint) {
      let $10 = h10.caretRangeFromPoint(c3, f3);
      $10 && ({ startContainer: g, startOffset: v10 } = $10, (!t10.contentDOM.contains(g) || ke.safari && NR(g, v10, c3) || ke.chrome && WR(g, v10, c3)) && (g = void 0));
    }
  }
  if (!g || !t10.docView.dom.contains(g)) {
    let $10 = Gt.find(t10.docView, p10);
    if (!$10)
      return d3 > l3.top + l3.height / 2 ? l3.to : l3.from;
    ({ node: g, offset: v10 } = dO($10.dom, c3, f3));
  }
  let S10 = t10.docView.nearest(g);
  if (!S10)
    return null;
  if (S10.isWidget && ((o3 = S10.dom) === null || o3 === void 0 ? void 0 : o3.nodeType) == 1) {
    let $10 = S10.dom.getBoundingClientRect();
    return e3.y < $10.top || e3.y <= $10.bottom && e3.x <= ($10.left + $10.right) / 2 ? S10.posAtStart : S10.posAtEnd;
  } else
    return S10.localPosFromDOM(g, v10) + S10.posAtStart;
}
function Yy(t10, e3, r3, n3, i3) {
  let o3 = Math.round((n3 - e3.left) * t10.defaultCharacterWidth);
  if (t10.lineWrapping && r3.height > t10.defaultLineHeight * 1.5) {
    let a3 = t10.viewState.heightOracle.textHeight, l3 = Math.floor((i3 - r3.top - (t10.defaultLineHeight - a3) * 0.5) / a3);
    o3 += l3 * t10.viewState.heightOracle.lineLength;
  }
  let s3 = t10.state.sliceDoc(r3.from, r3.to);
  return r3.from + oR(s3, o3, t10.state.tabSize);
}
function NR(t10, e3, r3) {
  let n3;
  if (t10.nodeType != 3 || e3 != (n3 = t10.nodeValue.length))
    return false;
  for (let i3 = t10.nextSibling; i3; i3 = i3.nextSibling)
    if (i3.nodeType != 1 || i3.nodeName != "BR")
      return false;
  return ns(t10, n3 - 1, n3).getBoundingClientRect().left > r3;
}
function WR(t10, e3, r3) {
  if (e3 != 0)
    return false;
  for (let i3 = t10; ; ) {
    let o3 = i3.parentNode;
    if (!o3 || o3.nodeType != 1 || o3.firstChild != i3)
      return false;
    if (o3.classList.contains("cm-line"))
      break;
    i3 = o3;
  }
  let n3 = t10.nodeType == 1 ? t10.getBoundingClientRect() : ns(t10, 0, Math.max(t10.nodeValue.length, 1)).getBoundingClientRect();
  return r3 - n3.left > 5;
}
function VR(t10, e3) {
  let r3 = t10.lineBlockAt(e3);
  if (Array.isArray(r3.type)) {
    for (let n3 of r3.type)
      if (n3.to > e3 || n3.to == e3 && (n3.to == r3.to || n3.type == Qn.Text))
        return n3;
  }
  return r3;
}
function YR(t10, e3, r3, n3) {
  let i3 = VR(t10, e3.head), o3 = !n3 || i3.type != Qn.Text || !(t10.lineWrapping || i3.widgetLineBreaks) ? null : t10.coordsAtPos(e3.assoc < 0 && e3.head > i3.from ? e3.head - 1 : e3.head);
  if (o3) {
    let s3 = t10.dom.getBoundingClientRect(), a3 = t10.textDirectionAt(i3.from), l3 = t10.posAtCoords({
      x: r3 == (a3 == br.LTR) ? s3.right - 1 : s3.left + 1,
      y: (o3.top + o3.bottom) / 2
    });
    if (l3 != null)
      return Pe.cursor(l3, r3 ? -1 : 1);
  }
  return Pe.cursor(r3 ? i3.to : i3.from, r3 ? -1 : 1);
}
function Ly(t10, e3, r3, n3) {
  let i3 = t10.state.doc.lineAt(e3.head), o3 = t10.bidiSpans(i3), s3 = t10.textDirectionAt(i3.from);
  for (let a3 = e3, l3 = null; ; ) {
    let u3 = RR(i3, o3, s3, a3, r3), c3 = gP;
    if (!u3) {
      if (i3.number == (r3 ? t10.state.doc.lines : 1))
        return a3;
      c3 = `
`, i3 = t10.state.doc.line(i3.number + (r3 ? 1 : -1)), o3 = t10.bidiSpans(i3), u3 = Pe.cursor(r3 ? i3.from : i3.to);
    }
    if (l3) {
      if (!l3(c3))
        return a3;
    } else {
      if (!n3)
        return u3;
      l3 = n3(c3);
    }
    a3 = u3;
  }
}
function LR(t10, e3, r3) {
  let n3 = t10.state.charCategorizer(e3), i3 = n3(r3);
  return (o3) => {
    let s3 = n3(o3);
    return i3 == wi.Space && (i3 = s3), i3 == s3;
  };
}
function BR(t10, e3, r3, n3) {
  let i3 = e3.head, o3 = r3 ? 1 : -1;
  if (i3 == (r3 ? t10.state.doc.length : 0))
    return Pe.cursor(i3, e3.assoc);
  let s3 = e3.goalColumn, a3, l3 = t10.contentDOM.getBoundingClientRect(), u3 = t10.coordsAtPos(i3, e3.assoc || -1), c3 = t10.documentTop;
  if (u3)
    s3 == null && (s3 = u3.left - l3.left), a3 = o3 < 0 ? u3.top : u3.bottom;
  else {
    let p10 = t10.viewState.lineBlockAt(i3);
    s3 == null && (s3 = Math.min(l3.right - l3.left, t10.defaultCharacterWidth * (i3 - p10.from))), a3 = (o3 < 0 ? p10.top : p10.bottom) + c3;
  }
  let f3 = l3.left + s3, d3 = n3 ?? t10.viewState.heightOracle.textHeight >> 1;
  for (let p10 = 0; ; p10 += 10) {
    let h10 = a3 + (d3 + p10) * o3, m10 = bP(t10, { x: f3, y: h10 }, false, o3);
    if (h10 < l3.top || h10 > l3.bottom || (o3 < 0 ? m10 < i3 : m10 > i3)) {
      let O10 = t10.docView.coordsForChar(m10), g = !O10 || h10 < O10.top ? -1 : 1;
      return Pe.cursor(m10, g, void 0, s3);
    }
  }
}
function Sc(t10, e3, r3) {
  for (; ; ) {
    let n3 = 0;
    for (let i3 of t10)
      i3.between(e3 - 1, e3 + 1, (o3, s3, a3) => {
        if (e3 > o3 && e3 < s3) {
          let l3 = n3 || r3 || (e3 - o3 < s3 - e3 ? -1 : 1);
          e3 = l3 < 0 ? o3 : s3, n3 = l3;
        }
      });
    if (!n3)
      return e3;
  }
}
function Oh(t10, e3, r3) {
  let n3 = Sc(t10.state.facet(Cg).map((i3) => i3(t10)), r3.from, e3.head > r3.from ? -1 : 1);
  return n3 == r3.from ? r3 : Pe.cursor(n3, n3 < r3.from ? 1 : -1);
}
class zR {
  setSelectionOrigin(e3) {
    this.lastSelectionOrigin = e3, this.lastSelectionTime = Date.now();
  }
  constructor(e3) {
    this.view = e3, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = false, this.compositionPendingChange = false, this.mouseSelection = null, this.handleEvent = this.handleEvent.bind(this), e3.scrollDOM.addEventListener("mousedown", (r3) => {
      if (r3.target == e3.scrollDOM && r3.clientY > e3.contentDOM.getBoundingClientRect().bottom && (this.runHandlers("mousedown", r3), !r3.defaultPrevented && r3.button == 2)) {
        let n3 = e3.contentDOM.style.minHeight;
        e3.contentDOM.style.minHeight = "100%", setTimeout(() => e3.contentDOM.style.minHeight = n3, 200);
      }
    }), e3.scrollDOM.addEventListener("drop", (r3) => {
      r3.target == e3.scrollDOM && r3.clientY > e3.contentDOM.getBoundingClientRect().bottom && this.runHandlers("drop", r3);
    }), this.notifiedFocused = e3.hasFocus, ke.safari && e3.contentDOM.addEventListener("input", () => null), ke.gecko && fA(e3.contentDOM.ownerDocument);
  }
  handleEvent(e3) {
    !nA(this.view, e3) || this.ignoreDuringComposition(e3) || e3.type == "keydown" && this.keydown(e3) || this.runHandlers(e3.type, e3);
  }
  runHandlers(e3, r3) {
    let n3 = this.handlers[e3];
    if (n3) {
      for (let i3 of n3.observers)
        i3(this.view, r3);
      for (let i3 of n3.handlers) {
        if (r3.defaultPrevented)
          break;
        if (i3(this.view, r3)) {
          r3.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e3) {
    let r3 = HR(e3), n3 = this.handlers, i3 = this.view.contentDOM;
    for (let o3 in r3)
      if (o3 != "scroll") {
        let s3 = !r3[o3].handlers.length, a3 = n3[o3];
        a3 && s3 != !a3.handlers.length && (i3.removeEventListener(o3, this.handleEvent), a3 = null), a3 || i3.addEventListener(o3, this.handleEvent, { passive: s3 });
      }
    for (let o3 in n3)
      o3 != "scroll" && !r3[o3] && i3.removeEventListener(o3, this.handleEvent);
    this.handlers = r3;
  }
  keydown(e3) {
    if (this.lastKeyCode = e3.keyCode, this.lastKeyTime = Date.now(), e3.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return true;
    if (e3.keyCode != 27 && $P.indexOf(e3.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), ke.android && ke.chrome && !e3.synthetic && (e3.keyCode == 13 || e3.keyCode == 8))
      return this.view.observer.delayAndroidKey(e3.key, e3.keyCode), true;
    let r3;
    return ke.ios && !e3.synthetic && !e3.altKey && !e3.metaKey && ((r3 = SP.find((n3) => n3.keyCode == e3.keyCode)) && !e3.ctrlKey || GR.indexOf(e3.key) > -1 && e3.ctrlKey && !e3.shiftKey) ? (this.pendingIOSKey = r3 || e3, setTimeout(() => this.flushIOSKey(), 250), true) : (e3.keyCode != 229 && this.view.observer.forceFlush(), false);
  }
  flushIOSKey() {
    let e3 = this.pendingIOSKey;
    return e3 ? (this.pendingIOSKey = void 0, Gs(this.view.contentDOM, e3.key, e3.keyCode)) : false;
  }
  ignoreDuringComposition(e3) {
    return /^key/.test(e3.type) ? this.composing > 0 ? true : ke.safari && !ke.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = false, true) : false : false;
  }
  startMouseSelection(e3) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e3;
  }
  update(e3) {
    this.mouseSelection && this.mouseSelection.update(e3), e3.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function By(t10, e3) {
  return (r3, n3) => {
    try {
      return e3.call(t10, n3, r3);
    } catch (i3) {
      zo(r3.state, i3);
    }
  };
}
function HR(t10) {
  let e3 = /* @__PURE__ */ Object.create(null);
  function r3(n3) {
    return e3[n3] || (e3[n3] = { observers: [], handlers: [] });
  }
  for (let n3 of t10) {
    let i3 = n3.spec;
    if (i3 && i3.domEventHandlers)
      for (let o3 in i3.domEventHandlers) {
        let s3 = i3.domEventHandlers[o3];
        s3 && r3(o3).handlers.push(By(n3.value, s3));
      }
    if (i3 && i3.domEventObservers)
      for (let o3 in i3.domEventObservers) {
        let s3 = i3.domEventObservers[o3];
        s3 && r3(o3).observers.push(By(n3.value, s3));
      }
  }
  for (let n3 in ai)
    r3(n3).handlers.push(ai[n3]);
  for (let n3 in En)
    r3(n3).observers.push(En[n3]);
  return e3;
}
const SP = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], GR = "dthko", $P = [16, 17, 18, 20, 91, 92, 224, 225], Vu = 6;
function Yu(t10) {
  return Math.max(0, t10) * 0.7 + 8;
}
function KR(t10, e3) {
  return Math.max(Math.abs(t10.clientX - e3.clientX), Math.abs(t10.clientY - e3.clientY));
}
class JR {
  constructor(e3, r3, n3, i3) {
    this.view = e3, this.startEvent = r3, this.style = n3, this.mustSelect = i3, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = r3, this.scrollParent = hR(e3.contentDOM), this.atoms = e3.state.facet(Cg).map((s3) => s3(e3));
    let o3 = e3.contentDOM.ownerDocument;
    o3.addEventListener("mousemove", this.move = this.move.bind(this)), o3.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = r3.shiftKey, this.multiple = e3.state.facet(pt.allowMultipleSelections) && eA(e3, r3), this.dragging = rA(e3, r3) && xP(r3) == 1 ? null : false;
  }
  start(e3) {
    this.dragging === false && this.select(e3);
  }
  move(e3) {
    var r3;
    if (e3.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && KR(this.startEvent, e3) < 10)
      return;
    this.select(this.lastEvent = e3);
    let n3 = 0, i3 = 0, o3 = ((r3 = this.scrollParent) === null || r3 === void 0 ? void 0 : r3.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, s3 = dP(this.view);
    e3.clientX - s3.left <= o3.left + Vu ? n3 = -Yu(o3.left - e3.clientX) : e3.clientX + s3.right >= o3.right - Vu && (n3 = Yu(e3.clientX - o3.right)), e3.clientY - s3.top <= o3.top + Vu ? i3 = -Yu(o3.top - e3.clientY) : e3.clientY + s3.bottom >= o3.bottom - Vu && (i3 = Yu(e3.clientY - o3.bottom)), this.setScrollSpeed(n3, i3);
  }
  up(e3) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e3.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e3 = this.view.contentDOM.ownerDocument;
    e3.removeEventListener("mousemove", this.move), e3.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = null;
  }
  setScrollSpeed(e3, r3) {
    this.scrollSpeed = { x: e3, y: r3 }, e3 || r3 ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === false && this.select(this.lastEvent);
  }
  skipAtoms(e3) {
    let r3 = null;
    for (let n3 = 0; n3 < e3.ranges.length; n3++) {
      let i3 = e3.ranges[n3], o3 = null;
      if (i3.empty) {
        let s3 = Sc(this.atoms, i3.from, 0);
        s3 != i3.from && (o3 = Pe.cursor(s3, -1));
      } else {
        let s3 = Sc(this.atoms, i3.from, -1), a3 = Sc(this.atoms, i3.to, 1);
        (s3 != i3.from || a3 != i3.to) && (o3 = Pe.range(i3.from == i3.anchor ? s3 : a3, i3.from == i3.head ? s3 : a3));
      }
      o3 && (r3 || (r3 = e3.ranges.slice()), r3[n3] = o3);
    }
    return r3 ? Pe.create(r3, e3.mainIndex) : e3;
  }
  select(e3) {
    let { view: r3 } = this, n3 = this.skipAtoms(this.style.get(e3, this.extend, this.multiple));
    (this.mustSelect || !n3.eq(r3.state.selection) || n3.main.assoc != r3.state.selection.main.assoc && this.dragging === false) && this.view.dispatch({
      selection: n3,
      userEvent: "select.pointer"
    }), this.mustSelect = false;
  }
  update(e3) {
    e3.docChanged && this.dragging && (this.dragging = this.dragging.map(e3.changes)), this.style.update(e3) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function eA(t10, e3) {
  let r3 = t10.state.facet(rP);
  return r3.length ? r3[0](e3) : ke.mac ? e3.metaKey : e3.ctrlKey;
}
function tA(t10, e3) {
  let r3 = t10.state.facet(nP);
  return r3.length ? r3[0](e3) : ke.mac ? !e3.altKey : !e3.ctrlKey;
}
function rA(t10, e3) {
  let { main: r3 } = t10.state.selection;
  if (r3.empty)
    return false;
  let n3 = tf(t10.root);
  if (!n3 || n3.rangeCount == 0)
    return true;
  let i3 = n3.getRangeAt(0).getClientRects();
  for (let o3 = 0; o3 < i3.length; o3++) {
    let s3 = i3[o3];
    if (s3.left <= e3.clientX && s3.right >= e3.clientX && s3.top <= e3.clientY && s3.bottom >= e3.clientY)
      return true;
  }
  return false;
}
function nA(t10, e3) {
  if (!e3.bubbles)
    return true;
  if (e3.defaultPrevented)
    return false;
  for (let r3 = e3.target, n3; r3 != t10.contentDOM; r3 = r3.parentNode)
    if (!r3 || r3.nodeType == 11 || (n3 = Qt.get(r3)) && n3.ignoreEvent(e3))
      return false;
  return true;
}
const ai = /* @__PURE__ */ Object.create(null), En = /* @__PURE__ */ Object.create(null), wP = ke.ie && ke.ie_version < 15 || ke.ios && ke.webkit_version < 604;
function iA(t10) {
  let e3 = t10.dom.parentNode;
  if (!e3)
    return;
  let r3 = e3.appendChild(document.createElement("textarea"));
  r3.style.cssText = "position: fixed; left: -10000px; top: 10px", r3.focus(), setTimeout(() => {
    t10.focus(), r3.remove(), PP(t10, r3.value);
  }, 50);
}
function PP(t10, e3) {
  let { state: r3 } = t10, n3, i3 = 1, o3 = r3.toText(e3), s3 = o3.lines == r3.selection.ranges.length;
  if (hO != null && r3.selection.ranges.every((l3) => l3.empty) && hO == o3.toString()) {
    let l3 = -1;
    n3 = r3.changeByRange((u3) => {
      let c3 = r3.doc.lineAt(u3.from);
      if (c3.from == l3)
        return { range: u3 };
      l3 = c3.from;
      let f3 = r3.toText((s3 ? o3.line(i3++).text : e3) + r3.lineBreak);
      return {
        changes: { from: c3.from, insert: f3 },
        range: Pe.cursor(u3.from + f3.length)
      };
    });
  } else
    s3 ? n3 = r3.changeByRange((l3) => {
      let u3 = o3.line(i3++);
      return {
        changes: { from: l3.from, to: l3.to, insert: u3.text },
        range: Pe.cursor(l3.from + u3.length)
      };
    }) : n3 = r3.replaceSelection(o3);
  t10.dispatch(n3, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
En.scroll = (t10) => {
  t10.inputState.lastScrollTop = t10.scrollDOM.scrollTop, t10.inputState.lastScrollLeft = t10.scrollDOM.scrollLeft;
};
ai.keydown = (t10, e3) => (t10.inputState.setSelectionOrigin("select"), e3.keyCode == 27 && (t10.inputState.lastEscPress = Date.now()), false);
En.touchstart = (t10, e3) => {
  t10.inputState.lastTouchTime = Date.now(), t10.inputState.setSelectionOrigin("select.pointer");
};
En.touchmove = (t10) => {
  t10.inputState.setSelectionOrigin("select.pointer");
};
ai.mousedown = (t10, e3) => {
  if (t10.observer.flush(), t10.inputState.lastTouchTime > Date.now() - 2e3)
    return false;
  let r3 = null;
  for (let n3 of t10.state.facet(iP))
    if (r3 = n3(t10, e3), r3)
      break;
  if (!r3 && e3.button == 0 && (r3 = aA(t10, e3)), r3) {
    let n3 = !t10.hasFocus;
    t10.inputState.startMouseSelection(new JR(t10, e3, r3, n3)), n3 && t10.observer.ignore(() => W2(t10.contentDOM));
    let i3 = t10.inputState.mouseSelection;
    if (i3)
      return i3.start(e3), !i3.dragging;
  }
  return false;
};
function zy(t10, e3, r3, n3) {
  if (n3 == 1)
    return Pe.cursor(e3, r3);
  if (n3 == 2)
    return FR(t10.state, e3, r3);
  {
    let i3 = Gt.find(t10.docView, e3), o3 = t10.state.doc.lineAt(i3 ? i3.posAtEnd : e3), s3 = i3 ? i3.posAtStart : o3.from, a3 = i3 ? i3.posAtEnd : o3.to;
    return a3 < t10.state.doc.length && a3 == o3.to && a3++, Pe.range(s3, a3);
  }
}
let _P = (t10, e3) => t10 >= e3.top && t10 <= e3.bottom, Hy = (t10, e3, r3) => _P(e3, r3) && t10 >= r3.left && t10 <= r3.right;
function oA(t10, e3, r3, n3) {
  let i3 = Gt.find(t10.docView, e3);
  if (!i3)
    return 1;
  let o3 = e3 - i3.posAtStart;
  if (o3 == 0)
    return 1;
  if (o3 == i3.length)
    return -1;
  let s3 = i3.coordsAt(o3, -1);
  if (s3 && Hy(r3, n3, s3))
    return -1;
  let a3 = i3.coordsAt(o3, 1);
  return a3 && Hy(r3, n3, a3) ? 1 : s3 && _P(n3, s3) ? -1 : 1;
}
function Gy(t10, e3) {
  let r3 = t10.posAtCoords({ x: e3.clientX, y: e3.clientY }, false);
  return { pos: r3, bias: oA(t10, r3, e3.clientX, e3.clientY) };
}
const sA = ke.ie && ke.ie_version <= 11;
let Ky = null, Jy = 0, ev = 0;
function xP(t10) {
  if (!sA)
    return t10.detail;
  let e3 = Ky, r3 = ev;
  return Ky = t10, ev = Date.now(), Jy = !e3 || r3 > Date.now() - 400 && Math.abs(e3.clientX - t10.clientX) < 2 && Math.abs(e3.clientY - t10.clientY) < 2 ? (Jy + 1) % 3 : 1;
}
function aA(t10, e3) {
  let r3 = Gy(t10, e3), n3 = xP(e3), i3 = t10.state.selection;
  return {
    update(o3) {
      o3.docChanged && (r3.pos = o3.changes.mapPos(r3.pos), i3 = i3.map(o3.changes));
    },
    get(o3, s3, a3) {
      let l3 = Gy(t10, o3), u3, c3 = zy(t10, l3.pos, l3.bias, n3);
      if (r3.pos != l3.pos && !s3) {
        let f3 = zy(t10, r3.pos, r3.bias, n3), d3 = Math.min(f3.from, c3.from), p10 = Math.max(f3.to, c3.to);
        c3 = d3 < c3.from ? Pe.range(d3, p10) : Pe.range(p10, d3);
      }
      return s3 ? i3.replaceRange(i3.main.extend(c3.from, c3.to)) : a3 && n3 == 1 && i3.ranges.length > 1 && (u3 = lA(i3, l3.pos)) ? u3 : a3 ? i3.addRange(c3) : Pe.create([c3]);
    }
  };
}
function lA(t10, e3) {
  for (let r3 = 0; r3 < t10.ranges.length; r3++) {
    let { from: n3, to: i3 } = t10.ranges[r3];
    if (n3 <= e3 && i3 >= e3)
      return Pe.create(t10.ranges.slice(0, r3).concat(t10.ranges.slice(r3 + 1)), t10.mainIndex == r3 ? 0 : t10.mainIndex - (t10.mainIndex > r3 ? 1 : 0));
  }
  return null;
}
ai.dragstart = (t10, e3) => {
  let { selection: { main: r3 } } = t10.state, { mouseSelection: n3 } = t10.inputState;
  return n3 && (n3.dragging = r3), e3.dataTransfer && (e3.dataTransfer.setData("Text", t10.state.sliceDoc(r3.from, r3.to)), e3.dataTransfer.effectAllowed = "copyMove"), false;
};
function tv(t10, e3, r3, n3) {
  if (!r3)
    return;
  let i3 = t10.posAtCoords({ x: e3.clientX, y: e3.clientY }, false), { mouseSelection: o3 } = t10.inputState, s3 = n3 && o3 && o3.dragging && tA(t10, e3) ? { from: o3.dragging.from, to: o3.dragging.to } : null, a3 = { from: i3, insert: r3 }, l3 = t10.state.changes(s3 ? [s3, a3] : a3);
  t10.focus(), t10.dispatch({
    changes: l3,
    selection: { anchor: l3.mapPos(i3, -1), head: l3.mapPos(i3, 1) },
    userEvent: s3 ? "move.drop" : "input.drop"
  });
}
ai.drop = (t10, e3) => {
  if (!e3.dataTransfer)
    return false;
  if (t10.state.readOnly)
    return true;
  let r3 = e3.dataTransfer.files;
  if (r3 && r3.length) {
    let n3 = Array(r3.length), i3 = 0, o3 = () => {
      ++i3 == r3.length && tv(t10, e3, n3.filter((s3) => s3 != null).join(t10.state.lineBreak), false);
    };
    for (let s3 = 0; s3 < r3.length; s3++) {
      let a3 = new FileReader();
      a3.onerror = o3, a3.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a3.result) || (n3[s3] = a3.result), o3();
      }, a3.readAsText(r3[s3]);
    }
    return true;
  } else {
    let n3 = e3.dataTransfer.getData("Text");
    if (n3)
      return tv(t10, e3, n3, true), true;
  }
  return false;
};
ai.paste = (t10, e3) => {
  if (t10.state.readOnly)
    return true;
  t10.observer.flush();
  let r3 = wP ? null : e3.clipboardData;
  return r3 ? (PP(t10, r3.getData("text/plain") || r3.getData("text/uri-text")), true) : (iA(t10), false);
};
function uA(t10, e3) {
  let r3 = t10.dom.parentNode;
  if (!r3)
    return;
  let n3 = r3.appendChild(document.createElement("textarea"));
  n3.style.cssText = "position: fixed; left: -10000px; top: 10px", n3.value = e3, n3.focus(), n3.selectionEnd = e3.length, n3.selectionStart = 0, setTimeout(() => {
    n3.remove(), t10.focus();
  }, 50);
}
function cA(t10) {
  let e3 = [], r3 = [], n3 = false;
  for (let i3 of t10.selection.ranges)
    i3.empty || (e3.push(t10.sliceDoc(i3.from, i3.to)), r3.push(i3));
  if (!e3.length) {
    let i3 = -1;
    for (let { from: o3 } of t10.selection.ranges) {
      let s3 = t10.doc.lineAt(o3);
      s3.number > i3 && (e3.push(s3.text), r3.push({ from: s3.from, to: Math.min(t10.doc.length, s3.to + 1) })), i3 = s3.number;
    }
    n3 = true;
  }
  return { text: e3.join(t10.lineBreak), ranges: r3, linewise: n3 };
}
let hO = null;
ai.copy = ai.cut = (t10, e3) => {
  let { text: r3, ranges: n3, linewise: i3 } = cA(t10.state);
  if (!r3 && !i3)
    return false;
  hO = i3 ? r3 : null, e3.type == "cut" && !t10.state.readOnly && t10.dispatch({
    changes: n3,
    scrollIntoView: true,
    userEvent: "delete.cut"
  });
  let o3 = wP ? null : e3.clipboardData;
  return o3 ? (o3.clearData(), o3.setData("text/plain", r3), true) : (uA(t10, r3), false);
};
const QP = /* @__PURE__ */ ms.define();
function TP(t10, e3) {
  let r3 = [];
  for (let n3 of t10.facet(aP)) {
    let i3 = n3(t10, e3);
    i3 && r3.push(i3);
  }
  return r3 ? t10.update({ effects: r3, annotations: QP.of(true) }) : null;
}
function kP(t10) {
  setTimeout(() => {
    let e3 = t10.hasFocus;
    if (e3 != t10.inputState.notifiedFocused) {
      let r3 = TP(t10.state, e3);
      r3 ? t10.dispatch(r3) : t10.update([]);
    }
  }, 10);
}
En.focus = (t10) => {
  t10.inputState.lastFocusTime = Date.now(), !t10.scrollDOM.scrollTop && (t10.inputState.lastScrollTop || t10.inputState.lastScrollLeft) && (t10.scrollDOM.scrollTop = t10.inputState.lastScrollTop, t10.scrollDOM.scrollLeft = t10.inputState.lastScrollLeft), kP(t10);
};
En.blur = (t10) => {
  t10.observer.clearSelectionRange(), kP(t10);
};
En.compositionstart = En.compositionupdate = (t10) => {
  t10.inputState.compositionFirstChange == null && (t10.inputState.compositionFirstChange = true), t10.inputState.composing < 0 && (t10.inputState.composing = 0);
};
En.compositionend = (t10) => {
  t10.inputState.composing = -1, t10.inputState.compositionEndedAt = Date.now(), t10.inputState.compositionPendingKey = true, t10.inputState.compositionPendingChange = t10.observer.pendingRecords().length > 0, t10.inputState.compositionFirstChange = null, ke.chrome && ke.android ? t10.observer.flushSoon() : t10.inputState.compositionPendingChange ? Promise.resolve().then(() => t10.observer.flush()) : setTimeout(() => {
    t10.inputState.composing < 0 && t10.docView.hasComposition && t10.update([]);
  }, 50);
};
En.contextmenu = (t10) => {
  t10.inputState.lastContextMenu = Date.now();
};
ai.beforeinput = (t10, e3) => {
  var r3;
  let n3;
  if (ke.chrome && ke.android && (n3 = SP.find((i3) => i3.inputType == e3.inputType)) && (t10.observer.delayAndroidKey(n3.key, n3.keyCode), n3.key == "Backspace" || n3.key == "Delete")) {
    let i3 = ((r3 = window.visualViewport) === null || r3 === void 0 ? void 0 : r3.height) || 0;
    setTimeout(() => {
      var o3;
      (((o3 = window.visualViewport) === null || o3 === void 0 ? void 0 : o3.height) || 0) > i3 + 10 && t10.hasFocus && (t10.contentDOM.blur(), t10.focus());
    }, 100);
  }
  return false;
};
const rv = /* @__PURE__ */ new Set();
function fA(t10) {
  rv.has(t10) || (rv.add(t10), t10.addEventListener("copy", () => {
  }), t10.addEventListener("cut", () => {
  }));
}
const nv = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class dA {
  constructor(e3) {
    this.lineWrapping = e3, this.doc = ct.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = false;
  }
  heightForGap(e3, r3) {
    let n3 = this.doc.lineAt(r3).number - this.doc.lineAt(e3).number + 1;
    return this.lineWrapping && (n3 += Math.max(0, Math.ceil((r3 - e3 - n3 * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * n3;
  }
  heightForLine(e3) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e3 - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e3) {
    return this.doc = e3, this;
  }
  mustRefreshForWrapping(e3) {
    return nv.indexOf(e3) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e3) {
    let r3 = false;
    for (let n3 = 0; n3 < e3.length; n3++) {
      let i3 = e3[n3];
      i3 < 0 ? n3++ : this.heightSamples[Math.floor(i3 * 10)] || (r3 = true, this.heightSamples[Math.floor(i3 * 10)] = true);
    }
    return r3;
  }
  refresh(e3, r3, n3, i3, o3, s3) {
    let a3 = nv.indexOf(e3) > -1, l3 = Math.round(r3) != Math.round(this.lineHeight) || this.lineWrapping != a3;
    if (this.lineWrapping = a3, this.lineHeight = r3, this.charWidth = n3, this.textHeight = i3, this.lineLength = o3, l3) {
      this.heightSamples = {};
      for (let u3 = 0; u3 < s3.length; u3++) {
        let c3 = s3[u3];
        c3 < 0 ? u3++ : this.heightSamples[Math.floor(c3 * 10)] = true;
      }
    }
    return l3;
  }
}
class hA {
  constructor(e3, r3) {
    this.from = e3, this.heights = r3, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class zn {
  /**
  @internal
  */
  constructor(e3, r3, n3, i3, o3) {
    this.from = e3, this.length = r3, this.top = n3, this.height = i3, this._content = o3;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Qn.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof ho ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e3) {
    let r3 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e3._content) ? e3._content : [e3]);
    return new zn(this.from, this.length + e3.length, this.top, this.height + e3.height, r3);
  }
}
var Pt = /* @__PURE__ */ function(t10) {
  return t10[t10.ByPos = 0] = "ByPos", t10[t10.ByHeight = 1] = "ByHeight", t10[t10.ByPosNoHeight = 2] = "ByPosNoHeight", t10;
}(Pt || (Pt = {}));
const $c = 1e-3;
class Ar {
  constructor(e3, r3, n3 = 2) {
    this.length = e3, this.height = r3, this.flags = n3;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e3) {
    this.flags = (e3 ? 2 : 0) | this.flags & -3;
  }
  setHeight(e3, r3) {
    this.height != r3 && (Math.abs(this.height - r3) > $c && (e3.heightChanged = true), this.height = r3);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e3, r3, n3) {
    return Ar.of(n3);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e3, r3) {
    r3.push(this);
  }
  decomposeRight(e3, r3) {
    r3.push(this);
  }
  applyChanges(e3, r3, n3, i3) {
    let o3 = this, s3 = n3.doc;
    for (let a3 = i3.length - 1; a3 >= 0; a3--) {
      let { fromA: l3, toA: u3, fromB: c3, toB: f3 } = i3[a3], d3 = o3.lineAt(l3, Pt.ByPosNoHeight, n3.setDoc(r3), 0, 0), p10 = d3.to >= u3 ? d3 : o3.lineAt(u3, Pt.ByPosNoHeight, n3, 0, 0);
      for (f3 += p10.to - u3, u3 = p10.to; a3 > 0 && d3.from <= i3[a3 - 1].toA; )
        l3 = i3[a3 - 1].fromA, c3 = i3[a3 - 1].fromB, a3--, l3 < d3.from && (d3 = o3.lineAt(l3, Pt.ByPosNoHeight, n3, 0, 0));
      c3 += d3.from - l3, l3 = d3.from;
      let h10 = Rg.build(n3.setDoc(s3), e3, c3, f3);
      o3 = o3.replace(l3, u3, h10);
    }
    return o3.updateHeight(n3, 0);
  }
  static empty() {
    return new zr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e3) {
    if (e3.length == 1)
      return e3[0];
    let r3 = 0, n3 = e3.length, i3 = 0, o3 = 0;
    for (; ; )
      if (r3 == n3)
        if (i3 > o3 * 2) {
          let a3 = e3[r3 - 1];
          a3.break ? e3.splice(--r3, 1, a3.left, null, a3.right) : e3.splice(--r3, 1, a3.left, a3.right), n3 += 1 + a3.break, i3 -= a3.size;
        } else if (o3 > i3 * 2) {
          let a3 = e3[n3];
          a3.break ? e3.splice(n3, 1, a3.left, null, a3.right) : e3.splice(n3, 1, a3.left, a3.right), n3 += 2 + a3.break, o3 -= a3.size;
        } else
          break;
      else if (i3 < o3) {
        let a3 = e3[r3++];
        a3 && (i3 += a3.size);
      } else {
        let a3 = e3[--n3];
        a3 && (o3 += a3.size);
      }
    let s3 = 0;
    return e3[r3 - 1] == null ? (s3 = 1, r3--) : e3[r3] == null && (s3 = 1, n3++), new pA(Ar.of(e3.slice(0, r3)), s3, Ar.of(e3.slice(n3)));
  }
}
Ar.prototype.size = 1;
class EP extends Ar {
  constructor(e3, r3, n3) {
    super(e3, r3), this.deco = n3;
  }
  blockAt(e3, r3, n3, i3) {
    return new zn(i3, this.length, n3, this.height, this.deco || 0);
  }
  lineAt(e3, r3, n3, i3, o3) {
    return this.blockAt(0, n3, i3, o3);
  }
  forEachLine(e3, r3, n3, i3, o3, s3) {
    e3 <= o3 + this.length && r3 >= o3 && s3(this.blockAt(0, n3, i3, o3));
  }
  updateHeight(e3, r3 = 0, n3 = false, i3) {
    return i3 && i3.from <= r3 && i3.more && this.setHeight(e3, i3.heights[i3.index++]), this.outdated = false, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class zr extends EP {
  constructor(e3, r3) {
    super(e3, r3, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e3, r3, n3, i3) {
    return new zn(i3, this.length, n3, this.height, this.breaks);
  }
  replace(e3, r3, n3) {
    let i3 = n3[0];
    return n3.length == 1 && (i3 instanceof zr || i3 instanceof ar && i3.flags & 4) && Math.abs(this.length - i3.length) < 10 ? (i3 instanceof ar ? i3 = new zr(i3.length, this.height) : i3.height = this.height, this.outdated || (i3.outdated = false), i3) : Ar.of(n3);
  }
  updateHeight(e3, r3 = 0, n3 = false, i3) {
    return i3 && i3.from <= r3 && i3.more ? this.setHeight(e3, i3.heights[i3.index++]) : (n3 || this.outdated) && this.setHeight(e3, Math.max(this.widgetHeight, e3.heightForLine(this.length - this.collapsed)) + this.breaks * e3.lineHeight), this.outdated = false, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class ar extends Ar {
  constructor(e3) {
    super(e3, 0);
  }
  heightMetrics(e3, r3) {
    let n3 = e3.doc.lineAt(r3).number, i3 = e3.doc.lineAt(r3 + this.length).number, o3 = i3 - n3 + 1, s3, a3 = 0;
    if (e3.lineWrapping) {
      let l3 = Math.min(this.height, e3.lineHeight * o3);
      s3 = l3 / o3, this.length > o3 + 1 && (a3 = (this.height - l3) / (this.length - o3 - 1));
    } else
      s3 = this.height / o3;
    return { firstLine: n3, lastLine: i3, perLine: s3, perChar: a3 };
  }
  blockAt(e3, r3, n3, i3) {
    let { firstLine: o3, lastLine: s3, perLine: a3, perChar: l3 } = this.heightMetrics(r3, i3);
    if (r3.lineWrapping) {
      let u3 = i3 + Math.round(Math.max(0, Math.min(1, (e3 - n3) / this.height)) * this.length), c3 = r3.doc.lineAt(u3), f3 = a3 + c3.length * l3, d3 = Math.max(n3, e3 - f3 / 2);
      return new zn(c3.from, c3.length, d3, f3, 0);
    } else {
      let u3 = Math.max(0, Math.min(s3 - o3, Math.floor((e3 - n3) / a3))), { from: c3, length: f3 } = r3.doc.line(o3 + u3);
      return new zn(c3, f3, n3 + a3 * u3, a3, 0);
    }
  }
  lineAt(e3, r3, n3, i3, o3) {
    if (r3 == Pt.ByHeight)
      return this.blockAt(e3, n3, i3, o3);
    if (r3 == Pt.ByPosNoHeight) {
      let { from: p10, to: h10 } = n3.doc.lineAt(e3);
      return new zn(p10, h10 - p10, 0, 0, 0);
    }
    let { firstLine: s3, perLine: a3, perChar: l3 } = this.heightMetrics(n3, o3), u3 = n3.doc.lineAt(e3), c3 = a3 + u3.length * l3, f3 = u3.number - s3, d3 = i3 + a3 * f3 + l3 * (u3.from - o3 - f3);
    return new zn(u3.from, u3.length, Math.max(i3, Math.min(d3, i3 + this.height - c3)), c3, 0);
  }
  forEachLine(e3, r3, n3, i3, o3, s3) {
    e3 = Math.max(e3, o3), r3 = Math.min(r3, o3 + this.length);
    let { firstLine: a3, perLine: l3, perChar: u3 } = this.heightMetrics(n3, o3);
    for (let c3 = e3, f3 = i3; c3 <= r3; ) {
      let d3 = n3.doc.lineAt(c3);
      if (c3 == e3) {
        let h10 = d3.number - a3;
        f3 += l3 * h10 + u3 * (e3 - o3 - h10);
      }
      let p10 = l3 + u3 * d3.length;
      s3(new zn(d3.from, d3.length, f3, p10, 0)), f3 += p10, c3 = d3.to + 1;
    }
  }
  replace(e3, r3, n3) {
    let i3 = this.length - r3;
    if (i3 > 0) {
      let o3 = n3[n3.length - 1];
      o3 instanceof ar ? n3[n3.length - 1] = new ar(o3.length + i3) : n3.push(null, new ar(i3 - 1));
    }
    if (e3 > 0) {
      let o3 = n3[0];
      o3 instanceof ar ? n3[0] = new ar(e3 + o3.length) : n3.unshift(new ar(e3 - 1), null);
    }
    return Ar.of(n3);
  }
  decomposeLeft(e3, r3) {
    r3.push(new ar(e3 - 1), null);
  }
  decomposeRight(e3, r3) {
    r3.push(null, new ar(this.length - e3 - 1));
  }
  updateHeight(e3, r3 = 0, n3 = false, i3) {
    let o3 = r3 + this.length;
    if (i3 && i3.from <= r3 + this.length && i3.more) {
      let s3 = [], a3 = Math.max(r3, i3.from), l3 = -1;
      for (i3.from > r3 && s3.push(new ar(i3.from - r3 - 1).updateHeight(e3, r3)); a3 <= o3 && i3.more; ) {
        let c3 = e3.doc.lineAt(a3).length;
        s3.length && s3.push(null);
        let f3 = i3.heights[i3.index++];
        l3 == -1 ? l3 = f3 : Math.abs(f3 - l3) >= $c && (l3 = -2);
        let d3 = new zr(c3, f3);
        d3.outdated = false, s3.push(d3), a3 += c3 + 1;
      }
      a3 <= o3 && s3.push(null, new ar(o3 - a3).updateHeight(e3, a3));
      let u3 = Ar.of(s3);
      return (l3 < 0 || Math.abs(u3.height - this.height) >= $c || Math.abs(l3 - this.heightMetrics(e3, r3).perLine) >= $c) && (e3.heightChanged = true), u3;
    } else
      (n3 || this.outdated) && (this.setHeight(e3, e3.heightForGap(r3, r3 + this.length)), this.outdated = false);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class pA extends Ar {
  constructor(e3, r3, n3) {
    super(e3.length + r3 + n3.length, e3.height + n3.height, r3 | (e3.outdated || n3.outdated ? 2 : 0)), this.left = e3, this.right = n3, this.size = e3.size + n3.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e3, r3, n3, i3) {
    let o3 = n3 + this.left.height;
    return e3 < o3 ? this.left.blockAt(e3, r3, n3, i3) : this.right.blockAt(e3, r3, o3, i3 + this.left.length + this.break);
  }
  lineAt(e3, r3, n3, i3, o3) {
    let s3 = i3 + this.left.height, a3 = o3 + this.left.length + this.break, l3 = r3 == Pt.ByHeight ? e3 < s3 : e3 < a3, u3 = l3 ? this.left.lineAt(e3, r3, n3, i3, o3) : this.right.lineAt(e3, r3, n3, s3, a3);
    if (this.break || (l3 ? u3.to < a3 : u3.from > a3))
      return u3;
    let c3 = r3 == Pt.ByPosNoHeight ? Pt.ByPosNoHeight : Pt.ByPos;
    return l3 ? u3.join(this.right.lineAt(a3, c3, n3, s3, a3)) : this.left.lineAt(a3, c3, n3, i3, o3).join(u3);
  }
  forEachLine(e3, r3, n3, i3, o3, s3) {
    let a3 = i3 + this.left.height, l3 = o3 + this.left.length + this.break;
    if (this.break)
      e3 < l3 && this.left.forEachLine(e3, r3, n3, i3, o3, s3), r3 >= l3 && this.right.forEachLine(e3, r3, n3, a3, l3, s3);
    else {
      let u3 = this.lineAt(l3, Pt.ByPos, n3, i3, o3);
      e3 < u3.from && this.left.forEachLine(e3, u3.from - 1, n3, i3, o3, s3), u3.to >= e3 && u3.from <= r3 && s3(u3), r3 > u3.to && this.right.forEachLine(u3.to + 1, r3, n3, a3, l3, s3);
    }
  }
  replace(e3, r3, n3) {
    let i3 = this.left.length + this.break;
    if (r3 < i3)
      return this.balanced(this.left.replace(e3, r3, n3), this.right);
    if (e3 > this.left.length)
      return this.balanced(this.left, this.right.replace(e3 - i3, r3 - i3, n3));
    let o3 = [];
    e3 > 0 && this.decomposeLeft(e3, o3);
    let s3 = o3.length;
    for (let a3 of n3)
      o3.push(a3);
    if (e3 > 0 && iv(o3, s3 - 1), r3 < this.length) {
      let a3 = o3.length;
      this.decomposeRight(r3, o3), iv(o3, a3);
    }
    return Ar.of(o3);
  }
  decomposeLeft(e3, r3) {
    let n3 = this.left.length;
    if (e3 <= n3)
      return this.left.decomposeLeft(e3, r3);
    r3.push(this.left), this.break && (n3++, e3 >= n3 && r3.push(null)), e3 > n3 && this.right.decomposeLeft(e3 - n3, r3);
  }
  decomposeRight(e3, r3) {
    let n3 = this.left.length, i3 = n3 + this.break;
    if (e3 >= i3)
      return this.right.decomposeRight(e3 - i3, r3);
    e3 < n3 && this.left.decomposeRight(e3, r3), this.break && e3 < i3 && r3.push(null), r3.push(this.right);
  }
  balanced(e3, r3) {
    return e3.size > 2 * r3.size || r3.size > 2 * e3.size ? Ar.of(this.break ? [e3, null, r3] : [e3, r3]) : (this.left = e3, this.right = r3, this.height = e3.height + r3.height, this.outdated = e3.outdated || r3.outdated, this.size = e3.size + r3.size, this.length = e3.length + this.break + r3.length, this);
  }
  updateHeight(e3, r3 = 0, n3 = false, i3) {
    let { left: o3, right: s3 } = this, a3 = r3 + o3.length + this.break, l3 = null;
    return i3 && i3.from <= r3 + o3.length && i3.more ? l3 = o3 = o3.updateHeight(e3, r3, n3, i3) : o3.updateHeight(e3, r3, n3), i3 && i3.from <= a3 + s3.length && i3.more ? l3 = s3 = s3.updateHeight(e3, a3, n3, i3) : s3.updateHeight(e3, a3, n3), l3 ? this.balanced(o3, s3) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function iv(t10, e3) {
  let r3, n3;
  t10[e3] == null && (r3 = t10[e3 - 1]) instanceof ar && (n3 = t10[e3 + 1]) instanceof ar && t10.splice(e3 - 1, 3, new ar(r3.length + 1 + n3.length));
}
const OA = 5;
class Rg {
  constructor(e3, r3) {
    this.pos = e3, this.oracle = r3, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e3;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e3, r3) {
    if (this.lineStart > -1) {
      let n3 = Math.min(r3, this.lineEnd), i3 = this.nodes[this.nodes.length - 1];
      i3 instanceof zr ? i3.length += n3 - this.pos : (n3 > this.pos || !this.isCovered) && this.nodes.push(new zr(n3 - this.pos, -1)), this.writtenTo = n3, r3 > n3 && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = r3;
  }
  point(e3, r3, n3) {
    if (e3 < r3 || n3.heightRelevant) {
      let i3 = n3.widget ? n3.widget.estimatedHeight : 0, o3 = n3.widget ? n3.widget.lineBreaks : 0;
      i3 < 0 && (i3 = this.oracle.lineHeight);
      let s3 = r3 - e3;
      n3.block ? this.addBlock(new EP(s3, i3, n3)) : (s3 || o3 || i3 >= OA) && this.addLineDeco(i3, o3, s3);
    } else
      r3 > e3 && this.span(e3, r3);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e3, to: r3 } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e3, this.lineEnd = r3, this.writtenTo < e3 && ((this.writtenTo < e3 - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e3 - 1)), this.nodes.push(null)), this.pos > e3 && this.nodes.push(new zr(this.pos - e3, -1)), this.writtenTo = this.pos;
  }
  blankContent(e3, r3) {
    let n3 = new ar(r3 - e3);
    return this.oracle.doc.lineAt(e3).to == r3 && (n3.flags |= 4), n3;
  }
  ensureLine() {
    this.enterLine();
    let e3 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e3 instanceof zr)
      return e3;
    let r3 = new zr(0, -1);
    return this.nodes.push(r3), r3;
  }
  addBlock(e3) {
    this.enterLine();
    let r3 = e3.deco;
    r3 && r3.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e3), this.writtenTo = this.pos = this.pos + e3.length, r3 && r3.endSide > 0 && (this.covering = e3);
  }
  addLineDeco(e3, r3, n3) {
    let i3 = this.ensureLine();
    i3.length += n3, i3.collapsed += n3, i3.widgetHeight = Math.max(i3.widgetHeight, e3), i3.breaks += r3, this.writtenTo = this.pos = this.pos + n3;
  }
  finish(e3) {
    let r3 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(r3 instanceof zr) && !this.isCovered ? this.nodes.push(new zr(0, -1)) : (this.writtenTo < this.pos || r3 == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let n3 = e3;
    for (let i3 of this.nodes)
      i3 instanceof zr && i3.updateHeight(this.oracle, n3), n3 += i3 ? i3.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e3, r3, n3, i3) {
    let o3 = new Rg(n3, e3);
    return xt.spans(r3, n3, i3, o3, 0), o3.finish(n3);
  }
}
function mA(t10, e3, r3) {
  let n3 = new gA();
  return xt.compare(t10, e3, r3, n3, 0), n3.changes;
}
class gA {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e3, r3, n3, i3) {
    (e3 < r3 || n3 && n3.heightRelevant || i3 && i3.heightRelevant) && aO(e3, r3, this.changes, 5);
  }
}
function yA(t10, e3) {
  let r3 = t10.getBoundingClientRect(), n3 = t10.ownerDocument, i3 = n3.defaultView || window, o3 = Math.max(0, r3.left), s3 = Math.min(i3.innerWidth, r3.right), a3 = Math.max(0, r3.top), l3 = Math.min(i3.innerHeight, r3.bottom);
  for (let u3 = t10.parentNode; u3 && u3 != n3.body; )
    if (u3.nodeType == 1) {
      let c3 = u3, f3 = window.getComputedStyle(c3);
      if ((c3.scrollHeight > c3.clientHeight || c3.scrollWidth > c3.clientWidth) && f3.overflow != "visible") {
        let d3 = c3.getBoundingClientRect();
        o3 = Math.max(o3, d3.left), s3 = Math.min(s3, d3.right), a3 = Math.max(a3, d3.top), l3 = u3 == t10.parentNode ? d3.bottom : Math.min(l3, d3.bottom);
      }
      u3 = f3.position == "absolute" || f3.position == "fixed" ? c3.offsetParent : c3.parentNode;
    } else if (u3.nodeType == 11)
      u3 = u3.host;
    else
      break;
  return {
    left: o3 - r3.left,
    right: Math.max(o3, s3) - r3.left,
    top: a3 - (r3.top + e3),
    bottom: Math.max(a3, l3) - (r3.top + e3)
  };
}
function vA(t10, e3) {
  let r3 = t10.getBoundingClientRect();
  return {
    left: 0,
    right: r3.right - r3.left,
    top: e3,
    bottom: r3.bottom - (r3.top + e3)
  };
}
class mh {
  constructor(e3, r3, n3) {
    this.from = e3, this.to = r3, this.size = n3;
  }
  static same(e3, r3) {
    if (e3.length != r3.length)
      return false;
    for (let n3 = 0; n3 < e3.length; n3++) {
      let i3 = e3[n3], o3 = r3[n3];
      if (i3.from != o3.from || i3.to != o3.to || i3.size != o3.size)
        return false;
    }
    return true;
  }
  draw(e3, r3) {
    return nr.replace({
      widget: new bA(this.size * (r3 ? e3.scaleY : e3.scaleX), r3)
    }).range(this.from, this.to);
  }
}
class bA extends Gf {
  constructor(e3, r3) {
    super(), this.size = e3, this.vertical = r3;
  }
  eq(e3) {
    return e3.size == this.size && e3.vertical == this.vertical;
  }
  toDOM() {
    let e3 = document.createElement("div");
    return this.vertical ? e3.style.height = this.size + "px" : (e3.style.width = this.size + "px", e3.style.height = "2px", e3.style.display = "inline-block"), e3;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class ov {
  constructor(e3) {
    this.state = e3, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = true, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = sv, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = br.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
    let r3 = e3.facet(Eg).some((n3) => typeof n3 != "function" && n3.class == "cm-lineWrapping");
    this.heightOracle = new dA(r3), this.stateDeco = e3.facet(jl).filter((n3) => typeof n3 != "function"), this.heightMap = Ar.empty().applyChanges(this.stateDeco, ct.empty, this.heightOracle.setDoc(e3.doc), [new fn(0, 0, 0, e3.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = nr.set(this.lineGaps.map((n3) => n3.draw(this, false))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e3 = [this.viewport], { main: r3 } = this.state.selection;
    for (let n3 = 0; n3 <= 1; n3++) {
      let i3 = n3 ? r3.head : r3.anchor;
      if (!e3.some(({ from: o3, to: s3 }) => i3 >= o3 && i3 <= s3)) {
        let { from: o3, to: s3 } = this.lineBlockAt(i3);
        e3.push(new Lu(o3, s3));
      }
    }
    this.viewports = e3.sort((n3, i3) => n3.from - i3.from), this.scaler = this.heightMap.height <= 7e6 ? sv : new wA(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e3) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e3 : al(e3, this.scaler));
    });
  }
  update(e3, r3 = null) {
    this.state = e3.state;
    let n3 = this.stateDeco;
    this.stateDeco = this.state.facet(jl).filter((c3) => typeof c3 != "function");
    let i3 = e3.changedRanges, o3 = fn.extendWithRanges(i3, mA(n3, this.stateDeco, e3 ? e3.changes : rr.empty(this.state.doc.length))), s3 = this.heightMap.height, a3 = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e3.startState.doc, this.heightOracle.setDoc(this.state.doc), o3), this.heightMap.height != s3 && (e3.flags |= 2), a3 ? (this.scrollAnchorPos = e3.changes.mapPos(a3.from, -1), this.scrollAnchorHeight = a3.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l3 = o3.length ? this.mapViewport(this.viewport, e3.changes) : this.viewport;
    (r3 && (r3.range.head < l3.from || r3.range.head > l3.to) || !this.viewportIsAppropriate(l3)) && (l3 = this.getViewport(0, r3));
    let u3 = !e3.changes.empty || e3.flags & 2 || l3.from != this.viewport.from || l3.to != this.viewport.to;
    this.viewport = l3, this.updateForViewport(), u3 && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e3.changes))), e3.flags |= this.computeVisibleRanges(), r3 && (this.scrollTarget = r3), !this.mustEnforceCursorAssoc && e3.selectionSet && e3.view.lineWrapping && e3.state.selection.main.empty && e3.state.selection.main.assoc && !e3.state.facet($R) && (this.mustEnforceCursorAssoc = true);
  }
  measure(e3) {
    let r3 = e3.contentDOM, n3 = window.getComputedStyle(r3), i3 = this.heightOracle, o3 = n3.whiteSpace;
    this.defaultTextDirection = n3.direction == "rtl" ? br.RTL : br.LTR;
    let s3 = this.heightOracle.mustRefreshForWrapping(o3), a3 = r3.getBoundingClientRect(), l3 = s3 || this.mustMeasureContent || this.contentDOMHeight != a3.height;
    this.contentDOMHeight = a3.height, this.mustMeasureContent = false;
    let u3 = 0, c3 = 0;
    if (a3.width && a3.height) {
      let $10 = a3.width / r3.offsetWidth, _10 = a3.height / r3.offsetHeight;
      $10 > 0.995 && $10 < 1.005 && ($10 = 1), _10 > 0.995 && _10 < 1.005 && (_10 = 1), (this.scaleX != $10 || this.scaleY != _10) && (this.scaleX = $10, this.scaleY = _10, u3 |= 8, s3 = l3 = true);
    }
    let f3 = (parseInt(n3.paddingTop) || 0) * this.scaleY, d3 = (parseInt(n3.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != f3 || this.paddingBottom != d3) && (this.paddingTop = f3, this.paddingBottom = d3, u3 |= 10), this.editorWidth != e3.scrollDOM.clientWidth && (i3.lineWrapping && (l3 = true), this.editorWidth = e3.scrollDOM.clientWidth, u3 |= 8);
    let p10 = e3.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != p10 && (this.scrollAnchorHeight = -1, this.scrollTop = p10), this.scrolledToBottom = Y2(e3.scrollDOM);
    let h10 = (this.printing ? vA : yA)(r3, this.paddingTop), m10 = h10.top - this.pixelViewport.top, O10 = h10.bottom - this.pixelViewport.bottom;
    this.pixelViewport = h10;
    let g = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (g != this.inView && (this.inView = g, g && (l3 = true)), !this.inView && !this.scrollTarget)
      return 0;
    let v10 = a3.width;
    if ((this.contentDOMWidth != v10 || this.editorHeight != e3.scrollDOM.clientHeight) && (this.contentDOMWidth = a3.width, this.editorHeight = e3.scrollDOM.clientHeight, u3 |= 8), l3) {
      let $10 = e3.docView.measureVisibleLineHeights(this.viewport);
      if (i3.mustRefreshForHeights($10) && (s3 = true), s3 || i3.lineWrapping && Math.abs(v10 - this.contentDOMWidth) > i3.charWidth) {
        let { lineHeight: _10, charWidth: P10, textHeight: q5 } = e3.docView.measureTextSize();
        s3 = _10 > 0 && i3.refresh(o3, _10, P10, q5, v10 / P10, $10), s3 && (e3.docView.minWidth = 0, u3 |= 8);
      }
      m10 > 0 && O10 > 0 ? c3 = Math.max(m10, O10) : m10 < 0 && O10 < 0 && (c3 = Math.min(m10, O10)), i3.heightChanged = false;
      for (let _10 of this.viewports) {
        let P10 = _10.from == this.viewport.from ? $10 : e3.docView.measureVisibleLineHeights(_10);
        this.heightMap = (s3 ? Ar.empty().applyChanges(this.stateDeco, ct.empty, this.heightOracle, [new fn(0, 0, 0, e3.state.doc.length)]) : this.heightMap).updateHeight(i3, 0, s3, new hA(_10.from, P10));
      }
      i3.heightChanged && (u3 |= 2);
    }
    let S10 = !this.viewportIsAppropriate(this.viewport, c3) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return S10 && (this.viewport = this.getViewport(c3, this.scrollTarget)), this.updateForViewport(), (u3 & 2 || S10) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(s3 ? [] : this.lineGaps, e3)), u3 |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, e3.docView.enforceCursorAssoc()), u3;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e3, r3) {
    let n3 = 0.5 - Math.max(-0.5, Math.min(0.5, e3 / 1e3 / 2)), i3 = this.heightMap, o3 = this.heightOracle, { visibleTop: s3, visibleBottom: a3 } = this, l3 = new Lu(i3.lineAt(s3 - n3 * 1e3, Pt.ByHeight, o3, 0, 0).from, i3.lineAt(a3 + (1 - n3) * 1e3, Pt.ByHeight, o3, 0, 0).to);
    if (r3) {
      let { head: u3 } = r3.range;
      if (u3 < l3.from || u3 > l3.to) {
        let c3 = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), f3 = i3.lineAt(u3, Pt.ByPos, o3, 0, 0), d3;
        r3.y == "center" ? d3 = (f3.top + f3.bottom) / 2 - c3 / 2 : r3.y == "start" || r3.y == "nearest" && u3 < l3.from ? d3 = f3.top : d3 = f3.bottom - c3, l3 = new Lu(i3.lineAt(d3 - 1e3 / 2, Pt.ByHeight, o3, 0, 0).from, i3.lineAt(d3 + c3 + 1e3 / 2, Pt.ByHeight, o3, 0, 0).to);
      }
    }
    return l3;
  }
  mapViewport(e3, r3) {
    let n3 = r3.mapPos(e3.from, -1), i3 = r3.mapPos(e3.to, 1);
    return new Lu(this.heightMap.lineAt(n3, Pt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i3, Pt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e3, to: r3 }, n3 = 0) {
    if (!this.inView)
      return true;
    let { top: i3 } = this.heightMap.lineAt(e3, Pt.ByPos, this.heightOracle, 0, 0), { bottom: o3 } = this.heightMap.lineAt(r3, Pt.ByPos, this.heightOracle, 0, 0), { visibleTop: s3, visibleBottom: a3 } = this;
    return (e3 == 0 || i3 <= s3 - Math.max(10, Math.min(
      -n3,
      250
      /* VP.MaxCoverMargin */
    ))) && (r3 == this.state.doc.length || o3 >= a3 + Math.max(10, Math.min(
      n3,
      250
      /* VP.MaxCoverMargin */
    ))) && i3 > s3 - 2 * 1e3 && o3 < a3 + 2 * 1e3;
  }
  mapLineGaps(e3, r3) {
    if (!e3.length || r3.empty)
      return e3;
    let n3 = [];
    for (let i3 of e3)
      r3.touchesRange(i3.from, i3.to) || n3.push(new mh(r3.mapPos(i3.from), r3.mapPos(i3.to), i3.size));
    return n3;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e3, r3) {
    let n3 = this.heightOracle.lineWrapping, i3 = n3 ? 1e4 : 2e3, o3 = i3 >> 1, s3 = i3 << 1;
    if (this.defaultTextDirection != br.LTR && !n3)
      return [];
    let a3 = [], l3 = (u3, c3, f3, d3) => {
      if (c3 - u3 < o3)
        return;
      let p10 = this.state.selection.main, h10 = [p10.from];
      p10.empty || h10.push(p10.to);
      for (let O10 of h10)
        if (O10 > u3 && O10 < c3) {
          l3(u3, O10 - 10, f3, d3), l3(O10 + 10, c3, f3, d3);
          return;
        }
      let m10 = $A(e3, (O10) => O10.from >= f3.from && O10.to <= f3.to && Math.abs(O10.from - u3) < o3 && Math.abs(O10.to - c3) < o3 && !h10.some((g) => O10.from < g && O10.to > g));
      if (!m10) {
        if (c3 < f3.to && r3 && n3 && r3.visibleRanges.some((O10) => O10.from <= c3 && O10.to >= c3)) {
          let O10 = r3.moveToLineBoundary(Pe.cursor(c3), false, true).head;
          O10 > u3 && (c3 = O10);
        }
        m10 = new mh(u3, c3, this.gapSize(f3, u3, c3, d3));
      }
      a3.push(m10);
    };
    for (let u3 of this.viewportLines) {
      if (u3.length < s3)
        continue;
      let c3 = SA(u3.from, u3.to, this.stateDeco);
      if (c3.total < s3)
        continue;
      let f3 = this.scrollTarget ? this.scrollTarget.range.head : null, d3, p10;
      if (n3) {
        let h10 = i3 / this.heightOracle.lineLength * this.heightOracle.lineHeight, m10, O10;
        if (f3 != null) {
          let g = zu(c3, f3), v10 = ((this.visibleBottom - this.visibleTop) / 2 + h10) / u3.height;
          m10 = g - v10, O10 = g + v10;
        } else
          m10 = (this.visibleTop - u3.top - h10) / u3.height, O10 = (this.visibleBottom - u3.top + h10) / u3.height;
        d3 = Bu(c3, m10), p10 = Bu(c3, O10);
      } else {
        let h10 = c3.total * this.heightOracle.charWidth, m10 = i3 * this.heightOracle.charWidth, O10, g;
        if (f3 != null) {
          let v10 = zu(c3, f3), S10 = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + m10) / h10;
          O10 = v10 - S10, g = v10 + S10;
        } else
          O10 = (this.pixelViewport.left - m10) / h10, g = (this.pixelViewport.right + m10) / h10;
        d3 = Bu(c3, O10), p10 = Bu(c3, g);
      }
      d3 > u3.from && l3(u3.from, d3, u3, c3), p10 < u3.to && l3(p10, u3.to, u3, c3);
    }
    return a3;
  }
  gapSize(e3, r3, n3, i3) {
    let o3 = zu(i3, n3) - zu(i3, r3);
    return this.heightOracle.lineWrapping ? e3.height * o3 : i3.total * this.heightOracle.charWidth * o3;
  }
  updateLineGaps(e3) {
    mh.same(e3, this.lineGaps) || (this.lineGaps = e3, this.lineGapDeco = nr.set(e3.map((r3) => r3.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e3 = this.stateDeco;
    this.lineGaps.length && (e3 = e3.concat(this.lineGapDeco));
    let r3 = [];
    xt.spans(e3, this.viewport.from, this.viewport.to, {
      span(i3, o3) {
        r3.push({ from: i3, to: o3 });
      },
      point() {
      }
    }, 20);
    let n3 = r3.length != this.visibleRanges.length || this.visibleRanges.some((i3, o3) => i3.from != r3[o3].from || i3.to != r3[o3].to);
    return this.visibleRanges = r3, n3 ? 4 : 0;
  }
  lineBlockAt(e3) {
    return e3 >= this.viewport.from && e3 <= this.viewport.to && this.viewportLines.find((r3) => r3.from <= e3 && r3.to >= e3) || al(this.heightMap.lineAt(e3, Pt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e3) {
    return al(this.heightMap.lineAt(this.scaler.fromDOM(e3), Pt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e3) {
    let r3 = this.lineBlockAtHeight(e3 + 8);
    return r3.from >= this.viewport.from || this.viewportLines[0].top - e3 > 200 ? r3 : this.viewportLines[0];
  }
  elementAtHeight(e3) {
    return al(this.heightMap.blockAt(this.scaler.fromDOM(e3), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Lu {
  constructor(e3, r3) {
    this.from = e3, this.to = r3;
  }
}
function SA(t10, e3, r3) {
  let n3 = [], i3 = t10, o3 = 0;
  return xt.spans(r3, t10, e3, {
    span() {
    },
    point(s3, a3) {
      s3 > i3 && (n3.push({ from: i3, to: s3 }), o3 += s3 - i3), i3 = a3;
    }
  }, 20), i3 < e3 && (n3.push({ from: i3, to: e3 }), o3 += e3 - i3), { total: o3, ranges: n3 };
}
function Bu({ total: t10, ranges: e3 }, r3) {
  if (r3 <= 0)
    return e3[0].from;
  if (r3 >= 1)
    return e3[e3.length - 1].to;
  let n3 = Math.floor(t10 * r3);
  for (let i3 = 0; ; i3++) {
    let { from: o3, to: s3 } = e3[i3], a3 = s3 - o3;
    if (n3 <= a3)
      return o3 + n3;
    n3 -= a3;
  }
}
function zu(t10, e3) {
  let r3 = 0;
  for (let { from: n3, to: i3 } of t10.ranges) {
    if (e3 <= i3) {
      r3 += e3 - n3;
      break;
    }
    r3 += i3 - n3;
  }
  return r3 / t10.total;
}
function $A(t10, e3) {
  for (let r3 of t10)
    if (e3(r3))
      return r3;
}
const sv = {
  toDOM(t10) {
    return t10;
  },
  fromDOM(t10) {
    return t10;
  },
  scale: 1
};
class wA {
  constructor(e3, r3, n3) {
    let i3 = 0, o3 = 0, s3 = 0;
    this.viewports = n3.map(({ from: a3, to: l3 }) => {
      let u3 = r3.lineAt(a3, Pt.ByPos, e3, 0, 0).top, c3 = r3.lineAt(l3, Pt.ByPos, e3, 0, 0).bottom;
      return i3 += c3 - u3, { from: a3, to: l3, top: u3, bottom: c3, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i3) / (r3.height - i3);
    for (let a3 of this.viewports)
      a3.domTop = s3 + (a3.top - o3) * this.scale, s3 = a3.domBottom = a3.domTop + (a3.bottom - a3.top), o3 = a3.bottom;
  }
  toDOM(e3) {
    for (let r3 = 0, n3 = 0, i3 = 0; ; r3++) {
      let o3 = r3 < this.viewports.length ? this.viewports[r3] : null;
      if (!o3 || e3 < o3.top)
        return i3 + (e3 - n3) * this.scale;
      if (e3 <= o3.bottom)
        return o3.domTop + (e3 - o3.top);
      n3 = o3.bottom, i3 = o3.domBottom;
    }
  }
  fromDOM(e3) {
    for (let r3 = 0, n3 = 0, i3 = 0; ; r3++) {
      let o3 = r3 < this.viewports.length ? this.viewports[r3] : null;
      if (!o3 || e3 < o3.domTop)
        return n3 + (e3 - i3) / this.scale;
      if (e3 <= o3.domBottom)
        return o3.top + (e3 - o3.domTop);
      n3 = o3.bottom, i3 = o3.domBottom;
    }
  }
}
function al(t10, e3) {
  if (e3.scale == 1)
    return t10;
  let r3 = e3.toDOM(t10.top), n3 = e3.toDOM(t10.bottom);
  return new zn(t10.from, t10.length, r3, n3 - r3, Array.isArray(t10._content) ? t10._content.map((i3) => al(i3, e3)) : t10._content);
}
const Hu = /* @__PURE__ */ Me.define({ combine: (t10) => t10.join(" ") }), pO = /* @__PURE__ */ Me.define({ combine: (t10) => t10.indexOf(true) > -1 }), OO = /* @__PURE__ */ uo.newName(), CP = /* @__PURE__ */ uo.newName(), RP = /* @__PURE__ */ uo.newName(), AP = { "&light": "." + CP, "&dark": "." + RP };
function mO(t10, e3, r3) {
  return new uo(e3, {
    finish(n3) {
      return /&/.test(n3) ? n3.replace(/&\w*/, (i3) => {
        if (i3 == "&")
          return t10;
        if (!r3 || !r3[i3])
          throw new RangeError(`Unsupported selector: ${i3}`);
        return r3[i3];
      }) : t10 + " " + n3;
    }
  });
}
const PA = /* @__PURE__ */ mO("." + OO, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, AP), ll = "￿";
class _A {
  constructor(e3, r3) {
    this.points = e3, this.text = "", this.lineSeparator = r3.facet(pt.lineSeparator);
  }
  append(e3) {
    this.text += e3;
  }
  lineBreak() {
    this.text += ll;
  }
  readRange(e3, r3) {
    if (!e3)
      return this;
    let n3 = e3.parentNode;
    for (let i3 = e3; ; ) {
      this.findPointBefore(n3, i3);
      let o3 = this.text.length;
      this.readNode(i3);
      let s3 = i3.nextSibling;
      if (s3 == r3)
        break;
      let a3 = Qt.get(i3), l3 = Qt.get(s3);
      (a3 && l3 ? a3.breakAfter : (a3 ? a3.breakAfter : av(i3)) || av(s3) && (i3.nodeName != "BR" || i3.cmIgnore) && this.text.length > o3) && this.lineBreak(), i3 = s3;
    }
    return this.findPointBefore(n3, r3), this;
  }
  readTextNode(e3) {
    let r3 = e3.nodeValue;
    for (let n3 of this.points)
      n3.node == e3 && (n3.pos = this.text.length + Math.min(n3.offset, r3.length));
    for (let n3 = 0, i3 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o3 = -1, s3 = 1, a3;
      if (this.lineSeparator ? (o3 = r3.indexOf(this.lineSeparator, n3), s3 = this.lineSeparator.length) : (a3 = i3.exec(r3)) && (o3 = a3.index, s3 = a3[0].length), this.append(r3.slice(n3, o3 < 0 ? r3.length : o3)), o3 < 0)
        break;
      if (this.lineBreak(), s3 > 1)
        for (let l3 of this.points)
          l3.node == e3 && l3.pos > this.text.length && (l3.pos -= s3 - 1);
      n3 = o3 + s3;
    }
  }
  readNode(e3) {
    if (e3.cmIgnore)
      return;
    let r3 = Qt.get(e3), n3 = r3 && r3.overrideDOMText;
    if (n3 != null) {
      this.findPointInside(e3, n3.length);
      for (let i3 = n3.iter(); !i3.next().done; )
        i3.lineBreak ? this.lineBreak() : this.append(i3.value);
    } else
      e3.nodeType == 3 ? this.readTextNode(e3) : e3.nodeName == "BR" ? e3.nextSibling && this.lineBreak() : e3.nodeType == 1 && this.readRange(e3.firstChild, null);
  }
  findPointBefore(e3, r3) {
    for (let n3 of this.points)
      n3.node == e3 && e3.childNodes[n3.offset] == r3 && (n3.pos = this.text.length);
  }
  findPointInside(e3, r3) {
    for (let n3 of this.points)
      (e3.nodeType == 3 ? n3.node == e3 : e3.contains(n3.node)) && (n3.pos = this.text.length + Math.min(r3, n3.offset));
  }
}
function av(t10) {
  return t10.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t10.nodeName);
}
class lv {
  constructor(e3, r3) {
    this.node = e3, this.offset = r3, this.pos = -1;
  }
}
class xA {
  constructor(e3, r3, n3, i3) {
    this.typeOver = i3, this.bounds = null, this.text = "";
    let { impreciseHead: o3, impreciseAnchor: s3 } = e3.docView;
    if (e3.state.readOnly && r3 > -1)
      this.newSel = null;
    else if (r3 > -1 && (this.bounds = e3.docView.domBoundsAround(r3, n3, 0))) {
      let a3 = o3 || s3 ? [] : kA(e3), l3 = new _A(a3, e3.state);
      l3.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l3.text, this.newSel = EA(a3, this.bounds.from);
    } else {
      let a3 = e3.observer.selectionRange, l3 = o3 && o3.node == a3.focusNode && o3.offset == a3.focusOffset || !tO(e3.contentDOM, a3.focusNode) ? e3.state.selection.main.head : e3.docView.posFromDOM(a3.focusNode, a3.focusOffset), u3 = s3 && s3.node == a3.anchorNode && s3.offset == a3.anchorOffset || !tO(e3.contentDOM, a3.anchorNode) ? e3.state.selection.main.anchor : e3.docView.posFromDOM(a3.anchorNode, a3.anchorOffset);
      this.newSel = Pe.single(u3, l3);
    }
  }
}
function XP(t10, e3) {
  let r3, { newSel: n3 } = e3, i3 = t10.state.selection.main, o3 = t10.inputState.lastKeyTime > Date.now() - 100 ? t10.inputState.lastKeyCode : -1;
  if (e3.bounds) {
    let { from: s3, to: a3 } = e3.bounds, l3 = i3.from, u3 = null;
    (o3 === 8 || ke.android && e3.text.length < a3 - s3) && (l3 = i3.to, u3 = "end");
    let c3 = TA(t10.state.doc.sliceString(s3, a3, ll), e3.text, l3 - s3, u3);
    c3 && (ke.chrome && o3 == 13 && c3.toB == c3.from + 2 && e3.text.slice(c3.from, c3.toB) == ll + ll && c3.toB--, r3 = {
      from: s3 + c3.from,
      to: s3 + c3.toA,
      insert: ct.of(e3.text.slice(c3.from, c3.toB).split(ll))
    });
  } else
    n3 && (!t10.hasFocus && t10.state.facet(Kf) || n3.main.eq(i3)) && (n3 = null);
  if (!r3 && !n3)
    return false;
  if (!r3 && e3.typeOver && !i3.empty && n3 && n3.main.empty ? r3 = { from: i3.from, to: i3.to, insert: t10.state.doc.slice(i3.from, i3.to) } : r3 && r3.from >= i3.from && r3.to <= i3.to && (r3.from != i3.from || r3.to != i3.to) && i3.to - i3.from - (r3.to - r3.from) <= 4 ? r3 = {
    from: i3.from,
    to: i3.to,
    insert: t10.state.doc.slice(i3.from, r3.from).append(r3.insert).append(t10.state.doc.slice(r3.to, i3.to))
  } : (ke.mac || ke.android) && r3 && r3.from == r3.to && r3.from == i3.head - 1 && /^\. ?$/.test(r3.insert.toString()) && t10.contentDOM.getAttribute("autocorrect") == "off" ? (n3 && r3.insert.length == 2 && (n3 = Pe.single(n3.main.anchor - 1, n3.main.head - 1)), r3 = { from: i3.from, to: i3.to, insert: ct.of([" "]) }) : ke.chrome && r3 && r3.from == r3.to && r3.from == i3.head && r3.insert.toString() == `
 ` && t10.lineWrapping && (n3 && (n3 = Pe.single(n3.main.anchor - 1, n3.main.head - 1)), r3 = { from: i3.from, to: i3.to, insert: ct.of([" "]) }), r3) {
    if (ke.ios && t10.inputState.flushIOSKey() || ke.android && (r3.from == i3.from && r3.to == i3.to && r3.insert.length == 1 && r3.insert.lines == 2 && Gs(t10.contentDOM, "Enter", 13) || (r3.from == i3.from - 1 && r3.to == i3.to && r3.insert.length == 0 || o3 == 8 && r3.insert.length < r3.to - r3.from && r3.to > i3.head) && Gs(t10.contentDOM, "Backspace", 8) || r3.from == i3.from && r3.to == i3.to + 1 && r3.insert.length == 0 && Gs(t10.contentDOM, "Delete", 46)))
      return true;
    let s3 = r3.insert.toString();
    t10.inputState.composing >= 0 && t10.inputState.composing++;
    let a3, l3 = () => a3 || (a3 = QA(t10, r3, n3));
    return t10.state.facet(sP).some((u3) => u3(t10, r3.from, r3.to, s3, l3)) || t10.dispatch(l3()), true;
  } else if (n3 && !n3.main.eq(i3)) {
    let s3 = false, a3 = "select";
    return t10.inputState.lastSelectionTime > Date.now() - 50 && (t10.inputState.lastSelectionOrigin == "select" && (s3 = true), a3 = t10.inputState.lastSelectionOrigin), t10.dispatch({ selection: n3, scrollIntoView: s3, userEvent: a3 }), true;
  } else
    return false;
}
function QA(t10, e3, r3) {
  let n3, i3 = t10.state, o3 = i3.selection.main;
  if (e3.from >= o3.from && e3.to <= o3.to && e3.to - e3.from >= (o3.to - o3.from) / 3 && (!r3 || r3.main.empty && r3.main.from == e3.from + e3.insert.length) && t10.inputState.composing < 0) {
    let a3 = o3.from < e3.from ? i3.sliceDoc(o3.from, e3.from) : "", l3 = o3.to > e3.to ? i3.sliceDoc(e3.to, o3.to) : "";
    n3 = i3.replaceSelection(t10.state.toText(a3 + e3.insert.sliceString(0, void 0, t10.state.lineBreak) + l3));
  } else {
    let a3 = i3.changes(e3), l3 = r3 && r3.main.to <= a3.newLength ? r3.main : void 0;
    if (i3.selection.ranges.length > 1 && t10.inputState.composing >= 0 && e3.to <= o3.to && e3.to >= o3.to - 10) {
      let u3 = t10.state.sliceDoc(e3.from, e3.to), c3, f3 = r3 && yP(t10, r3.main.head);
      if (f3) {
        let h10 = e3.insert.length - (e3.to - e3.from);
        c3 = { from: f3.from, to: f3.to - h10 };
      } else
        c3 = t10.state.doc.lineAt(o3.head);
      let d3 = o3.to - e3.to, p10 = o3.to - o3.from;
      n3 = i3.changeByRange((h10) => {
        if (h10.from == o3.from && h10.to == o3.to)
          return { changes: a3, range: l3 || h10.map(a3) };
        let m10 = h10.to - d3, O10 = m10 - u3.length;
        if (h10.to - h10.from != p10 || t10.state.sliceDoc(O10, m10) != u3 || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        h10.to >= c3.from && h10.from <= c3.to)
          return { range: h10 };
        let g = i3.changes({ from: O10, to: m10, insert: e3.insert }), v10 = h10.to - o3.to;
        return {
          changes: g,
          range: l3 ? Pe.range(Math.max(0, l3.anchor + v10), Math.max(0, l3.head + v10)) : h10.map(g)
        };
      });
    } else
      n3 = {
        changes: a3,
        selection: l3 && i3.selection.replaceRange(l3)
      };
  }
  let s3 = "input.type";
  return (t10.composing || t10.inputState.compositionPendingChange && t10.inputState.compositionEndedAt > Date.now() - 50) && (t10.inputState.compositionPendingChange = false, s3 += ".compose", t10.inputState.compositionFirstChange && (s3 += ".start", t10.inputState.compositionFirstChange = false)), i3.update(n3, { userEvent: s3, scrollIntoView: true });
}
function TA(t10, e3, r3, n3) {
  let i3 = Math.min(t10.length, e3.length), o3 = 0;
  for (; o3 < i3 && t10.charCodeAt(o3) == e3.charCodeAt(o3); )
    o3++;
  if (o3 == i3 && t10.length == e3.length)
    return null;
  let s3 = t10.length, a3 = e3.length;
  for (; s3 > 0 && a3 > 0 && t10.charCodeAt(s3 - 1) == e3.charCodeAt(a3 - 1); )
    s3--, a3--;
  if (n3 == "end") {
    let l3 = Math.max(0, o3 - Math.min(s3, a3));
    r3 -= s3 + l3 - o3;
  }
  if (s3 < o3 && t10.length < e3.length) {
    let l3 = r3 <= o3 && r3 >= s3 ? o3 - r3 : 0;
    o3 -= l3, a3 = o3 + (a3 - s3), s3 = o3;
  } else if (a3 < o3) {
    let l3 = r3 <= o3 && r3 >= a3 ? o3 - r3 : 0;
    o3 -= l3, s3 = o3 + (s3 - a3), a3 = o3;
  }
  return { from: o3, toA: s3, toB: a3 };
}
function kA(t10) {
  let e3 = [];
  if (t10.root.activeElement != t10.contentDOM)
    return e3;
  let { anchorNode: r3, anchorOffset: n3, focusNode: i3, focusOffset: o3 } = t10.observer.selectionRange;
  return r3 && (e3.push(new lv(r3, n3)), (i3 != r3 || o3 != n3) && e3.push(new lv(i3, o3))), e3;
}
function EA(t10, e3) {
  if (t10.length == 0)
    return null;
  let r3 = t10[0].pos, n3 = t10.length == 2 ? t10[1].pos : r3;
  return r3 > -1 && n3 > -1 ? Pe.single(r3 + e3, n3 + e3) : null;
}
const CA = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
}, gh = ke.ie && ke.ie_version <= 11;
class RA {
  constructor(e3) {
    this.view = e3, this.active = false, this.selectionRange = new pR(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.resizeContent = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e3.contentDOM, this.observer = new MutationObserver((r3) => {
      for (let n3 of r3)
        this.queue.push(n3);
      (ke.ie && ke.ie_version <= 11 || ke.ios && e3.composing) && r3.some((n3) => n3.type == "childList" && n3.removedNodes.length || n3.type == "characterData" && n3.oldValue.length > n3.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), gh && (this.onCharData = (r3) => {
      this.queue.push({
        target: r3.target,
        type: "characterData",
        oldValue: r3.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var r3;
      ((r3 = this.view.docView) === null || r3 === void 0 ? void 0 : r3.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e3.scrollDOM), this.resizeContent = new ResizeObserver(() => this.view.requestMeasure()), this.resizeContent.observe(e3.contentDOM)), this.addWindowListeners(this.win = e3.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((r3) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), r3.length > 0 && r3[r3.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((r3) => {
      r3.length > 0 && r3[r3.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e3) {
    this.view.inputState.runHandlers("scroll", e3), this.intersecting && this.view.measure();
  }
  onScroll(e3) {
    this.intersecting && this.flush(false), this.onScrollChanged(e3);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = false, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e3) {
    if (this.gapIntersection && (e3.length != this.gaps.length || this.gaps.some((r3, n3) => r3 != e3[n3]))) {
      this.gapIntersection.disconnect();
      for (let r3 of e3)
        this.gapIntersection.observe(r3);
      this.gaps = e3;
    }
  }
  onSelectionChange(e3) {
    let r3 = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: n3 } = this, i3 = this.selectionRange;
    if (n3.state.facet(Kf) ? n3.root.activeElement != this.dom : !bc(n3.dom, i3))
      return;
    let o3 = i3.anchorNode && n3.docView.nearest(i3.anchorNode);
    if (o3 && o3.ignoreEvent(e3)) {
      r3 || (this.selectionChanged = false);
      return;
    }
    (ke.ie && ke.ie_version <= 11 || ke.android && ke.chrome) && !n3.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i3.focusNode && rf(i3.focusNode, i3.focusOffset, i3.anchorNode, i3.anchorOffset) ? this.flushSoon() : this.flush(false);
  }
  readSelectionRange() {
    let { view: e3 } = this, r3 = ke.safari && e3.root.nodeType == 11 && cR(this.dom.ownerDocument) == this.dom && AA(this.view) || tf(e3.root);
    if (!r3 || this.selectionRange.eq(r3))
      return false;
    let n3 = bc(this.dom, r3);
    return n3 && !this.selectionChanged && e3.inputState.lastFocusTime > Date.now() - 200 && e3.inputState.lastTouchTime < Date.now() - 300 && mR(this.dom, r3) ? (this.view.inputState.lastFocusTime = 0, e3.docView.updateSelection(), false) : (this.selectionRange.setRange(r3), n3 && (this.selectionChanged = true), true);
  }
  setSelectionRange(e3, r3) {
    this.selectionRange.set(e3.node, e3.offset, r3.node, r3.offset), this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e3 = 0, r3 = null;
    for (let n3 = this.dom; n3; )
      if (n3.nodeType == 1)
        !r3 && e3 < this.scrollTargets.length && this.scrollTargets[e3] == n3 ? e3++ : r3 || (r3 = this.scrollTargets.slice(0, e3)), r3 && r3.push(n3), n3 = n3.assignedSlot || n3.parentNode;
      else if (n3.nodeType == 11)
        n3 = n3.host;
      else
        break;
    if (e3 < this.scrollTargets.length && !r3 && (r3 = this.scrollTargets.slice(0, e3)), r3) {
      for (let n3 of this.scrollTargets)
        n3.removeEventListener("scroll", this.onScroll);
      for (let n3 of this.scrollTargets = r3)
        n3.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e3) {
    if (!this.active)
      return e3();
    try {
      return this.stop(), e3();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, CA), gh && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
  }
  stop() {
    this.active && (this.active = false, this.observer.disconnect(), gh && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e3, r3) {
    var n3;
    if (!this.delayedAndroidKey) {
      let i3 = () => {
        let o3 = this.delayedAndroidKey;
        o3 && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o3.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o3.force && Gs(this.dom, o3.key, o3.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i3);
    }
    (!this.delayedAndroidKey || e3 == "Enter") && (this.delayedAndroidKey = {
      key: e3,
      keyCode: r3,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((n3 = this.delayedAndroidKey) === null || n3 === void 0) && n3.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e3 of this.observer.takeRecords())
      this.queue.push(e3);
    return this.queue;
  }
  processRecords() {
    let e3 = this.pendingRecords();
    e3.length && (this.queue = []);
    let r3 = -1, n3 = -1, i3 = false;
    for (let o3 of e3) {
      let s3 = this.readMutation(o3);
      s3 && (s3.typeOver && (i3 = true), r3 == -1 ? { from: r3, to: n3 } = s3 : (r3 = Math.min(s3.from, r3), n3 = Math.max(s3.to, n3)));
    }
    return { from: r3, to: n3, typeOver: i3 };
  }
  readChange() {
    let { from: e3, to: r3, typeOver: n3 } = this.processRecords(), i3 = this.selectionChanged && bc(this.dom, this.selectionRange);
    if (e3 < 0 && !i3)
      return null;
    e3 > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false;
    let o3 = new xA(this.view, e3, r3, n3);
    return this.view.docView.domChanged = { newSel: o3.newSel ? o3.newSel.main : null }, o3;
  }
  // Apply pending changes, if any
  flush(e3 = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    e3 && this.readSelectionRange();
    let r3 = this.readChange();
    if (!r3)
      return false;
    let n3 = this.view.state, i3 = XP(this.view, r3);
    return this.view.state == n3 && this.view.update([]), i3;
  }
  readMutation(e3) {
    let r3 = this.view.docView.nearest(e3.target);
    if (!r3 || r3.ignoreMutation(e3))
      return null;
    if (r3.markDirty(e3.type == "attributes"), e3.type == "attributes" && (r3.flags |= 4), e3.type == "childList") {
      let n3 = uv(r3, e3.previousSibling || e3.target.previousSibling, -1), i3 = uv(r3, e3.nextSibling || e3.target.nextSibling, 1);
      return {
        from: n3 ? r3.posAfter(n3) : r3.posAtStart,
        to: i3 ? r3.posBefore(i3) : r3.posAtEnd,
        typeOver: false
      };
    } else
      return e3.type == "characterData" ? { from: r3.posAtStart, to: r3.posAtEnd, typeOver: e3.target.nodeValue == e3.oldValue } : null;
  }
  setWindow(e3) {
    e3 != this.win && (this.removeWindowListeners(this.win), this.win = e3, this.addWindowListeners(this.win));
  }
  addWindowListeners(e3) {
    e3.addEventListener("resize", this.onResize), e3.addEventListener("beforeprint", this.onPrint), e3.addEventListener("scroll", this.onScroll), e3.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e3) {
    e3.removeEventListener("scroll", this.onScroll), e3.removeEventListener("resize", this.onResize), e3.removeEventListener("beforeprint", this.onPrint), e3.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e3, r3, n3, i3;
    this.stop(), (e3 = this.intersection) === null || e3 === void 0 || e3.disconnect(), (r3 = this.gapIntersection) === null || r3 === void 0 || r3.disconnect(), (n3 = this.resizeScroll) === null || n3 === void 0 || n3.disconnect(), (i3 = this.resizeContent) === null || i3 === void 0 || i3.disconnect();
    for (let o3 of this.scrollTargets)
      o3.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function uv(t10, e3, r3) {
  for (; e3; ) {
    let n3 = Qt.get(e3);
    if (n3 && n3.parent == t10)
      return n3;
    let i3 = e3.parentNode;
    e3 = i3 != t10.dom ? i3 : r3 > 0 ? e3.nextSibling : e3.previousSibling;
  }
  return null;
}
function AA(t10) {
  let e3 = null;
  function r3(l3) {
    l3.preventDefault(), l3.stopImmediatePropagation(), e3 = l3.getTargetRanges()[0];
  }
  if (t10.contentDOM.addEventListener("beforeinput", r3, true), t10.dom.ownerDocument.execCommand("indent"), t10.contentDOM.removeEventListener("beforeinput", r3, true), !e3)
    return null;
  let n3 = e3.startContainer, i3 = e3.startOffset, o3 = e3.endContainer, s3 = e3.endOffset, a3 = t10.docView.domAtPos(t10.state.selection.main.anchor);
  return rf(a3.node, a3.offset, o3, s3) && ([n3, i3, o3, s3] = [o3, s3, n3, i3]), { anchorNode: n3, anchorOffset: i3, focusNode: o3, focusOffset: s3 };
}
class Be {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e3 = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: fixed; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM);
    let { dispatch: r3 } = e3;
    this.dispatchTransactions = e3.dispatchTransactions || r3 && ((n3) => n3.forEach((i3) => r3(i3, this))) || ((n3) => this.update(n3)), this.dispatch = this.dispatch.bind(this), this._root = e3.root || OR(e3.parent) || document, this.viewState = new ov(e3.state || pt.create(e3)), this.plugins = this.state.facet(ol).map((n3) => new hh(n3));
    for (let n3 of this.plugins)
      n3.update(this);
    this.observer = new RA(this), this.inputState = new zR(this), this.inputState.ensureHandlers(this.plugins), this.docView = new Zy(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), e3.parent && e3.parent.appendChild(this.dom);
  }
  dispatch(...e3) {
    let r3 = e3.length == 1 && e3[0] instanceof vr ? e3 : e3.length == 1 && Array.isArray(e3[0]) ? e3[0] : [this.state.update(...e3)];
    this.dispatchTransactions(r3, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e3) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let r3 = false, n3 = false, i3, o3 = this.state;
    for (let d3 of e3) {
      if (d3.startState != o3)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o3 = d3.state;
    }
    if (this.destroyed) {
      this.viewState.state = o3;
      return;
    }
    let s3 = this.hasFocus, a3 = 0, l3 = null;
    e3.some((d3) => d3.annotation(QP)) ? (this.inputState.notifiedFocused = s3, a3 = 1) : s3 != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s3, l3 = TP(o3, s3), l3 || (a3 = 1));
    let u3 = this.observer.delayedAndroidKey, c3 = null;
    if (u3 ? (this.observer.clearDelayedAndroidKey(), c3 = this.observer.readChange(), (c3 && !this.state.doc.eq(o3.doc) || !this.state.selection.eq(o3.selection)) && (c3 = null)) : this.observer.clear(), o3.facet(pt.phrases) != this.state.facet(pt.phrases))
      return this.setState(o3);
    i3 = sf.create(this, o3, e3), i3.flags |= a3;
    let f3 = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d3 of e3) {
        if (f3 && (f3 = f3.map(d3.changes)), d3.scrollIntoView) {
          let { main: p10 } = d3.state.selection;
          f3 = new of(p10.empty ? p10 : Pe.cursor(p10.head, p10.head > p10.anchor ? -1 : 1));
        }
        for (let p10 of d3.effects)
          p10.is(Iy) && (f3 = p10.value);
      }
      this.viewState.update(i3, f3), this.bidiCache = af.update(this.bidiCache, i3.changes), i3.empty || (this.updatePlugins(i3), this.inputState.update(i3)), r3 = this.docView.update(i3), this.state.facet(sl) != this.styleModules && this.mountStyles(), n3 = this.updateAttrs(), this.showAnnouncements(e3), this.docView.updateSelection(r3, e3.some((d3) => d3.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i3.startState.facet(Hu) != i3.state.facet(Hu) && (this.viewState.mustMeasureContent = true), (r3 || n3 || f3 || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !i3.empty)
      for (let d3 of this.state.facet(lO))
        d3(i3);
    (l3 || c3) && Promise.resolve().then(() => {
      l3 && this.state == l3.startState && this.dispatch(l3), c3 && !XP(this, c3) && u3.force && Gs(this.contentDOM, u3.key, u3.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e3) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e3;
      return;
    }
    this.updateState = 2;
    let r3 = this.hasFocus;
    try {
      for (let n3 of this.plugins)
        n3.destroy(this);
      this.viewState = new ov(e3), this.plugins = e3.facet(ol).map((n3) => new hh(n3)), this.pluginMap.clear();
      for (let n3 of this.plugins)
        n3.update(this);
      this.docView = new Zy(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    r3 && this.focus(), this.requestMeasure();
  }
  updatePlugins(e3) {
    let r3 = e3.startState.facet(ol), n3 = e3.state.facet(ol);
    if (r3 != n3) {
      let i3 = [];
      for (let o3 of n3) {
        let s3 = r3.indexOf(o3);
        if (s3 < 0)
          i3.push(new hh(o3));
        else {
          let a3 = this.plugins[s3];
          a3.mustUpdate = e3, i3.push(a3);
        }
      }
      for (let o3 of this.plugins)
        o3.mustUpdate != e3 && o3.destroy(this);
      this.plugins = i3, this.pluginMap.clear(), this.inputState.ensureHandlers(this.plugins);
    } else
      for (let i3 of this.plugins)
        i3.mustUpdate = e3;
    for (let i3 = 0; i3 < this.plugins.length; i3++)
      this.plugins[i3].update(this);
  }
  /**
  @internal
  */
  measure(e3 = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e3 && this.observer.forceFlush();
    let r3 = null, n3 = this.scrollDOM, i3 = n3.scrollTop * this.scaleY, { scrollAnchorPos: o3, scrollAnchorHeight: s3 } = this.viewState;
    Math.abs(i3 - this.viewState.scrollTop) > 1 && (s3 = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a3 = 0; ; a3++) {
        if (s3 < 0)
          if (Y2(n3))
            o3 = -1, s3 = this.viewState.heightMap.height;
          else {
            let p10 = this.viewState.scrollAnchorAt(i3);
            o3 = p10.from, s3 = p10.top;
          }
        this.updateState = 1;
        let l3 = this.viewState.measure(this);
        if (!l3 && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a3 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u3 = [];
        l3 & 4 || ([this.measureRequests, u3] = [u3, this.measureRequests]);
        let c3 = u3.map((p10) => {
          try {
            return p10.read(this);
          } catch (h10) {
            return zo(this.state, h10), cv;
          }
        }), f3 = sf.create(this, this.state, []), d3 = false;
        f3.flags |= l3, r3 ? r3.flags |= l3 : r3 = f3, this.updateState = 2, f3.empty || (this.updatePlugins(f3), this.inputState.update(f3), this.updateAttrs(), d3 = this.docView.update(f3));
        for (let p10 = 0; p10 < u3.length; p10++)
          if (c3[p10] != cv)
            try {
              let h10 = u3[p10];
              h10.write && h10.write(c3[p10], this);
            } catch (h10) {
              zo(this.state, h10);
            }
        if (d3 && this.docView.updateSelection(true), !f3.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null;
              continue;
            } else {
              let h10 = (o3 < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o3).top) - s3;
              if (h10 > 1 || h10 < -1) {
                i3 = i3 + h10, n3.scrollTop = i3 / this.scaleY, s3 = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (r3 && !r3.empty)
      for (let a3 of this.state.facet(lO))
        a3(r3);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return OO + " " + (this.state.facet(pO) ? RP : CP) + " " + this.state.facet(Hu);
  }
  updateAttrs() {
    let e3 = fv(this, uP, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), r3 = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(Kf) ? "true" : "false",
      class: "cm-content",
      style: `${ke.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (r3["aria-readonly"] = "true"), fv(this, Eg, r3);
    let n3 = this.observer.ignore(() => {
      let i3 = sO(this.contentDOM, this.contentAttrs, r3), o3 = sO(this.dom, this.editorAttrs, e3);
      return i3 || o3;
    });
    return this.editorAttrs = e3, this.contentAttrs = r3, n3;
  }
  showAnnouncements(e3) {
    let r3 = true;
    for (let n3 of e3)
      for (let i3 of n3.effects)
        if (i3.is(Be.announce)) {
          r3 && (this.announceDOM.textContent = ""), r3 = false;
          let o3 = this.announceDOM.appendChild(document.createElement("div"));
          o3.textContent = i3.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(sl);
    let e3 = this.state.facet(Be.cspNonce);
    uo.mount(this.root, this.styleModules.concat(PA).reverse(), e3 ? { nonce: e3 } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e3) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e3) {
      if (this.measureRequests.indexOf(e3) > -1)
        return;
      if (e3.key != null) {
        for (let r3 = 0; r3 < this.measureRequests.length; r3++)
          if (this.measureRequests[r3].key === e3.key) {
            this.measureRequests[r3] = e3;
            return;
          }
      }
      this.measureRequests.push(e3);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e3) {
    let r3 = this.pluginMap.get(e3);
    return (r3 === void 0 || r3 && r3.spec != e3) && this.pluginMap.set(e3, r3 = this.plugins.find((n3) => n3.spec == e3) || null), r3 && r3.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e3) {
    return this.readMeasured(), this.viewState.elementAtHeight(e3);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e3) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e3);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e3) {
    return this.viewState.lineBlockAt(e3);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e3, r3, n3) {
    return Oh(this, e3, Ly(this, e3, r3, n3));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e3, r3) {
    return Oh(this, e3, Ly(this, e3, r3, (n3) => LR(this, e3.head, n3)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e3, r3, n3 = true) {
    return YR(this, e3, r3, n3);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e3, r3, n3) {
    return Oh(this, e3, BR(this, e3, r3, n3));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e3) {
    return this.docView.domAtPos(e3);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e3, r3 = 0) {
    return this.docView.posFromDOM(e3, r3);
  }
  posAtCoords(e3, r3 = true) {
    return this.readMeasured(), bP(this, e3, r3);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e3, r3 = 1) {
    this.readMeasured();
    let n3 = this.docView.coordsAt(e3, r3);
    if (!n3 || n3.left == n3.right)
      return n3;
    let i3 = this.state.doc.lineAt(e3), o3 = this.bidiSpans(i3), s3 = o3[to.find(o3, e3 - i3.from, -1, r3)];
    return Qg(n3, s3.dir == br.LTR == r3 > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e3) {
    return this.readMeasured(), this.docView.coordsForChar(e3);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e3) {
    return !this.state.facet(lP) || e3 < this.viewport.from || e3 > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e3));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e3) {
    if (e3.length > XA)
      return mP(e3.length);
    let r3 = this.textDirectionAt(e3.from), n3;
    for (let o3 of this.bidiCache)
      if (o3.from == e3.from && o3.dir == r3 && (o3.fresh || OP(o3.isolates, n3 = Fy(this, e3.from, e3.to))))
        return o3.order;
    n3 || (n3 = Fy(this, e3.from, e3.to));
    let i3 = CR(e3.text, r3, n3);
    return this.bidiCache.push(new af(e3.from, e3.to, r3, n3, true, i3)), i3;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e3;
    return (this.dom.ownerDocument.hasFocus() || ke.safari && ((e3 = this.inputState) === null || e3 === void 0 ? void 0 : e3.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      W2(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e3) {
    this._root != e3 && (this._root = e3, this.observer.setWindow((e3.nodeType == 9 ? e3 : e3.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e3 of this.plugins)
      e3.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e3, r3 = {}) {
    return Iy.of(new of(typeof e3 == "number" ? Pe.cursor(e3) : e3, r3.y, r3.x, r3.yMargin, r3.xMargin));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e3) {
    return Xi.define(() => ({}), { eventHandlers: e3 });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e3) {
    return Xi.define(() => ({}), { eventObservers: e3 });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e3, r3) {
    let n3 = uo.newName(), i3 = [Hu.of(n3), sl.of(mO(`.${n3}`, e3))];
    return r3 && r3.dark && i3.push(pO.of(true)), i3;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e3) {
    return Bf.lowest(sl.of(mO("." + OO, e3, AP)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e3) {
    var r3;
    let n3 = e3.querySelector(".cm-content"), i3 = n3 && Qt.get(n3) || Qt.get(e3);
    return ((r3 = i3 == null ? void 0 : i3.rootView) === null || r3 === void 0 ? void 0 : r3.view) || null;
  }
}
Be.styleModule = sl;
Be.inputHandler = sP;
Be.focusChangeEffect = aP;
Be.perLineTextDirection = lP;
Be.exceptionSink = oP;
Be.updateListener = lO;
Be.editable = Kf;
Be.mouseSelectionStyle = iP;
Be.dragMovesSelection = nP;
Be.clickAddsSelectionRange = rP;
Be.decorations = jl;
Be.atomicRanges = Cg;
Be.bidiIsolatedRanges = cP;
Be.scrollMargins = fP;
Be.darkTheme = pO;
Be.cspNonce = /* @__PURE__ */ Me.define({ combine: (t10) => t10.length ? t10[0] : "" });
Be.contentAttributes = Eg;
Be.editorAttributes = uP;
Be.lineWrapping = /* @__PURE__ */ Be.contentAttributes.of({ class: "cm-lineWrapping" });
Be.announce = /* @__PURE__ */ Dt.define();
const XA = 4096, cv = {};
class af {
  constructor(e3, r3, n3, i3, o3, s3) {
    this.from = e3, this.to = r3, this.dir = n3, this.isolates = i3, this.fresh = o3, this.order = s3;
  }
  static update(e3, r3) {
    if (r3.empty && !e3.some((o3) => o3.fresh))
      return e3;
    let n3 = [], i3 = e3.length ? e3[e3.length - 1].dir : br.LTR;
    for (let o3 = Math.max(0, e3.length - 10); o3 < e3.length; o3++) {
      let s3 = e3[o3];
      s3.dir == i3 && !r3.touchesRange(s3.from, s3.to) && n3.push(new af(r3.mapPos(s3.from, 1), r3.mapPos(s3.to, -1), s3.dir, s3.isolates, false, s3.order));
    }
    return n3;
  }
}
function fv(t10, e3, r3) {
  for (let n3 = t10.state.facet(e3), i3 = n3.length - 1; i3 >= 0; i3--) {
    let o3 = n3[i3], s3 = typeof o3 == "function" ? o3(t10) : o3;
    s3 && oO(s3, r3);
  }
  return r3;
}
const qA = ke.mac ? "mac" : ke.windows ? "win" : ke.linux ? "linux" : "key";
function DA(t10, e3) {
  const r3 = t10.split(/-(?!$)/);
  let n3 = r3[r3.length - 1];
  n3 == "Space" && (n3 = " ");
  let i3, o3, s3, a3;
  for (let l3 = 0; l3 < r3.length - 1; ++l3) {
    const u3 = r3[l3];
    if (/^(cmd|meta|m)$/i.test(u3))
      a3 = true;
    else if (/^a(lt)?$/i.test(u3))
      i3 = true;
    else if (/^(c|ctrl|control)$/i.test(u3))
      o3 = true;
    else if (/^s(hift)?$/i.test(u3))
      s3 = true;
    else if (/^mod$/i.test(u3))
      e3 == "mac" ? a3 = true : o3 = true;
    else
      throw new Error("Unrecognized modifier name: " + u3);
  }
  return i3 && (n3 = "Alt-" + n3), o3 && (n3 = "Ctrl-" + n3), a3 && (n3 = "Meta-" + n3), s3 && (n3 = "Shift-" + n3), n3;
}
function Gu(t10, e3, r3) {
  return e3.altKey && (t10 = "Alt-" + t10), e3.ctrlKey && (t10 = "Ctrl-" + t10), e3.metaKey && (t10 = "Meta-" + t10), r3 !== false && e3.shiftKey && (t10 = "Shift-" + t10), t10;
}
const jA = /* @__PURE__ */ Bf.default(/* @__PURE__ */ Be.domEventHandlers({
  keydown(t10, e3) {
    return ZA(UA(e3.state), t10, e3, "editor");
  }
})), Jf = /* @__PURE__ */ Me.define({ enables: jA }), dv = /* @__PURE__ */ new WeakMap();
function UA(t10) {
  let e3 = t10.facet(Jf), r3 = dv.get(e3);
  return r3 || dv.set(e3, r3 = FA(e3.reduce((n3, i3) => n3.concat(i3), []))), r3;
}
let Ji = null;
const IA = 4e3;
function FA(t10, e3 = qA) {
  let r3 = /* @__PURE__ */ Object.create(null), n3 = /* @__PURE__ */ Object.create(null), i3 = (s3, a3) => {
    let l3 = n3[s3];
    if (l3 == null)
      n3[s3] = a3;
    else if (l3 != a3)
      throw new Error("Key binding " + s3 + " is used both as a regular binding and as a multi-stroke prefix");
  }, o3 = (s3, a3, l3, u3, c3) => {
    var f3, d3;
    let p10 = r3[s3] || (r3[s3] = /* @__PURE__ */ Object.create(null)), h10 = a3.split(/ (?!$)/).map((g) => DA(g, e3));
    for (let g = 1; g < h10.length; g++) {
      let v10 = h10.slice(0, g).join(" ");
      i3(v10, true), p10[v10] || (p10[v10] = {
        preventDefault: true,
        stopPropagation: false,
        run: [(S10) => {
          let $10 = Ji = { view: S10, prefix: v10, scope: s3 };
          return setTimeout(() => {
            Ji == $10 && (Ji = null);
          }, IA), true;
        }]
      });
    }
    let m10 = h10.join(" ");
    i3(m10, false);
    let O10 = p10[m10] || (p10[m10] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((d3 = (f3 = p10._any) === null || f3 === void 0 ? void 0 : f3.run) === null || d3 === void 0 ? void 0 : d3.slice()) || []
    });
    l3 && O10.run.push(l3), u3 && (O10.preventDefault = true), c3 && (O10.stopPropagation = true);
  };
  for (let s3 of t10) {
    let a3 = s3.scope ? s3.scope.split(" ") : ["editor"];
    if (s3.any)
      for (let u3 of a3) {
        let c3 = r3[u3] || (r3[u3] = /* @__PURE__ */ Object.create(null));
        c3._any || (c3._any = { preventDefault: false, stopPropagation: false, run: [] });
        for (let f3 in c3)
          c3[f3].run.push(s3.any);
      }
    let l3 = s3[e3] || s3.key;
    if (l3)
      for (let u3 of a3)
        o3(u3, l3, s3.run, s3.preventDefault, s3.stopPropagation), s3.shift && o3(u3, "Shift-" + l3, s3.shift, s3.preventDefault, s3.stopPropagation);
  }
  return r3;
}
function ZA(t10, e3, r3, n3) {
  let i3 = uR(e3), o3 = yc(i3, 0), s3 = Np(o3) == i3.length && i3 != " ", a3 = "", l3 = false, u3 = false, c3 = false;
  Ji && Ji.view == r3 && Ji.scope == n3 && (a3 = Ji.prefix + " ", $P.indexOf(e3.keyCode) < 0 && (u3 = true, Ji = null));
  let f3 = /* @__PURE__ */ new Set(), d3 = (O10) => {
    if (O10) {
      for (let g of O10.run)
        if (!f3.has(g) && (f3.add(g), g(r3, e3)))
          return O10.stopPropagation && (c3 = true), true;
      O10.preventDefault && (O10.stopPropagation && (c3 = true), u3 = true);
    }
    return false;
  }, p10 = t10[n3], h10, m10;
  return p10 && (d3(p10[a3 + Gu(i3, e3, !s3)]) ? l3 = true : s3 && (e3.altKey || e3.metaKey || e3.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(ke.windows && e3.ctrlKey && e3.altKey) && (h10 = co[e3.keyCode]) && h10 != i3 ? (d3(p10[a3 + Gu(h10, e3, true)]) || e3.shiftKey && (m10 = ql[e3.keyCode]) != i3 && m10 != h10 && d3(p10[a3 + Gu(m10, e3, false)])) && (l3 = true) : s3 && e3.shiftKey && d3(p10[a3 + Gu(i3, e3, true)]) && (l3 = true), !l3 && d3(p10._any) && (l3 = true)), u3 && (l3 = true), l3 && c3 && e3.stopPropagation(), l3;
}
function hv(t10, e3, r3, n3, i3) {
  e3.lastIndex = 0;
  for (let o3 = t10.iterRange(r3, n3), s3 = r3, a3; !o3.next().done; s3 += o3.value.length)
    if (!o3.lineBreak)
      for (; a3 = e3.exec(o3.value); )
        i3(s3 + a3.index, a3);
}
function WA(t10, e3) {
  let r3 = t10.visibleRanges;
  if (r3.length == 1 && r3[0].from == t10.viewport.from && r3[0].to == t10.viewport.to)
    return r3;
  let n3 = [];
  for (let { from: i3, to: o3 } of r3)
    i3 = Math.max(t10.state.doc.lineAt(i3).from, i3 - e3), o3 = Math.min(t10.state.doc.lineAt(o3).to, o3 + e3), n3.length && n3[n3.length - 1].to >= i3 ? n3[n3.length - 1].to = o3 : n3.push({ from: i3, to: o3 });
  return n3;
}
class VA {
  /**
  Create a decorator.
  */
  constructor(e3) {
    const { regexp: r3, decoration: n3, decorate: i3, boundary: o3, maxLength: s3 = 1e3 } = e3;
    if (!r3.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = r3, i3)
      this.addMatch = (a3, l3, u3, c3) => i3(c3, u3, u3 + a3[0].length, a3, l3);
    else if (typeof n3 == "function")
      this.addMatch = (a3, l3, u3, c3) => {
        let f3 = n3(a3, l3, u3);
        f3 && c3(u3, u3 + a3[0].length, f3);
      };
    else if (n3)
      this.addMatch = (a3, l3, u3, c3) => c3(u3, u3 + a3[0].length, n3);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = o3, this.maxLength = s3;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e3) {
    let r3 = new aa(), n3 = r3.add.bind(r3);
    for (let { from: i3, to: o3 } of WA(e3, this.maxLength))
      hv(e3.state.doc, this.regexp, i3, o3, (s3, a3) => this.addMatch(a3, e3, s3, n3));
    return r3.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e3, r3) {
    let n3 = 1e9, i3 = -1;
    return e3.docChanged && e3.changes.iterChanges((o3, s3, a3, l3) => {
      l3 > e3.view.viewport.from && a3 < e3.view.viewport.to && (n3 = Math.min(a3, n3), i3 = Math.max(l3, i3));
    }), e3.viewportChanged || i3 - n3 > 1e3 ? this.createDeco(e3.view) : i3 > -1 ? this.updateRange(e3.view, r3.map(e3.changes), n3, i3) : r3;
  }
  updateRange(e3, r3, n3, i3) {
    for (let o3 of e3.visibleRanges) {
      let s3 = Math.max(o3.from, n3), a3 = Math.min(o3.to, i3);
      if (a3 > s3) {
        let l3 = e3.state.doc.lineAt(s3), u3 = l3.to < a3 ? e3.state.doc.lineAt(a3) : l3, c3 = Math.max(o3.from, l3.from), f3 = Math.min(o3.to, u3.to);
        if (this.boundary) {
          for (; s3 > l3.from; s3--)
            if (this.boundary.test(l3.text[s3 - 1 - l3.from])) {
              c3 = s3;
              break;
            }
          for (; a3 < u3.to; a3++)
            if (this.boundary.test(u3.text[a3 - u3.from])) {
              f3 = a3;
              break;
            }
        }
        let d3 = [], p10, h10 = (m10, O10, g) => d3.push(g.range(m10, O10));
        if (l3 == u3)
          for (this.regexp.lastIndex = c3 - l3.from; (p10 = this.regexp.exec(l3.text)) && p10.index < f3 - l3.from; )
            this.addMatch(p10, e3, p10.index + l3.from, h10);
        else
          hv(e3.state.doc, this.regexp, c3, f3, (m10, O10) => this.addMatch(O10, e3, m10, h10));
        r3 = r3.update({ filterFrom: c3, filterTo: f3, filter: (m10, O10) => m10 < c3 || O10 > f3, add: d3 });
      }
    }
    return r3;
  }
}
class is extends rs {
  /**
  @internal
  */
  compare(e3) {
    return this == e3 || this.constructor == e3.constructor && this.eq(e3);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e3) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e3) {
  }
}
is.prototype.elementClass = "";
is.prototype.toDOM = void 0;
is.prototype.mapMode = kr.TrackBefore;
is.prototype.startSide = is.prototype.endSide = -1;
is.prototype.point = true;
const yh = /* @__PURE__ */ Me.define(), wc = /* @__PURE__ */ Me.define(), gO = /* @__PURE__ */ Me.define({
  combine: (t10) => t10.some((e3) => e3)
});
function YA(t10) {
  let e3 = [
    LA
  ];
  return t10 && t10.fixed === false && e3.push(gO.of(true)), e3;
}
const LA = /* @__PURE__ */ Xi.fromClass(class {
  constructor(t10) {
    this.view = t10, this.prevViewport = t10.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t10.state.facet(wc).map((e3) => new Ov(t10, e3));
    for (let e3 of this.gutters)
      this.dom.appendChild(e3.dom);
    this.fixed = !t10.state.facet(gO), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(false), t10.scrollDOM.insertBefore(this.dom, t10.contentDOM);
  }
  update(t10) {
    if (this.updateGutters(t10)) {
      let e3 = this.prevViewport, r3 = t10.view.viewport, n3 = Math.min(e3.to, r3.to) - Math.max(e3.from, r3.from);
      this.syncGutters(n3 < (r3.to - r3.from) * 0.8);
    }
    t10.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(gO) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t10.view.viewport;
  }
  syncGutters(t10) {
    let e3 = this.dom.nextSibling;
    t10 && this.dom.remove();
    let r3 = xt.iter(this.view.state.facet(yh), this.view.viewport.from), n3 = [], i3 = this.gutters.map((o3) => new BA(o3, this.view.viewport, -this.view.documentPadding.top));
    for (let o3 of this.view.viewportLineBlocks)
      if (n3.length && (n3 = []), Array.isArray(o3.type)) {
        let s3 = true;
        for (let a3 of o3.type)
          if (a3.type == Qn.Text && s3) {
            yO(r3, n3, a3.from);
            for (let l3 of i3)
              l3.line(this.view, a3, n3);
            s3 = false;
          } else if (a3.widget)
            for (let l3 of i3)
              l3.widget(this.view, a3);
      } else if (o3.type == Qn.Text) {
        yO(r3, n3, o3.from);
        for (let s3 of i3)
          s3.line(this.view, o3, n3);
      } else if (o3.widget)
        for (let s3 of i3)
          s3.widget(this.view, o3);
    for (let o3 of i3)
      o3.finish();
    t10 && this.view.scrollDOM.insertBefore(this.dom, e3);
  }
  updateGutters(t10) {
    let e3 = t10.startState.facet(wc), r3 = t10.state.facet(wc), n3 = t10.docChanged || t10.heightChanged || t10.viewportChanged || !xt.eq(t10.startState.facet(yh), t10.state.facet(yh), t10.view.viewport.from, t10.view.viewport.to);
    if (e3 == r3)
      for (let i3 of this.gutters)
        i3.update(t10) && (n3 = true);
    else {
      n3 = true;
      let i3 = [];
      for (let o3 of r3) {
        let s3 = e3.indexOf(o3);
        s3 < 0 ? i3.push(new Ov(this.view, o3)) : (this.gutters[s3].update(t10), i3.push(this.gutters[s3]));
      }
      for (let o3 of this.gutters)
        o3.dom.remove(), i3.indexOf(o3) < 0 && o3.destroy();
      for (let o3 of i3)
        this.dom.appendChild(o3.dom);
      this.gutters = i3;
    }
    return n3;
  }
  destroy() {
    for (let t10 of this.gutters)
      t10.destroy();
    this.dom.remove();
  }
}, {
  provide: (t10) => Be.scrollMargins.of((e3) => {
    let r3 = e3.plugin(t10);
    return !r3 || r3.gutters.length == 0 || !r3.fixed ? null : e3.textDirection == br.LTR ? { left: r3.dom.offsetWidth * e3.scaleX } : { right: r3.dom.offsetWidth * e3.scaleX };
  })
});
function pv(t10) {
  return Array.isArray(t10) ? t10 : [t10];
}
function yO(t10, e3, r3) {
  for (; t10.value && t10.from <= r3; )
    t10.from == r3 && e3.push(t10.value), t10.next();
}
class BA {
  constructor(e3, r3, n3) {
    this.gutter = e3, this.height = n3, this.i = 0, this.cursor = xt.iter(e3.markers, r3.from);
  }
  addElement(e3, r3, n3) {
    let { gutter: i3 } = this, o3 = r3.top - this.height;
    if (this.i == i3.elements.length) {
      let s3 = new qP(e3, r3.height, o3, n3);
      i3.elements.push(s3), i3.dom.appendChild(s3.dom);
    } else
      i3.elements[this.i].update(e3, r3.height, o3, n3);
    this.height = r3.bottom, this.i++;
  }
  line(e3, r3, n3) {
    let i3 = [];
    yO(this.cursor, i3, r3.from), n3.length && (i3 = i3.concat(n3));
    let o3 = this.gutter.config.lineMarker(e3, r3, i3);
    o3 && i3.unshift(o3);
    let s3 = this.gutter;
    i3.length == 0 && !s3.config.renderEmptyElements || this.addElement(e3, r3, i3);
  }
  widget(e3, r3) {
    let n3 = this.gutter.config.widgetMarker(e3, r3.widget, r3);
    n3 && this.addElement(e3, r3, [n3]);
  }
  finish() {
    let e3 = this.gutter;
    for (; e3.elements.length > this.i; ) {
      let r3 = e3.elements.pop();
      e3.dom.removeChild(r3.dom), r3.destroy();
    }
  }
}
class Ov {
  constructor(e3, r3) {
    this.view = e3, this.config = r3, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let n3 in r3.domEventHandlers)
      this.dom.addEventListener(n3, (i3) => {
        let o3 = i3.target, s3;
        if (o3 != this.dom && this.dom.contains(o3)) {
          for (; o3.parentNode != this.dom; )
            o3 = o3.parentNode;
          let l3 = o3.getBoundingClientRect();
          s3 = (l3.top + l3.bottom) / 2;
        } else
          s3 = i3.clientY;
        let a3 = e3.lineBlockAtHeight(s3 - e3.documentTop);
        r3.domEventHandlers[n3](e3, a3, i3) && i3.preventDefault();
      });
    this.markers = pv(r3.markers(e3)), r3.initialSpacer && (this.spacer = new qP(e3, 0, 0, [r3.initialSpacer(e3)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e3) {
    let r3 = this.markers;
    if (this.markers = pv(this.config.markers(e3.view)), this.spacer && this.config.updateSpacer) {
      let i3 = this.config.updateSpacer(this.spacer.markers[0], e3);
      i3 != this.spacer.markers[0] && this.spacer.update(e3.view, 0, 0, [i3]);
    }
    let n3 = e3.view.viewport;
    return !xt.eq(this.markers, r3, n3.from, n3.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e3) : false);
  }
  destroy() {
    for (let e3 of this.elements)
      e3.destroy();
  }
}
class qP {
  constructor(e3, r3, n3, i3) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e3, r3, n3, i3);
  }
  update(e3, r3, n3, i3) {
    this.height != r3 && (this.height = r3, this.dom.style.height = r3 / e3.scaleY + "px"), this.above != n3 && (this.dom.style.marginTop = (this.above = n3) ? n3 / e3.scaleY + "px" : ""), zA(this.markers, i3) || this.setMarkers(e3, i3);
  }
  setMarkers(e3, r3) {
    let n3 = "cm-gutterElement", i3 = this.dom.firstChild;
    for (let o3 = 0, s3 = 0; ; ) {
      let a3 = s3, l3 = o3 < r3.length ? r3[o3++] : null, u3 = false;
      if (l3) {
        let c3 = l3.elementClass;
        c3 && (n3 += " " + c3);
        for (let f3 = s3; f3 < this.markers.length; f3++)
          if (this.markers[f3].compare(l3)) {
            a3 = f3, u3 = true;
            break;
          }
      } else
        a3 = this.markers.length;
      for (; s3 < a3; ) {
        let c3 = this.markers[s3++];
        if (c3.toDOM) {
          c3.destroy(i3);
          let f3 = i3.nextSibling;
          i3.remove(), i3 = f3;
        }
      }
      if (!l3)
        break;
      l3.toDOM && (u3 ? i3 = i3.nextSibling : this.dom.insertBefore(l3.toDOM(e3), i3)), u3 && s3++;
    }
    this.dom.className = n3, this.markers = r3;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function zA(t10, e3) {
  if (t10.length != e3.length)
    return false;
  for (let r3 = 0; r3 < t10.length; r3++)
    if (!t10[r3].compare(e3[r3]))
      return false;
  return true;
}
const HA = /* @__PURE__ */ Me.define(), Ds = /* @__PURE__ */ Me.define({
  combine(t10) {
    return nR(t10, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e3, r3) {
        let n3 = Object.assign({}, e3);
        for (let i3 in r3) {
          let o3 = n3[i3], s3 = r3[i3];
          n3[i3] = o3 ? (a3, l3, u3) => o3(a3, l3, u3) || s3(a3, l3, u3) : s3;
        }
        return n3;
      }
    });
  }
});
class vh extends is {
  constructor(e3) {
    super(), this.number = e3;
  }
  eq(e3) {
    return this.number == e3.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function bh(t10, e3) {
  return t10.state.facet(Ds).formatNumber(e3, t10.state);
}
const GA = /* @__PURE__ */ wc.compute([Ds], (t10) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(e3) {
    return e3.state.facet(HA);
  },
  lineMarker(e3, r3, n3) {
    return n3.some((i3) => i3.toDOM) ? null : new vh(bh(e3, e3.state.doc.lineAt(r3.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e3) => e3.startState.facet(Ds) != e3.state.facet(Ds),
  initialSpacer(e3) {
    return new vh(bh(e3, mv(e3.state.doc.lines)));
  },
  updateSpacer(e3, r3) {
    let n3 = bh(r3.view, mv(r3.view.state.doc.lines));
    return n3 == e3.number ? e3 : new vh(n3);
  },
  domEventHandlers: t10.facet(Ds).domEventHandlers
}));
function KA(t10 = {}) {
  return [
    Ds.of(t10),
    YA(),
    GA
  ];
}
function mv(t10) {
  let e3 = 9;
  for (; e3 < t10; )
    e3 = e3 * 10 + 9;
  return e3;
}
var Sh;
const No = /* @__PURE__ */ new ut();
function Ag(t10) {
  return Me.define({
    combine: t10 ? (e3) => e3.concat(t10) : void 0
  });
}
const Xg = /* @__PURE__ */ new ut();
class cn {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e3, r3, n3 = [], i3 = "") {
    this.data = e3, this.name = i3, pt.prototype.hasOwnProperty("tree") || Object.defineProperty(pt.prototype, "tree", { get() {
      return tn(this);
    } }), this.parser = r3, this.extension = [
      fa.of(this),
      pt.languageData.of((o3, s3, a3) => {
        let l3 = gv(o3, s3, a3), u3 = l3.type.prop(No);
        if (!u3)
          return [];
        let c3 = o3.facet(u3), f3 = l3.type.prop(Xg);
        if (f3) {
          let d3 = l3.resolve(s3 - l3.from, a3);
          for (let p10 of f3)
            if (p10.test(d3, o3)) {
              let h10 = o3.facet(p10.facet);
              return p10.type == "replace" ? h10 : h10.concat(c3);
            }
        }
        return c3;
      })
    ].concat(n3);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e3, r3, n3 = -1) {
    return gv(e3, r3, n3).type.prop(No) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e3) {
    let r3 = e3.facet(fa);
    if ((r3 == null ? void 0 : r3.data) == this.data)
      return [{ from: 0, to: e3.doc.length }];
    if (!r3 || !r3.allowsNesting)
      return [];
    let n3 = [], i3 = (o3, s3) => {
      if (o3.prop(No) == this.data) {
        n3.push({ from: s3, to: s3 + o3.length });
        return;
      }
      let a3 = o3.prop(ut.mounted);
      if (a3) {
        if (a3.tree.prop(No) == this.data) {
          if (a3.overlay)
            for (let l3 of a3.overlay)
              n3.push({ from: l3.from + s3, to: l3.to + s3 });
          else
            n3.push({ from: s3, to: s3 + o3.length });
          return;
        } else if (a3.overlay) {
          let l3 = n3.length;
          if (i3(a3.tree, a3.overlay[0].from + s3), n3.length > l3)
            return;
        }
      }
      for (let l3 = 0; l3 < o3.children.length; l3++) {
        let u3 = o3.children[l3];
        u3 instanceof ft && i3(u3, o3.positions[l3] + s3);
      }
    };
    return i3(tn(e3), 0), n3;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
}
cn.setState = /* @__PURE__ */ Dt.define();
function gv(t10, e3, r3) {
  let n3 = t10.facet(fa), i3 = tn(t10).topNode;
  if (!n3 || n3.allowsNesting)
    for (let o3 = i3; o3; o3 = o3.enter(e3, r3, vt.ExcludeBuffers))
      o3.type.isTop && (i3 = o3);
  return i3;
}
class qi extends cn {
  constructor(e3, r3, n3) {
    super(e3, r3, [], n3), this.parser = r3;
  }
  /**
  Define a language from a parser.
  */
  static define(e3) {
    let r3 = Ag(e3.languageData);
    return new qi(r3, e3.parser.configure({
      props: [No.add((n3) => n3.isTop ? r3 : void 0)]
    }), e3.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e3, r3) {
    return new qi(this.data, this.parser.configure(e3), r3 || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function tn(t10) {
  let e3 = t10.field(cn.state, false);
  return e3 ? e3.tree : ft.empty;
}
class JA {
  /**
  Create an input object for the given document.
  */
  constructor(e3) {
    this.doc = e3, this.cursorPos = 0, this.string = "", this.cursor = e3.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e3) {
    return this.string = this.cursor.next(e3 - this.cursorPos).value, this.cursorPos = e3 + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e3) {
    return this.syncTo(e3), this.string;
  }
  get lineChunks() {
    return true;
  }
  read(e3, r3) {
    let n3 = this.cursorPos - this.string.length;
    return e3 < n3 || r3 >= this.cursorPos ? this.doc.sliceString(e3, r3) : this.string.slice(e3 - n3, r3 - n3);
  }
}
let Ya = null;
class ua {
  constructor(e3, r3, n3 = [], i3, o3, s3, a3, l3) {
    this.parser = e3, this.state = r3, this.fragments = n3, this.tree = i3, this.treeLen = o3, this.viewport = s3, this.skipped = a3, this.scheduleOn = l3, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e3, r3, n3) {
    return new ua(e3, r3, [], ft.empty, 0, n3, [], null);
  }
  startParse() {
    return this.parser.startParse(new JA(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e3, r3) {
    return r3 != null && r3 >= this.state.doc.length && (r3 = void 0), this.tree != ft.empty && this.isDone(r3 ?? this.state.doc.length) ? (this.takeTree(), true) : this.withContext(() => {
      var n3;
      if (typeof e3 == "number") {
        let i3 = Date.now() + e3;
        e3 = () => Date.now() > i3;
      }
      for (this.parse || (this.parse = this.startParse()), r3 != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > r3) && r3 < this.state.doc.length && this.parse.stopAt(r3); ; ) {
        let i3 = this.parse.advance();
        if (i3)
          if (this.fragments = this.withoutTempSkipped(Pi.addTree(i3, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (n3 = this.parse.stoppedAt) !== null && n3 !== void 0 ? n3 : this.state.doc.length, this.tree = i3, this.parse = null, this.treeLen < (r3 ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        if (e3())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e3, r3;
    this.parse && (e3 = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e3) && this.parse.stopAt(e3), this.withContext(() => {
      for (; !(r3 = this.parse.advance()); )
        ;
    }), this.treeLen = e3, this.tree = r3, this.fragments = this.withoutTempSkipped(Pi.addTree(this.tree, this.fragments, true)), this.parse = null);
  }
  withContext(e3) {
    let r3 = Ya;
    Ya = this;
    try {
      return e3();
    } finally {
      Ya = r3;
    }
  }
  withoutTempSkipped(e3) {
    for (let r3; r3 = this.tempSkipped.pop(); )
      e3 = yv(e3, r3.from, r3.to);
    return e3;
  }
  /**
  @internal
  */
  changes(e3, r3) {
    let { fragments: n3, tree: i3, treeLen: o3, viewport: s3, skipped: a3 } = this;
    if (this.takeTree(), !e3.empty) {
      let l3 = [];
      if (e3.iterChangedRanges((u3, c3, f3, d3) => l3.push({ fromA: u3, toA: c3, fromB: f3, toB: d3 })), n3 = Pi.applyChanges(n3, l3), i3 = ft.empty, o3 = 0, s3 = { from: e3.mapPos(s3.from, -1), to: e3.mapPos(s3.to, 1) }, this.skipped.length) {
        a3 = [];
        for (let u3 of this.skipped) {
          let c3 = e3.mapPos(u3.from, 1), f3 = e3.mapPos(u3.to, -1);
          c3 < f3 && a3.push({ from: c3, to: f3 });
        }
      }
    }
    return new ua(this.parser, r3, n3, i3, o3, s3, a3, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e3) {
    if (this.viewport.from == e3.from && this.viewport.to == e3.to)
      return false;
    this.viewport = e3;
    let r3 = this.skipped.length;
    for (let n3 = 0; n3 < this.skipped.length; n3++) {
      let { from: i3, to: o3 } = this.skipped[n3];
      i3 < e3.to && o3 > e3.from && (this.fragments = yv(this.fragments, i3, o3), this.skipped.splice(n3--, 1));
    }
    return this.skipped.length >= r3 ? false : (this.reset(), true);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e3, r3) {
    this.skipped.push({ from: e3, to: r3 });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e3) {
    return new class extends bg {
      createParse(r3, n3, i3) {
        let o3 = i3[0].from, s3 = i3[i3.length - 1].to;
        return {
          parsedPos: o3,
          advance() {
            let l3 = Ya;
            if (l3) {
              for (let u3 of i3)
                l3.tempSkipped.push(u3);
              e3 && (l3.scheduleOn = l3.scheduleOn ? Promise.all([l3.scheduleOn, e3]) : e3);
            }
            return this.parsedPos = s3, new ft($r.none, [], [], s3 - o3);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e3) {
    e3 = Math.min(e3, this.state.doc.length);
    let r3 = this.fragments;
    return this.treeLen >= e3 && r3.length && r3[0].from == 0 && r3[0].to >= e3;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Ya;
  }
}
function yv(t10, e3, r3) {
  return Pi.applyChanges(t10, [{ fromA: e3, toA: r3, fromB: e3, toB: r3 }]);
}
class ca {
  constructor(e3) {
    this.context = e3, this.tree = e3.tree;
  }
  apply(e3) {
    if (!e3.docChanged && this.tree == this.context.tree)
      return this;
    let r3 = this.context.changes(e3.changes, e3.state), n3 = this.context.treeLen == e3.startState.doc.length ? void 0 : Math.max(e3.changes.mapPos(this.context.treeLen), r3.viewport.to);
    return r3.work(20, n3) || r3.takeTree(), new ca(r3);
  }
  static init(e3) {
    let r3 = Math.min(3e3, e3.doc.length), n3 = ua.create(e3.facet(fa).parser, e3, { from: 0, to: r3 });
    return n3.work(20, r3) || n3.takeTree(), new ca(n3);
  }
}
cn.state = /* @__PURE__ */ vo.define({
  create: ca.init,
  update(t10, e3) {
    for (let r3 of e3.effects)
      if (r3.is(cn.setState))
        return r3.value;
    return e3.startState.facet(fa) != e3.state.facet(fa) ? ca.init(e3.state) : t10.apply(e3);
  }
});
let DP = (t10) => {
  let e3 = setTimeout(
    () => t10(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e3);
};
typeof requestIdleCallback < "u" && (DP = (t10) => {
  let e3 = -1, r3 = setTimeout(
    () => {
      e3 = requestIdleCallback(t10, {
        timeout: 500 - 100
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e3 < 0 ? clearTimeout(r3) : cancelIdleCallback(e3);
});
const $h = typeof navigator < "u" && (!((Sh = navigator.scheduling) === null || Sh === void 0) && Sh.isInputPending) ? () => navigator.scheduling.isInputPending() : null, e8 = /* @__PURE__ */ Xi.fromClass(class {
  constructor(e3) {
    this.view = e3, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e3) {
    let r3 = this.view.state.field(cn.state).context;
    (r3.updateViewport(e3.view.viewport) || this.view.viewport.to > r3.treeLen) && this.scheduleWork(), (e3.docChanged || e3.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(r3);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e3 } = this.view, r3 = e3.field(cn.state);
    (r3.tree != r3.context.tree || !r3.context.isDone(e3.doc.length)) && (this.working = DP(this.work));
  }
  work(e3) {
    this.working = null;
    let r3 = Date.now();
    if (this.chunkEnd < r3 && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = r3 + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: n3, viewport: { to: i3 } } = this.view, o3 = n3.field(cn.state);
    if (o3.tree == o3.context.tree && o3.context.isDone(
      i3 + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let s3 = Date.now() + Math.min(this.chunkBudget, 100, e3 && !$h ? Math.max(25, e3.timeRemaining() - 5) : 1e9), a3 = o3.context.treeLen < i3 && n3.doc.length > i3 + 1e3, l3 = o3.context.work(() => $h && $h() || Date.now() > s3, i3 + (a3 ? 0 : 1e5));
    this.chunkBudget -= Date.now() - r3, (l3 || this.chunkBudget <= 0) && (o3.context.takeTree(), this.view.dispatch({ effects: cn.setState.of(new ca(o3.context)) })), this.chunkBudget > 0 && !(l3 && !a3) && this.scheduleWork(), this.checkAsyncSchedule(o3.context);
  }
  checkAsyncSchedule(e3) {
    e3.scheduleOn && (this.workScheduled++, e3.scheduleOn.then(() => this.scheduleWork()).catch((r3) => zo(this.view.state, r3)).then(() => this.workScheduled--), e3.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), fa = /* @__PURE__ */ Me.define({
  combine(t10) {
    return t10.length ? t10[0] : null;
  },
  enables: (t10) => [
    cn.state,
    e8,
    Be.contentAttributes.compute([t10], (e3) => {
      let r3 = e3.facet(t10);
      return r3 && r3.name ? { "data-language": r3.name } : {};
    })
  ]
});
class _a {
  /**
  Create a language support object.
  */
  constructor(e3, r3 = []) {
    this.language = e3, this.support = r3, this.extension = [e3, r3];
  }
}
const t8 = /* @__PURE__ */ Me.define(), jP = /* @__PURE__ */ Me.define({
  combine: (t10) => {
    if (!t10.length)
      return "  ";
    let e3 = t10[0];
    if (!e3 || /\S/.test(e3) || Array.from(e3).some((r3) => r3 != e3[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t10[0]));
    return e3;
  }
});
function vO(t10) {
  let e3 = t10.facet(jP);
  return e3.charCodeAt(0) == 9 ? t10.tabSize * e3.length : e3.length;
}
const xa = /* @__PURE__ */ new ut();
function r8(t10) {
  let e3 = t10.node, r3 = e3.childAfter(e3.from), n3 = e3.lastChild;
  if (!r3)
    return null;
  let i3 = t10.options.simulateBreak, o3 = t10.state.doc.lineAt(r3.from), s3 = i3 == null || i3 <= o3.from ? o3.to : Math.min(o3.to, i3);
  for (let a3 = r3.to; ; ) {
    let l3 = e3.childAfter(a3);
    if (!l3 || l3 == n3)
      return null;
    if (!l3.type.isSkipped)
      return l3.from < s3 ? r3 : null;
    a3 = l3.to;
  }
}
function yl({ closing: t10, align: e3 = true, units: r3 = 1 }) {
  return (n3) => n8(n3, e3, r3, t10);
}
function n8(t10, e3, r3, n3, i3) {
  let o3 = t10.textAfter, s3 = o3.match(/^\s*/)[0].length, a3 = n3 && o3.slice(s3, s3 + n3.length) == n3 || i3 == t10.pos + s3, l3 = e3 ? r8(t10) : null;
  return l3 ? a3 ? t10.column(l3.from) : t10.column(l3.to) : t10.baseIndent + (a3 ? 0 : t10.unit * r3);
}
const UP = (t10) => t10.baseIndent;
function xi({ except: t10, units: e3 = 1 } = {}) {
  return (r3) => {
    let n3 = t10 && t10.test(r3.textAfter);
    return r3.baseIndent + (n3 ? 0 : e3 * r3.unit);
  };
}
const Qa = /* @__PURE__ */ new ut();
function cu(t10) {
  let e3 = t10.firstChild, r3 = t10.lastChild;
  return e3 && e3.to < r3.from ? { from: e3.to, to: r3.type.isError ? t10.to : r3.from } : null;
}
class ed {
  constructor(e3, r3) {
    this.specs = e3;
    let n3;
    function i3(a3) {
      let l3 = uo.newName();
      return (n3 || (n3 = /* @__PURE__ */ Object.create(null)))["." + l3] = a3, l3;
    }
    const o3 = typeof r3.all == "string" ? r3.all : r3.all ? i3(r3.all) : void 0, s3 = r3.scope;
    this.scope = s3 instanceof cn ? (a3) => a3.prop(No) == s3.data : s3 ? (a3) => a3 == s3 : void 0, this.style = d2(e3.map((a3) => ({
      tag: a3.tag,
      class: a3.class || i3(Object.assign({}, a3, { tag: null }))
    })), {
      all: o3
    }).style, this.module = n3 ? new uo(n3) : null, this.themeType = r3.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e3, r3) {
    return new ed(e3, r3 || {});
  }
}
const bO = /* @__PURE__ */ Me.define(), IP = /* @__PURE__ */ Me.define({
  combine(t10) {
    return t10.length ? [t10[0]] : null;
  }
});
function wh(t10) {
  let e3 = t10.facet(bO);
  return e3.length ? e3 : t10.facet(IP);
}
function i8(t10, e3) {
  let r3 = [s8], n3;
  return t10 instanceof ed && (t10.module && r3.push(Be.styleModule.of(t10.module)), n3 = t10.themeType), e3 != null && e3.fallback ? r3.push(IP.of(t10)) : n3 ? r3.push(bO.computeN([Be.darkTheme], (i3) => i3.facet(Be.darkTheme) == (n3 == "dark") ? [t10] : [])) : r3.push(bO.of(t10)), r3;
}
class o8 {
  constructor(e3) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = tn(e3.state), this.decorations = this.buildDeco(e3, wh(e3.state));
  }
  update(e3) {
    let r3 = tn(e3.state), n3 = wh(e3.state), i3 = n3 != wh(e3.startState);
    r3.length < e3.view.viewport.to && !i3 && r3.type == this.tree.type ? this.decorations = this.decorations.map(e3.changes) : (r3 != this.tree || e3.viewportChanged || i3) && (this.tree = r3, this.decorations = this.buildDeco(e3.view, n3));
  }
  buildDeco(e3, r3) {
    if (!r3 || !this.tree.length)
      return nr.none;
    let n3 = new aa();
    for (let { from: i3, to: o3 } of e3.visibleRanges)
      U4(this.tree, r3, (s3, a3, l3) => {
        n3.add(s3, a3, this.markCache[l3] || (this.markCache[l3] = nr.mark({ class: l3 })));
      }, i3, o3);
    return n3.finish();
  }
}
const s8 = /* @__PURE__ */ Bf.high(/* @__PURE__ */ Xi.fromClass(o8, {
  decorations: (t10) => t10.decorations
})), a8 = /* @__PURE__ */ new ut();
function vv(t10, e3, r3, n3 = 0, i3 = 0) {
  e3 == null && (e3 = t10.search(/[^\s\u00a0]/), e3 == -1 && (e3 = t10.length));
  let o3 = i3;
  for (let s3 = n3; s3 < e3; s3++)
    t10.charCodeAt(s3) == 9 ? o3 += r3 - o3 % r3 : o3++;
  return o3;
}
class FP {
  /**
  Create a stream.
  */
  constructor(e3, r3, n3, i3) {
    this.string = e3, this.tabSize = r3, this.indentUnit = n3, this.overrideIndent = i3, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(e3) {
    let r3 = this.string.charAt(this.pos), n3;
    if (typeof e3 == "string" ? n3 = r3 == e3 : n3 = r3 && (e3 instanceof RegExp ? e3.test(r3) : e3(r3)), n3)
      return ++this.pos, r3;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(e3) {
    let r3 = this.pos;
    for (; this.eat(e3); )
      ;
    return this.pos > r3;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let e3 = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e3;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(e3) {
    let r3 = this.string.indexOf(e3, this.pos);
    if (r3 > -1)
      return this.pos = r3, true;
  }
  /**
  Move back `n` characters.
  */
  backUp(e3) {
    this.pos -= e3;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = vv(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var e3;
    return (e3 = this.overrideIndent) !== null && e3 !== void 0 ? e3 : vv(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(e3, r3, n3) {
    if (typeof e3 == "string") {
      let i3 = (s3) => n3 ? s3.toLowerCase() : s3, o3 = this.string.substr(this.pos, e3.length);
      return i3(o3) == i3(e3) ? (r3 !== false && (this.pos += e3.length), true) : null;
    } else {
      let i3 = this.string.slice(this.pos).match(e3);
      return i3 && i3.index > 0 ? null : (i3 && r3 !== false && (this.pos += i3[0].length), i3);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function l8(t10) {
  return {
    name: t10.name || "",
    token: t10.token,
    blankLine: t10.blankLine || (() => {
    }),
    startState: t10.startState || (() => true),
    copyState: t10.copyState || u8,
    indent: t10.indent || (() => null),
    languageData: t10.languageData || {},
    tokenTable: t10.tokenTable || Dg
  };
}
function u8(t10) {
  if (typeof t10 != "object")
    return t10;
  let e3 = {};
  for (let r3 in t10) {
    let n3 = t10[r3];
    e3[r3] = n3 instanceof Array ? n3.slice() : n3;
  }
  return e3;
}
const bv = /* @__PURE__ */ new WeakMap();
class pr extends cn {
  constructor(e3) {
    let r3 = Ag(e3.languageData), n3 = l8(e3), i3, o3 = new class extends bg {
      createParse(s3, a3, l3) {
        return new f8(i3, s3, a3, l3);
      }
    }();
    super(r3, o3, [t8.of((s3, a3) => this.getIndent(s3, a3))], e3.name), this.topNode = p8(r3), i3 = this, this.streamParser = n3, this.stateAfter = new ut({ perNode: true }), this.tokenTable = e3.tokenTable ? new WP(n3.tokenTable) : h8;
  }
  /**
  Define a stream language.
  */
  static define(e3) {
    return new pr(e3);
  }
  getIndent(e3, r3) {
    let n3 = tn(e3.state), i3 = n3.resolve(r3);
    for (; i3 && i3.type != this.topNode; )
      i3 = i3.parent;
    if (!i3)
      return null;
    let o3, { overrideIndentation: s3 } = e3.options;
    s3 && (o3 = bv.get(e3.state), o3 != null && o3 < r3 - 1e4 && (o3 = void 0));
    let a3 = qg(this, n3, 0, i3.from, o3 ?? r3), l3, u3;
    if (a3 ? (u3 = a3.state, l3 = a3.pos + 1) : (u3 = this.streamParser.startState(e3.unit), l3 = 0), r3 - l3 > 1e4)
      return null;
    for (; l3 < r3; ) {
      let f3 = e3.state.doc.lineAt(l3), d3 = Math.min(r3, f3.to);
      if (f3.length) {
        let p10 = s3 ? s3(f3.from) : -1, h10 = new FP(f3.text, e3.state.tabSize, e3.unit, p10 < 0 ? void 0 : p10);
        for (; h10.pos < d3 - f3.from; )
          MP(this.streamParser.token, h10, u3);
      } else
        this.streamParser.blankLine(u3, e3.unit);
      if (d3 == r3)
        break;
      l3 = f3.to + 1;
    }
    let c3 = e3.lineAt(r3);
    return s3 && o3 == null && bv.set(e3.state, c3.from), this.streamParser.indent(u3, /^\s*(.*)/.exec(c3.text)[1], e3);
  }
  get allowsNesting() {
    return false;
  }
}
function qg(t10, e3, r3, n3, i3) {
  let o3 = r3 >= n3 && r3 + e3.length <= i3 && e3.prop(t10.stateAfter);
  if (o3)
    return { state: t10.streamParser.copyState(o3), pos: r3 + e3.length };
  for (let s3 = e3.children.length - 1; s3 >= 0; s3--) {
    let a3 = e3.children[s3], l3 = r3 + e3.positions[s3], u3 = a3 instanceof ft && l3 < i3 && qg(t10, a3, l3, n3, i3);
    if (u3)
      return u3;
  }
  return null;
}
function ZP(t10, e3, r3, n3, i3) {
  if (i3 && r3 <= 0 && n3 >= e3.length)
    return e3;
  !i3 && e3.type == t10.topNode && (i3 = true);
  for (let o3 = e3.children.length - 1; o3 >= 0; o3--) {
    let s3 = e3.positions[o3], a3 = e3.children[o3], l3;
    if (s3 < n3 && a3 instanceof ft) {
      if (!(l3 = ZP(t10, a3, r3 - s3, n3 - s3, i3)))
        break;
      return i3 ? new ft(e3.type, e3.children.slice(0, o3).concat(l3), e3.positions.slice(0, o3 + 1), s3 + l3.length) : l3;
    }
  }
  return null;
}
function c8(t10, e3, r3, n3) {
  for (let i3 of e3) {
    let o3 = i3.from + (i3.openStart ? 25 : 0), s3 = i3.to - (i3.openEnd ? 25 : 0), a3 = o3 <= r3 && s3 > r3 && qg(t10, i3.tree, 0 - i3.offset, r3, s3), l3;
    if (a3 && (l3 = ZP(t10, i3.tree, r3 + i3.offset, a3.pos + i3.offset, false)))
      return { state: a3.state, tree: l3 };
  }
  return { state: t10.streamParser.startState(n3 ? vO(n3) : 4), tree: ft.empty };
}
class f8 {
  constructor(e3, r3, n3, i3) {
    this.lang = e3, this.input = r3, this.fragments = n3, this.ranges = i3, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = i3[i3.length - 1].to;
    let o3 = ua.get(), s3 = i3[0].from, { state: a3, tree: l3 } = c8(e3, n3, s3, o3 == null ? void 0 : o3.state);
    this.state = a3, this.parsedPos = this.chunkStart = s3 + l3.length;
    for (let u3 = 0; u3 < l3.children.length; u3++)
      this.chunks.push(l3.children[u3]), this.chunkPos.push(l3.positions[u3]);
    o3 && this.parsedPos < o3.viewport.from - 1e5 && (this.state = this.lang.streamParser.startState(vO(o3.state)), o3.skipUntilInView(this.parsedPos, o3.viewport.from), this.parsedPos = o3.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let e3 = ua.get(), r3 = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), n3 = Math.min(
      r3,
      this.chunkStart + 2048
      /* C.ChunkSize */
    );
    for (e3 && (n3 = Math.min(n3, e3.viewport.to)); this.parsedPos < n3; )
      this.parseLine(e3);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= r3 ? this.finish() : e3 && this.parsedPos >= e3.viewport.to ? (e3.skipUntilInView(this.parsedPos, r3), this.finish()) : null;
  }
  stopAt(e3) {
    this.stoppedAt = e3;
  }
  lineAfter(e3) {
    let r3 = this.input.chunk(e3);
    if (this.input.lineChunks)
      r3 == `
` && (r3 = "");
    else {
      let n3 = r3.indexOf(`
`);
      n3 > -1 && (r3 = r3.slice(0, n3));
    }
    return e3 + r3.length <= this.to ? r3 : r3.slice(0, this.to - e3);
  }
  nextLine() {
    let e3 = this.parsedPos, r3 = this.lineAfter(e3), n3 = e3 + r3.length;
    for (let i3 = this.rangeIndex; ; ) {
      let o3 = this.ranges[i3].to;
      if (o3 >= n3 || (r3 = r3.slice(0, o3 - (n3 - r3.length)), i3++, i3 == this.ranges.length))
        break;
      let s3 = this.ranges[i3].from, a3 = this.lineAfter(s3);
      r3 += a3, n3 = s3 + a3.length;
    }
    return { line: r3, end: n3 };
  }
  skipGapsTo(e3, r3, n3) {
    for (; ; ) {
      let i3 = this.ranges[this.rangeIndex].to, o3 = e3 + r3;
      if (n3 > 0 ? i3 > o3 : i3 >= o3)
        break;
      let s3 = this.ranges[++this.rangeIndex].from;
      r3 += s3 - i3;
    }
    return r3;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(e3, r3, n3, i3, o3) {
    if (this.ranges.length > 1) {
      o3 = this.skipGapsTo(r3, o3, 1), r3 += o3;
      let s3 = this.chunk.length;
      o3 = this.skipGapsTo(n3, o3, -1), n3 += o3, i3 += this.chunk.length - s3;
    }
    return this.chunk.push(e3, r3, n3, i3), o3;
  }
  parseLine(e3) {
    let { line: r3, end: n3 } = this.nextLine(), i3 = 0, { streamParser: o3 } = this.lang, s3 = new FP(r3, e3 ? e3.state.tabSize : 4, e3 ? vO(e3.state) : 2);
    if (s3.eol())
      o3.blankLine(this.state, s3.indentUnit);
    else
      for (; !s3.eol(); ) {
        let a3 = MP(o3.token, s3, this.state);
        if (a3 && (i3 = this.emitToken(this.lang.tokenTable.resolve(a3), this.parsedPos + s3.start, this.parsedPos + s3.pos, 4, i3)), s3.start > 1e4)
          break;
      }
    this.parsedPos = n3, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e3 = ft.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: d8,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused
    });
    e3 = new ft(e3.type, e3.children, e3.positions, e3.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(e3), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new ft(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}
function MP(t10, e3, r3) {
  e3.start = e3.pos;
  for (let n3 = 0; n3 < 10; n3++) {
    let i3 = t10(e3, r3);
    if (e3.pos > e3.start)
      return i3;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const Dg = /* @__PURE__ */ Object.create(null), Il = [$r.none], d8 = /* @__PURE__ */ new Lf(Il), Sv = [], NP = /* @__PURE__ */ Object.create(null);
for (let [t10, e3] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  NP[t10] = /* @__PURE__ */ VP(Dg, e3);
class WP {
  constructor(e3) {
    this.extra = e3, this.table = Object.assign(/* @__PURE__ */ Object.create(null), NP);
  }
  resolve(e3) {
    return e3 ? this.table[e3] || (this.table[e3] = VP(this.extra, e3)) : 0;
  }
}
const h8 = /* @__PURE__ */ new WP(Dg);
function Ph(t10, e3) {
  Sv.indexOf(t10) > -1 || (Sv.push(t10), console.warn(e3));
}
function VP(t10, e3) {
  let r3 = null;
  for (let o3 of e3.split(".")) {
    let s3 = t10[o3] || R[o3];
    s3 ? typeof s3 == "function" ? r3 ? r3 = s3(r3) : Ph(o3, `Modifier ${o3} used at start of tag`) : r3 ? Ph(o3, `Tag ${o3} used as modifier`) : r3 = s3 : Ph(o3, `Unknown highlighting tag ${o3}`);
  }
  if (!r3)
    return 0;
  let n3 = e3.replace(/ /g, "_"), i3 = $r.define({
    id: Il.length,
    name: n3,
    props: [Os({ [n3]: r3 })]
  });
  return Il.push(i3), i3.id;
}
function p8(t10) {
  let e3 = $r.define({ id: Il.length, name: "Document", props: [No.add(() => t10)], top: true });
  return Il.push(e3), e3;
}
let _h = null;
function xh() {
  if (!_h && typeof document == "object" && document.body) {
    let { style: t10 } = document.body, e3 = [], r3 = /* @__PURE__ */ new Set();
    for (let n3 in t10)
      n3 != "cssText" && n3 != "cssFloat" && typeof t10[n3] == "string" && (/[A-Z]/.test(n3) && (n3 = n3.replace(/[A-Z]/g, (i3) => "-" + i3.toLowerCase())), r3.has(n3) || (e3.push(n3), r3.add(n3)));
    _h = e3.sort().map((n3) => ({ type: "property", label: n3 }));
  }
  return _h || [];
}
const $v = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((t10) => ({ type: "class", label: t10 })), wv = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((t10) => ({ type: "keyword", label: t10 })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((t10) => ({ type: "constant", label: t10 }))), O8 = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((t10) => ({ type: "type", label: t10 })), Vi = /^(\w[\w-]*|-\w[\w-]*|)$/, m8 = /^-(-[\w-]*)?$/;
function g8(t10, e3) {
  var r3;
  if ((t10.name == "(" || t10.type.isError) && (t10 = t10.parent || t10), t10.name != "ArgList")
    return false;
  let n3 = (r3 = t10.parent) === null || r3 === void 0 ? void 0 : r3.firstChild;
  return (n3 == null ? void 0 : n3.name) != "Callee" ? false : e3.sliceString(n3.from, n3.to) == "var";
}
const Pv = /* @__PURE__ */ new vg(), y8 = ["Declaration"];
function v8(t10) {
  for (let e3 = t10; ; ) {
    if (e3.type.isTop)
      return e3;
    if (!(e3 = e3.parent))
      return t10;
  }
}
function YP(t10, e3, r3) {
  if (e3.to - e3.from > 4096) {
    let n3 = Pv.get(e3);
    if (n3)
      return n3;
    let i3 = [], o3 = /* @__PURE__ */ new Set(), s3 = e3.cursor(vt.IncludeAnonymous);
    if (s3.firstChild())
      do
        for (let a3 of YP(t10, s3.node, r3))
          o3.has(a3.label) || (o3.add(a3.label), i3.push(a3));
      while (s3.nextSibling());
    return Pv.set(e3, i3), i3;
  } else {
    let n3 = [], i3 = /* @__PURE__ */ new Set();
    return e3.cursor().iterate((o3) => {
      var s3;
      if (r3(o3) && o3.matchContext(y8) && ((s3 = o3.node.nextSibling) === null || s3 === void 0 ? void 0 : s3.name) == ":") {
        let a3 = t10.sliceString(o3.from, o3.to);
        i3.has(a3) || (i3.add(a3), n3.push({ label: a3, type: "variable" }));
      }
    }), n3;
  }
}
const b8 = (t10) => (e3) => {
  let { state: r3, pos: n3 } = e3, i3 = tn(r3).resolveInner(n3, -1), o3 = i3.type.isError && i3.from == i3.to - 1 && r3.doc.sliceString(i3.from, i3.to) == "-";
  if (i3.name == "PropertyName" || (o3 || i3.name == "TagName") && /^(Block|Styles)$/.test(i3.resolve(i3.to).name))
    return { from: i3.from, options: xh(), validFor: Vi };
  if (i3.name == "ValueName")
    return { from: i3.from, options: wv, validFor: Vi };
  if (i3.name == "PseudoClassName")
    return { from: i3.from, options: $v, validFor: Vi };
  if (t10(i3) || (e3.explicit || o3) && g8(i3, r3.doc))
    return {
      from: t10(i3) || o3 ? i3.from : n3,
      options: YP(r3.doc, v8(i3), t10),
      validFor: m8
    };
  if (i3.name == "TagName") {
    for (let { parent: l3 } = i3; l3; l3 = l3.parent)
      if (l3.name == "Block")
        return { from: i3.from, options: xh(), validFor: Vi };
    return { from: i3.from, options: O8, validFor: Vi };
  }
  if (!e3.explicit)
    return null;
  let s3 = i3.resolve(n3), a3 = s3.childBefore(n3);
  return a3 && a3.name == ":" && s3.name == "PseudoClassSelector" ? { from: n3, options: $v, validFor: Vi } : a3 && a3.name == ":" && s3.name == "Declaration" || s3.name == "ArgList" ? { from: n3, options: wv, validFor: Vi } : s3.name == "Block" || s3.name == "Styles" ? { from: n3, options: xh(), validFor: Vi } : null;
}, S8 = /* @__PURE__ */ b8((t10) => t10.name == "VariableName"), lf = /* @__PURE__ */ qi.define({
  name: "css",
  parser: /* @__PURE__ */ ZC.configure({
    props: [
      /* @__PURE__ */ xa.add({
        Declaration: /* @__PURE__ */ xi()
      }),
      /* @__PURE__ */ Qa.add({
        "Block KeyframeList": cu
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function $8() {
  return new _a(lf, lf.data.of({ autocomplete: S8 }));
}
const w8 = 303, _v = 1, P8 = 2, _8 = 304, x8 = 306, Q8 = 307, T8 = 3, k8 = 4, E8 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], LP = 125, C8 = 59, xv = 47, R8 = 42, A8 = 43, X8 = 45, q8 = new Sg({
  start: false,
  shift(t10, e3) {
    return e3 == T8 || e3 == k8 || e3 == x8 ? t10 : e3 == Q8;
  },
  strict: false
}), D8 = new Wr((t10, e3) => {
  let { next: r3 } = t10;
  (r3 == LP || r3 == -1 || e3.context) && t10.acceptToken(_8);
}, { contextual: true, fallback: true }), j8 = new Wr((t10, e3) => {
  let { next: r3 } = t10, n3;
  E8.indexOf(r3) > -1 || r3 == xv && ((n3 = t10.peek(1)) == xv || n3 == R8) || r3 != LP && r3 != C8 && r3 != -1 && !e3.context && t10.acceptToken(w8);
}, { contextual: true }), U8 = new Wr((t10, e3) => {
  let { next: r3 } = t10;
  if ((r3 == A8 || r3 == X8) && (t10.advance(), r3 == t10.next)) {
    t10.advance();
    let n3 = !e3.context && e3.canShift(_v);
    t10.acceptToken(n3 ? _v : P8);
  }
}, { contextual: true }), I8 = Os({
  "get set async static": R.modifier,
  "for while do if else switch try catch finally return throw break continue default case": R.controlKeyword,
  "in of await yield void typeof delete instanceof": R.operatorKeyword,
  "let var const function class extends": R.definitionKeyword,
  "import export from": R.moduleKeyword,
  "with debugger as new": R.keyword,
  TemplateString: R.special(R.string),
  super: R.atom,
  BooleanLiteral: R.bool,
  this: R.self,
  null: R.null,
  Star: R.modifier,
  VariableName: R.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": R.function(R.variableName),
  VariableDefinition: R.definition(R.variableName),
  Label: R.labelName,
  PropertyName: R.propertyName,
  PrivatePropertyName: R.special(R.propertyName),
  "CallExpression/MemberExpression/PropertyName": R.function(R.propertyName),
  "FunctionDeclaration/VariableDefinition": R.function(R.definition(R.variableName)),
  "ClassDeclaration/VariableDefinition": R.definition(R.className),
  PropertyDefinition: R.definition(R.propertyName),
  PrivatePropertyDefinition: R.definition(R.special(R.propertyName)),
  UpdateOp: R.updateOperator,
  LineComment: R.lineComment,
  BlockComment: R.blockComment,
  Number: R.number,
  String: R.string,
  Escape: R.escape,
  ArithOp: R.arithmeticOperator,
  LogicOp: R.logicOperator,
  BitOp: R.bitwiseOperator,
  CompareOp: R.compareOperator,
  RegExp: R.regexp,
  Equals: R.definitionOperator,
  Arrow: R.function(R.punctuation),
  ": Spread": R.punctuation,
  "( )": R.paren,
  "[ ]": R.squareBracket,
  "{ }": R.brace,
  "InterpolationStart InterpolationEnd": R.special(R.brace),
  ".": R.derefOperator,
  ", ;": R.separator,
  "@": R.meta,
  TypeName: R.typeName,
  TypeDefinition: R.definition(R.typeName),
  "type enum interface implements namespace module declare": R.definitionKeyword,
  "abstract global Privacy readonly override": R.modifier,
  "is keyof unique infer": R.operatorKeyword,
  JSXAttributeValue: R.attributeValue,
  JSXText: R.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": R.angleBracket,
  "JSXIdentifier JSXNameSpacedName": R.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": R.attributeName,
  "JSXBuiltin/JSXIdentifier": R.standard(R.tagName)
}), F8 = { __proto__: null, export: 14, as: 19, from: 27, default: 30, async: 35, function: 36, extends: 46, this: 50, true: 58, false: 58, null: 70, void: 74, typeof: 78, super: 96, new: 130, delete: 146, yield: 155, await: 159, class: 164, public: 221, private: 221, protected: 221, readonly: 223, instanceof: 242, satisfies: 245, in: 246, const: 248, import: 280, keyof: 335, unique: 339, infer: 345, is: 381, abstract: 401, implements: 403, type: 405, let: 408, var: 410, using: 413, interface: 419, enum: 423, namespace: 429, module: 431, declare: 435, global: 439, for: 458, of: 467, while: 470, with: 474, do: 478, if: 482, else: 484, switch: 488, case: 494, try: 500, catch: 504, finally: 508, return: 512, throw: 516, break: 520, continue: 524, debugger: 528 }, Z8 = { __proto__: null, async: 117, get: 119, set: 121, declare: 181, public: 183, private: 183, protected: 183, static: 185, abstract: 187, override: 189, readonly: 195, accessor: 197, new: 385 }, M8 = { __proto__: null, "<": 137 }, N8 = Ci.deserialize({
  version: 14,
  states: "$6tO`QUOOO%TQUOOO'WQWOOP(eOSOOO*sQ(CjO'#CfO*zOpO'#CgO+YO!bO'#CgO+hO07`O'#DZO-yQUO'#DaO.ZQUO'#DlO%TQUO'#DvO0_QUO'#EOOOQ(CY'#EW'#EWO0xQSO'#ETOOQO'#Ei'#EiOOQO'#Ic'#IcO1QQSO'#GkO1]QSO'#EhO1bQSO'#EhO3dQ(CjO'#JdO6TQ(CjO'#JeO6qQSO'#FWO6vQ#tO'#FoOOQ(CY'#F`'#F`O7RO&jO'#F`O7aQ,UO'#FvO8wQSO'#FuOOQ(CY'#Je'#JeOOQ(CW'#Jd'#JdO8|QSO'#GoOOQQ'#KP'#KPO9XQSO'#IPO9^Q(C[O'#IQOOQQ'#JQ'#JQOOQQ'#IU'#IUQ`QUOOO%TQUO'#DnO9fQUO'#DzO9mQUO'#D|O9SQSO'#GkO9tQ,UO'#ClO:SQSO'#EgO:_QSO'#ErO:dQ,UO'#F_O;RQSO'#GkOOQO'#KQ'#KQO;WQSO'#KQO;fQSO'#GsO;fQSO'#GtO;fQSO'#GvO9SQSO'#GyO<]QSO'#G|O=tQSO'#CbO>UQSO'#HYO>^QSO'#H`O>^QSO'#HbO`QUO'#HdO>^QSO'#HfO>^QSO'#HiO>cQSO'#HoO>hQ(C]O'#HuO%TQUO'#HwO>sQ(C]O'#HyO?OQ(C]O'#H{O9^Q(C[O'#H}O?ZQ(CjO'#CfO@]QWO'#DfQOQSOOO%TQUO'#D|O@sQSO'#EPO9tQ,UO'#EgOAOQSO'#EgOAZQ`O'#F_OOQQ'#Cd'#CdOOQ(CW'#Dk'#DkOOQ(CW'#Jh'#JhO%TQUO'#JhOOQO'#Jl'#JlOOQO'#I`'#I`OBZQWO'#E`OOQ(CW'#E_'#E_OCVQ(C`O'#E`OCaQWO'#ESOOQO'#Jk'#JkOCuQWO'#JlOESQWO'#ESOCaQWO'#E`PEaO?MpO'#C`POOO)CDo)CDoOOOO'#IV'#IVOElOpO,59ROOQ(CY,59R,59ROOOO'#IW'#IWOEzO!bO,59RO%TQUO'#D]OOOO'#IY'#IYOFYO07`O,59uOOQ(CY,59u,59uOFhQUO'#IZOF{QSO'#JfOH}QbO'#JfO+vQUO'#JfOIUQSO,59{OIlQSO'#EiOIyQSO'#JtOJUQSO'#JsOJUQSO'#JsOJ^QSO,5;VOJcQSO'#JrOOQ(CY,5:W,5:WOJjQUO,5:WOLkQ(CjO,5:bOM[QSO,5:jOMuQ(C[O'#JqOM|QSO'#JpO8|QSO'#JpONbQSO'#JpONjQSO,5;UONoQSO'#JpO!!wQbO'#JeOOQ(CY'#Cf'#CfO%TQUO'#EOO!#gQ`O,5:oOOQO'#Jm'#JmOOQO-E<a-E<aO9SQSO,5=VO!#}QSO,5=VO!$SQUO,5;SO!&VQ,UO'#EdO!'jQSO,5;SO!)SQ,UO'#DpO!)ZQUO'#DuO!)eQWO,5;]O!)mQWO,5;]O%TQUO,5;]OOQQ'#FO'#FOOOQQ'#FQ'#FQO%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^OOQQ'#FU'#FUO!){QUO,5;oOOQ(CY,5;t,5;tOOQ(CY,5;u,5;uO!,OQSO,5;uOOQ(CY,5;v,5;vO%TQUO'#IgO!,WQ(C[O,5<cO!&VQ,UO,5;^O!,uQ,UO,5;^O%TQUO,5;rO!,|Q#tO'#FeO!-yQ#tO'#JxO!-eQ#tO'#JxO!.QQ#tO'#JxOOQO'#Jx'#JxO!.fQ#tO,5;}OOOO,5<Z,5<ZO!.wQUO'#FqOOOO'#If'#IfO7RO&jO,5;zO!/OQ#tO'#FsOOQ(CY,5;z,5;zO!/oQ7[O'#CrOOQ(CY'#Cv'#CvO!0SQSO'#CvO!0XO07`O'#CzO!0uQ,UO,5<`O!0|QSO,5<bO!2cQMhO'#GQO!2pQSO'#GRO!2uQSO'#GRO!2zQMhO'#GVO!3yQWO'#GZO!4lQ7[O'#J_OOQ(CY'#J_'#J_O!4vQSO'#J^O!5UQSO'#J]O!5^QSO'#CqOOQ(CY'#Ct'#CtOOQ(CY'#DO'#DOOOQ(CY'#DQ'#DQO0{QSO'#DSO!'oQ,UO'#FxO!'oQ,UO'#FzO!5fQSO'#F|O!5kQSO'#F}O!2uQSO'#GTO!'oQ,UO'#GYO!5pQSO'#EjO!6_QSO,5<aOOQ(CW'#Co'#CoO!6gQSO'#EkO!7aQWO'#ElOOQ(CW'#Jr'#JrO!7hQ(C[O'#KRO9^Q(C[O,5=ZO`QUO,5>kOOQQ'#JY'#JYOOQQ,5>l,5>lOOQQ-E<S-E<SO!9jQ(CjO,5:YO!<WQ(CjO,5:fO%TQUO,5:fO!>qQ(CjO,5:hOOQO,5@l,5@lO!?bQ,UO,5=VO!?pQ(C[O'#JZO8wQSO'#JZO!@RQ(C[O,59WO!@^QWO,59WO!@fQ,UO,59WO9tQ,UO,59WO!@qQSO,5;SO!@yQSO'#HXO!A[QSO'#KUO%TQUO,5;wO!7[QWO,5;yO!AdQSO,5=rO!AiQSO,5=rO!AnQSO,5=rO9^Q(C[O,5=rO;fQSO,5=bOOQO'#Cr'#CrO!A|QWO,5=_O!BUQ,UO,5=`O!BaQSO,5=bO!BfQ`O,5=eO!BnQSO'#KQO>cQSO'#HOO9SQSO'#HQO!BsQSO'#HQO9tQ,UO'#HSO!BxQSO'#HSOOQQ,5=h,5=hO!B}QSO'#HTO!CVQSO'#ClO!C[QSO,58|O!CfQSO,58|O!EkQUO,58|OOQQ,58|,58|O!E{Q(C[O,58|O%TQUO,58|O!HWQUO'#H[OOQQ'#H]'#H]OOQQ'#H^'#H^O`QUO,5=tO!HnQSO,5=tO`QUO,5=zO`QUO,5=|O!HsQSO,5>OO`QUO,5>QO!HxQSO,5>TO!H}QUO,5>ZOOQQ,5>a,5>aO%TQUO,5>aO9^Q(C[O,5>cOOQQ,5>e,5>eO!MXQSO,5>eOOQQ,5>g,5>gO!MXQSO,5>gOOQQ,5>i,5>iO!M^QWO'#DXO%TQUO'#JhO!M{QWO'#JhO!NjQWO'#DgO!N{QWO'#DgO##^QUO'#DgO##eQSO'#JgO##mQSO,5:QO##rQSO'#EmO#$QQSO'#JuO#$YQSO,5;WO#$_QWO'#DgO#$lQWO'#EROOQ(CY,5:k,5:kO%TQUO,5:kO#$sQSO,5:kO>cQSO,5;RO!@^QWO,5;RO!@fQ,UO,5;RO9tQ,UO,5;RO#${QSO,5@SO#%QQ!LQO,5:oOOQO-E<^-E<^O#&WQ(C`O,5:zOCaQWO,5:nO#&bQWO,5:nOCaQWO,5:zO!@RQ(C[O,5:nOOQ(CW'#Ec'#EcOOQO,5:z,5:zO%TQUO,5:zO#&oQ(C[O,5:zO#&zQ(C[O,5:zO!@^QWO,5:nOOQO,5;Q,5;QO#'YQ(C[O,5:zPOOO'#IT'#ITP#'nO?MpO,58zPOOO,58z,58zOOOO-E<T-E<TOOQ(CY1G.m1G.mOOOO-E<U-E<UO#'yQ`O,59wOOOO-E<W-E<WOOQ(CY1G/a1G/aO#(OQbO,5>uO+vQUO,5>uOOQO,5>{,5>{O#(YQUO'#IZOOQO-E<X-E<XO#(gQSO,5@QO#(oQbO,5@QO#(vQSO,5@_OOQ(CY1G/g1G/gO%TQUO,5@`O#)OQSO'#IaOOQO-E<_-E<_O#(vQSO,5@_OOQ(CW1G0q1G0qOOQ(CY1G/r1G/rOOQ(CY1G0U1G0UO%TQUO,5@]O#)dQ(C[O,5@]O#)uQ(C[O,5@]O#)|QSO,5@[O8|QSO,5@[O#*UQSO,5@[O#*dQSO'#IdO#)|QSO,5@[OOQ(CW1G0p1G0pO!)eQWO,5:qO!)pQWO,5:qOOQO,5:s,5:sO#+UQSO,5:sO#+^Q,UO1G2qO9SQSO1G2qOOQ(CY1G0n1G0nO#+lQ(CjO1G0nO#,qQ(ChO,5;OOOQ(CY'#GP'#GPO#-_Q(CjO'#J_O!$SQUO1G0nO#/gQ,UO'#JiO#/qQSO,5:[O#/vQbO'#JjO%TQUO'#JjO#0QQSO,5:aOOQ(CY'#DX'#DXOOQ(CY1G0w1G0wO%TQUO1G0wOOQ(CY1G1a1G1aO#0VQSO1G0wO#2nQ(CjO1G0xO#2uQ(CjO1G0xO#5`Q(CjO1G0xO#5gQ(CjO1G0xO#7qQ(CjO1G0xO#8XQ(CjO1G0xO#;RQ(CjO1G0xO#;YQ(CjO1G0xO#=sQ(CjO1G0xO#=zQ(CjO1G0xO#?rQ(CjO1G0xO#BrQ$IUO'#CfO#DpQ$IUO1G1ZO#DwQ$IUO'#JeO!,RQSO1G1aO#EXQ(CjO,5?ROOQ(CW-E<e-E<eO#E{Q(CjO1G0xOOQ(CY1G0x1G0xO#HWQ(CjO1G1^O#HzQ#tO,5<RO#ISQ#tO,5<SO#I[Q#tO'#FjO#IsQSO'#FiOOQO'#Jy'#JyOOQO'#Ie'#IeO#IxQ#tO1G1iOOQ(CY1G1i1G1iOOOO1G1t1G1tO#JZQ$IUO'#JdO#JeQSO,5<]O!){QUO,5<]OOOO-E<d-E<dOOQ(CY1G1f1G1fO#JjQWO'#JxOOQ(CY,5<_,5<_O#JrQWO,5<_OOQ(CY,59b,59bO!&VQ,UO'#C|OOOO'#IX'#IXO#JwO07`O,59fOOQ(CY,59f,59fO%TQUO1G1zO!5kQSO'#IiO#KSQ,UO,5<sOOQ(CY,5<p,5<pOOQO'#Gf'#GfO!'oQ,UO,5=POOQO'#Gh'#GhO!'oQ,UO,5=RO!&VQ,UO,5=TOOQO1G1|1G1|O#KZQ`O'#CoO#KnQ`O,5<lO#KuQSO'#J|O9SQSO'#J|O#LTQSO,5<nO!'oQ,UO,5<mO#LYQSO'#GSO#LeQSO,5<mO#LjQ`O'#GPO#LwQ`O'#J}O#MRQSO'#J}O!&VQ,UO'#J}O#MWQSO,5<qO#M]QWO'#G[O!3tQWO'#G[O#MnQSO'#G^O#MsQSO'#G`O!2uQSO'#GcO#MxQ(C[O'#IkO#NTQWO,5<uOOQ(CY,5<u,5<uO#N[QWO'#G[O#NjQWO'#G]O#NrQWO'#G]OOQ(CY,5=U,5=UO!'oQ,UO,5?xO!'oQ,UO,5?xO#NwQSO'#IlO$ SQSO,5?wO$ [QSO,59]O$ {Q,UO,59nOOQ(CY,59n,59nO$!nQ,UO,5<dO$#aQ,UO,5<fO@TQSO,5<hOOQ(CY,5<i,5<iO$#kQSO,5<oO$#pQ,UO,5<tO$$QQSO'#JpO!$SQUO1G1{O$$VQSO1G1{O8|QSO'#JsO8|QSO'#EmO%TQUO'#EmO8|QSO'#InO$$[Q(C[O,5@mOOQQ1G2u1G2uOOQQ1G4V1G4VOOQ(CY1G/t1G/tO!,OQSO1G/tO$&aQ(CjO1G0QOOQQ1G2q1G2qO!&VQ,UO1G2qO%TQUO1G2qO$'QQSO1G2qO$']Q,UO'#EdOOQ(CW,5?u,5?uO$'gQ(C[O,5?uOOQQ1G.r1G.rO!@RQ(C[O1G.rO!@^QWO1G.rO!@fQ,UO1G.rO$'xQSO1G0nO$'}QSO'#CfO$(YQSO'#KVO$(bQSO,5=sO$(gQSO'#KVO$(lQSO'#KVO$(wQSO'#ItO$)VQSO,5@pO$)_QbO1G1cOOQ(CY1G1e1G1eO9SQSO1G3^O@TQSO1G3^O$)fQSO1G3^O$)kQSO1G3^OOQQ1G3^1G3^O!BaQSO1G2|O!&VQ,UO1G2yO$)pQSO1G2yOOQQ1G2z1G2zO!&VQ,UO1G2zO$)uQSO1G2zO$)}QWO'#GxOOQQ1G2|1G2|O!3tQWO'#IpO!BfQ`O1G3POOQQ1G3P1G3POOQQ,5=j,5=jO$*VQ,UO,5=lO9SQSO,5=lO#MsQSO,5=nO8wQSO,5=nO!@^QWO,5=nO!@fQ,UO,5=nO9tQ,UO,5=nO$*eQSO'#KTO$*pQSO,5=oOOQQ1G.h1G.hO$*uQ(C[O1G.hO@TQSO1G.hO$+QQSO1G.hO9^Q(C[O1G.hO$-VQbO,5@rO$-gQSO,5@rO8|QSO,5@rO$-rQUO,5=vO$-yQSO,5=vOOQQ1G3`1G3`O`QUO1G3`OOQQ1G3f1G3fOOQQ1G3h1G3hO>^QSO1G3jO$.OQUO1G3lO$2SQUO'#HkOOQQ1G3o1G3oO$2aQSO'#HqO>cQSO'#HsOOQQ1G3u1G3uO$2iQUO1G3uO9^Q(C[O1G3{OOQQ1G3}1G3}OOQ(CW'#GW'#GWO9^Q(C[O1G4PO9^Q(C[O1G4RO$6pQSO,5@SO!){QUO,5;XO8|QSO,5;XO>cQSO,5:RO!){QUO,5:RO!@^QWO,5:RO$6uQ$IUO,5:ROOQO,5;X,5;XO$7PQWO'#I[O$7gQSO,5@ROOQ(CY1G/l1G/lO$7oQWO'#IbO$7yQSO,5@aOOQ(CW1G0r1G0rO!N{QWO,5:ROOQO'#I_'#I_O$8RQWO,5:mOOQ(CY,5:m,5:mO#$vQSO1G0VOOQ(CY1G0V1G0VO%TQUO1G0VOOQ(CY1G0m1G0mO>cQSO1G0mO!@^QWO1G0mO!@fQ,UO1G0mOOQ(CW1G5n1G5nO!@RQ(C[O1G0YOOQO1G0f1G0fO%TQUO1G0fO$8YQ(C[O1G0fO$8eQ(C[O1G0fO!@^QWO1G0YOCaQWO1G0YO$8sQ(C[O1G0fOOQO1G0Y1G0YO$9XQ(CjO1G0fPOOO-E<R-E<RPOOO1G.f1G.fOOOO1G/c1G/cO$9cQ`O,5<cO$9kQbO1G4aOOQO1G4g1G4gO%TQUO,5>uO$9uQSO1G5lO$9}QSO1G5yO$:VQbO1G5zO8|QSO,5>{O$:aQ(CjO1G5wO%TQUO1G5wO$:qQ(C[O1G5wO$;SQSO1G5vO$;SQSO1G5vO8|QSO1G5vO$;[QSO,5?OO8|QSO,5?OOOQO,5?O,5?OO$;pQSO,5?OO$$QQSO,5?OOOQO-E<b-E<bOOQO1G0]1G0]OOQO1G0_1G0_O!,RQSO1G0_OOQQ7+(]7+(]O!&VQ,UO7+(]O%TQUO7+(]O$<OQSO7+(]O$<ZQ,UO7+(]O$<iQ(CjO,59nO$>qQ(CjO,5<dO$@|Q(CjO,5<fO$CXQ(CjO,5<tOOQ(CY7+&Y7+&YO$EjQ(CjO7+&YO$F^Q,UO'#I]O$FhQSO,5@TOOQ(CY1G/v1G/vO$FpQUO'#I^O$F}QSO,5@UO$GVQbO,5@UOOQ(CY1G/{1G/{O$GaQSO7+&cOOQ(CY7+&c7+&cO$GfQ$IUO,5:bO%TQUO7+&uO$GpQ$IUO,5:YO$G}Q$IUO,5:fO$HXQ$IUO,5:hOOQ(CY7+&{7+&{OOQO1G1m1G1mOOQO1G1n1G1nO$HcQ#tO,5<UO!){QUO,5<TOOQO-E<c-E<cOOQ(CY7+'T7+'TOOOO7+'`7+'`OOOO1G1w1G1wO$HnQSO1G1wOOQ(CY1G1y1G1yO$HsQ`O,59hOOOO-E<V-E<VOOQ(CY1G/Q1G/QO$HzQ(CjO7+'fOOQ(CY,5?T,5?TO$InQ`O,5?TOOQ(CY1G2_1G2_P!&VQ,UO'#IiPOQ(CY-E<g-E<gO$J^Q,UO1G2kO$KPQ,UO1G2mO$KZQ`O1G2oOOQ(CY1G2W1G2WO$KbQSO'#IhO$KpQSO,5@hO$KpQSO,5@hO$KxQSO,5@hO$LTQSO,5@hOOQO1G2Y1G2YO$LcQ,UO1G2XO!'oQ,UO1G2XO$LsQMhO'#IjO$MTQSO,5@iO!&VQ,UO,5@iO$M]Q`O,5@iOOQ(CY1G2]1G2]OOQ(CW,5<v,5<vOOQ(CW,5<w,5<wO$$QQSO,5<wOCQQSO,5<wO!@^QWO,5<vOOQO'#G_'#G_O$MgQSO,5<xOOQ(CW,5<z,5<zO$$QQSO,5<}OOQO,5?V,5?VOOQO-E<i-E<iOOQ(CY1G2a1G2aO!3tQWO,5<vO$MoQSO,5<wO#MnQSO,5<xO!3tQWO,5<wO$MzQ,UO1G5dO$NUQ,UO1G5dOOQO,5?W,5?WOOQO-E<j-E<jOOQO1G.w1G.wO!7[QWO,59pO%TQUO,59pO$NcQSO1G2SO!'oQ,UO1G2ZO$NhQ(CjO7+'gOOQ(CY7+'g7+'gO!$SQUO7+'gO% [QSO,5;XOOQ(CW,5?Y,5?YOOQ(CW-E<l-E<lOOQ(CY7+%`7+%`O% aQ`O'#KOO#$vQSO7+(]O% kQbO7+(]O$<RQSO7+(]O% rQ(ChO'#CfO%!VQ(ChO,5<{O%!wQSO,5<{OOQ(CW1G5a1G5aOOQQ7+$^7+$^O!@RQ(C[O7+$^O!@^QWO7+$^O!$SQUO7+&YO%!|QSO'#IsO%#bQSO,5@qOOQO1G3_1G3_O9SQSO,5@qO%#bQSO,5@qO%#jQSO,5@qOOQO,5?`,5?`OOQO-E<r-E<rOOQ(CY7+&}7+&}O%#oQSO7+(xO9^Q(C[O7+(xO9SQSO7+(xO@TQSO7+(xOOQQ7+(h7+(hO%#tQ(ChO7+(eO!&VQ,UO7+(eO%$OQ`O7+(fOOQQ7+(f7+(fO!&VQ,UO7+(fO%$VQSO'#KSO%$bQSO,5=dOOQO,5?[,5?[OOQO-E<n-E<nOOQQ7+(k7+(kO%%qQWO'#HROOQQ1G3W1G3WO!&VQ,UO1G3WO%TQUO1G3WO%%xQSO1G3WO%&TQ,UO1G3WO9^Q(C[O1G3YO#MsQSO1G3YO8wQSO1G3YO!@^QWO1G3YO!@fQ,UO1G3YO%&cQSO'#IrO%&nQSO,5@oO%&vQWO,5@oOOQ(CW1G3Z1G3ZOOQQ7+$S7+$SO@TQSO7+$SO9^Q(C[O7+$SO%'RQSO7+$SO%TQUO1G6^O%TQUO1G6_O%'WQ(C[O1G6^O%'bQUO1G3bO%'iQSO1G3bO%'nQUO1G3bOOQQ7+(z7+(zO9^Q(C[O7+)UO`QUO7+)WOOQQ'#KY'#KYOOQQ'#Iu'#IuO%'uQUO,5>VOOQQ,5>V,5>VO%TQUO'#HlO%(SQSO'#HnOOQQ,5>],5>]O8|QSO,5>]OOQQ,5>_,5>_OOQQ7+)a7+)aOOQQ7+)g7+)gOOQQ7+)k7+)kOOQQ7+)m7+)mO%(XQWO1G5nO%(mQ$IUO1G0sO%(wQSO1G0sOOQO1G/m1G/mO%)SQ$IUO1G/mO>cQSO1G/mO!){QUO'#DgOOQO,5>v,5>vOOQO-E<Y-E<YOOQO,5>|,5>|OOQO-E<`-E<`O!@^QWO1G/mOOQO-E<]-E<]OOQ(CY1G0X1G0XOOQ(CY7+%q7+%qO#$vQSO7+%qOOQ(CY7+&X7+&XO>cQSO7+&XO!@^QWO7+&XOOQO7+%t7+%tO$9XQ(CjO7+&QOOQO7+&Q7+&QO%TQUO7+&QO%)^Q(C[O7+&QO!@RQ(C[O7+%tO!@^QWO7+%tO%)iQ(C[O7+&QO%)wQ(CjO7++cO%TQUO7++cO%*XQSO7++bO%*XQSO7++bOOQO1G4j1G4jO8|QSO1G4jO%*aQSO1G4jOOQO7+%y7+%yO#$vQSO<<KwO% kQbO<<KwO%*oQSO<<KwOOQQ<<Kw<<KwO!&VQ,UO<<KwO%TQUO<<KwO%*wQSO<<KwO%+SQ(CjO1G2kO%-_Q(CjO1G2mO%/jQ(CjO1G2XO%1{Q,UO,5>wOOQO-E<Z-E<ZO%2VQbO,5>xO%TQUO,5>xOOQO-E<[-E<[O%2aQSO1G5pOOQ(CY<<I}<<I}O%2iQ$IUO1G0nO%4sQ$IUO1G0xO%4zQ$IUO1G0xO%7OQ$IUO1G0xO%7VQ$IUO1G0xO%8zQ$IUO1G0xO%9bQ$IUO1G0xO%;uQ$IUO1G0xO%;|Q$IUO1G0xO%>QQ$IUO1G0xO%>XQ$IUO1G0xO%@PQ$IUO1G0xO%@dQ(CjO<<JaO%AiQ$IUO1G0xO%C_Q$IUO'#J_O%EbQ$IUO1G1^O%EoQ$IUO1G0QO!){QUO'#FlOOQO'#Jz'#JzOOQO1G1p1G1pO%EyQSO1G1oO%FOQ$IUO,5?ROOOO7+'c7+'cOOOO1G/S1G/SOOQ(CY1G4o1G4oO!'oQ,UO7+(ZO%FYQSO,5?SO9SQSO,5?SOOQO-E<f-E<fO%FhQSO1G6SO%FhQSO1G6SO%FpQSO1G6SO%F{Q,UO7+'sO%G]Q`O,5?UO%GgQSO,5?UO!&VQ,UO,5?UOOQO-E<h-E<hO%GlQ`O1G6TO%GvQSO1G6TOOQ(CW1G2c1G2cO$$QQSO1G2cOOQ(CW1G2b1G2bO%HOQSO1G2dO!&VQ,UO1G2dOOQ(CW1G2i1G2iO!@^QWO1G2bOCQQSO1G2cO%HTQSO1G2dO%H]QSO1G2cO!'oQ,UO7++OOOQ(CY1G/[1G/[O%HhQSO1G/[OOQ(CY7+'n7+'nO%HmQ,UO7+'uO%H}Q(CjO<<KROOQ(CY<<KR<<KRO%IqQSO1G0sO!&VQ,UO'#ImO%IvQSO,5@jO!&VQ,UO1G2gOOQQ<<Gx<<GxO!@RQ(C[O<<GxO%JOQ(CjO<<ItOOQ(CY<<It<<ItOOQO,5?_,5?_O%JrQSO,5?_O$(lQSO,5?_OOQO-E<q-E<qO%JwQSO1G6]O%JwQSO1G6]O9SQSO1G6]O@TQSO<<LdOOQQ<<Ld<<LdO%KPQSO<<LdO9^Q(C[O<<LdOOQQ<<LP<<LPO%#tQ(ChO<<LPOOQQ<<LQ<<LQO%$OQ`O<<LQO%KUQWO'#IoO%KaQSO,5@nO!){QUO,5@nOOQQ1G3O1G3OO%KiQUO'#JhOOQO'#Iq'#IqO9^Q(C[O'#IqO%KsQWO,5=mOOQQ,5=m,5=mO%KzQWO'#E`O%L`QSO7+(rO%LeQSO7+(rOOQQ7+(r7+(rO!&VQ,UO7+(rO%TQUO7+(rO%LmQSO7+(rOOQQ7+(t7+(tO9^Q(C[O7+(tO#MsQSO7+(tO8wQSO7+(tO!@^QWO7+(tO%LxQSO,5?^OOQO-E<p-E<pOOQO'#HU'#HUO%MTQSO1G6ZO9^Q(C[O<<GnOOQQ<<Gn<<GnO@TQSO<<GnO%M]QSO7++xO%MbQSO7++yO%TQUO7++xO%TQUO7++yOOQQ7+(|7+(|O%MgQSO7+(|O%MlQUO7+(|O%MsQSO7+(|OOQQ<<Lp<<LpOOQQ<<Lr<<LrOOQQ-E<s-E<sOOQQ1G3q1G3qO%MxQSO,5>WOOQQ,5>Y,5>YO%M}QSO1G3wO8|QSO7+&_O!){QUO7+&_OOQO7+%X7+%XO%NSQ$IUO1G5zO>cQSO7+%XOOQ(CY<<I]<<I]OOQ(CY<<Is<<IsO>cQSO<<IsOOQO<<Il<<IlO$9XQ(CjO<<IlO%TQUO<<IlOOQO<<I`<<I`O!@RQ(C[O<<I`O%N^Q(C[O<<IlO%NiQ(CjO<<N}O%NyQSO<<N|OOQO7+*U7+*UO8|QSO7+*UOOQQANAcANAcO& RQSOANAcO!&VQ,UOANAcO#$vQSOANAcO% kQbOANAcO%TQUOANAcO& ZQ(CjO7+'sO&#lQ(CjO7+'uO&%}QbO1G4dO&&XQ$IUO7+&YO&&fQ$IUO,59nO&(iQ$IUO,5<dO&*lQ$IUO,5<fO&,oQ$IUO,5<tO&.eQ$IUO7+'fO&.rQ$IUO7+'gO&/PQSO,5<WOOQO7+'Z7+'ZO&/UQ,UO<<KuOOQO1G4n1G4nO&/]QSO1G4nO&/hQSO1G4nO&/vQSO7++nO&/vQSO7++nO!&VQ,UO1G4pO&0OQ`O1G4pO&0YQSO7++oOOQ(CW7+'}7+'}O$$QQSO7+(OO&0bQ`O7+(OOOQ(CW7+'|7+'|O$$QQSO7+'}O&0iQSO7+(OO!&VQ,UO7+(OOCQQSO7+'}O&0nQ,UO<<NjOOQ(CY7+$v7+$vO&0xQ`O,5?XOOQO-E<k-E<kO&1SQ(ChO7+(ROOQQAN=dAN=dO9SQSO1G4yOOQO1G4y1G4yO&1dQSO1G4yO&1iQSO7++wO&1iQSO7++wO9^Q(C[OANBOO@TQSOANBOOOQQANBOANBOOOQQANAkANAkOOQQANAlANAlO&1qQSO,5?ZOOQO-E<m-E<mO&1|Q$IUO1G6YO&4^QbO'#CfOOQO,5?],5?]OOQO-E<o-E<oOOQQ1G3X1G3XO%KiQUO,5<xOOQQ<<L^<<L^O!&VQ,UO<<L^O%L`QSO<<L^O&4hQSO<<L^O%TQUO<<L^OOQQ<<L`<<L`O9^Q(C[O<<L`O#MsQSO<<L`O8wQSO<<L`O&4pQWO1G4xO&4{QSO7++uOOQQAN=YAN=YO9^Q(C[OAN=YOOQQ<= d<= dOOQQ<= e<= eO&5TQSO<= dO&5YQSO<= eOOQQ<<Lh<<LhO&5_QSO<<LhO&5dQUO<<LhOOQQ1G3r1G3rO>cQSO7+)cO&5kQSO<<IyO&5vQ$IUO<<IyOOQO<<Hs<<HsOOQ(CYAN?_AN?_OOQOAN?WAN?WO$9XQ(CjOAN?WOOQOAN>zAN>zO%TQUOAN?WOOQO<<Mp<<MpOOQQG26}G26}O!&VQ,UOG26}O#$vQSOG26}O&6QQSOG26}O% kQbOG26}O&6YQ$IUO<<JaO&6gQ$IUO1G2XO&8]Q$IUO1G2kO&:`Q$IUO1G2mO&<cQ$IUO<<KRO&<pQ$IUO<<ItOOQO1G1r1G1rO!'oQ,UOANAaOOQO7+*Y7+*YO&<}QSO7+*YO&=YQSO<= YO&=bQ`O7+*[OOQ(CW<<Kj<<KjO$$QQSO<<KjOOQ(CW<<Ki<<KiO&=lQ`O<<KjO$$QQSO<<KiOOQO7+*e7+*eO9SQSO7+*eO&=sQSO<= cOOQQG27jG27jO9^Q(C[OG27jO!){QUO1G4uO&={QSO7++tO%L`QSOANAxOOQQANAxANAxO!&VQ,UOANAxO&>TQSOANAxOOQQANAzANAzO9^Q(C[OANAzO#MsQSOANAzOOQO'#HV'#HVOOQO7+*d7+*dOOQQG22tG22tOOQQANEOANEOOOQQANEPANEPOOQQANBSANBSO&>]QSOANBSOOQQ<<L}<<L}O!){QUOAN?eOOQOG24rG24rO$9XQ(CjOG24rO#$vQSOLD,iOOQQLD,iLD,iO!&VQ,UOLD,iO&>bQSOLD,iO&>jQ$IUO7+'sO&@`Q$IUO7+'uO&BUQ,UOG26{OOQO<<Mt<<MtOOQ(CWANAUANAUO$$QQSOANAUOOQ(CWANATANATOOQO<<NP<<NPOOQQLD-ULD-UO&BfQ$IUO7+*aOOQQG27dG27dO%L`QSOG27dO!&VQ,UOG27dOOQQG27fG27fO9^Q(C[OG27fOOQQG27nG27nO&BpQ$IUOG25POOQOLD*^LD*^OOQQ!$(!T!$(!TO#$vQSO!$(!TO!&VQ,UO!$(!TO&BzQ(CjOG26{OOQ(CWG26pG26pOOQQLD-OLD-OO%L`QSOLD-OOOQQLD-QLD-QOOQQ!)9Eo!)9EoO#$vQSO!)9EoOOQQ!$(!j!$(!jOOQQ!.K;Z!.K;ZO&E]Q$IUOG26{O!){QUO'#DvO0xQSO'#ETO&GRQbO'#JdO!){QUO'#DnO&GYQUO'#DzO&GaQbO'#CfO&IwQbO'#CfO!){QUO'#D|O&JXQUO,5;SO!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO'#IgO&L[QSO,5<cO&LdQ,UO,5;^O&MwQ,UO,5;^O!){QUO,5;rO0{QSO'#DSO0{QSO'#DSO!&VQ,UO'#FxO&LdQ,UO'#FxO!&VQ,UO'#FzO&LdQ,UO'#FzO!&VQ,UO'#GYO&LdQ,UO'#GYO!){QUO,5:fO!){QUO,5@`O&JXQUO1G0nO&NOQ$IUO'#CfO!){QUO1G1zO!&VQ,UO,5=PO&LdQ,UO,5=PO!&VQ,UO,5=RO&LdQ,UO,5=RO!&VQ,UO,5<mO&LdQ,UO,5<mO&JXQUO1G1{O!){QUO7+&uO!&VQ,UO1G2XO&LdQ,UO1G2XO!&VQ,UO1G2ZO&LdQ,UO1G2ZO&JXQUO7+'gO&JXQUO7+&YO!&VQ,UOANAaO&LdQ,UOANAaO&NYQSO'#EhO&N_QSO'#EhO&NgQSO'#FWO&NlQSO'#ErO&NqQSO'#JtO&N|QSO'#JrO' XQSO,5;SO' ^Q,UO,5<`O' eQSO'#GRO' jQSO'#GRO' oQSO,5<aO' wQSO,5;SO'!PQ$IUO1G1ZO'!WQSO,5<mO'!]QSO,5<mO'!bQSO,5<oO'!gQSO,5<oO'!lQSO1G1{O'!qQSO1G0nO'!vQ,UO<<KuO'!}Q,UO<<KuO7aQ,UO'#FvO8wQSO'#FuOAOQSO'#EgO!){QUO,5;oO!2uQSO'#GRO!2uQSO'#GRO!2uQSO'#GTO!2uQSO'#GTO!'oQ,UO7+(ZO!'oQ,UO7+(ZO$KZQ`O1G2oO$KZQ`O1G2oO!&VQ,UO,5=TO!&VQ,UO,5=T",
  stateData: "'$W~O'nOS'oOSROS'pRQ~OPYOQYOV!UO^qOayObxOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!ctO!hZO!kYO!lYO!mYO!ouO!qvO!twO!x]O#p!OO$Q{O$UfO%`|O%b!PO%d}O%e}O%f}O%i!QO%k!RO%n!SO%o!SO%q!TO%}!VO&T!WO&V!XO&X!YO&Z!ZO&^![O&d!]O&j!^O&l!_O&n!`O&p!aO&r!bO'uSO'wTO'zUO(SVO(b[O(oiO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'u!cO'wTO'zUO(SVO(b[O(oiO~O^!uOl!mO|!nO![!wO!]!tO!^!tO!x9qO!|!oO!}!oO#O!vO#P!oO#Q!oO#T!xO#U!xO'v!kO'wTO'zUO(V!lO(b!rO~O'p!yO~OPYXXYX^YXkYXyYXzYX|YX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX'lYX(SYX(cYX(jYX(kYX~O!a$zX~P(jO[!{O'w!}O'x!{O'y!}O~O[#OO'y!}O'z!}O'{#OO~Oq#QO!O#RO(T#RO(U#TO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'u9uO'wTO'zUO(SVO(b[O(oiO~O!U#XO!V#UO!S(YP!S(gP~P+vO!W#aO~P`OPYOQYOa!iOb!hOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'wTO'zUO(SVO(b[O(oiO~Oi#kO!U#gO!x]O#b#jO#c#gO'u9vO!g(dP~P.bO!h#mO'u#lO~O!t#qO!x]O%`#rO~O#d#sO~O!a#tO#d#sO~OP$[OX$cOk$POy#xOz#yO|#zO!V$`O!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO#v$XO(SVO(c$YO(j#{O(k#|O~O^(WX'l(WX'j(WX!g(WX!S(WX!X(WX%a(WX!a(WX~P1jO#X$dO#{$dOP(XXX(XXk(XXy(XXz(XX|(XX!V(XX!e(XX!h(XX!l(XX#g(XX#h(XX#i(XX#j(XX#k(XX#l(XX#m(XX#n(XX#o(XX#q(XX#s(XX#u(XX#v(XX(S(XX(c(XX(j(XX(k(XX!X(XX%a(XX~O^(XX!f(XX'l(XX'j(XX!S(XX!g(XXo(XX!a(XX~P4QO#X$dO~O$W$fO$Y$eO$a$kO~O!X$lO$UfO$d$mO$f$oO~Oi%ROk$sOl$rOm$rOs%SOu%TOw%UO|$zO!X${O!c%ZO!h$wO#c%[O$Q%XO$m%VO$o%WO$r%YO'u$qO'wTO'zUO(O%QO(S$tOd(PP~O!h%]O~O|%`O!X%aO'u%_O~O!a%eO~O^%fO'l%fO~O'v!kO~P%TO%f%mO~P%TO!h%]O'u%_O'v!kO(O%QO~Ob%tO!h%]O'u%_O~O#o$RO~Oy%yO!X%vO!h%xO%b%|O'u%_O'v!kO'wTO'zUO](xP~O!t#qO~O%k&OO|(tX!X(tX'u(tX~O'u&PO~O!q&UO#p!OO%b!PO%d}O%e}O%f}O%i!QO%k!RO%n!SO%o!SO~Oa&ZOb&YO!t&WO%`&XO%s&VO~P;kOa&^ObxO!X&]O!q&UO!twO!x]O#p!OO%`|O%d}O%e}O%f}O%i!QO%k!RO%n!SO%o!SO%q!TO~O_&aO#X&dO%b&_O'v!kO~P<pO!h&eO!q&iO~O!h#mO~O!XXO~O^%fO'k&qO'l%fO~O^%fO'k&tO'l%fO~O^%fO'k&vO'l%fO~O'jYX!SYXoYX!gYX&RYX!XYX%aYX!aYX~P(jO!['TO!]&|O!^&|O'v!kO'wTO'zUO~Ol&zO|&yO!U&}O(V&xO!W(ZP!W(iP~P?wOg'WO!X'UO'u%_O~Ob']O!h%]O'u%_O~Oy%yO!h%xO~Ol!mO|!nO!x9qO!|!oO!}!oO#P!oO#Q!oO'v!kO'wTO'zUO(V!lO(b!rO~O!['cO!]'bO!^'bO#O!oO#T'dO#U'dO~PAcO^%fO!a#tO!h%]O'l%fO(O%QO(c'fO~O!l'jO#X'hO~PBqOl!mO|!nO'wTO'zUO(V!lO(b!rO~O!XXOl(`X|(`X![(`X!](`X!^(`X!x(`X!|(`X!}(`X#O(`X#P(`X#Q(`X#T(`X#U(`X'v(`X'w(`X'z(`X(V(`X(b(`X~O!]'bO!^'bO'v!kO~PCaO'q'nO'r'nO's'pO~O[!{O'w'rO'x!{O'y'rO~O[#OO'y'rO'z'rO'{#OO~Oq#QO!O#RO(T#RO(U'vO~O!U'xO!S&}X!S'TX!V&}X!V'TX~P+vO!V'zO!S(YX~OP$[OX$cOk$POy#xOz#yO|#zO!V'zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO#v$XO(SVO(c$YO(j#{O(k#|O~O!S(YX~PGTO!S(PO~O!S(fX!V(fX!a(fX!g(fX(c(fX~O#X(fX#d#]X!W(fX~PIZO#X(QO!S(hX!V(hX~O!V(RO!S(gX~O!S(UO~O#X$dO~PIZO!W(VO~P`Oy#xOz#yO|#zO!f#vO!h#wO(SVOP!jaX!jak!ja!V!ja!e!ja!l!ja#g!ja#h!ja#i!ja#j!ja#k!ja#l!ja#m!ja#n!ja#o!ja#q!ja#s!ja#u!ja#v!ja(c!ja(j!ja(k!ja~O^!ja'l!ja'j!ja!S!ja!g!jao!ja!X!ja%a!ja!a!ja~PJqO!g(WO~O!a#tO#X(XO(c'fO!V(eX^(eX'l(eX~O!g(eX~PMaO|%`O!X%aO!x]O#b(^O#c(]O'u%_O~O!V(_O!g(dX~O!g(aO~O|%`O!X%aO#c(]O'u%_O~OP(XXX(XXk(XXy(XXz(XX|(XX!V(XX!e(XX!f(XX!h(XX!l(XX#g(XX#h(XX#i(XX#j(XX#k(XX#l(XX#m(XX#n(XX#o(XX#q(XX#s(XX#u(XX#v(XX(S(XX(c(XX(j(XX(k(XX~O!a#tO!g(XX~PN}Oy(bOz(cO!f#vO!h#wO!x!wa|!wa~O!t!wa%`!wa!X!wa#b!wa#c!wa'u!wa~P!#RO!t(gO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'u!cO'wTO'zUO(SVO(b[O(oiO~Oi%ROk$sOl$rOm$rOs%SOu%TOw:ZO|$zO!X${O!c;eO!h$wO#c:aO$Q%XO$m:]O$o:_O$r%YO'u(kO'wTO'zUO(O%QO(S$tO~O#d(mO~Oi%ROk$sOl$rOm$rOs%SOu%TOw%UO|$zO!X${O!c%ZO!h$wO#c%[O$Q%XO$m%VO$o%WO$r%YO'u(kO'wTO'zUO(O%QO(S$tO~Od(]P~P!'oO!U(qO!g(^P~P%TO(V(sO(b[O~O|(uO!h#wO(V(sO(b[O~OP9pOQ9pOa;aOb!hOikOk9pOlkOmkOskOu9pOw9pO|WO!QkO!RkO!X!dO!c9sO!hZO!k9pO!l9pO!m9pO!o9tO!q9wO!t!gO$Q!jO$UfO'u)TO'wTO'zUO(SVO(b[O(o;_O~Oz)WO!h#wO~O!V$`O^$ka'l$ka'j$ka!g$ka!S$ka!X$ka%a$ka!a$ka~O#p)[O~P!&VOy)_O!a)^O!X$XX$T$XX$W$XX$Y$XX$a$XX~O!a)^O!X(lX$T(lX$W(lX$Y(lX$a(lX~Oy)_O~P!-eOy)_O!X(lX$T(lX$W(lX$Y(lX$a(lX~O!X)aO$T)eO$W)`O$Y)`O$a)fO~O!U)iO~P!){O$W$fO$Y$eO$a)mO~Og$sXy$sX|$sX!f$sX(j$sX(k$sX~OdfXd$sXgfX!VfX#XfX~P!/ZOl)oO~Oq)pO(T)qO(U)sO~Og)|Oy)uO|)vO(j)xO(k)zO~Od)tO~P!0dOd)}O~Oi%ROk$sOl$rOm$rOs%SOu%TOw:ZO|$zO!X${O!c;eO!h$wO#c:aO$Q%XO$m:]O$o:_O$r%YO'wTO'zUO(O%QO(S$tO~O!U*RO'u*OO!g(pP~P!1RO#d*TO~O!h*UO~O!U*ZO'u*WO!S(qP~P!1ROk*gO|*_O![*eO!]*^O!^*^O!h*UO#T*fO%W*aO'v!kO(V!lO~O!W*dO~P!3XO!f#vOg(RXy(RX|(RX(j(RX(k(RX!V(RX#X(RX~Od(RX#y(RX~P!4QOg*jO#X*iOd(QX!V(QX~O!V*kOd(PX~O'u&POd(PP~O!h*rO~O'u(kO~Oi*vO|%`O!U#gO!X%aO!x]O#b#jO#c#gO'u%_O!g(dP~O!a#tO#d*wO~O|%`O!U*yO!V(RO!X%aO'u%_O!S(gP~Ol'QO|*{O!U*zO'wTO'zUO(V(sO~O!W(iP~P!6{O!V*|O^(uX'l(uX~OP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO#v$XO(SVO(c$YO(j#{O(k#|O~O^!ba!V!ba'l!ba'j!ba!S!ba!g!bao!ba!X!ba%a!ba!a!ba~P!7sOy#xOz#yO|#zO!f#vO!h#wO(SVOP!naX!nak!na!V!na!e!na!l!na#g!na#h!na#i!na#j!na#k!na#l!na#m!na#n!na#o!na#q!na#s!na#u!na#v!na(c!na(j!na(k!na~O^!na'l!na'j!na!S!na!g!nao!na!X!na%a!na!a!na~P!:^Oy#xOz#yO|#zO!f#vO!h#wO(SVOP!paX!pak!pa!V!pa!e!pa!l!pa#g!pa#h!pa#i!pa#j!pa#k!pa#l!pa#m!pa#n!pa#o!pa#q!pa#s!pa#u!pa#v!pa(c!pa(j!pa(k!pa~O^!pa'l!pa'j!pa!S!pa!g!pao!pa!X!pa%a!pa!a!pa~P!<wOg+VO!X'UO%a+UO(O%QO~O!a+XO^'}X!X'}X'l'}X!V'}X~O^%fO!XXO'l%fO~O!h%]O(O%QO~O!h%]O'u%_O(O%QO~O!a#tO#d(mO~O%b+eO'u+aO'wTO'zUO!W(yP~O!V+fO](xX~OX+jO~O]+kO~O!X%vO'u%_O'v!kO](xP~O#X+pO(O%QO~Og+sO!X${O(O%QO~O!X+uO~Oy+wO!XXO~O%f%mO~O!t+|O~Ob,RO~O'u#lO!W(wP~Ob%tO~O%b!PO'u&PO~P<pOX,XO],WO~OPYOQYOayObxOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!ctO!hZO!kYO!lYO!mYO!ouO!twO!x]O$UfO%`|O'wTO'zUO(SVO(b[O(oiO~O!X!dO!q!fO$Q!jO'u!cO~P!CnO],WO^%fO'l%fO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!t!gO$Q!jO$UfO'u!cO'wTO'zUO(SVO(b[O(oiO~O^,^O!qvO#p}O%d}O%e}O%f}O~P!FWO!h&eO~O&T,dO~O!X,fO~O&f,hO&h,iOP&caQ&caV&ca^&caa&cab&cai&cak&cal&cam&cas&cau&caw&ca|&ca!Q&ca!R&ca!X&ca!c&ca!h&ca!k&ca!l&ca!m&ca!o&ca!q&ca!t&ca!x&ca#p&ca$Q&ca$U&ca%`&ca%b&ca%d&ca%e&ca%f&ca%i&ca%k&ca%n&ca%o&ca%q&ca%}&ca&T&ca&V&ca&X&ca&Z&ca&^&ca&d&ca&j&ca&l&ca&n&ca&p&ca&r&ca'j&ca'u&ca'w&ca'z&ca(S&ca(b&ca(o&ca!W&ca&[&ca_&ca&a&ca~O'u,nO~O!V{X!V!_X!W{X!W!_X!a{X!a!_X!h!_X#X{X(O!_X~O!a,sO#X,rO!V#aX!V([X!W#aX!W([X!a([X!h([X(O([X~O!a,uO!h%]O(O%QO!V!ZX!W!ZX~Ol!mO|!nO'wTO'zUO(V!lO~OP9pOQ9pOa;aOb!hOikOk9pOlkOmkOskOu9pOw9pO|WO!QkO!RkO!X!dO!c9sO!hZO!k9pO!l9pO!m9pO!o9tO!q9wO!t!gO$Q!jO$UfO'wTO'zUO(SVO(b[O(o;_O~O'u:fO~P# ^O!V,yO!W(ZX~O!W,{O~O!a,sO#X,rO!V#aX!W#aX~O!V,|O!W(iX~O!W-OO~O!]-PO!^-PO'v!kO~P!N{O!W-SO~P'WOg-VO!X'UO~O!S-[O~Ol!wa![!wa!]!wa!^!wa!|!wa!}!wa#O!wa#P!wa#Q!wa#T!wa#U!wa'v!wa'w!wa'z!wa(V!wa(b!wa~P!#RO!l-aO#X-_O~PBqO!]-cO!^-cO'v!kO~PCaO^%fO#X-_O'l%fO~O^%fO!a#tO#X-_O'l%fO~O^%fO!a#tO!l-aO#X-_O'l%fO(c'fO~O'q'nO'r'nO's-hO~Oo-iO~O!S&}a!V&}a~P!7sO!U-mO!S&}X!V&}X~P%TO!V'zO!S(Ya~O!S(Ya~PGTO!V(RO!S(ga~O|%`O!U-qO!X%aO'u%_O!S'TX!V'TX~O#X-sO!V(ea!g(ea^(ea'l(ea~O!a#tO~P#)dO!V(_O!g(da~O|%`O!X%aO#c-wO'u%_O~Oi-|O|%`O!U-yO!X%aO!x]O#b-{O#c-yO'u%_O!V'WX!g'WX~Oz.QO!h#wO~Og.TO!X'UO%a.SO(O%QO~O^#[i!V#[i'l#[i'j#[i!S#[i!g#[io#[i!X#[i%a#[i!a#[i~P!7sOg;kOy)uO|)vO(j)xO(k)zO~O#d#Wa^#Wa#X#Wa'l#Wa!V#Wa!g#Wa!X#Wa!S#Wa~P#,`O#d(RXP(RXX(RX^(RXk(RXz(RX!e(RX!h(RX!l(RX#g(RX#h(RX#i(RX#j(RX#k(RX#l(RX#m(RX#n(RX#o(RX#q(RX#s(RX#u(RX#v(RX'l(RX(S(RX(c(RX!g(RX!S(RX'j(RXo(RX!X(RX%a(RX!a(RX~P!4QO!V.^Od(]X~P!0dOd.`O~O!V.aO!g(^X~P!7sO!g.dO~O!S.fO~OP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O(SVOX#fi^#fik#fi!V#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'l#fi(c#fi(j#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O#g#fi~P#0[O#g#}O~P#0[OP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO(SVOX#fi^#fi!V#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'l#fi(c#fi(j#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~Ok#fi~P#2|Ok$PO~P#2|OP$[Ok$POy#xOz#yO|#zO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO(SVO^#fi!V#fi#q#fi#s#fi#u#fi#v#fi'l#fi(c#fi(j#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P#5nOX$cO!e$RO#l$RO#m$RO#n$bO#o$RO~P#5nOP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO(SVO^#fi!V#fi#s#fi#u#fi#v#fi'l#fi(c#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(j#fi~P#8oO(j#{O~P#8oOP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO(SVO(j#{O^#fi!V#fi#u#fi#v#fi'l#fi(c#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(k#fi~P#;aO(k#|O~P#;aOP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO(SVO(j#{O(k#|O~O^#fi!V#fi#v#fi'l#fi(c#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#>ROPYXXYXkYXyYXzYX|YX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(SYX(cYX(jYX(kYX!VYX!WYX~O#yYX~P#@lOP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO#s:QO#u:SO#v:TO(SVO(c$YO(j#{O(k#|O~O#y.hO~P#ByO#X:YO#{:YO#y(XX!W(XX~PN}O^'Za!V'Za'l'Za'j'Za!g'Za!S'Zao'Za!X'Za%a'Za!a'Za~P!7sOP#fiX#fi^#fik#fiz#fi!V#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'l#fi(S#fi(c#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#,`O^#zi!V#zi'l#zi'j#zi!S#zi!g#zio#zi!X#zi%a#zi!a#zi~P!7sO$W.mO$Y.mO~O$W.nO$Y.nO~O!a)^O#X.oO!X$^X$T$^X$W$^X$Y$^X$a$^X~O!U.pO~O!X)aO$T.rO$W)`O$Y)`O$a.sO~O!V:UO!W(WX~P#ByO!W.tO~O!a)^O$a(lX~O$a.vO~Oq)pO(T)qO(U.yO~O!S.}O~P!&VO!VcX!acX!gcX!g$sX(ccX~P!/ZO!g/TO~P#,`O!V/UO!a#tO(c'fO!g(pX~O!g/ZO~O!U*RO'u%_O!g(pP~O#d/]O~O!S$sX!V$sX!a$zX~P!/ZO!V/^O!S(qX~P#,`O!a/`O~O!S/bO~Ok/fO!a#tO!h%]O(O%QO(c'fO~O'u/hO~O!a+XO~O^%fO!V/lO'l%fO~O!W/nO~P!3XO!]/oO!^/oO'v!kO(V!lO~O|/qO(V!lO~O#T/rO~O'u&POd'`X!V'`X~O!V*kOd(Pa~Od/wO~Oy/xOz/xO|/yOgva(jva(kva!Vva#Xva~Odva#yva~P$ aOy)uO|)vOg$la(j$la(k$la!V$la#X$la~Od$la#y$la~P$!VOy)uO|)vOg$na(j$na(k$na!V$na#X$na~Od$na#y$na~P$!xO#d/{O~Od$|a!V$|a#X$|a#y$|a~P!0dO!a#tO~O#d0OO~O!V*|O^(ua'l(ua~Oy#xOz#yO|#zO!f#vO!h#wO(SVOP!niX!nik!ni!V!ni!e!ni!l!ni#g!ni#h!ni#i!ni#j!ni#k!ni#l!ni#m!ni#n!ni#o!ni#q!ni#s!ni#u!ni#v!ni(c!ni(j!ni(k!ni~O^!ni'l!ni'j!ni!S!ni!g!nio!ni!X!ni%a!ni!a!ni~P$$gOg.TO!X'UO%a.SO~Oi0YO'u0XO~P!1UO!a+XO^'}a!X'}a'l'}a!V'}a~O#d0`O~OXYX!VcX!WcX~O!V0aO!W(yX~O!W0cO~OX0dO~O'u+aO'wTO'zUO~O!X%vO'u%_O]'hX!V'hX~O!V+fO](xa~O!g0iO~P!7sOX0lO~O]0mO~O#X0pO~Og0sO!X${O~O(V(sO!W(vP~Og0|O!X0yO%a0{O(O%QO~OX1WO!V1UO!W(wX~O!W1XO~O]1ZO^%fO'l%fO~O'u#lO'wTO'zUO~O#X$dO#{$dOP(XXX(XXk(XXy(XXz(XX|(XX!V(XX!e(XX!h(XX!l(XX#g(XX#h(XX#i(XX#j(XX#k(XX#l(XX#m(XX#n(XX#q(XX#s(XX#u(XX#v(XX(S(XX(c(XX(j(XX(k(XX~O#o1^O&R1_O^(XX!f(XX~P$+]O#X$dO#o1^O&R1_O~O^1aO~P%TO^1cO~O&[1fOP&YiQ&YiV&Yi^&Yia&Yib&Yii&Yik&Yil&Yim&Yis&Yiu&Yiw&Yi|&Yi!Q&Yi!R&Yi!X&Yi!c&Yi!h&Yi!k&Yi!l&Yi!m&Yi!o&Yi!q&Yi!t&Yi!x&Yi#p&Yi$Q&Yi$U&Yi%`&Yi%b&Yi%d&Yi%e&Yi%f&Yi%i&Yi%k&Yi%n&Yi%o&Yi%q&Yi%}&Yi&T&Yi&V&Yi&X&Yi&Z&Yi&^&Yi&d&Yi&j&Yi&l&Yi&n&Yi&p&Yi&r&Yi'j&Yi'u&Yi'w&Yi'z&Yi(S&Yi(b&Yi(o&Yi!W&Yi_&Yi&a&Yi~O_1lO!W1jO&a1kO~P`O!XXO!h1nO~O&h,iOP&ciQ&ciV&ci^&cia&cib&cii&cik&cil&cim&cis&ciu&ciw&ci|&ci!Q&ci!R&ci!X&ci!c&ci!h&ci!k&ci!l&ci!m&ci!o&ci!q&ci!t&ci!x&ci#p&ci$Q&ci$U&ci%`&ci%b&ci%d&ci%e&ci%f&ci%i&ci%k&ci%n&ci%o&ci%q&ci%}&ci&T&ci&V&ci&X&ci&Z&ci&^&ci&d&ci&j&ci&l&ci&n&ci&p&ci&r&ci'j&ci'u&ci'w&ci'z&ci(S&ci(b&ci(o&ci!W&ci&[&ci_&ci&a&ci~O!S1tO~O!V!Za!W!Za~P#ByOl!mO|!nO!U1zO(V!lO!V'OX!W'OX~P?wO!V,yO!W(Za~O!V'UX!W'UX~P!6{O!V,|O!W(ia~O!W2RO~P'WO^%fO#X2[O'l%fO~O^%fO!a#tO#X2[O'l%fO~O^%fO!a#tO!l2`O#X2[O'l%fO(c'fO~O^%fO'l%fO~P!7sO!V$`Oo$ka~O!S&}i!V&}i~P!7sO!V'zO!S(Yi~O!V(RO!S(gi~O!S(hi!V(hi~P!7sO!V(ei!g(ei^(ei'l(ei~P!7sO#X2bO!V(ei!g(ei^(ei'l(ei~O!V(_O!g(di~O|%`O!X%aO!x]O#b2gO#c2fO'u%_O~O|%`O!X%aO#c2fO'u%_O~Og2nO!X'UO%a2mO~Og2nO!X'UO%a2mO(O%QO~O#dvaPvaXva^vakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva'lva(Sva(cva!gva!Sva'jvaova!Xva%ava!ava~P$ aO#d$laP$laX$la^$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la'l$la(S$la(c$la!g$la!S$la'j$lao$la!X$la%a$la!a$la~P$!VO#d$naP$naX$na^$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na'l$na(S$na(c$na!g$na!S$na'j$nao$na!X$na%a$na!a$na~P$!xO#d$|aP$|aX$|a^$|ak$|az$|a!V$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a'l$|a(S$|a(c$|a!g$|a!S$|a'j$|a#X$|ao$|a!X$|a%a$|a!a$|a~P#,`O^#[q!V#[q'l#[q'j#[q!S#[q!g#[qo#[q!X#[q%a#[q!a#[q~P!7sOd'PX!V'PX~P!'oO!V.^Od(]a~O!U2vO!V'QX!g'QX~P%TO!V.aO!g(^a~O!V.aO!g(^a~P!7sO!S2yO~O#y!ja!W!ja~PJqO#y!ba!V!ba!W!ba~P#ByO#y!na!W!na~P!:^O#y!pa!W!pa~P!<wO!X3]O$UfO$_3^O~O!W3bO~Oo3cO~P#,`O^$hq!V$hq'l$hq'j$hq!S$hq!g$hqo$hq!X$hq%a$hq!a$hq~P!7sO!S3dO~P#,`Oy)uO|)vO(k)zOg%Xi(j%Xi!V%Xi#X%Xi~Od%Xi#y%Xi~P$IuOy)uO|)vOg%Zi(j%Zi(k%Zi!V%Zi#X%Zi~Od%Zi#y%Zi~P$JhO(c$YO~P#,`O!U3gO'u%_O!V'[X!g'[X~O!V/UO!g(pa~O!V/UO!a#tO!g(pa~O!V/UO!a#tO(c'fO!g(pa~Od$ui!V$ui#X$ui#y$ui~P!0dO!U3oO'u*WO!S'^X!V'^X~P!1RO!V/^O!S(qa~O!V/^O!S(qa~P#,`O!a#tO#o3wO~Ok3zO!a#tO(c'fO~Od(Qi!V(Qi~P!0dO#X3}Od(Qi!V(Qi~P!0dO!g4QO~O^$iq!V$iq'l$iq'j$iq!S$iq!g$iqo$iq!X$iq%a$iq!a$iq~P!7sO!S4UO~O!V4VO!X(rX~P#,`O!f#vO~P4QO^$sX!X$sX%UYX'l$sX!V$sX~P!/ZO%U4XO^hXghXyhX|hX!XhX'lhX(jhX(khX!VhX~O%U4XO~O%b4`O'u+aO'wTO'zUO!V'gX!W'gX~O!V0aO!W(ya~OX4dO~O]4eO~O^%fO'l%fO~P#,`O!X${O~P#,`O!V4mO#X4oO!W(vX~O!W4pO~Ol!mO|4qO![!wO!]!tO!^!tO!x9qO!|!oO!}!oO#O!oO#P!oO#Q!oO#T4vO#U!xO'v!kO'wTO'zUO(V!lO(b!rO~O!W4uO~P%$gOg4{O!X0yO%a4zO~Og4{O!X0yO%a4zO(O%QO~O'u#lO!V'fX!W'fX~O!V1UO!W(wa~O'wTO'zUO(V5UO~O]5YO~O#o5]O&R5^O~PMaO!g5_O~P%TO^5aO~O^5aO~P%TO_1lO!W5fO&a1kO~P`O!a5hO~O!a5jO!V([i!W([i!a([i!h([i(O([i~O!V#ai!W#ai~P#ByO#X5kO!V#ai!W#ai~O!V!Zi!W!Zi~P#ByO^%fO#X5tO'l%fO~O^%fO!a#tO#X5tO'l%fO~O!V(eq!g(eq^(eq'l(eq~P!7sO!V(_O!g(dq~O|%`O!X%aO#c5{O'u%_O~O!X'UO%a6OO~Og6RO!X'UO%a6OO~O#d%XiP%XiX%Xi^%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi'l%Xi(S%Xi(c%Xi!g%Xi!S%Xi'j%Xio%Xi!X%Xi%a%Xi!a%Xi~P$IuO#d%ZiP%ZiX%Zi^%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi'l%Zi(S%Zi(c%Zi!g%Zi!S%Zi'j%Zio%Zi!X%Zi%a%Zi!a%Zi~P$JhO#d$uiP$uiX$ui^$uik$uiz$ui!V$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui'l$ui(S$ui(c$ui!g$ui!S$ui'j$ui#X$uio$ui!X$ui%a$ui!a$ui~P#,`Od'Pa!V'Pa~P!0dO!V'Qa!g'Qa~P!7sO!V.aO!g(^i~O#y#[i!V#[i!W#[i~P#ByOP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O(SVOX#fik#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(c#fi(j#fi(k#fi!V#fi!W#fi~O#g#fi~P%2vO#g9yO~P%2vOP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO(SVOX#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(c#fi(j#fi(k#fi!V#fi!W#fi~Ok#fi~P%5ROk9{O~P%5ROP$[Ok9{Oy#xOz#yO|#zO!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O(SVO#q#fi#s#fi#u#fi#v#fi#y#fi(c#fi(j#fi(k#fi!V#fi!W#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P%7^OX:XO!e9}O#l9}O#m9}O#n:WO#o9}O~P%7^OP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO(SVO#s#fi#u#fi#v#fi#y#fi(c#fi(k#fi!V#fi!W#fi~O(j#fi~P%9xO(j#{O~P%9xOP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO#s:QO(SVO(j#{O#u#fi#v#fi#y#fi(c#fi!V#fi!W#fi~O(k#fi~P%<TO(k#|O~P%<TOP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO#s:QO#u:SO(SVO(j#{O(k#|O~O#v#fi#y#fi(c#fi!V#fi!W#fi~P%>`O^#wy!V#wy'l#wy'j#wy!S#wy!g#wyo#wy!X#wy%a#wy!a#wy~P!7sOg;lOy)uO|)vO(j)xO(k)zO~OP#fiX#fik#fiz#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(S#fi(c#fi!V#fi!W#fi~P%AWO!f#vOP(RXX(RXg(RXk(RXy(RXz(RX|(RX!e(RX!h(RX!l(RX#g(RX#h(RX#i(RX#j(RX#k(RX#l(RX#m(RX#n(RX#o(RX#q(RX#s(RX#u(RX#v(RX#y(RX(S(RX(c(RX(j(RX(k(RX!V(RX!W(RX~O#y#zi!V#zi!W#zi~P#ByO#y!ni!W!ni~P$$gO!W6_O~O!V'Za!W'Za~P#ByO!a#tO(c'fO!V'[a!g'[a~O!V/UO!g(pi~O!V/UO!a#tO!g(pi~Od$uq!V$uq#X$uq#y$uq~P!0dO!S'^a!V'^a~P#,`O!a6fO~O!V/^O!S(qi~P#,`O!V/^O!S(qi~O!S6jO~O!a#tO#o6oO~Ok6pO!a#tO(c'fO~O!S6rO~Od$wq!V$wq#X$wq#y$wq~P!0dO^$iy!V$iy'l$iy'j$iy!S$iy!g$iyo$iy!X$iy%a$iy!a$iy~P!7sO!a5jO~O!V4VO!X(ra~O^#[y!V#[y'l#[y'j#[y!S#[y!g#[yo#[y!X#[y%a#[y!a#[y~P!7sOX6wO~O!V0aO!W(yi~O]6}O~O(V(sO!V'cX!W'cX~O!V4mO!W(va~OikO'u7UO~P.bO!W7XO~P%$gOl!mO|7YO'wTO'zUO(V!lO(b!rO~O!X0yO~O!X0yO%a7[O~Og7_O!X0yO%a7[O~OX7dO!V'fa!W'fa~O!V1UO!W(wi~O!g7hO~O!g7iO~O!g7lO~O!g7lO~P%TO^7nO~O!a7oO~O!g7pO~O!V(hi!W(hi~P#ByO^%fO#X7xO'l%fO~O!V(ey!g(ey^(ey'l(ey~P!7sO!V(_O!g(dy~O!X'UO%a7{O~O#d$uqP$uqX$uq^$uqk$uqz$uq!V$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq'l$uq(S$uq(c$uq!g$uq!S$uq'j$uq#X$uqo$uq!X$uq%a$uq!a$uq~P#,`O#d$wqP$wqX$wq^$wqk$wqz$wq!V$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq'l$wq(S$wq(c$wq!g$wq!S$wq'j$wq#X$wqo$wq!X$wq%a$wq!a$wq~P#,`O!V'Qi!g'Qi~P!7sO#y#[q!V#[q!W#[q~P#ByOy/xOz/xO|/yOPvaXvagvakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva#yva(Sva(cva(jva(kva!Vva!Wva~Oy)uO|)vOP$laX$lag$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la#y$la(S$la(c$la(j$la(k$la!V$la!W$la~Oy)uO|)vOP$naX$nag$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na#y$na(S$na(c$na(j$na(k$na!V$na!W$na~OP$|aX$|ak$|az$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a#y$|a(S$|a(c$|a!V$|a!W$|a~P%AWO#y$hq!V$hq!W$hq~P#ByO#y$iq!V$iq!W$iq~P#ByO!W8VO~O#y8WO~P!0dO!a#tO!V'[i!g'[i~O!a#tO(c'fO!V'[i!g'[i~O!V/UO!g(pq~O!S'^i!V'^i~P#,`O!V/^O!S(qq~O!S8^O~P#,`O!S8^O~Od(Qy!V(Qy~P!0dO!V'aa!X'aa~P#,`O^%Tq!X%Tq'l%Tq!V%Tq~P#,`OX8cO~O!V0aO!W(yq~O#X8gO!V'ca!W'ca~O!V4mO!W(vi~P#ByOPYXXYXkYXyYXzYX|YX!SYX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(SYX(cYX(jYX(kYX~O!a%RX#o%RX~P&2WO!X0yO%a8kO~O'wTO'zUO(V8pO~O!V1UO!W(wq~O!g8sO~O!g8tO~O!g8uO~O!g8uO~P%TO#X8xO!V#ay!W#ay~O!V#ay!W#ay~P#ByO!X'UO%a8}O~O#y#wy!V#wy!W#wy~P#ByOP$uiX$uik$uiz$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui#y$ui(S$ui(c$ui!V$ui!W$ui~P%AWOy)uO|)vO(k)zOP%XiX%Xig%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi#y%Xi(S%Xi(c%Xi(j%Xi!V%Xi!W%Xi~Oy)uO|)vOP%ZiX%Zig%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi#y%Zi(S%Zi(c%Zi(j%Zi(k%Zi!V%Zi!W%Zi~O#y$iy!V$iy!W$iy~P#ByO#y#[y!V#[y!W#[y~P#ByO!a#tO!V'[q!g'[q~O!V/UO!g(py~O!S'^q!V'^q~P#,`O!S9UO~P#,`O!V0aO!W(yy~O!V4mO!W(vq~O!X0yO%a9]O~O!g9`O~O!X'UO%a9eO~OP$uqX$uqk$uqz$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq#y$uq(S$uq(c$uq!V$uq!W$uq~P%AWOP$wqX$wqk$wqz$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq#y$wq(S$wq(c$wq!V$wq!W$wq~P%AWOd%]!Z!V%]!Z#X%]!Z#y%]!Z~P!0dO!V'cq!W'cq~P#ByO!V#a!Z!W#a!Z~P#ByO#d%]!ZP%]!ZX%]!Z^%]!Zk%]!Zz%]!Z!V%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z'l%]!Z(S%]!Z(c%]!Z!g%]!Z!S%]!Z'j%]!Z#X%]!Zo%]!Z!X%]!Z%a%]!Z!a%]!Z~P#,`OP%]!ZX%]!Zk%]!Zz%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z#y%]!Z(S%]!Z(c%]!Z!V%]!Z!W%]!Z~P%AWOo(WX~P1jO'v!kO~P!){O!ScX!VcX#XcX~P&2WOPYXXYXkYXyYXzYX|YX!VYX!VcX!eYX!fYX!hYX!lYX#XYX#XcX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(SYX(cYX(jYX(kYX~O!acX!gYX!gcX(ccX~P&GnOP9pOQ9pOa;aOb!hOikOk9pOlkOmkOskOu9pOw9pO|WO!QkO!RkO!XXO!c9sO!hZO!k9pO!l9pO!m9pO!o9tO!q9wO!t!gO$Q!jO$UfO'u)TO'wTO'zUO(SVO(b[O(o;_O~O!V:UO!W$ka~Oi%ROk$sOl$rOm$rOs%SOu%TOw:[O|$zO!X${O!c;fO!h$wO#c:bO$Q%XO$m:^O$o:`O$r%YO'u(kO'wTO'zUO(O%QO(S$tO~O#p)[O~P&LdO!WYX!WcX~P&GnO#d9xO~O!a#tO#d9xO~O#X:YO~O#o9}O~O#X:dO!V(hX!W(hX~O#X:YO!V(fX!W(fX~O#d:eO~Od:gO~P!0dO#d:lO~O#d:mO~O!a#tO#d:nO~O!a#tO#d:eO~O#y:oO~P#ByO#d:pO~O#d:qO~O#d:rO~O#d:sO~O#d:tO~O#d:uO~O#y:vO~P!0dO#y:wO~P!0dO$U~!f!|!}#P#Q#T#b#c#n(o$m$o$r%U%`%a%b%i%k%n%o%q%s~'pR$U(o#h!R'n'v#il#g#jky'o(V'o'u$W$Y$W~",
  goto: "$&a(}PPPP)OP)RP)cP*r.uPPPP5UPP5kP;f>mP?QP?QPPP?QP@rP?QP?QP?QP@vPP@{PAfPF]PPPFaPPPPFaIaPPPIgJbPFaPLoPPPPN}FaPPPFaPFaP!#]FaP!&p!'r!'{P!(n!(r!(nPPPPP!+|!'rPP!,j!-dP!0WFaFa!0]!3f!7z!7z!;oPPP!;vFaPPPPPPPPPPP!?SP!@ePPFa!ArPFaPFaFaFaFaPFa!CUPP!F]P!I`P!Id!In!Ir!IrP!FYP!Iv!IvP!LyP!L}FaFa!MT#!V?QP?QP?Q?QP##a?Q?Q#%]?Q#'l?Q#)b?Q?Q#*O#+|#+|#,Q#,Y#+|#,bP#+|P?Q#,z?Q#.T?Q?Q5UPPP#/aPPP#/y#/yP#/yP#0`#/yPP#0fP#0]P#0]#0x#0]#1d#1j5R)R#1m)RP#1t#1t#1tP)RP)RP)RP)RPP)RP#1z#1}P#1})RP#2RP#2UP)RP)RP)RP)RP)RP)R)RPP#2[#2b#2l#2r#2x#3O#3U#3d#3j#3p#3z#4Q#4[#4k#4q#5b#5t#5z#6Q#6`#6u#8W#8f#8l#8r#8x#9O#9Y#9`#9f#9p#:S#:YPPPPPPPPPP#:`PPPPPPP#;S#>ZP#?j#?q#?yPPPP#DX#F}#Me#Mh#Mk#Nd#Ng#Nj#Nq#NyPP$ P$ T$ {$!z$#O$#dPP$#h$#n$#rP$#u$#y$#|$$r$%Y$%p$%t$%w$%z$&Q$&T$&X$&]R!zRmqOXs!Y#b%e&h&j&k&m,a,f1f1iY!tQ'U-R0y4tQ%kuQ%sxQ%z{Q&`!US&|!d,yQ'[!hS'b!q!wS*^${*cQ+_%tQ+l%|Q,Q&YQ-P'TQ-Z']Q-c'cQ/o*eQ1T,RR:c9t$|dOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{,^,a,f-V-_-m-s.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2v4q4{5]5^5a5t7Y7_7n7xS#o]9q!r)V$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ*n%UQ+d%vQ,S&]Q,Z&eQ.W:ZQ0V+VQ0Z+XQ0f+eQ1],XQ2j.TQ4_0aQ5S1UQ6Q2nQ6W:[Q6y4`R8O6R&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bt!mQ!q!t!w!x&|'T'U'b'c'd,y-P-R-c0y4t4v$^$ri#t#v$b$c$w$z%V%W%[)p)v)y){)|*T*Z*i*j+U+X+p+s.S.^/O/]/^/`/{0p0s0{2m3e3o3w3}4V4X4z6O6f6o7[7{8W8k8}9]9e:W:X:]:^:_:`:a:b:h:i:j:k:l:m:p:q:r:s:v:w;_;g;h;k;lQ%}{Q&z!dS'Q%a,|Q+d%vQ/z*rQ0f+eQ0k+kQ1[,WQ1],XQ4_0aQ4h0mQ5V1WQ5W1ZQ6y4`Q6|4eQ7g5YQ8f6}R8q7dpnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iR,U&a&t^OPXYstuvy!Y!_!f!i!n#Q#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y'W'h'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;a;b[#ZWZ#U#X&}'x!S%bm#f#g#j%]%`(R(](^(_*y*z*|,],s-q-w-x-y-{1n2f2g5j5{Q%nwQ%rxS%w{%|Q&T!SQ'X!gQ'Z!hQ(f#qS*Q$w*US+^%s%tQ+b%vQ+{&WQ,P&YS-Y'[']Q.V(gQ/Y*RQ0_+_Q0e+eQ0g+fQ0j+jQ1O+|S1S,Q,RQ2W-ZQ3f/UQ4^0aQ4b0dQ4g0lQ5R1TQ6c3gQ6x4`Q6{4dQ8b6wR9W8cv$yi#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;h!S%px!h!s%r%s%t&{'Z'[']'a'k*]+^+_,v-Y-Z-b/g0_2P2W2_3yQ+W%nQ+q&QQ+t&RQ,O&YQ.U(fQ0}+{U1R,P,Q,RQ2o.VQ4|1OS5Q1S1TQ7c5R#O;c#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lg;d:W:X:^:`:b:i:k:m:q:s:wW%Oi%Q*k;_S&Q!P&_Q&R!QQ&S!RR+o&O$_$}i#t#v$b$c$w$z%V%W%[)p)v)y){)|*T*Z*i*j+U+X+p+s.S.^/O/]/^/`/{0p0s0{2m3e3o3w3}4V4X4z6O6f6o7[7{8W8k8}9]9e:W:X:]:^:_:`:a:b:h:i:j:k:l:m:p:q:r:s:v:w;_;g;h;k;lT)q$t)rV*o%U:Z:[U'Q!d%a,|S(t#x#yQ+i%yS.O(b(cQ0t+uQ4O/xR7R4m&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;b$i$_c#W#c%i%j%l'w'}(i(p(x(y(z({(|(})O)P)Q)R)S)U)X)])g+S+h,w-f-k-p-r.].c.g.i.j.k.z/|1u1x2Y2a2u2z2{2|2}3O3P3Q3R3S3T3U3V3W3Z3[3a4S4[5m5s5x6U6V6[6]7T7r7v8P8T8U8z9Y9a9r;UT#RV#S&{kOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ'O!dR1{,yv!mQ!d!q!t!w!x&|'T'U'b'c'd,y-P-R-c0y4t4vS*]${*cS/g*^*eQ/p*fQ0v+wQ3y/oR3|/rlqOXs!Y#b%e&h&j&k&m,a,f1f1iQ&o!]Q'l!vS(h#s9xQ+[%qQ+y&TQ+z&VQ-W'YQ-e'eS.[(m:eS/}*w:nQ0]+]Q0x+xQ1m,hQ1o,iQ1w,tQ2U-XQ2X-]S4T0O:tQ4Y0^S4]0`:uQ5l1yQ5p2VQ5u2^Q6v4ZQ7s5nQ7t5qQ7w5vR8w7p$d$^c#W#c%j%l'w'}(i(p(x(y(z({(|(})O)P)Q)R)S)U)X)])g+S+h,w-f-k-p-r.].c.g.j.k.z/|1u1x2Y2a2u2z2{2|2}3O3P3Q3R3S3T3U3V3W3Z3[3a4S4[5m5s5x6U6V6[6]7T7r7v8P8T8U8z9Y9a9r;US(e#n'_U*h$|(l3YS+R%i.iQ2k0VQ5}2jQ7}6QR9O8O$d$]c#W#c%j%l'w'}(i(p(x(y(z({(|(})O)P)Q)R)S)U)X)])g+S+h,w-f-k-p-r.].c.g.j.k.z/|1u1x2Y2a2u2z2{2|2}3O3P3Q3R3S3T3U3V3W3Z3[3a4S4[5m5s5x6U6V6[6]7T7r7v8P8T8U8z9Y9a9r;US(d#n'_S(v#y$^S+Q%i.iS.P(c(eQ.l)WQ0S+RR2h.Q&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bS#o]9qQ&j!WQ&k!XQ&m!ZQ&n![R1e,dQ'V!gQ+T%nQ-U'XS.R(f+WQ2S-TW2l.U.V0U0WQ5o2TU5|2i2k2oS7z5}6PS8|7|7}S9c8{9OQ9k9dR9n9lU!uQ'U-RT4r0y4t!O_OXZ`s!U!Y#b#f%]%e&_&a&h&j&k&m(_,a,f-x1f1i]!oQ!q'U-R0y4tT#o]9q%WzOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xS(t#x#yS.O(b(c!s:{$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bY!sQ'U-R0y4tQ'a!qS'k!t!wS'm!x4vS-b'b'cQ-d'dR2_-cQ'j!sS(Z#e1`S-a'a'mQ/X*QQ/e*]Q2`-dQ3k/YS3t/f/pQ6b3fS6m3z3|Q8Y6cR8a6pQ#ubQ'i!sS(Y#e1`S([#k*vQ*x%^Q+Y%oQ+`%uU-`'a'j'mQ-t(ZQ/W*QQ/d*]Q/j*`Q0[+ZQ1P+}S2]-a-dQ2e-|S3j/X/YS3s/e/pQ3v/iQ3x/kQ5O1QQ5w2`Q6a3fQ6e3kS6i3t3|Q6n3{Q7a5PS8X6b6cQ8]6jQ8_6mQ8n7bQ9S8YQ9T8^Q9V8aQ9_8oQ9g9UQ;O:yQ;Z;SR;[;TV!uQ'U-R%WaOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xS#uy!i!r:x$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bR;O;a%WbOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xQ%^j!S%ox!h!s%r%s%t&{'Z'[']'a'k*]+^+_,v-Y-Z-b/g0_2P2W2_3yS%uy!iQ+Z%pQ+}&YW1Q,O,P,Q,RU5P1R1S1TS7b5Q5RQ8o7c!r:y$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ;S;`R;T;a$zeOPXYstuv!Y!_!f!n#Q#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&h&j&k&m&q&y'W'h'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xY#`WZ#U#X'x!S%bm#f#g#j%]%`(R(](^(_*y*z*|,],s-q-w-x-y-{1n2f2g5j5{Q,[&e!p:z$Z$l)i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bR:}&}S'R!d%aR1},|$|dOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{,^,a,f-V-_-m-s.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2v4q4{5]5^5a5t7Y7_7n7x!r)V$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ,Z&eQ0V+VQ2j.TQ6Q2nR8O6R!f$Tc#W%i'w'}(i(p)P)Q)R)S)X)]+h-f-k-p-r.].c.z/|2Y2a2u3W4S4[5s5x6U7v8z9r!T:P)U)g,w.i1u1x2z3S3T3U3V3Z3a5m6V6[6]7T7r8P8T8U9Y9a;U!b$Vc#W%i'w'}(i(p)R)S)X)]+h-f-k-p-r.].c.z/|2Y2a2u3W4S4[5s5x6U7v8z9r!P:R)U)g,w.i1u1x2z3U3V3Z3a5m6V6[6]7T7r8P8T8U9Y9a;U!^$Zc#W%i'w'}(i(p)X)]+h-f-k-p-r.].c.z/|2Y2a2u3W4S4[5s5x6U7v8z9rQ3e/Sz;b)U)g,w.i1u1x2z3Z3a5m6V6[6]7T7r8P8T8U9Y9a;UQ;g;iR;h;j&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bS$mh$nR3^.o'RgOPWXYZhstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l$n%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.o.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bT$if$oQ$gfS)`$j)dR)l$oT$hf$oT)b$j)d'RhOPWXYZhstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l$n%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.o.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bT$mh$nQ$phR)k$n%WjOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7x!s;`$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;b#alOPXZs!Y!_!n#Q#b#m#z$l%e&a&d&e&h&j&k&m&q&y'W(u)i*{+V,^,a,f-V.T.p/y0|1^1_1a1c1f1i1k2n3]4q4{5]5^5a6R7Y7_7nv$|i#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;h#O(l#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lQ*s%YQ.{)ug3Y:W:X:^:`:b:i:k:m:q:s:wv$xi#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;hQ*V$yS*`${*cQ*t%ZQ/k*a#O;Q#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lf;R:W:X:^:`:b:i:k:m:q:s:wQ;V;cQ;W;dQ;X;eR;Y;fv$|i#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;h#O(l#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lg3Y:W:X:^:`:b:i:k:m:q:s:wloOXs!Y#b%e&h&j&k&m,a,f1f1iQ*Y$zQ,o&tQ,p&vR3n/^$^$}i#t#v$b$c$w$z%V%W%[)p)v)y){)|*T*Z*i*j+U+X+p+s.S.^/O/]/^/`/{0p0s0{2m3e3o3w3}4V4X4z6O6f6o7[7{8W8k8}9]9e:W:X:]:^:_:`:a:b:h:i:j:k:l:m:p:q:r:s:v:w;_;g;h;k;lQ+r&RQ0r+tQ4k0qR7Q4lT*b${*cS*b${*cT4s0y4tS/i*_4qT3{/q7YQ+Y%oQ/j*`Q0[+ZQ1P+}Q5O1QQ7a5PQ8n7bR9_8on)y$u(n*u/[/s/t2s3l4R6`6q9R;P;];^!Y:h(j)Z*P*X.Z.w.|/S/a0T0o0q2r3m3q4j4l6S6T6g6k6s6u8[8`9f;i;j]:i3X6Z8Q9P9Q9op){$u(n*u/Q/[/s/t2s3l4R6`6q9R;P;];^![:j(j)Z*P*X.Z.w.|/S/a0T0o0q2p2r3m3q4j4l6S6T6g6k6s6u8[8`9f;i;j_:k3X6Z8Q8R9P9Q9opnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iQ&[!TR,^&epnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iR&[!TQ+v&SR0n+oqnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iQ0z+{S4y0}1OU7Z4w4x4|S8j7]7^S9Z8i8lQ9h9[R9m9iQ&c!UR,V&_R5V1WS%w{%|R0g+fQ&h!VR,a&iR,g&nT1g,f1iR,k&oQ,j&oR1p,kQ'o!yR-g'oQsOQ#bXT%hs#bQ!|TR'q!|Q#PUR's#PQ)r$tR.x)rQ#SVR'u#SQ#VWU'{#V'|-nQ'|#WR-n'}Q,z'OR1|,zQ._(nR2t._Q.b(pS2w.b2xR2x.cQ-R'UR2Q-RY!qQ'U-R0y4tR'`!qS#]W%`U(S#](T-oQ(T#^R-o(OQ,}'RR2O,}r`OXs!U!Y#b%e&_&a&h&j&k&m,a,f1f1iS#fZ%]U#p`#f-xR-x(_Q(`#hQ-u([W-}(`-u2c5yQ2c-vR5y2dQ)d$jR.q)dQ$nhR)j$nQ$acU)Y$a-j:VQ-j9rR:V)gQ/V*QW3h/V3i6d8ZU3i/W/X/YS6d3j3kR8Z6e#o)w$u(j(n)Z*P*X*p*q*u.X.Y.Z.w.|/Q/R/S/[/a/s/t0T0o0q2p2q2r2s3X3l3m3q4R4j4l6S6T6X6Y6Z6`6g6k6q6s6u8Q8R8S8[8`9P9Q9R9f9o;P;];^;i;jQ/_*XU3p/_3r6hQ3r/aR6h3qQ*c${R/m*cQ*l%PR/v*lQ4W0TR6t4WQ*}%cR0R*}Q4n0tS7S4n8hR8h7TQ+x&TR0w+xQ4t0yR7W4tQ1V,SS5T1V7eR7e5VQ0b+bW4a0b4c6z8dQ4c0eQ6z4bR8d6{Q+g%wR0h+gQ1i,fR5e1iWrOXs#bQ&l!YQ+P%eQ,`&hQ,b&jQ,c&kQ,e&mQ1d,aS1g,f1iR5d1fQ%gpQ&p!^Q&s!`Q&u!aQ&w!bQ'g!sQ+O%dQ+[%qQ+n%}Q,U&cQ,m&rW-^'a'i'j'mQ-e'eQ/l*bQ0]+]S1Y,V,YQ1q,lQ1r,oQ1s,pQ2X-]W2Z-`-a-d-fQ4Y0^Q4f0kQ4i0oQ4}1PQ5X1[Q5c1eU5r2Y2]2`Q5u2^Q6v4ZQ7O4hQ7P4jQ7V4sQ7`5OQ7f5WS7u5s5wQ7w5vQ8e6|Q8m7aQ8r7gQ8y7vQ9X8fQ9^8nQ9b8zR9j9_Q%qxQ'Y!hQ'e!sU+]%r%s%tQ,t&{U-X'Z'[']S-]'a'kQ/c*]S0^+^+_Q1y,vS2V-Y-ZQ2^-bQ3u/gQ4Z0_Q5n2PQ5q2WQ5v2_R6l3yS$vi;_R*m%QU%Pi%Q;_R/u*kQ$uiS(j#t+XQ(n#vS)Z$b$cQ*P$wQ*X$zQ*p%VQ*q%WQ*u%[Q.X:]Q.Y:_Q.Z:aQ.w)pS.|)v/OQ/Q)yQ/R){Q/S)|Q/[*TQ/a*ZQ/s*iQ/t*jh0T+U.S0{2m4z6O7[7{8k8}9]9eQ0o+pQ0q+sQ2p:hQ2q:jQ2r:lQ2s.^S3X:W:XQ3l/]Q3m/^Q3q/`Q4R/{Q4j0pQ4l0sQ6S:pQ6T:rQ6X:^Q6Y:`Q6Z:bQ6`3eQ6g3oQ6k3wQ6q3}Q6s4VQ6u4XQ8Q:mQ8R:iQ8S:kQ8[6fQ8`6oQ9P:qQ9Q:sQ9R8WQ9f:vQ9o:wQ;P;_Q;];gQ;^;hQ;i;kR;j;llpOXs!Y#b%e&h&j&k&m,a,f1f1iQ!ePS#dZ#mQ&r!_U'^!n4q7YQ't#QQ(w#zQ)h$lS,Y&a&dQ,_&eQ,l&qQ,q&yQ-T'WQ.e(uQ.u)iQ0P*{Q0W+VQ1b,^Q2T-VQ2k.TQ3`.pQ4P/yQ4x0|Q5Z1^Q5[1_Q5`1aQ5b1cQ5g1kQ5}2nQ6^3]Q7^4{Q7j5]Q7k5^Q7m5aQ7}6RQ8l7_R8v7n#UcOPXZs!Y!_!n#b#m#z%e&a&d&e&h&j&k&m&q&y'W(u*{+V,^,a,f-V.T/y0|1^1_1a1c1f1i1k2n4q4{5]5^5a6R7Y7_7nQ#WWQ#cYQ%itQ%juS%lv!fS'w#U'zQ'}#XQ(i#sQ(p#wQ(x#}Q(y$OQ(z$PQ({$QQ(|$RQ(}$SQ)O$TQ)P$UQ)Q$VQ)R$WQ)S$XQ)U$ZQ)X$`Q)]$dW)g$l)i.p3]Q+S%kQ+h%xS,w&}1zQ-f'hS-k'x-mQ-p(QQ-r(XQ.](mQ.c(qQ.g9pQ.i9sQ.j9tQ.k9wQ.z)tQ/|*wQ1u,rQ1x,uQ2Y-_Q2a-sQ2u.aQ2z9xQ2{9yQ2|9zQ2}9{Q3O9|Q3P9}Q3Q:OQ3R:PQ3S:QQ3T:RQ3U:SQ3V:TQ3W.hQ3Z:YQ3[:cQ3a:UQ4S0OQ4[0`Q5m:dQ5s2[Q5x2bQ6U2vQ6V:eQ6[:gQ6]:nQ7T4oQ7r5kQ7v5tQ8P:oQ8T:tQ8U:uQ8z7xQ9Y8gQ9a8xQ9r#QR;U;bR#YWR'P!dY!sQ'U-R0y4tS&{!d,yQ'a!qS'k!t!wS'm!x4vS,v&|'TS-b'b'cQ-d'dQ2P-PR2_-cR(o#vR(r#wQ!eQT-Q'U-R]!pQ!q'U-R0y4tQ#n]R'_9qT#iZ%]S#hZ%]S%cm,]U([#f#g#jS-v(](^Q-z(_Q0Q*|Q2d-wU2e-x-y-{S5z2f2gR7y5{`#[W#U#X%`'x(R*y-qr#eZm#f#g#j%](](^(_*|-w-x-y-{2f2g5{Q1`,]Q1v,sQ5i1nQ7q5jT:|&}*zT#_W%`S#^W%`S'y#U(RS(O#X*yS,x&}*zT-l'x-qT'S!d%aQ$jfR)n$oT)c$j)dR3_.oT*S$w*UR*[$zQ0U+UQ2i.SQ4w0{Q6P2mQ7]4zQ7|6OQ8i7[Q8{7{Q9[8kQ9d8}Q9i9]R9l9elqOXs!Y#b%e&h&j&k&m,a,f1f1iQ&b!UR,U&_rmOXs!T!U!Y#b%e&_&h&j&k&m,a,f1f1iR,]&eT%dm,]R0u+uR,T&]Q%{{R+m%|R+c%vT&f!V&iT&g!V&iT1h,f1i",
  nodeNames: "⚠ ArithOp ArithOp LineComment BlockComment Script ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 366,
  context: q8,
  nodeProps: [
    ["group", -26, 6, 14, 16, 62, 199, 203, 207, 208, 210, 213, 216, 226, 228, 234, 236, 238, 240, 243, 249, 255, 257, 259, 261, 263, 265, 266, "Statement", -32, 10, 11, 25, 28, 29, 35, 45, 48, 49, 51, 56, 64, 72, 76, 78, 80, 81, 103, 104, 113, 114, 131, 134, 136, 137, 138, 139, 141, 142, 162, 163, 165, "Expression", -23, 24, 26, 30, 34, 36, 38, 166, 168, 170, 171, 173, 174, 175, 177, 178, 179, 181, 182, 183, 193, 195, 197, 198, "Type", -3, 84, 96, 102, "ClassItem"],
    ["openedBy", 31, "InterpolationStart", 50, "[", 54, "{", 69, "(", 143, "JSXStartTag", 155, "JSXStartTag JSXStartCloseTag"],
    ["closedBy", 33, "InterpolationEnd", 44, "]", 55, "}", 70, ")", 144, "JSXSelfCloseEndTag JSXEndTag", 160, "JSXEndTag"]
  ],
  propSources: [I8],
  skippedNodes: [0, 3, 4, 269],
  repeatNodeCount: 33,
  tokenData: "$>y(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tu>PuvBavwDxwxGgxyMvyz! Qz{!![{|!%O|}!&]}!O!%O!O!P!'g!P!Q!1w!Q!R#0t!R![#3T![!]#@T!]!^#Aa!^!_#Bk!_!`#GS!`!a#In!a!b#N{!b!c$$z!c!}>P!}#O$&U#O#P$'`#P#Q$,w#Q#R$.R#R#S>P#S#T$/`#T#o$0j#o#p$4z#p#q$5p#q#r$7Q#r#s$8^#s$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$I|>P$I|$I}$<s$I}$JO$<s$JO$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(n%d_$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$d&j'{!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU'{!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$d&j'xpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'xpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$d&j'xp'{!b'n(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST'y#S$d&j'o(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$d&j'xp'{!b'o(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$d&j!l$Ip'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#q$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#q$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'w$(n$d&j'{!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$d&j'{!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$d&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$_#t$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$_#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$_#t$d&j'{!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ'{!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$_#t'{!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hg$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|<[i$d&j(b!L^'xp'{!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!Q%Z!Q![<P![!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|=|P;=`<%l<P(CS>`k$d&j'xp'{!b(V!LY'u&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P+d@`k$d&j'xp'{!b$W#tOY%ZYZ&cZr%Zrs&}st%Ztu@Tuw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![@T![!^%Z!^!_*g!_!c%Z!c!}@T!}#O%Z#O#P&c#P#R%Z#R#S@T#S#T%Z#T#o@T#o#p*g#p$g%Z$g;'S@T;'S;=`BT<%lO@T+dBWP;=`<%l@T(CSB^P;=`<%l>P%#SBl`$d&j'xp'{!b#i$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SCy_$d&j#{$Id'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%DfETa(k%<v$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sv%ZvwFYwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SFe`$d&j#u$Id'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2bGp_'z$)`$d&j'xpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo*QHv_$d&j'xpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo)`IzX$d&jOwIuwx6cx!^Iu!^!_Jg!_#oIu#o#pJg#p;'SIu;'S;=`KP<%lOIu#tJjTOwJgwx7]x;'SJg;'S;=`Jy<%lOJg#tJ|P;=`<%lJg)`KSP;=`<%lIu*QK`]$_#t$d&j'xpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$fL^Z'xpOYLXYZJgZrLXrsJgswLXwxMPx#OLX#O#PJg#P;'SLX;'S;=`Mj<%lOLX$fMWU$_#t'xpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$fMmP;=`<%lLX*QMsP;=`<%lHo(*QNR_!h(!b$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l! ]_!gM|$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!!ib$d&j'xp'{!b'v#)d#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!#q{!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!#|`$d&j'xp'{!b#g$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!%Z`$d&j'xp'{!bk&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!&h_!V&;l$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!'rc$d&j'xp'{!by'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!(}!P!Q%Z!Q![!+g![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!)Wa$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!*]!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!*h_!UMt$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!+rg$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!+g![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S!+g#S#X%Z#X#Y!-Z#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!-dg$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!.{|}%Z}!O!.{!O!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!/Uc$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!0lc$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!2Sf$d&j'xp'{!b#h$IdOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}xz!3hz{#$s{!P!3h!P!Q#&Y!Q!^!3h!^!_!Mh!_!`#-x!`!a#/_!a!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(r!3sb$d&j'xp'{!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(Q!5U`$d&j'{!b!RSOY!4{YZ&cZw!4{wx!6Wx!P!4{!P!Q!=o!Q!^!4{!^!_!?g!_!}!4{!}#O!Bn#O#P!<w#P#o!4{#o#p!?g#p;'S!4{;'S;=`!Cw<%lO!4{&n!6_^$d&j!RSOY!6WYZ&cZ!P!6W!P!Q!7Z!Q!^!6W!^!_!8g!_!}!6W!}#O!;U#O#P!<w#P#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!7ba$d&j!RSO!^&c!_#Z&c#Z#[!7Z#[#]&c#]#^!7Z#^#a&c#a#b!7Z#b#g&c#g#h!7Z#h#i&c#i#j!7Z#j#m&c#m#n!7Z#n#o&c#p;'S&c;'S;=`&w<%lO&cS!8lX!RSOY!8gZ!P!8g!P!Q!9X!Q!}!8g!}#O!9p#O#P!:o#P;'S!8g;'S;=`!;O<%lO!8gS!9^U!RS#Z#[!9X#]#^!9X#a#b!9X#g#h!9X#i#j!9X#m#n!9XS!9sVOY!9pZ#O!9p#O#P!:Y#P#Q!8g#Q;'S!9p;'S;=`!:i<%lO!9pS!:]SOY!9pZ;'S!9p;'S;=`!:i<%lO!9pS!:lP;=`<%l!9pS!:rSOY!8gZ;'S!8g;'S;=`!;O<%lO!8gS!;RP;=`<%l!8g&n!;Z[$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#O!;U#O#P!<P#P#Q!6W#Q#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<UX$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<tP;=`<%l!;U&n!<|X$d&jOY!6WYZ&cZ!^!6W!^!_!8g!_#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!=lP;=`<%l!6W(Q!=xi$d&j'{!b!RSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!=o#[#]&}#]#^!=o#^#a&}#a#b!=o#b#g&}#g#h!=o#h#i&}#i#j!=o#j#m&}#m#n!=o#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!?nZ'{!b!RSOY!?gZw!?gwx!8gx!P!?g!P!Q!@a!Q!}!?g!}#O!Ap#O#P!:o#P;'S!?g;'S;=`!Bh<%lO!?g!f!@hb'{!b!RSOY'}Zw'}x#O'}#P#Z'}#Z#[!@a#[#]'}#]#^!@a#^#a'}#a#b!@a#b#g'}#g#h!@a#h#i'}#i#j!@a#j#m'}#m#n!@a#n;'S'};'S;=`(f<%lO'}!f!AuX'{!bOY!ApZw!Apwx!9px#O!Ap#O#P!:Y#P#Q!?g#Q;'S!Ap;'S;=`!Bb<%lO!Ap!f!BeP;=`<%l!Ap!f!BkP;=`<%l!?g(Q!Bu^$d&j'{!bOY!BnYZ&cZw!Bnwx!;Ux!^!Bn!^!_!Ap!_#O!Bn#O#P!<P#P#Q!4{#Q#o!Bn#o#p!Ap#p;'S!Bn;'S;=`!Cq<%lO!Bn(Q!CtP;=`<%l!Bn(Q!CzP;=`<%l!4{'`!DW`$d&j'xp!RSOY!C}YZ&cZr!C}rs!6Ws!P!C}!P!Q!EY!Q!^!C}!^!_!GQ!_!}!C}!}#O!JX#O#P!<w#P#o!C}#o#p!GQ#p;'S!C};'S;=`!Kb<%lO!C}'`!Eci$d&j'xp!RSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!EY#[#](r#]#^!EY#^#a(r#a#b!EY#b#g(r#g#h!EY#h#i(r#i#j!EY#j#m(r#m#n!EY#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!GXZ'xp!RSOY!GQZr!GQrs!8gs!P!GQ!P!Q!Gz!Q!}!GQ!}#O!IZ#O#P!:o#P;'S!GQ;'S;=`!JR<%lO!GQt!HRb'xp!RSOY)rZr)rs#O)r#P#Z)r#Z#[!Gz#[#])r#]#^!Gz#^#a)r#a#b!Gz#b#g)r#g#h!Gz#h#i)r#i#j!Gz#j#m)r#m#n!Gz#n;'S)r;'S;=`*Z<%lO)rt!I`X'xpOY!IZZr!IZrs!9ps#O!IZ#O#P!:Y#P#Q!GQ#Q;'S!IZ;'S;=`!I{<%lO!IZt!JOP;=`<%l!IZt!JUP;=`<%l!GQ'`!J`^$d&j'xpOY!JXYZ&cZr!JXrs!;Us!^!JX!^!_!IZ!_#O!JX#O#P!<P#P#Q!C}#Q#o!JX#o#p!IZ#p;'S!JX;'S;=`!K[<%lO!JX'`!K_P;=`<%l!JX'`!KeP;=`<%l!C}(r!Ksk$d&j'xp'{!b!RSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[!Kh#[#]%Z#]#^!Kh#^#a%Z#a#b!Kh#b#g%Z#g#h!Kh#h#i%Z#i#j!Kh#j#m%Z#m#n!Kh#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W!Mq]'xp'{!b!RSOY!MhZr!Mhrs!?gsw!Mhwx!GQx!P!Mh!P!Q!Nj!Q!}!Mh!}#O#!U#O#P!:o#P;'S!Mh;'S;=`##U<%lO!Mh#W!Nse'xp'{!b!RSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[!Nj#[#]*g#]#^!Nj#^#a*g#a#b!Nj#b#g*g#g#h!Nj#h#i*g#i#j!Nj#j#m*g#m#n!Nj#n;'S*g;'S;=`+Z<%lO*g#W#!]Z'xp'{!bOY#!UZr#!Urs!Apsw#!Uwx!IZx#O#!U#O#P!:Y#P#Q!Mh#Q;'S#!U;'S;=`##O<%lO#!U#W##RP;=`<%l#!U#W##XP;=`<%l!Mh(r##e`$d&j'xp'{!bOY##[YZ&cZr##[rs!Bnsw##[wx!JXx!^##[!^!_#!U!_#O##[#O#P!<P#P#Q!3h#Q#o##[#o#p#!U#p;'S##[;'S;=`#$g<%lO##[(r#$jP;=`<%l##[(r#$pP;=`<%l!3h(CS#%Qb$d&j'xp'{!b'p(;d!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(CS#&e_$d&j'xp'{!bR(;dOY#&YYZ&cZr#&Yrs#'dsw#&Ywx#*tx!^#&Y!^!_#,s!_#O#&Y#O#P#(f#P#o#&Y#o#p#,s#p;'S#&Y;'S;=`#-r<%lO#&Y(Bb#'m]$d&j'{!bR(;dOY#'dYZ&cZw#'dwx#(fx!^#'d!^!_#)w!_#O#'d#O#P#(f#P#o#'d#o#p#)w#p;'S#'d;'S;=`#*n<%lO#'d(AO#(mX$d&jR(;dOY#(fYZ&cZ!^#(f!^!_#)Y!_#o#(f#o#p#)Y#p;'S#(f;'S;=`#)q<%lO#(f(;d#)_SR(;dOY#)YZ;'S#)Y;'S;=`#)k<%lO#)Y(;d#)nP;=`<%l#)Y(AO#)tP;=`<%l#(f(<v#*OW'{!bR(;dOY#)wZw#)wwx#)Yx#O#)w#O#P#)Y#P;'S#)w;'S;=`#*h<%lO#)w(<v#*kP;=`<%l#)w(Bb#*qP;=`<%l#'d(Ap#*}]$d&j'xpR(;dOY#*tYZ&cZr#*trs#(fs!^#*t!^!_#+v!_#O#*t#O#P#(f#P#o#*t#o#p#+v#p;'S#*t;'S;=`#,m<%lO#*t(<U#+}W'xpR(;dOY#+vZr#+vrs#)Ys#O#+v#O#P#)Y#P;'S#+v;'S;=`#,g<%lO#+v(<U#,jP;=`<%l#+v(Ap#,pP;=`<%l#*t(=h#,|Y'xp'{!bR(;dOY#,sZr#,srs#)wsw#,swx#+vx#O#,s#O#P#)Y#P;'S#,s;'S;=`#-l<%lO#,s(=h#-oP;=`<%l#,s(CS#-uP;=`<%l#&Y%#W#.Vb$d&j#{$Id'xp'{!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h+h#/lb$T#t$d&j'xp'{!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h$/l#1Pp$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#U%Z#U#V#6_#V#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#d#9g#d#l%Z#l#m#<i#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#3`k$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#5`_$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#6hd$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#8Rf$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#9pc$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;We$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#<rg$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>fi$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#@b_!a$b$d&j#y%<f'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Al_^l$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Bz^(O!*v!e'.r'xp'{!b$U)d(oSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Cv!Q!^*g!^!_#Dl!_!`#F^!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#DPX$f&j'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#DuZ#k$Id'xp'{!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Eh!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#EqX#{$Id'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#FgX#l$Id'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh#G_a#X%?x$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a#Hd!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W#Ho_#d$Ih$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#I}adBf#l$Id$a#|$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`#KS!`!a#L^!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#K__#l$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#Lia#k$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`!a#Mn!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#My`#k$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$ Wc(c$Ip$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$!c!P!^%Z!^!_*g!_!a%Z!a!b$#m!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$!n_z'#p$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$#x`$d&j#v$Id'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$%V_!x!Ln$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$&a_|(8n$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$'eZ$d&jO!^$(W!^!_$(n!_#i$(W#i#j$(s#j#l$(W#l#m$*f#m#o$(W#o#p$(n#p;'S$(W;'S;=`$,q<%lO$(W(n$(_T[#S$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$(sO[#S(n$(x[$d&jO!Q&c!Q![$)n![!^&c!_!c&c!c!i$)n!i#T&c#T#Z$)n#Z#o&c#o#p$,U#p;'S&c;'S;=`&w<%lO&c(n$)sZ$d&jO!Q&c!Q![$*f![!^&c!_!c&c!c!i$*f!i#T&c#T#Z$*f#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$*kZ$d&jO!Q&c!Q![$+^![!^&c!_!c&c!c!i$+^!i#T&c#T#Z$+^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$+cZ$d&jO!Q&c!Q![$(W![!^&c!_!c&c!c!i$(W!i#T&c#T#Z$(W#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$,XR!Q![$,b!c!i$,b#T#Z$,b#S$,eS!Q![$,b!c!i$,b#T#Z$,b#q#r$(n(n$,tP;=`<%l$(W!2r$-S_!S!+S$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$.^`#s$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$/k_$d&j'xp'{!b(S&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$0yk$d&j'xp'{!b(V!LY'u&;d$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$0juw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$0j![!^%Z!^!_*g!_!c%Z!c!}$0j!}#O%Z#O#P&c#P#R%Z#R#S$0j#S#T%Z#T#o$0j#o#p*g#p$g%Z$g;'S$0j;'S;=`$4t<%lO$0j+d$2yk$d&j'xp'{!b$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$2nuw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$2n![!^%Z!^!_*g!_!c%Z!c!}$2n!}#O%Z#O#P&c#P#R%Z#R#S$2n#S#T%Z#T#o$2n#o#p*g#p$g%Z$g;'S$2n;'S;=`$4n<%lO$2n+d$4qP;=`<%l$2n(CS$4wP;=`<%l$0j!5p$5TX!X!3l'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Df$5{a(j%<v$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$#m#q;'S%Z;'S;=`+a<%lO%Z%#`$7__!W$I`o`$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$8i_!mS$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$9y|$d&j'xp'{!b'n(;d(V!LY'u&;d$W#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(CS$=Uk$d&j'xp'{!b'o(;d(V!LY'u&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P",
  tokenizers: [j8, U8, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, D8, new Lc("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOq~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!O~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(U~~", 141, 327), new Lc("j~RQYZXz{^~^O'r~~aP!P!Qd~iO's~~", 25, 309)],
  topRules: { Script: [0, 5], SingleExpression: [1, 267], SingleClassItem: [2, 268] },
  dialects: { jsx: 12794, ts: 12796 },
  dynamicPrecedences: { 76: 1, 78: 1, 163: 1, 191: 1 },
  specialized: [{ term: 313, get: (t10) => F8[t10] || -1 }, { term: 329, get: (t10) => Z8[t10] || -1 }, { term: 67, get: (t10) => M8[t10] || -1 }],
  tokenPrec: 12820
});
function Qv(t10) {
  let e3 = Object.keys(t10).join(""), r3 = /\w/.test(e3);
  return r3 && (e3 = e3.replace(/\w/g, "")), `[${r3 ? "\\w" : ""}${e3.replace(/[^\w\s]/g, "\\$&")}]`;
}
function W8(t10) {
  let e3 = /* @__PURE__ */ Object.create(null), r3 = /* @__PURE__ */ Object.create(null);
  for (let { label: i3 } of t10) {
    e3[i3[0]] = true;
    for (let o3 = 1; o3 < i3.length; o3++)
      r3[i3[o3]] = true;
  }
  let n3 = Qv(e3) + Qv(r3) + "*$";
  return [new RegExp("^" + n3), new RegExp(n3)];
}
function BP(t10) {
  let e3 = t10.map((i3) => typeof i3 == "string" ? { label: i3 } : i3), [r3, n3] = e3.every((i3) => /^\w+$/.test(i3.label)) ? [/\w*$/, /\w+$/] : W8(e3);
  return (i3) => {
    let o3 = i3.matchBefore(n3);
    return o3 || i3.explicit ? { from: o3 ? o3.from : i3.pos, options: e3, validFor: r3 } : null;
  };
}
function zP(t10, e3) {
  return (r3) => {
    for (let n3 = tn(r3.state).resolveInner(r3.pos, -1); n3; n3 = n3.parent) {
      if (t10.indexOf(n3.name) > -1)
        return null;
      if (n3.type.isTop)
        break;
    }
    return e3(r3);
  };
}
const V8 = /* @__PURE__ */ ms.define(), Y8 = /* @__PURE__ */ Be.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class L8 {
  constructor(e3, r3, n3, i3) {
    this.field = e3, this.line = r3, this.from = n3, this.to = i3;
  }
}
class jg {
  constructor(e3, r3, n3) {
    this.field = e3, this.from = r3, this.to = n3;
  }
  map(e3) {
    let r3 = e3.mapPos(this.from, -1, kr.TrackDel), n3 = e3.mapPos(this.to, 1, kr.TrackDel);
    return r3 == null || n3 == null ? null : new jg(this.field, r3, n3);
  }
}
class Ug {
  constructor(e3, r3) {
    this.lines = e3, this.fieldPositions = r3;
  }
  instantiate(e3, r3) {
    let n3 = [], i3 = [r3], o3 = e3.doc.lineAt(r3), s3 = /^\s*/.exec(o3.text)[0];
    for (let l3 of this.lines) {
      if (n3.length) {
        let u3 = s3, c3 = /^\t*/.exec(l3)[0].length;
        for (let f3 = 0; f3 < c3; f3++)
          u3 += e3.facet(jP);
        i3.push(r3 + u3.length - c3), l3 = u3 + l3.slice(c3);
      }
      n3.push(l3), r3 += l3.length + 1;
    }
    let a3 = this.fieldPositions.map((l3) => new jg(l3.field, i3[l3.line] + l3.from, i3[l3.line] + l3.to));
    return { text: n3, ranges: a3 };
  }
  static parse(e3) {
    let r3 = [], n3 = [], i3 = [], o3;
    for (let s3 of e3.split(/\r\n?|\n/)) {
      for (; o3 = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(s3); ) {
        let a3 = o3[1] ? +o3[1] : null, l3 = o3[2] || o3[3] || "", u3 = -1;
        for (let c3 = 0; c3 < r3.length; c3++)
          (a3 != null ? r3[c3].seq == a3 : l3 && r3[c3].name == l3) && (u3 = c3);
        if (u3 < 0) {
          let c3 = 0;
          for (; c3 < r3.length && (a3 == null || r3[c3].seq != null && r3[c3].seq < a3); )
            c3++;
          r3.splice(c3, 0, { seq: a3, name: l3 }), u3 = c3;
          for (let f3 of i3)
            f3.field >= u3 && f3.field++;
        }
        i3.push(new L8(u3, n3.length, o3.index, o3.index + l3.length)), s3 = s3.slice(0, o3.index) + l3 + s3.slice(o3.index + o3[0].length);
      }
      for (let a3; a3 = /\\([{}])/.exec(s3); ) {
        s3 = s3.slice(0, a3.index) + a3[1] + s3.slice(a3.index + a3[0].length);
        for (let l3 of i3)
          l3.line == n3.length && l3.from > a3.index && (l3.from--, l3.to--);
      }
      n3.push(s3);
    }
    return new Ug(n3, i3);
  }
}
let B8 = /* @__PURE__ */ nr.widget({ widget: /* @__PURE__ */ new class extends Gf {
  toDOM() {
    let t10 = document.createElement("span");
    return t10.className = "cm-snippetFieldPosition", t10;
  }
  ignoreEvent() {
    return false;
  }
}() }), z8 = /* @__PURE__ */ nr.mark({ class: "cm-snippetField" });
class Ta {
  constructor(e3, r3) {
    this.ranges = e3, this.active = r3, this.deco = nr.set(e3.map((n3) => (n3.from == n3.to ? B8 : z8).range(n3.from, n3.to)));
  }
  map(e3) {
    let r3 = [];
    for (let n3 of this.ranges) {
      let i3 = n3.map(e3);
      if (!i3)
        return null;
      r3.push(i3);
    }
    return new Ta(r3, this.active);
  }
  selectionInsideField(e3) {
    return e3.ranges.every((r3) => this.ranges.some((n3) => n3.field == this.active && n3.from <= r3.from && n3.to >= r3.to));
  }
}
const fu = /* @__PURE__ */ Dt.define({
  map(t10, e3) {
    return t10 && t10.map(e3);
  }
}), H8 = /* @__PURE__ */ Dt.define(), Fl = /* @__PURE__ */ vo.define({
  create() {
    return null;
  },
  update(t10, e3) {
    for (let r3 of e3.effects) {
      if (r3.is(fu))
        return r3.value;
      if (r3.is(H8) && t10)
        return new Ta(t10.ranges, r3.value);
    }
    return t10 && e3.docChanged && (t10 = t10.map(e3.changes)), t10 && e3.selection && !t10.selectionInsideField(e3.selection) && (t10 = null), t10;
  },
  provide: (t10) => Be.decorations.from(t10, (e3) => e3 ? e3.deco : nr.none)
});
function Ig(t10, e3) {
  return Pe.create(t10.filter((r3) => r3.field == e3).map((r3) => Pe.range(r3.from, r3.to)));
}
function G8(t10) {
  let e3 = Ug.parse(t10);
  return (r3, n3, i3, o3) => {
    let { text: s3, ranges: a3 } = e3.instantiate(r3.state, i3), l3 = {
      changes: { from: i3, to: o3, insert: ct.of(s3) },
      scrollIntoView: true,
      annotations: n3 ? V8.of(n3) : void 0
    };
    if (a3.length && (l3.selection = Ig(a3, 0)), a3.length > 1) {
      let u3 = new Ta(a3, 0), c3 = l3.effects = [fu.of(u3)];
      r3.state.field(Fl, false) === void 0 && c3.push(Dt.appendConfig.of([Fl, r7, n7, Y8]));
    }
    r3.dispatch(r3.state.update(l3));
  };
}
function HP(t10) {
  return ({ state: e3, dispatch: r3 }) => {
    let n3 = e3.field(Fl, false);
    if (!n3 || t10 < 0 && n3.active == 0)
      return false;
    let i3 = n3.active + t10, o3 = t10 > 0 && !n3.ranges.some((s3) => s3.field == i3 + t10);
    return r3(e3.update({
      selection: Ig(n3.ranges, i3),
      effects: fu.of(o3 ? null : new Ta(n3.ranges, i3))
    })), true;
  };
}
const K8 = ({ state: t10, dispatch: e3 }) => t10.field(Fl, false) ? (e3(t10.update({ effects: fu.of(null) })), true) : false, J8 = /* @__PURE__ */ HP(1), e7 = /* @__PURE__ */ HP(-1), t7 = [
  { key: "Tab", run: J8, shift: e7 },
  { key: "Escape", run: K8 }
], Tv = /* @__PURE__ */ Me.define({
  combine(t10) {
    return t10.length ? t10[0] : t7;
  }
}), r7 = /* @__PURE__ */ Bf.highest(/* @__PURE__ */ Jf.compute([Tv], (t10) => t10.facet(Tv)));
function At(t10, e3) {
  return Object.assign(Object.assign({}, e3), { apply: G8(t10) });
}
const n7 = /* @__PURE__ */ Be.domEventHandlers({
  mousedown(t10, e3) {
    let r3 = e3.state.field(Fl, false), n3;
    if (!r3 || (n3 = e3.posAtCoords({ x: t10.clientX, y: t10.clientY })) == null)
      return false;
    let i3 = r3.ranges.find((o3) => o3.from <= n3 && o3.to >= n3);
    return !i3 || i3.field == r3.active ? false : (e3.dispatch({
      selection: Ig(r3.ranges, i3.field),
      effects: fu.of(r3.ranges.some((o3) => o3.field > i3.field) ? new Ta(r3.ranges, i3.field) : null)
    }), true);
  }
}), GP = /* @__PURE__ */ new class extends rs {
}();
GP.startSide = 1;
GP.endSide = -1;
const KP = [
  /* @__PURE__ */ At("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ At("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ At("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ At("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ At("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ At(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ At("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ At(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ At(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ At('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ At('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], i7 = /* @__PURE__ */ KP.concat([
  /* @__PURE__ */ At("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ At("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ At("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), kv = /* @__PURE__ */ new vg(), JP = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function La(t10) {
  return (e3, r3) => {
    let n3 = e3.node.getChild("VariableDefinition");
    return n3 && r3(n3, t10), true;
  };
}
const o7 = ["FunctionDeclaration"], s7 = {
  FunctionDeclaration: /* @__PURE__ */ La("function"),
  ClassDeclaration: /* @__PURE__ */ La("class"),
  ClassExpression: () => true,
  EnumDeclaration: /* @__PURE__ */ La("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ La("type"),
  NamespaceDeclaration: /* @__PURE__ */ La("namespace"),
  VariableDefinition(t10, e3) {
    t10.matchContext(o7) || e3(t10, "variable");
  },
  TypeDefinition(t10, e3) {
    e3(t10, "type");
  },
  __proto__: null
};
function e_(t10, e3) {
  let r3 = kv.get(e3);
  if (r3)
    return r3;
  let n3 = [], i3 = true;
  function o3(s3, a3) {
    let l3 = t10.sliceString(s3.from, s3.to);
    n3.push({ label: l3, type: a3 });
  }
  return e3.cursor(vt.IncludeAnonymous).iterate((s3) => {
    if (i3)
      i3 = false;
    else if (s3.name) {
      let a3 = s7[s3.name];
      if (a3 && a3(s3, o3) || JP.has(s3.name))
        return false;
    } else if (s3.to - s3.from > 8192) {
      for (let a3 of e_(t10, s3.node))
        n3.push(a3);
      return false;
    }
  }), kv.set(e3, n3), n3;
}
const Ev = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, t_ = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function a7(t10) {
  let e3 = tn(t10.state).resolveInner(t10.pos, -1);
  if (t_.indexOf(e3.name) > -1)
    return null;
  let r3 = e3.name == "VariableName" || e3.to - e3.from < 20 && Ev.test(t10.state.sliceDoc(e3.from, e3.to));
  if (!r3 && !t10.explicit)
    return null;
  let n3 = [];
  for (let i3 = e3; i3; i3 = i3.parent)
    JP.has(i3.name) && (n3 = n3.concat(e_(t10.state.doc, i3)));
  return {
    options: n3,
    from: r3 ? e3.from : t10.pos,
    validFor: Ev
  };
}
const ii = /* @__PURE__ */ qi.define({
  name: "javascript",
  parser: /* @__PURE__ */ N8.configure({
    props: [
      /* @__PURE__ */ xa.add({
        IfStatement: /* @__PURE__ */ xi({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ xi({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: UP,
        SwitchBody: (t10) => {
          let e3 = t10.textAfter, r3 = /^\s*\}/.test(e3), n3 = /^\s*(case|default)\b/.test(e3);
          return t10.baseIndent + (r3 ? 0 : n3 ? 1 : 2) * t10.unit;
        },
        Block: /* @__PURE__ */ yl({ closing: "}" }),
        ArrowFunction: (t10) => t10.baseIndent + t10.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ xi({ except: /^{/ }),
        JSXElement(t10) {
          let e3 = /^\s*<\//.test(t10.textAfter);
          return t10.lineIndent(t10.node.from) + (e3 ? 0 : t10.unit);
        },
        JSXEscape(t10) {
          let e3 = /\s*\}/.test(t10.textAfter);
          return t10.lineIndent(t10.node.from) + (e3 ? 0 : t10.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t10) {
          return t10.column(t10.node.from) + t10.unit;
        }
      }),
      /* @__PURE__ */ Qa.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": cu,
        BlockComment(t10) {
          return { from: t10.from + 2, to: t10.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), r_ = {
  test: (t10) => /^JSX/.test(t10.name),
  facet: /* @__PURE__ */ Ag({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, n_ = /* @__PURE__ */ ii.configure({ dialect: "ts" }, "typescript"), i_ = /* @__PURE__ */ ii.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Xg.add((t10) => t10.isTop ? [r_] : void 0)]
}), o_ = /* @__PURE__ */ ii.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Xg.add((t10) => t10.isTop ? [r_] : void 0)]
}, "typescript");
let s_ = (t10) => ({ label: t10, type: "keyword" });
const a_ = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(s_), l7 = /* @__PURE__ */ a_.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(s_));
function SO(t10 = {}) {
  let e3 = t10.jsx ? t10.typescript ? o_ : i_ : t10.typescript ? n_ : ii, r3 = t10.typescript ? i7.concat(l7) : KP.concat(a_);
  return new _a(e3, [
    ii.data.of({
      autocomplete: zP(t_, BP(r3))
    }),
    ii.data.of({
      autocomplete: a7
    }),
    t10.jsx ? f7 : []
  ]);
}
function u7(t10) {
  for (; ; ) {
    if (t10.name == "JSXOpenTag" || t10.name == "JSXSelfClosingTag" || t10.name == "JSXFragmentTag")
      return t10;
    if (t10.name == "JSXEscape" || !t10.parent)
      return null;
    t10 = t10.parent;
  }
}
function Cv(t10, e3, r3 = t10.length) {
  for (let n3 = e3 == null ? void 0 : e3.firstChild; n3; n3 = n3.nextSibling)
    if (n3.name == "JSXIdentifier" || n3.name == "JSXBuiltin" || n3.name == "JSXNamespacedName" || n3.name == "JSXMemberExpression")
      return t10.sliceString(n3.from, Math.min(n3.to, r3));
  return "";
}
const c7 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), f7 = /* @__PURE__ */ Be.inputHandler.of((t10, e3, r3, n3, i3) => {
  if ((c7 ? t10.composing : t10.compositionStarted) || t10.state.readOnly || e3 != r3 || n3 != ">" && n3 != "/" || !ii.isActiveAt(t10.state, e3, -1))
    return false;
  let o3 = i3(), { state: s3 } = o3, a3 = s3.changeByRange((l3) => {
    var u3;
    let { head: c3 } = l3, f3 = tn(s3).resolveInner(c3 - 1, -1), d3;
    if (f3.name == "JSXStartTag" && (f3 = f3.parent), !(s3.doc.sliceString(c3 - 1, c3) != n3 || f3.name == "JSXAttributeValue" && f3.to > c3)) {
      if (n3 == ">" && f3.name == "JSXFragmentTag")
        return { range: l3, changes: { from: c3, insert: "</>" } };
      if (n3 == "/" && f3.name == "JSXStartCloseTag") {
        let p10 = f3.parent, h10 = p10.parent;
        if (h10 && p10.from == c3 - 2 && ((d3 = Cv(s3.doc, h10.firstChild, c3)) || ((u3 = h10.firstChild) === null || u3 === void 0 ? void 0 : u3.name) == "JSXFragmentTag")) {
          let m10 = `${d3}>`;
          return { range: Pe.cursor(c3 + m10.length, -1), changes: { from: c3, insert: m10 } };
        }
      } else if (n3 == ">") {
        let p10 = u7(f3);
        if (p10 && !/^\/?>|^<\//.test(s3.doc.sliceString(c3, c3 + 2)) && (d3 = Cv(s3.doc, p10, c3)))
          return { range: l3, changes: { from: c3, insert: `</${d3}>` } };
      }
    }
    return { range: l3 };
  });
  return a3.changes.empty ? false : (t10.dispatch([
    o3,
    s3.update(a3, { userEvent: "input.complete", scrollIntoView: true })
  ]), true);
}), Ba = ["_blank", "_self", "_top", "_parent"], Qh = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], Th = ["get", "post", "put", "delete"], kh = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Lr = ["true", "false"], Qe = {}, d7 = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Ba,
      hreflang: null
    }
  },
  abbr: Qe,
  address: Qe,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: Qe,
  aside: Qe,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: Qe,
  base: { attrs: { href: null, target: Ba } },
  bdi: Qe,
  bdo: Qe,
  blockquote: { attrs: { cite: null } },
  body: Qe,
  br: Qe,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: kh,
      formmethod: Th,
      formnovalidate: ["novalidate"],
      formtarget: Ba,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: Qe,
  center: Qe,
  cite: Qe,
  code: Qe,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: Qe,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: Qe,
  div: Qe,
  dl: Qe,
  dt: Qe,
  em: Qe,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: Qe,
  figure: Qe,
  footer: Qe,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Qh,
      autocomplete: ["on", "off"],
      enctype: kh,
      method: Th,
      novalidate: ["novalidate"],
      target: Ba
    }
  },
  h1: Qe,
  h2: Qe,
  h3: Qe,
  h4: Qe,
  h5: Qe,
  h6: Qe,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: Qe,
  hgroup: Qe,
  hr: Qe,
  html: {
    attrs: { manifest: null }
  },
  i: Qe,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: kh,
      formmethod: Th,
      formnovalidate: ["novalidate"],
      formtarget: Ba,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: Qe,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: Qe,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: Qe,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Qh,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: Qe,
  noscript: Qe,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: Qe,
  param: { attrs: { name: null, value: null } },
  pre: Qe,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: Qe,
  rt: Qe,
  ruby: Qe,
  samp: Qe,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Qh
    }
  },
  section: Qe,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: Qe,
  source: { attrs: { src: null, type: null, media: null } },
  span: Qe,
  strong: Qe,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: Qe,
  summary: Qe,
  sup: Qe,
  table: Qe,
  tbody: Qe,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: Qe,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: Qe,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: Qe,
  time: { attrs: { datetime: null } },
  title: Qe,
  tr: Qe,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: Qe,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: Qe
}, l_ = {
  accesskey: null,
  class: null,
  contenteditable: Lr,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Lr,
  autocorrect: Lr,
  autocapitalize: Lr,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Lr,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Lr,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Lr,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Lr,
  "aria-hidden": Lr,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Lr,
  "aria-multiselectable": Lr,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Lr,
  "aria-relevant": null,
  "aria-required": Lr,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, u_ = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((t10) => "on" + t10);
for (let t10 of u_)
  l_[t10] = null;
let uf = class {
  constructor(e3, r3) {
    this.tags = Object.assign(Object.assign({}, d7), e3), this.globalAttrs = Object.assign(Object.assign({}, l_), r3), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
};
uf.default = /* @__PURE__ */ new uf();
function da(t10, e3, r3 = t10.length) {
  if (!e3)
    return "";
  let n3 = e3.firstChild, i3 = n3 && n3.getChild("TagName");
  return i3 ? t10.sliceString(i3.from, Math.min(i3.to, r3)) : "";
}
function ha(t10, e3 = false) {
  for (; t10; t10 = t10.parent)
    if (t10.name == "Element")
      if (e3)
        e3 = false;
      else
        return t10;
  return null;
}
function c_(t10, e3, r3) {
  let n3 = r3.tags[da(t10, ha(e3))];
  return (n3 == null ? void 0 : n3.children) || r3.allTags;
}
function Fg(t10, e3) {
  let r3 = [];
  for (let n3 = ha(e3); n3 && !n3.type.isTop; n3 = ha(n3.parent)) {
    let i3 = da(t10, n3);
    if (i3 && n3.lastChild.name == "CloseTag")
      break;
    i3 && r3.indexOf(i3) < 0 && (e3.name == "EndTag" || e3.from >= n3.firstChild.to) && r3.push(i3);
  }
  return r3;
}
const f_ = /^[:\-\.\w\u00b7-\uffff]*$/;
function Rv(t10, e3, r3, n3, i3) {
  let o3 = /\s*>/.test(t10.sliceDoc(i3, i3 + 5)) ? "" : ">", s3 = ha(r3, true);
  return {
    from: n3,
    to: i3,
    options: c_(t10.doc, s3, e3).map((a3) => ({ label: a3, type: "type" })).concat(Fg(t10.doc, r3).map((a3, l3) => ({
      label: "/" + a3,
      apply: "/" + a3 + o3,
      type: "type",
      boost: 99 - l3
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function Av(t10, e3, r3, n3) {
  let i3 = /\s*>/.test(t10.sliceDoc(n3, n3 + 5)) ? "" : ">";
  return {
    from: r3,
    to: n3,
    options: Fg(t10.doc, e3).map((o3, s3) => ({ label: o3, apply: o3 + i3, type: "type", boost: 99 - s3 })),
    validFor: f_
  };
}
function h7(t10, e3, r3, n3) {
  let i3 = [], o3 = 0;
  for (let s3 of c_(t10.doc, r3, e3))
    i3.push({ label: "<" + s3, type: "type" });
  for (let s3 of Fg(t10.doc, r3))
    i3.push({ label: "</" + s3 + ">", type: "type", boost: 99 - o3++ });
  return { from: n3, to: n3, options: i3, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function p7(t10, e3, r3, n3, i3) {
  let o3 = ha(r3), s3 = o3 ? e3.tags[da(t10.doc, o3)] : null, a3 = s3 && s3.attrs ? Object.keys(s3.attrs) : [], l3 = s3 && s3.globalAttrs === false ? a3 : a3.length ? a3.concat(e3.globalAttrNames) : e3.globalAttrNames;
  return {
    from: n3,
    to: i3,
    options: l3.map((u3) => ({ label: u3, type: "property" })),
    validFor: f_
  };
}
function O7(t10, e3, r3, n3, i3) {
  var o3;
  let s3 = (o3 = r3.parent) === null || o3 === void 0 ? void 0 : o3.getChild("AttributeName"), a3 = [], l3;
  if (s3) {
    let u3 = t10.sliceDoc(s3.from, s3.to), c3 = e3.globalAttrs[u3];
    if (!c3) {
      let f3 = ha(r3), d3 = f3 ? e3.tags[da(t10.doc, f3)] : null;
      c3 = (d3 == null ? void 0 : d3.attrs) && d3.attrs[u3];
    }
    if (c3) {
      let f3 = t10.sliceDoc(n3, i3).toLowerCase(), d3 = '"', p10 = '"';
      /^['"]/.test(f3) ? (l3 = f3[0] == '"' ? /^[^"]*$/ : /^[^']*$/, d3 = "", p10 = t10.sliceDoc(i3, i3 + 1) == f3[0] ? "" : f3[0], f3 = f3.slice(1), n3++) : l3 = /^[^\s<>='"]*$/;
      for (let h10 of c3)
        a3.push({ label: h10, apply: d3 + h10 + p10, type: "constant" });
    }
  }
  return { from: n3, to: i3, options: a3, validFor: l3 };
}
function m7(t10, e3) {
  let { state: r3, pos: n3 } = e3, i3 = tn(r3).resolveInner(n3, -1), o3 = i3.resolve(n3);
  for (let s3 = n3, a3; o3 == i3 && (a3 = i3.childBefore(s3)); ) {
    let l3 = a3.lastChild;
    if (!l3 || !l3.type.isError || l3.from < l3.to)
      break;
    o3 = i3 = a3, s3 = l3.from;
  }
  return i3.name == "TagName" ? i3.parent && /CloseTag$/.test(i3.parent.name) ? Av(r3, i3, i3.from, n3) : Rv(r3, t10, i3, i3.from, n3) : i3.name == "StartTag" ? Rv(r3, t10, i3, n3, n3) : i3.name == "StartCloseTag" || i3.name == "IncompleteCloseTag" ? Av(r3, i3, n3, n3) : e3.explicit && (i3.name == "OpenTag" || i3.name == "SelfClosingTag") || i3.name == "AttributeName" ? p7(r3, t10, i3, i3.name == "AttributeName" ? i3.from : n3, n3) : i3.name == "Is" || i3.name == "AttributeValue" || i3.name == "UnquotedAttributeValue" ? O7(r3, t10, i3, i3.name == "Is" ? n3 : i3.from, n3) : e3.explicit && (o3.name == "Element" || o3.name == "Text" || o3.name == "Document") ? h7(r3, t10, i3, n3) : null;
}
function g7(t10) {
  let { extraTags: e3, extraGlobalAttributes: r3 } = t10, n3 = r3 || e3 ? new uf(e3, r3) : uf.default;
  return (i3) => m7(n3, i3);
}
const y7 = /* @__PURE__ */ ii.parser.configure({ top: "SingleExpression" }), d_ = [
  {
    tag: "script",
    attrs: (t10) => t10.type == "text/typescript" || t10.lang == "ts",
    parser: n_.parser
  },
  {
    tag: "script",
    attrs: (t10) => t10.type == "text/babel" || t10.type == "text/jsx",
    parser: i_.parser
  },
  {
    tag: "script",
    attrs: (t10) => t10.type == "text/typescript-jsx",
    parser: o_.parser
  },
  {
    tag: "script",
    attrs: (t10) => t10.type == "importmap" || t10.type == "speculationrules",
    parser: y7
  },
  {
    tag: "script",
    attrs(t10) {
      return !t10.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t10.type);
    },
    parser: ii.parser
  },
  {
    tag: "style",
    attrs(t10) {
      return (!t10.lang || t10.lang == "css") && (!t10.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t10.type));
    },
    parser: lf.parser
  }
], h_ = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ lf.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ u_.map((t10) => ({ name: t10, parser: ii.parser }))), p_ = /* @__PURE__ */ qi.define({
  name: "html",
  parser: /* @__PURE__ */ wC.configure({
    props: [
      /* @__PURE__ */ xa.add({
        Element(t10) {
          let e3 = /^(\s*)(<\/)?/.exec(t10.textAfter);
          return t10.node.to <= t10.pos + e3[0].length ? t10.continue() : t10.lineIndent(t10.node.from) + (e3[2] ? 0 : t10.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t10) {
          return t10.column(t10.node.from) + t10.unit;
        },
        Document(t10) {
          if (t10.pos + /\s*/.exec(t10.textAfter)[0].length < t10.node.to)
            return t10.continue();
          let e3 = null, r3;
          for (let n3 = t10.node; ; ) {
            let i3 = n3.lastChild;
            if (!i3 || i3.name != "Element" || i3.to != n3.to)
              break;
            e3 = n3 = i3;
          }
          return e3 && !((r3 = e3.lastChild) && (r3.name == "CloseTag" || r3.name == "SelfClosingTag")) ? t10.lineIndent(e3.from) + t10.unit : null;
        }
      }),
      /* @__PURE__ */ Qa.add({
        Element(t10) {
          let e3 = t10.firstChild, r3 = t10.lastChild;
          return !e3 || e3.name != "OpenTag" ? null : { from: e3.to, to: r3.name == "CloseTag" ? r3.from : t10.to };
        }
      }),
      /* @__PURE__ */ a8.add({
        "OpenTag CloseTag": (t10) => t10.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), Pc = /* @__PURE__ */ p_.configure({
  wrap: /* @__PURE__ */ w2(d_, h_)
});
function v7(t10 = {}) {
  let e3 = "", r3;
  t10.matchClosingTags === false && (e3 = "noMatch"), t10.selfClosingTags === true && (e3 = (e3 ? e3 + " " : "") + "selfClosing"), (t10.nestedLanguages && t10.nestedLanguages.length || t10.nestedAttributes && t10.nestedAttributes.length) && (r3 = w2((t10.nestedLanguages || []).concat(d_), (t10.nestedAttributes || []).concat(h_)));
  let n3 = r3 ? p_.configure({ wrap: r3, dialect: e3 }) : e3 ? Pc.configure({ dialect: e3 }) : Pc;
  return new _a(n3, [
    Pc.data.of({ autocomplete: g7(t10) }),
    t10.autoCloseTags !== false ? b7 : [],
    SO().support,
    $8().support
  ]);
}
const Xv = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), b7 = /* @__PURE__ */ Be.inputHandler.of((t10, e3, r3, n3, i3) => {
  if (t10.composing || t10.state.readOnly || e3 != r3 || n3 != ">" && n3 != "/" || !Pc.isActiveAt(t10.state, e3, -1))
    return false;
  let o3 = i3(), { state: s3 } = o3, a3 = s3.changeByRange((l3) => {
    var u3, c3, f3;
    let d3 = s3.doc.sliceString(l3.from - 1, l3.to) == n3, { head: p10 } = l3, h10 = tn(s3).resolveInner(p10 - 1, -1), m10;
    if ((h10.name == "TagName" || h10.name == "StartTag") && (h10 = h10.parent), d3 && n3 == ">" && h10.name == "OpenTag") {
      if (((c3 = (u3 = h10.parent) === null || u3 === void 0 ? void 0 : u3.lastChild) === null || c3 === void 0 ? void 0 : c3.name) != "CloseTag" && (m10 = da(s3.doc, h10.parent, p10)) && !Xv.has(m10)) {
        let O10 = p10 + (s3.doc.sliceString(p10, p10 + 1) === ">" ? 1 : 0), g = `</${m10}>`;
        return { range: l3, changes: { from: p10, to: O10, insert: g } };
      }
    } else if (d3 && n3 == "/" && h10.name == "IncompleteCloseTag") {
      let O10 = h10.parent;
      if (h10.from == p10 - 2 && ((f3 = O10.lastChild) === null || f3 === void 0 ? void 0 : f3.name) != "CloseTag" && (m10 = da(s3.doc, O10, p10)) && !Xv.has(m10)) {
        let g = p10 + (s3.doc.sliceString(p10, p10 + 1) === ">" ? 1 : 0), v10 = `${m10}>`;
        return {
          range: Pe.cursor(p10 + v10.length, -1),
          changes: { from: p10, to: g, insert: v10 }
        };
      }
    }
    return { range: l3 };
  });
  return a3.changes.empty ? false : (t10.dispatch([
    o3,
    s3.update(a3, {
      userEvent: "input.complete",
      scrollIntoView: true
    })
  ]), true);
}), S7 = Os({
  null: R.null,
  instanceof: R.operatorKeyword,
  this: R.self,
  "new super assert open to with void": R.keyword,
  "class interface extends implements enum var": R.definitionKeyword,
  "module package import": R.moduleKeyword,
  "switch while for if else case default do break continue return try catch finally throw": R.controlKeyword,
  "requires exports opens uses provides public private protected static transitive abstract final strictfp synchronized native transient volatile throws": R.modifier,
  IntegerLiteral: R.integer,
  FloatingPointLiteral: R.float,
  "StringLiteral TextBlock": R.string,
  CharacterLiteral: R.character,
  LineComment: R.lineComment,
  BlockComment: R.blockComment,
  BooleanLiteral: R.bool,
  PrimitiveType: R.standard(R.typeName),
  TypeName: R.typeName,
  Identifier: R.variableName,
  "MethodName/Identifier": R.function(R.variableName),
  Definition: R.definition(R.variableName),
  ArithOp: R.arithmeticOperator,
  LogicOp: R.logicOperator,
  BitOp: R.bitwiseOperator,
  CompareOp: R.compareOperator,
  AssignOp: R.definitionOperator,
  UpdateOp: R.updateOperator,
  Asterisk: R.punctuation,
  Label: R.labelName,
  "( )": R.paren,
  "[ ]": R.squareBracket,
  "{ }": R.brace,
  ".": R.derefOperator,
  ", ;": R.separator
}), $7 = { __proto__: null, true: 34, false: 34, null: 42, void: 46, byte: 48, short: 48, int: 48, long: 48, char: 48, float: 48, double: 48, boolean: 48, extends: 62, super: 64, class: 76, this: 78, new: 84, public: 100, protected: 102, private: 104, abstract: 106, static: 108, final: 110, strictfp: 112, default: 114, synchronized: 116, native: 118, transient: 120, volatile: 122, throws: 150, implements: 160, interface: 166, enum: 176, instanceof: 236, open: 265, module: 267, requires: 272, transitive: 274, exports: 276, to: 278, opens: 280, uses: 282, provides: 284, with: 286, package: 290, import: 294, if: 306, else: 308, while: 312, for: 316, var: 323, assert: 330, switch: 334, case: 340, do: 344, break: 348, continue: 352, return: 356, throw: 362, try: 366, catch: 370, finally: 378 }, w7 = Ci.deserialize({
  version: 14,
  states: "#!hQ]QPOOO&tQQO'#H[O(xQQO'#CbOOQO'#Cb'#CbO)PQPO'#CaO)XOSO'#CpOOQO'#Ha'#HaOOQO'#Cu'#CuO*tQPO'#D_O+_QQO'#HkOOQO'#Hk'#HkO-sQQO'#HfO-zQQO'#HfOOQO'#Hf'#HfOOQO'#He'#HeO0OQPO'#DUO0]QPO'#GlO3TQPO'#D_O3[QPO'#DzO)PQPO'#E[O3}QPO'#E[OOQO'#DV'#DVO5]QQO'#H_O7dQQO'#EeO7kQPO'#EdO7pQPO'#EfOOQO'#H`'#H`O5sQQO'#H`O8sQQO'#FgO8zQPO'#EwO9PQPO'#E|O9PQPO'#FOOOQO'#H_'#H_OOQO'#HW'#HWOOQO'#Gf'#GfOOQO'#HV'#HVO:aQPO'#FhOOQO'#HU'#HUOOQO'#Ge'#GeQ]QPOOOOQO'#Hq'#HqO:fQPO'#HqO:kQPO'#D{O:kQPO'#EVO:kQPO'#EQO:sQPO'#HnO;UQQO'#EfO)PQPO'#C`O;^QPO'#C`O)PQPO'#FbO;cQPO'#FdO;nQPO'#FjO;nQPO'#FmO:kQPO'#FrO;sQPO'#FoO9PQPO'#FvO;nQPO'#FxO]QPO'#F}O;xQPO'#GPO<TQPO'#GRO<`QPO'#GTO;nQPO'#GVO9PQPO'#GWO<gQPO'#GYOOQO'#H['#H[O=WQQO,58{OOQO'#HY'#HYOOOO'#Gg'#GgO>yOSO,59[OOQO,59[,59[OOQO'#Hg'#HgO?jQPO,59eO@lQPO,59yOOQO-E:d-E:dO)PQPO,58zOA`QPO,58zO)PQPO,5;|OAeQPO'#DQOAjQPO'#DQOOQO'#Gi'#GiOBjQQO,59jOOQO'#Dm'#DmODRQPO'#HsOD]QPO'#DlODkQPO'#HrODsQPO,5<^ODxQPO,59^OEcQPO'#CxOOQO,59c,59cOEjQPO,59bOGrQQO'#H[OJVQQO'#CbOJmQPO'#D_OKrQQO'#HkOLSQQO,59pOLZQPO'#DvOLiQPO'#HzOLqQPO,5:`OLvQPO,5:`OM^QPO,5;mOMiQPO'#IROMtQPO,5;dOMyQPO,5=WOOQO-E:j-E:jOOQO,5:f,5:fO! aQPO,5:fO! hQPO,5:vO! mQPO,5<^O)PQPO,5:vO:kQPO,5:gO:kQPO,5:qO:kQPO,5:lO:kQPO,5<^O!!^QPO,59qO9PQPO,5:}O!!eQPO,5;QO9PQPO,59TO!!sQPO'#DXOOQO,5;O,5;OOOQO'#El'#ElOOQO'#En'#EnO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;eOOQO,5;h,5;hOOQO,5<R,5<RO!!zQPO,5;aO!#]QPO,5;cO!!zQPO'#CyO!#dQQO'#HkO!#rQQO,5;jO]QPO,5<SOOQO-E:c-E:cOOQO,5>],5>]O!%SQPO,5:gO!%bQPO,5:qO!%jQPO,5:lO!%uQPO,5>YOLZQPO,5>YO! {QPO,59UO!&QQQO,58zO!&YQQO,5;|O!&bQQO,5<OO)PQPO,5<OO9PQPO'#DUO]QPO,5<UO]QPO,5<XO!&jQPO'#FqO]QPO,5<ZO]QPO,5<`O!&zQQO,5<bO!'UQPO,5<dO!'ZQPO,5<iOOQO'#Fi'#FiOOQO,5<k,5<kO!'`QPO,5<kOOQO,5<m,5<mO!'eQPO,5<mO!'jQQO,5<oOOQO,5<o,5<oO<jQPO,5<qO!'qQQO,5<rO!'xQPO'#GcO!)OQPO,5<tO<jQPO,5<|O)PQPO,58}O!,|QPO'#ChOOQO1G.k1G.kOOOO-E:e-E:eOOQO1G.v1G.vO!-WQPO,59jO!&QQQO1G.fO)PQPO1G.fO!-eQQO1G1hOOQO,59l,59lO!-mQPO,59lOOQO-E:g-E:gO!-rQPO,5>_O!.ZQPO,5:WO:kQPO'#GnO!.bQPO,5>^OOQO1G1x1G1xOOQO1G.x1G.xO!.{QPO'#CyO!/kQPO'#HkO!/uQPO'#CzO!0TQPO'#HjO!0]QPO,59dOOQO1G.|1G.|OEjQPO1G.|O!0sQPO,59eO!1QQQO'#H[O!1cQQO'#CbOOQO,5:b,5:bO:kQPO,5:cOOQO,5:a,5:aO!1tQQO,5:aOOQO1G/[1G/[O!1yQPO,5:bO!2[QPO'#GqO!2oQPO,5>fOOQO1G/z1G/zO!2wQPO'#DvO!3YQPO'#D_O!3aQPO1G/zO!!zQPO'#GoO!3fQPO1G1XO9PQPO1G1XO:kQPO'#GwO!3nQPO,5>mOOQO1G1O1G1OOOQO1G0Q1G0QO!3vQPO'#E]OOQO1G0b1G0bO!4gQPO1G1xO! hQPO1G0bO!%SQPO1G0RO!%bQPO1G0]O!%jQPO1G0WOOQO1G/]1G/]O!4lQQO1G.pO7kQPO1G0jO)PQPO1G0jO:sQPO'#HnO!6`QQO1G.pOOQO1G.p1G.pO!6eQQO1G0iOOQO1G0l1G0lO!6lQPO1G0lO!6wQQO1G.oO!7_QQO'#HoO!7lQPO,59sO!8{QQO1G0pO!:dQQO1G0pO!;rQQO1G0pO!<PQQO1G0pO!=UQQO1G0pO!=lQQO1G0pO!=vQQO1G1PO!=}QQO'#HkOOQO1G0{1G0{O!?QQQO1G0}OOQO1G0}1G0}OOQO1G1n1G1nO! pQPO'#DqO!ARQPO'#D[O!!zQPO'#D|O!!zQPO'#D}OOQO1G0R1G0RO!AYQPO1G0RO!A_QPO1G0RO!AgQPO1G0RO!ArQPO'#EXOOQO1G0]1G0]O!BVQPO1G0]O!B[QPO'#ETO!!zQPO'#ESOOQO1G0W1G0WO!CUQPO1G0WO!CZQPO1G0WO!CcQPO'#EhO!CjQPO'#EhOOQO'#Gv'#GvO!CrQQO1G0mO!EcQQO1G3tO7kQPO1G3tO!GbQPO'#FWOOQO1G.f1G.fOOQO1G1h1G1hO!GiQPO1G1jOOQO1G1j1G1jO!GtQQO1G1jO!G|QPO1G1pOOQO1G1s1G1sO)aQPO'#D_O+_QQO,5<aO!KtQPO,5<aO!LVQPO,5<]O!L^QPO,5<]OOQO1G1u1G1uOOQO1G1z1G1zOOQO1G1|1G1|O9PQPO1G1|O#!QQPO'#FzOOQO1G2O1G2OO;nQPO1G2TOOQO1G2V1G2VOOQO1G2X1G2XOOQO1G2Z1G2ZOOQO1G2]1G2]OOQO1G2^1G2^O#!XQQO'#H[O##SQQO'#CbO+_QQO'#HkO##}QQOOO#$kQQO'#EeO#$YQQO'#H`OLZQPO'#GdO#$rQPO,5<}OOQO'#HO'#HOO#$zQPO1G2`O#(xQPO'#G[O<jQPO'#G`OOQO1G2`1G2`O#(}QPO1G2hOOQO1G.i1G.iO#.SQQO'#EeO#.dQQO'#H^O#.tQPO'#FSOOQO'#H^'#H^O#/OQPO'#H^O#/mQPO'#IUO#/uQPO,59SOOQO7+$Q7+$QO!&QQQO7+$QOOQO7+'S7+'SOOQO1G/W1G/WO#/zQPO'#DoO#0UQQO'#HtOOQO'#Ht'#HtOOQO1G/r1G/rOOQO,5=Y,5=YOOQO-E:l-E:lO#0fQWO,58{O#0mQPO,59fOOQO,59f,59fO!!zQPO'#HmOD}QPO'#GhO#0{QPO,5>UOOQO1G/O1G/OOOQO7+$h7+$hOOQO1G/{1G/{O#1TQQO1G/{OOQO1G/}1G/}O#1YQPO1G/{OOQO1G/|1G/|O:kQPO1G/}OOQO,5=],5=]OOQO-E:o-E:oOOQO7+%f7+%fOOQO,5=Z,5=ZOOQO-E:m-E:mO9PQPO7+&sOOQO7+&s7+&sOOQO,5=c,5=cOOQO-E:u-E:uO#1_QPO'#EUO#1mQPO'#EUOOQO'#Gu'#GuO#2UQPO,5:wOOQO,5:w,5:wOOQO7+'d7+'dOOQO7+%|7+%|OOQO7+%m7+%mO!AYQPO7+%mO!A_QPO7+%mO!AgQPO7+%mOOQO7+%w7+%wO!BVQPO7+%wOOQO7+%r7+%rO!CUQPO7+%rO!CZQPO7+%rOOQO7+&U7+&UOOQO'#Ee'#EeO7kQPO7+&UO7kQPO,5>YO#2uQPO7+$[OOQO7+&T7+&TOOQO7+&W7+&WO9PQPO'#GjO#3TQPO,5>ZOOQO1G/_1G/_O9PQPO7+&kO#3`QQO,59eO#4cQPO'#DrO! pQPO'#DrO#4nQPO'#HwO#4vQPO,5:]O#5aQQO'#HgO#5|QQO'#CuO! mQPO'#HvO#6lQPO'#DpO#6vQPO'#HvO#7XQPO'#DpO#7aQPO'#IPO#7fQPO'#E`OOQO'#Hp'#HpOOQO'#Gk'#GkO#7nQPO,59vOOQO,59v,59vO#7uQPO'#HqOOQO,5:h,5:hO#9]QPO'#H|OOQO'#EP'#EPOOQO,5:i,5:iO#9hQPO'#EYO:kQPO'#EYO#9yQPO'#H}O#:UQPO,5:sO! mQPO'#HvO!!zQPO'#HvO#:^QPO'#DpOOQO'#Gs'#GsO#:eQPO,5:oOOQO,5:o,5:oOOQO,5:n,5:nOOQO,5;S,5;SO#;_QQO,5;SO#;fQPO,5;SOOQO-E:t-E:tOOQO7+&X7+&XOOQO7+)`7+)`O#;mQQO7+)`OOQO'#Gz'#GzO#=ZQPO,5;rOOQO,5;r,5;rO#=bQPO'#FXO)PQPO'#FXO)PQPO'#FXO)PQPO'#FXO#=pQPO7+'UO#=uQPO7+'UOOQO7+'U7+'UO]QPO7+'[O#>QQPO1G1{O! mQPO1G1{O#>`QQO1G1wO!!sQPO1G1wO#>gQPO1G1wO#>nQQO7+'hOOQO'#G}'#G}O#>uQPO,5<fOOQO,5<f,5<fO#>|QPO'#HqO9PQPO'#F{O#?UQPO7+'oO#?ZQPO,5=OO! mQPO,5=OO#?`QPO1G2iO#@iQPO1G2iOOQO1G2i1G2iOOQO-E:|-E:|OOQO7+'z7+'zO!2[QPO'#G^O<jQPO,5<vOOQO,5<z,5<zO#@qQPO7+(SOOQO7+(S7+(SO#DoQPO,59TO#DvQPO'#ITO#EOQPO,5;nO)PQPO'#GyO#ETQPO,5>pOOQO1G.n1G.nOOQO<<Gl<<GlO#E]QPO'#HuO#EeQPO,5:ZOOQO1G/Q1G/QOOQO,5>X,5>XOOQO,5=S,5=SOOQO-E:f-E:fO#EjQPO7+%gOOQO7+%g7+%gOOQO7+%i7+%iOOQO<<J_<<J_O#FQQPO'#H[O#FXQPO'#CbO#F`QPO,5:pO#FeQPO,5:xO#1_QPO,5:pOOQO-E:s-E:sOOQO1G0c1G0cOOQO<<IX<<IXO!AYQPO<<IXO!A_QPO<<IXOOQO<<Ic<<IcOOQO<<I^<<I^O!CUQPO<<I^OOQO<<Ip<<IpO#FjQQO<<GvO7kQPO<<IpO)PQPO<<IpOOQO<<Gv<<GvO#H^QQO,5=UOOQO-E:h-E:hO#HkQQO<<JVOOQO,5:^,5:^O!!zQPO'#DsO#IRQPO,5:^O! pQPO'#GpO#I^QPO,5>cOOQO1G/w1G/wO#IfQPO'#HsO#ImQPO,59xO#IrQPO,5>bO! mQPO,59xO#I}QPO,5:[O#7fQPO,5:zO! mQPO,5>bO!!zQPO,5>bO#7aQPO,5>kOOQO,5:[,5:[OLvQPO'#DtOOQO,5>k,5>kO#JVQPO'#EaOOQO,5:z,5:zO#MWQPO,5:zO!!zQPO'#DxOOQO-E:i-E:iOOQO1G/b1G/bOOQO,5:y,5:yO!!zQPO'#GrO#M]QPO,5>hOOQO,5:t,5:tO#MhQPO,5:tO#MvQPO,5:tO#NXQPO'#GtO#NoQPO,5>iO#NzQPO'#EZOOQO1G0_1G0_O$ RQPO1G0_O! mQPO,5:pOOQO-E:q-E:qOOQO1G0Z1G0ZOOQO1G0n1G0nO$ WQQO1G0nOOQO<<Lz<<LzOOQO-E:x-E:xOOQO1G1^1G1^O$ _QQO,5;sOOQO'#G{'#G{O#=bQPO,5;sOOQO'#IV'#IVO$ gQQO,5;sO$ xQQO,5;sOOQO<<Jp<<JpO$!QQPO<<JpOOQO<<Jv<<JvO9PQPO7+'gO$!VQPO7+'gO!!sQPO7+'cO$!eQPO7+'cO$!jQQO7+'cOOQO<<KS<<KSOOQO-E:{-E:{OOQO1G2Q1G2QOOQO,5<g,5<gO$!qQQO,5<gOOQO<<KZ<<KZO9PQPO1G2jO$!xQPO1G2jOOQO,5=l,5=lOOQO7+(T7+(TO$!}QPO7+(TOOQO-E;O-E;OO$$lQWO'#HfO$$WQWO'#HfO$$sQPO'#G_O:kQPO,5<xOLZQPO,5<xOOQO1G2b1G2bOOQO<<Kn<<KnO$%UQQO1G.oOOQO1G1Z1G1ZO$%`QPO'#GxO$%mQPO,5>oOOQO1G1Y1G1YO$%uQPO'#FTOOQO,5=e,5=eOOQO-E:w-E:wO$%zQPO'#GmO$&XQPO,5>aOOQO1G/u1G/uOOQO<<IR<<IROOQO1G0[1G0[O$&aQPO1G0dO$&fQPO1G0[O$&kQPO1G0dOOQOAN>sAN>sO!AYQPOAN>sOOQOAN>xAN>xOOQOAN?[AN?[O7kQPOAN?[O$&pQPO,5:_OOQO1G/x1G/xOOQO,5=[,5=[OOQO-E:n-E:nO$&{QPO,5>eOOQO1G/d1G/dOOQO1G3|1G3|O$'^QPO1G/dOOQO1G/v1G/vOOQO1G0f1G0fO#MWQPO1G0fO#7aQPO'#HyO$'cQPO1G3|O! mQPO1G3|OOQO1G4V1G4VOK^QPO'#DvOJmQPO'#D_OOQO,5:{,5:{O$'nQPO,5:{O$'nQPO,5:{O$'uQQO'#H_O$'|QQO'#H`O$(WQQO'#EbO$(cQPO'#EbOOQO,5:d,5:dOOQO,5=^,5=^OOQO-E:p-E:pOOQO1G0`1G0`O$(kQPO1G0`OOQO,5=`,5=`OOQO-E:r-E:rO$(yQPO,5:uOOQO7+%y7+%yOOQO7+&Y7+&YOOQO1G1_1G1_O$)QQQO1G1_OOQO-E:y-E:yO$)YQQO'#IWO$)TQPO1G1_O$ mQPO1G1_O)PQPO1G1_OOQOAN@[AN@[O$)eQQO<<KRO9PQPO<<KRO$)lQPO<<J}OOQO<<J}<<J}O!!sQPO<<J}OOQO1G2R1G2RO$)qQQO7+(UO9PQPO7+(UOOQO<<Ko<<KoP!'xQPO'#HQOLZQPO'#HPO$){QPO,5<yO$*WQPO1G2dO:kQPO1G2dOOQO,5=d,5=dOOQO-E:v-E:vO#DoQPO,5;oOOQO,5=X,5=XOOQO-E:k-E:kO$*]QPO7+&OOOQO7+%v7+%vO$*kQPO7+&OOOQOG24_G24_OOQOG24vG24vO$*pQPO1G/yO$*{QPO1G4POOQO7+%O7+%OOOQO7+&Q7+&QOOQO7+)h7+)hO$+^QPO7+)hO!0bQPO,5:aOOQO1G0g1G0gO$+iQPO1G0gO$+pQPO,59qO$,UQPO,5:|O7kQPO,5:|OOQO7+%z7+%zOOQO7+&y7+&yO)PQPO'#G|O$,ZQPO,5>rO$,cQPO7+&yO$,hQQO'#IXOOQOAN@mAN@mO$,sQQOAN@mOOQOAN@iAN@iO$,zQPOAN@iO$-PQQO<<KpO$-ZQPO,5=kOOQO-E:}-E:}OOQO7+(O7+(OO$-lQPO7+(OO$-qQPO<<IjOOQO<<Ij<<IjO#DoQPO<<IjO$-qQPO<<IjOOQO<<MS<<MSOOQO7+&R7+&RO$.PQPO1G0jO$.[QQO1G0hOOQO1G0h1G0hO$.dQPO1G0hO$.iQQO,5=hOOQO-E:z-E:zOOQO<<Je<<JeO$.tQPO,5>sOOQOG26XG26XOOQOG26TG26TOOQO<<Kj<<KjOOQOAN?UAN?UO#DoQPOAN?UO$.|QPOAN?UO$/RQPOAN?UO7kQPO7+&SO$/aQPO7+&SOOQO7+&S7+&SO$/fQPOG24pOOQOG24pG24pO#DoQPOG24pO$/kQPO<<InOOQO<<In<<InOOQOLD*[LD*[O$/pQPOLD*[OOQOAN?YAN?YOOQO!$'Mv!$'MvO)PQPO'#CaO$/uQQO'#H[O$0YQQO'#CbO!!zQPO'#Cy",
  stateData: "$0u~OPOSQOS%wOS~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~OWiXW&OXZ&OXuiXu&OX!P&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~O#o$]X~P$wOWUXW&ZXZUXuUXu&ZX!PUX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~O#o$]X~P&{O%}RO&P!bO~O&U!gO&W!eO~Og]Oh]O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO%{SO%}!hO&PVOg!RXh!RX$g!RX%}!RX&P!RX~O#x!mO#y!lO$V!nOv!RX!u!RX!z!RX&r!RX~P)aOW!xOu!oO%{SO%}!sO&P!sO&t&_X~OW!{Ou&YX%{&YX%}&YX&P&YX&t&YXY&YXw&YX&l&YX&o&YXZ&YXq&YX&[&YX!P&YX#_&YX#a&YX#c&YX#d&YX#e&YX#f&YX#g&YX#h&YX#j&YX#n&YX#q&YX}&YX!r&YX#o&YXs&YX|&YX~O&]!yO~P+sO&]&YX~P+sOZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO#eoO#qnO#soO#toO%{SO&VTO~O%}!}O&P!|OY&nP~P.RO%{SOg%`Xh%`Xv%`X!S%`X!T%`X!U%`X!V%`X!W%`X!X%`X!Y%`X!Z%`X!]%`X!^%`X!_%`X!u%`X!z%`X$g%`X%}%`X&P%`X&r%`X&]%`X~O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xOg!RXh!RXv!RX!u!RX!z!RX%}!RX&P!RX&r!RX&]!RX~O$g!RX~P1sO|#[O~P]Og]Oh]Ov#aO!u#cO!z#bO%}!hO&PVO&r#`O~O$g#dO~P3cOu#fO&t#gO!P&RX#_&RX#a&RX#c&RX#d&RX#e&RX#f&RX#g&RX#h&RX#j&RX#n&RX#q&RX&[&RX&]&RX&l&RX~OW#eOY&RX#o&RXs&RXq&RX|&RX~P4UO!b#hO#]#hOW&SXu&SX!P&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SXY&SX#o&SXs&SXq&SX|&SX~OZ#XX~P5sOZ#iO~O&t#gO~O#_#mO#a#nO#c#oO#d#oO#e#pO#f#qO#g#rO#h#rO#j#vO#n#sO#q#tO&[#kO&]#kO&l#lO~O!P#uO~P7uO&v#wO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O#eoO#qnO#soO#toO%{SO%}0iO&P0hO&VTO~O#o#{O~O![#}O~O%}!sO&P!sO~Og]Oh]O%}!hO&PVO&]!yO~OW$TO&t#gO~O#y!lO~O!W$XO%}RO&P!bO~OZ$YO~OZ$]O~O!P$dO%}$cO&P$cO~O!P$fO%}$cO&P$cO~O!P$iO~P9POZ$lO}bO~OW$oOZ$pOgTahTa%{Ta%}Ta&PTa~OvTa!STa!TTa!UTa!VTa!WTa!XTa!YTa!ZTa!]Ta!^Ta!_Ta!uTa!zTa#xTa#yTa$VTa$gTa&rTauTaYTa&]TaqTa|Ta!PTa~P<oO&U$sO&W!eO~Ou!oO%{SOqma&[maYma&lma!Pma~O&tma}ma!rma~P?RO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO~Og!Rah!Rav!Ra!u!Ra!z!Ra$g!Ra%}!Ra&P!Ra&r!Ra&]!Ra~P?wO#y$vO~Os$xO~Ou$yO%{SO~Ou!oO%{ra%}ra&Pra&traYrawra&lra&ora!Pra&[raqra~OWra#_ra#ara#cra#dra#era#fra#gra#hra#jra#nra#qra&]ra#orasra|ra~PArOu!oO%{SOq&gX!P&gX!b&gX~OY&gX#o&gX~PCpO!b$|Oq!`X!P!`XY!`X~Oq$}O!P&fX~O!P%PO~Ov%QO~Og]Oh]O%{0gO%}!hO&PVO&`%TO~O&[&^P~PD}O%{SO%}!hO&PVO~OWiXW&OXY&OXZ&OXuiXu&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~OYiXY!aXq!aXwiX&liX&oiX~PEuOWUXW&ZXYUXZUXuUXu&ZX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~OY!aXY&ZXq!aXw&ZX&l&ZX&o&ZX~PHYOg]Oh]O%{SO%}!hO&PVOg!RXh!RX%}!RX&P!RX~P?wOu!oOw%_O%{SO%}%[O&P%ZO&o%^O~OW!xOY&_X&l&_X&t&_X~PK^OY%aO~P7uOg]Oh]O%}!hO&PVO~Oq%cOY&nX~OY%eO~Og]Oh]O%{SO%}!hO&PVOY&nP~P?wOY%kO&l%iO&t#gO~Oq%lO&v#wOY&uX~OY%nO~O%{SOg%`ah%`av%`a!S%`a!T%`a!U%`a!V%`a!W%`a!X%`a!Y%`a!Z%`a!]%`a!^%`a!_%`a!u%`a!z%`a$g%`a%}%`a&P%`a&r%`a&]%`a~O|%oO~P]O}%pO~Ou!oO%{SO%}!sO&P!sO~Op%|Ow%}O%}RO&P!bO&]!yO~Oz%{O~P! {Oz&PO%}RO&P!bO&]!yO~OY&cP~P9POg]Oh]O%{SO%}!hO&PVO~O}bO~P9POW!xOu!oO%{SO&t&_X~O#q#tO!P#ra#_#ra#a#ra#c#ra#d#ra#e#ra#f#ra#g#ra#h#ra#j#ra#n#ra&[#ra&]#ra&l#raY#ra#o#ras#raq#ra|#ra~Oo&dO}&cO!r&eO&]&bO~O}&jO!r&eO~Oo&nO}&mO&]&bO~OZ#iOu&rO%{SO~OW$oO}&xO~OW$oO!P&zO~OW&{O!P&|O~O$g!VO%}0iO&P0hO!P&cP~P.RO!P'XO#o'YO~P7uO}'ZO~O$b']O~O!P'^O~O!P'_O~O!P'`O~P7uO!P'bO~P7uOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wO%P'mO%T'nOZ$|a_$|a`$|aa$|ab$|ac$|ae$|ag$|ah$|ap$|av$|aw$|az$|a}$|a!P$|a!S$|a!T$|a!U$|a!V$|a!W$|a!X$|a!Y$|a!Z$|a![$|a!]$|a!^$|a!_$|a!u$|a!z$|a#e$|a#q$|a#s$|a#t$|a#x$|a#y$|a$V$|a$X$|a$_$|a$b$|a$d$|a$g$|a$k$|a$m$|a$r$|a$t$|a$v$|a$x$|a${$|a$}$|a%u$|a%{$|a%}$|a&P$|a&V$|a&r$|a|$|a$`$|a$p$|a~O}'tOY&xP~P9PO}ra!rra&|ra~PArOW$oO!P'{O~Os'|O~Ou!oO%{SOq&ga!P&ga!b&gaY&ga#o&ga~O}'}O~P9POq$}O!P&fa~Og]Oh]O%{0gO%}!hO&PVO~O&`(UO~P!.jOu!oO%{SOq&_X&[&_XY&_X&l&_X!P&_X~O}&_X!r&_X~P!/SOo(WOp(WOqnX&[nX~Oq(XO&[&^X~O&[(ZO~Ou!oOw(]O%{SO%}RO&P!bO~OYma&lma&tma~P!0bOW&OXY!aXq!aXu!aX%{!aX~OWUXY!aXq!aXu!aX%{!aX~OW(`O~Ou!oO%{SO%}!sO&P!sO&o(bO~Og]Oh]O%{SO%}!hO&PVO~P?wOq%cOY&na~Ou!oO%{SO%}!sO&P!sO&o%^O~O%{SO~P1sOY(eO~OY(hO&l%iO~Oq%lOY&ua~Og]Oh]OvzO|(pO!u|O%{SO%}!hO&PVO&rcO~P?wO!P(qO~OW^iZ#XXu^i!P^i!b^i#]^i#_^i#a^i#c^i#d^i#e^i#f^i#g^i#h^i#j^i#n^i#q^i&[^i&]^i&l^i&t^iY^i#o^is^iq^i|^i~OW)QO~Os)RO~P7uOz)SO%}RO&P!bO~O!P]iY]i#o]is]iq]i|]i~P7uOq)TOY&cX!P&cX~P7uOY)VO~O#q#tO!P#^i#_#^i#a#^i#c#^i#d#^i#e#^i#f#^i#j#^i#n#^i&[#^i&]#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#g#rO#h#rO~P!7qO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#a#^i#c#^i#d#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#e#pO~P!9VO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#c#^i#d#^i#n#^iY#^i#o#^is#^iq#^i|#^i~O#a#nO#e#pO&l#lO~P!:kO#e#^i~P!9VO#q#tO!P#^i#a#^i#c#^i#d#^i#e#^i#f#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#_#mO#g#rO#h#rO#j#vO&[#kO&]#kO~P!<WO#g#^i#h#^i~P!7qO#o)WO~P7uO#_&_X#a&_X#c&_X#d&_X#e&_X#f&_X#g&_X#h&_X#j&_X#n&_X#q&_X&]&_X#o&_Xs&_X|&_X~P!/SO!P#kiY#ki#o#kis#kiq#ki|#ki~P7uOg]Oh]OvzO}bO!P)fO!SxO!TxO!UxO!VxO!W)jO!XxO!YxO!ZyO!]xO!^xO!_xO!u|O!z{O%{SO%})^O&P)_O&]&bO&rcO~O|)iO~P!?hO}&cO~O}&cO!r&eO~Oo&dO}&cO!r&eO~O%{SO%}!sO&P!sO|&qP!P&qP~P?wO}&jO~Og]Oh]OvzO|)xO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wO}&mO~Oo&nO}&mO~Os)zO~P9POu)|O%{SO~Ou&rO}'}O%{SOW#Zi!P#Zi#_#Zi#a#Zi#c#Zi#d#Zi#e#Zi#f#Zi#g#Zi#h#Zi#j#Zi#n#Zi#q#Zi&[#Zi&]#Zi&l#Zi&t#ZiY#Zi#o#Zis#Ziq#Zi|#Zi~O}&cOW&biu&bi!P&bi#_&bi#a&bi#c&bi#d&bi#e&bi#f&bi#g&bi#h&bi#j&bi#n&bi#q&bi&[&bi&]&bi&l&bi&t&biY&bi#o&bis&biq&bi|&bi~O#|*UO$O*VO$Q*VO$R*WO$S*XO~O|*TO~P!GPO$Y*YO%}RO&P!bO~OW*ZO!P*[O~O$`*]OZ$^i_$^i`$^ia$^ib$^ic$^ie$^ig$^ih$^ip$^iv$^iw$^iz$^i}$^i!P$^i!S$^i!T$^i!U$^i!V$^i!W$^i!X$^i!Y$^i!Z$^i![$^i!]$^i!^$^i!_$^i!u$^i!z$^i#e$^i#q$^i#s$^i#t$^i#x$^i#y$^i$V$^i$X$^i$_$^i$b$^i$d$^i$g$^i$k$^i$m$^i$r$^i$t$^i$v$^i$x$^i${$^i$}$^i%u$^i%{$^i%}$^i&P$^i&V$^i&r$^i|$^i$p$^i~Og]Oh]O$g#dO%}!hO&PVO~O!P*aO~P9PO!P*bO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!Z*gO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$p*hO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~O|*fO~P!LcOWiXW&OXY&OXZ&OXuiXu&OX!P&OX%{iX%}iX&PiX&]iX&tiX&t&OX~OWUXW&ZXYUXZUXuUXu&ZX!PUX%{&ZX%}&ZX&P&ZX&]&ZX&tUX&t&ZX~OW#eOu#fO&t#gO~OW&SXY%WXu&SX!P%WX&t&SX~OZ#XX~P#$YOY*nO!P*lO~O%P'mO%T'nOZ$|i_$|i`$|ia$|ib$|ic$|ie$|ig$|ih$|ip$|iv$|iw$|iz$|i}$|i!P$|i!S$|i!T$|i!U$|i!V$|i!W$|i!X$|i!Y$|i!Z$|i![$|i!]$|i!^$|i!_$|i!u$|i!z$|i#e$|i#q$|i#s$|i#t$|i#x$|i#y$|i$V$|i$X$|i$_$|i$b$|i$d$|i$g$|i$k$|i$m$|i$r$|i$t$|i$v$|i$x$|i${$|i$}$|i%u$|i%{$|i%}$|i&P$|i&V$|i&r$|i|$|i$`$|i$p$|i~OZ*qO~O%P'mO%T'nOZ%Ui_%Ui`%Uia%Uib%Uic%Uie%Uig%Uih%Uip%Uiv%Uiw%Uiz%Ui}%Ui!P%Ui!S%Ui!T%Ui!U%Ui!V%Ui!W%Ui!X%Ui!Y%Ui!Z%Ui![%Ui!]%Ui!^%Ui!_%Ui!u%Ui!z%Ui#e%Ui#q%Ui#s%Ui#t%Ui#x%Ui#y%Ui$V%Ui$X%Ui$_%Ui$b%Ui$d%Ui$g%Ui$k%Ui$m%Ui$r%Ui$t%Ui$v%Ui$x%Ui${%Ui$}%Ui%u%Ui%{%Ui%}%Ui&P%Ui&V%Ui&r%Ui|%Ui$`%Ui$p%Ui~OW&SXu&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SX~O!b*vO#]#hOY&SXZ#XX~P#,{OY&QXq&QX|&QX!P&QX~P7uO}'tO|&wP~P9POY&QXg%YXh%YX%{%YX%}%YX&P%YXq&QX|&QX!P&QX~Oq*yOY&xX~OY*{O~O}'}O|&iP~P9POq&hX!P&hX|&hXY&hX~P7uO&`Ta~P<oOo(WOp(WOqna&[na~Oq(XO&[&^a~OW+TO~Ow+UO~Ou!oO%{SO%}+YO&P+XO~Og]Oh]Ov#aO!u#cO%}!hO&PVO&r#`O~Og]Oh]OvzO|+_O!u|O%{SO%}!hO&PVO&rcO~P?wOw+jO%}RO&P!bO&]!yO~Oq)TOY&ca!P&ca~O#_ma#ama#cma#dma#ema#fma#gma#hma#jma#nma#qma&]ma#omasma|ma~P?ROo+oOq!fX&[!fX~Oq+qO&[&kX~O&[+sO~OW&ZXu&ZX%{&ZX%}&ZX&P&ZX&]&ZX~OZ!aX~P#4{OWiXuiX%{iX%}iX&PiX&]iX~OZ!aX~P#5hOg]Oh]Ov#aO!u#cO!z#bO&]&bO&r#`O~O%})^O&P)_O~P#6TOg]Oh]O%{SO%})^O&P)_O~O}bO!P+}O~OZ,OO~O},QO!m,TO~O|,VO~P!?hO}bOg&eXh&eXv&eX!S&eX!T&eX!U&eX!V&eX!W&eX!X&eX!Y&eX!Z&eX!]&eX!^&eX!_&eX!u&eX!z&eX%{&eX%}&eX&P&eX&]&eX&r&eX~Oq,XO}&pX!P&pX~OZ#iO}&cOq!|X|!|X!P!|X~Oq,^O|&qX!P&qX~O|,aO!P,`O~O&]&bO~P3cOg]Oh]OvzO|,eO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wOs,fO~P7uOs,fO~P9PO}&cOW&bqu&bq!P&bq#_&bq#a&bq#c&bq#d&bq#e&bq#f&bq#g&bq#h&bq#j&bq#n&bq#q&bq&[&bq&]&bq&l&bq&t&bqY&bq#o&bqs&bqq&bq|&bq~O|,jO~P!GPO!W,nO#},nO%}RO&P!bO~O!P,qO~O$Y,rO%}RO&P!bO~O!b$|O#o,tOq!`X!P!`X~O!P,vO~P7uO!P,vO~P9PO!P,yO~P7uO|,{O~P!LcO![#}O#o,|O~O!P-OO~O!b-PO~OY-SOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOY-SO!P-TO~O%P'mO%T'nOZ%Uq_%Uq`%Uqa%Uqb%Uqc%Uqe%Uqg%Uqh%Uqp%Uqv%Uqw%Uqz%Uq}%Uq!P%Uq!S%Uq!T%Uq!U%Uq!V%Uq!W%Uq!X%Uq!Y%Uq!Z%Uq![%Uq!]%Uq!^%Uq!_%Uq!u%Uq!z%Uq#e%Uq#q%Uq#s%Uq#t%Uq#x%Uq#y%Uq$V%Uq$X%Uq$_%Uq$b%Uq$d%Uq$g%Uq$k%Uq$m%Uq$r%Uq$t%Uq$v%Uq$x%Uq${%Uq$}%Uq%u%Uq%{%Uq%}%Uq&P%Uq&V%Uq&r%Uq|%Uq$`%Uq$p%Uq~O}'tO~P9POq-`O|&wX~O|-bO~Oq*yOY&xa~Oq-fO|&iX~O|-hO~Ow-iO~Oq!aXu!aX!P!aX!b!aX%{!aX~OZ&OX~P#EoOZUX~P#EoO!P-jO~OZ-kO~OW^yZ#XXu^y!P^y!b^y#]^y#_^y#a^y#c^y#d^y#e^y#f^y#g^y#h^y#j^y#n^y#q^y&[^y&]^y&l^y&t^yY^y#o^ys^yq^y|^y~OY%^aq%^a!P%^a~P7uO!P#myY#my#o#mys#myq#my|#my~P7uOo+oOq!fa&[!fa~Oq+qO&[&ka~OZ,OO~PCpO!P-xO~O!m,TO}&ja!P&ja~O}bO!P-{O~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op.ZOvzOw.YOz}O|.UO}bO!PuO![!_O!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&]!yO&rcO~P?wO},QO~Oq,XO}&pa!P&pa~O}&cOq!|a|!|a!P!|a~OZ#iO}&cOq!|a|!|a!P!|a~O%{SO%}!sO&P!sOq%hX|%hX!P%hX~P?wOq,^O|&qa!P&qa~O|!}X~P!?hO|.eO~Os.fO~P7uOW$oO!P.gO~OW$oO$P.lO%}RO&P!bO!P&zP~OW$oO$T.mO~O!P.nO~O!b$|O#o.pOq!`X!P!`X~OY.rO~O!P.sO~P7uO#o.tO~P7uO!b.vO~OY.wOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOW!{Ou&YX%{&YX%}&YX&P&YX&|&YX~O&]!yO~P$$WOu!oO%{SO&|.yO%}%RX&P%RX~OY&QXq&QX~P7uO}'tOq%lX|%lX~P9POq-`O|&wa~O!b/PO~O}'}Oq%aX|%aX~P9POq-fO|&ia~OY/SO~O!P/TO~OZ/UO~O&l%iOq!ga&[!ga~Ou!oO%{SO}&ma!P&ma!m&ma~O!P/ZO~O!m,TO}&ji!P&ji~O|/`O~P]OW/bO~P4UOZ#iO!P&SX~P#,{OW$TOZ#iO&t#gO~Op/dOw/dO~O}&cOq!|i|!|i!P!|i~O|!}a~P!?hOW$oO!P/fO~OW$oOq/gO!P&zX~OY/kO~P7uOY/mO~OY%Wq!P%Wq~P7uO&|.yO%}%Ra&P%Ra~OY/rO~Ou!oO!P/uO!Z/vO%{SO~OY/wO~O&l%iOq!gi&[!gi~Ou!oO%{SO}&mi!P&mi!m&mi~O!m,TO}&jq!P&jq~O|/yO~P]Op/{Ow%}Oz%{O%}RO&P!bO&]!yO~O!P/|O~Oq/gO!P&za~O!P0QO~OW$oOq/gO!P&{X~OY0SO~P7uOY0TO~OY%Wy!P%Wy~P7uOu!oO%{SO%}%sa&P%sa&|%sa~OY0UO~Ou!oO!P0VO!Z0WO%{SO~Op0ZO%}RO&P!bO~OW)QOZ#iO~O!P0]O~OW$oOq%pa!P%pa~Oq/gO!P&{a~O!P0_O~Ou!oO!P0_O!Z0`O%{SO~O!P0bO~O!P0cO~O!P0eO~O!P0fO~O#o&OXY&OXs&OXq&OX|&OX~P$wO#oUXYUXsUXqUX|UX~P&{O`Q_P#f&Vc~",
  goto: "#(V&|PPPP&}'b*q-tP'bPP.Y.^/rPPPPP1^P2vPP4`7P9j<T<m>bPPP>hP@|PPPAv2vPCoPPDjPEaEgPPPPPPPPPPPPFpGXPJ_JgJqKZKaKgMVMZMZMcPMrNx! k! uP!![NxP!!b!!l!!{!#TP!#r!#|!$SNx!$V!$]EaEa!$a!$k!$n2v!&Y2v2v!(RP.^P!(VP!(vPPPPPP.^P.^!)d.^PP.^P.^PP.^!*x!+SPP!+Y!+cPPPPPPPP&}P&}PP!+g!+g!+z!+gPP!+gP!+gP!,e!,hP!+g!-O!+gP!+gP!-R!-UP!+gP!+gP!+gP!+gP!+g!+gP!+gP!-YP!-`!-c!-iP!+g!-u!-x!.Q!.d!2a!2g!2m!3s!3y!4T!5X!5_!5e!5o!5u!5{!6R!6X!6_!6e!6k!6q!6w!6}!7T!7Z!7e!7k!7u!7{PPP!8R!+g!8vP!<XP!=]P!?n!@U!CQ2vPPP!Dn!HY!JwPP!Mb!MeP# n# t##b##q##w#$w#%a#&[#&e#&h#&tP#&w#'TP#'[#'cP#'fP#'oP#'r#'u#'x#'|#(SssObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/a'kqOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l$p${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e't'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q*v+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-`-f-w.Q.S.T.V.W.d.p.s.v.x/P/S/Y/_/a/p/t/v/w0W0Y0`0j#rgO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`t!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gQ#^cS%`#P.SQ%s#`U%x#e$T/bQ&P#gW'g$l*l-T.xU'q$o&{*ZQ'r$pS(^%Y/_U(}%z+i/zQ)S&QQ+[(lQ+g)QQ-c*yR-m+]u!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gT$q!c(T#upO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#tkO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`X'h$l*l-T.x#}UO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`#}jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jQ%W!{Q([%XV-V*q-Z.y%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-V*q-Z.y%t[OW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-W*q-Z.yS!zZ-VS$S}%{S%z#e$TQ&Q#gQ+i)QQ.[,QR/z/b$eYO_bnow!X!Z!^!`!y#]#f#h#i#m#n#o#p#q#r#s#v#w#{$Y$Z$[$]$^$_$l$p$|%i%k&d&e&n&r'T'Y'Z't'}(W(X(h)T)W)|*]*a*b*e*h*l*v+o,Q,T,X,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q%U!yR+R(X%u^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0j!o!qX!i!r!t#P#_#y$t${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0Y#|jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q$Z!TQ$[!UQ$a!YQ$j!_R*i']Q#jhS&v$R)PQ(|%yQ*Q&wQ+f)OQ,[)oQ-q+hQ.a,]Q/W-rS/c.Y.ZQ/}/dQ0[/{R0a0ZQ&f$OW(s%t&g&h&iQ*P&vU+`(t(u(vQ,Z)oQ,h*QS-n+a+bS.`,[,]Q/V-oR/e.aX)f&c)h,`.drdObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW#R_#U%c,OQ'S$]W'i$l*l-T.xS(m%p(oW)a&c)h,`.dS)p&j,^S)u&m)wR-Z*qh!vX!V#_#d'R(l)`)s*_+]+w,cQ(R$}Q(_%^R+V(b#rmObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`v!tX!V#P#_#d$}%^%b%f'R'e(b(l*_*k+]-Y.S.|Q#W_Q$OzQ$P{Q$Q|Q%t#aQ%u#bQ%v#cQ(j%lS)Y&b+qY)d&c)a)h,`.dS)o&j,^Q+p)ZW+t)`)s+w,cQ+|)bQ,])pT.O+z.QU(P$|'}-fR*O&uW)f&c)h,`.dT)v&m)wQ&i$OQ&q$QQ(v%tQ({%vY)b&c)a)h,`.dV)t&m)u)wQ)[&bR-u+qQ+n)YR-t+p#tmO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`Q,P)dS-w+t.OR.R+|T#U_,OU#S_#U,OR(c%cQ,S)eQ-y+vQ-}+yQ/].PR/x/^ruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$m!aQ&`#wQ'a$jQ'p$nW)f&c)h,`.dQ*s'nQ+})cQ,W)jQ-[*rR-{+xrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS(n%p(oW)f&c)h,`.dT)v&m)wQ&h$OS(u%t&iR+b(vQ&g$OQ&l$PU(t%t&h&iQ(x%uS+a(u(vR-o+bQ)n&eR)y&nQ&p$QS(z%v&qR+e({Q&o$QU(y%v&p&qS+d(z({R-p+eS(n%p(oT)v&m)wrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW)f&c)h,`.dT)v&m)wQ&k$PS(w%u&lR+c(xQ)q&jR.b,^R,b)rQ%q#^R(r%sT(n%p(oQ,R)eS-|+y,SR/[-}R.W,QWj$l*l-T.x#ukO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#|hO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`U%y#e$T/bS)O%z/zQ+h)QR-r+iT&t$R&u!]#ml#Q$`$h$k&O&R&S&V&W&X&Y&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o!V#nl#Q$`$h$k&O&R&S&W&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o#umO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`a'u$p't*v-`/P/v0W0`Q'w$pR-d*yQ&y$UQ'y$uR*|'zT*R&x*SsuObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/artObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$e![R$g!]R$^!WruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aR'T$]R$_!WR'[$aT*d'Z*eX'k$m'l'p*tR*r'mQ-Y*qR.|-ZQ'o$mQ*p'lQ*u'pR-]*tR$n!aQ'j$lV-R*l-T.xQwOQ#]bW#|w#].V/aQ.V,QR/a.WrWObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/al!kW!p#O#Y#x%R%X%g&s'Q)Z+{.T0j!j!pX!i!t#P#_#y${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0YQ#O_Q#Y`#^#xno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%i%k&d&e&n&r'T'Y't'}(W(h)T)W)|*a*b*h*v+o,T,X,t,v-P-`-f.p.s.v/P/v0W0`S%R!y(XQ%X!{j%g#U%c%p&c&j&m(o)h)w*q,^,`.dS&s$R&uY'Q$]$l*l-T.xS)Z&b+qS+{)b)tQ.T,OR0j#vQ!fTR$r!fQ(Y%UR+S(Y^!rX#P#y&]'R'e)Xx$t!i#_%S%Y%b%f(l)`)s*_*k+]+w+z,c-X.Q.S/_/p[$z!r$t${/Y/t0YS${!t+tQ/Y-wQ/t/SR0Y/wQ)U&SR+l)UQ)h&cS,U)h.dR.d,`!laO_bw!Z#U#]#{$Z$[$]$^$_$l%c%p&c&j&m'Z(o)h)w*]*e*l*q,O,Q,^,`-T.V.W.d.x/aY!jW#O%g'Q.TT#Za!jQ-g*}R/R-gQ%O!vR(S%OQ%j#VS(g%j/XR/X-sQ+r)[R-v+rQ%d#SR(d%dQ,Y)lR._,YQ)w&mR,d)wQ,_)qR.c,_Q(o%pR+^(oQ&u$RR)}&uQ%m#WR(k%mQ-a*wR/O-aQ*z'wR-e*zQ*S&xR,i*SQ,m*UR.i,mQ/h.jS0P/h0RR0R/jQ*e'ZR,z*eQ'l$mS*o'l*tR*t'pQ.z-XR/q.zQ*m'jR-U*m`vObw#],Q.V.W/aQ$b!ZQ&a#{Q'O$ZQ'P$[Q'V$^Q'W$_S*d'Z*eR,s*]'YrOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-f-w.Q.S.T.V.W.d.p.s.v.x/S/Y/_/a/p/t/w0Y0ja'v$p't*v-`/P/v0W0`Q!cSQ$U!PQ$V!RQ$W!SQ$u!lQ$w!nQ&}$XQ'z$vQ(T0gS,k*U*WQ,o*VQ,p*XQ.h,mS.j,o.lQ/j.mR0O/g%oROS_bcnow!P!R!S!X!Z!^!`!l!n#P#]#`#e#f#g#h#i#m#n#o#p#q#r#s#w#{$T$X$Y$Z$[$]$^$_$l$o$p$v$|%Y%k%z&Q&r&{'T'Y'Z't'}(h(l)Q)T)W)|*U*V*W*X*Z*]*a*b*e*h*l*v*y+]+i,Q,m,o,t,v-P-T-`-f.S.V.W.l.m.p.s.v.x/P/_/a/b/g/v/z0W0`0gQ'x$pQ*w'tS-_*v/PQ.}-`Q0X/vQ0^0WR0d0`rlObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS#Q_$YQ#tnQ#zoQ$`!XQ$h!^Q$k!`Q&O#fQ&R#hY&S#i$]*a,v.sQ&U#mQ&V#nQ&W#oQ&X#pQ&Y#qQ&Z#rQ&[#sQ&_#w^'s$p't-`/P/v0W0`U(O$|'}-fQ(i%kQ){&rQ*`'TQ*c'YQ+W(hQ+k)TQ+m)WQ,g)|Q,x*bQ,}*hQ-^*vQ.o,tQ.u-PQ/l.pR/o.v#rfO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`W'f$l*l-T.xR.X,QrXObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW!iW#x%R'QQ#P_Q#_d!|#yno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%k&r'T'Y't'}(h)T)W)|*a*b*h*v,t,v-P-`-f.p.s.v/P/v0W0`d%S!y%i&d&e&n(W(X+o,T,XQ%Y#OQ%b#RS%f#U%cQ&]#vQ'R$]W'e$l*l-T.xS(l%p(oQ)X0jW)`&c)h,`.dS)s&m)wQ*_'SQ*k'iQ+](mQ+w)aS+z)b)tQ,c)uS-X*q-ZQ.Q+{Q.S,OQ/_.TR/p.y%t^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jQ$R}Q&w$SR)P%{&PVOW_bdnow}!X!Z!^!`!y!{#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%X%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jR%V!y#ziObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q#V_Q%U!yQ&^#vQ(f%iQ)k&dU)l&e&n,TQ+Q(WQ+R(XQ-s+oR.^,XQ(V%TR+P(U#|eO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`T%w#e/bQ&T#iQ'U$]Q,w*aQ.q,vR/n.sX)g&c)h,`.d!{`OW_abw!Z!j#O#U#]#{$Z$[$]$^$_$l%c%g%p&c&j&m'Q'Z(o)h)w*]*e*l*q,O,Q,^,`-T.T.V.W.d.x/aU!wX!V'RU%r#_#d*_S+Z(l)sQ+u)`S-l+],cR-z+wj!uX!V#_#d$}%^(b(l)`)s+]+w,cU%]#P%f.SQ(a%bQ*^'RQ*j'eQ,u*_Q-Q*kQ.{-YR/s.|Q(Q$|Q*}'}R/Q-fR+O'}[)c&c&m)h)w,`.dT+x)a)uR)]&bW+v)`)s+w,cQ.P+zR/^.QS#T_,OR%h#US)m&e&nR.],TR)r&jW)e&c)h,`.dR+y)aR#X_R*x'tR'x$pT,l*U,mQ.k,oR/i.lR/i.m",
  nodeNames: "⚠ LineComment BlockComment Program ModuleDeclaration MarkerAnnotation Identifier ScopedIdentifier . Annotation ) ( AnnotationArgumentList AssignmentExpression FieldAccess IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock null ClassLiteral void PrimitiveType TypeName ScopedTypeName GenericType TypeArguments AnnotatedType Wildcard extends super , ArrayType ] Dimension [ class this ParenthesizedExpression ObjectCreationExpression new ArgumentList } { ClassBody ; FieldDeclaration Modifiers public protected private abstract static final strictfp default synchronized native transient volatile VariableDeclarator Definition AssignOp ArrayInitializer MethodDeclaration TypeParameters TypeParameter TypeBound FormalParameters ReceiverParameter FormalParameter SpreadParameter Throws throws Block ClassDeclaration Superclass SuperInterfaces implements InterfaceTypeList InterfaceDeclaration interface ExtendsInterfaces InterfaceBody ConstantDeclaration EnumDeclaration enum EnumBody EnumConstant EnumBodyDeclarations AnnotationTypeDeclaration AnnotationTypeBody AnnotationTypeElementDeclaration StaticInitializer ConstructorDeclaration ConstructorBody ExplicitConstructorInvocation ArrayAccess MethodInvocation MethodName MethodReference ArrayCreationExpression Dimension AssignOp BinaryExpression CompareOp CompareOp LogicOp BitOp BitOp LogicOp ArithOp ArithOp ArithOp BitOp InstanceofExpression instanceof LambdaExpression InferredParameters TernaryExpression LogicOp : UpdateExpression UpdateOp UnaryExpression LogicOp BitOp CastExpression ElementValueArrayInitializer ElementValuePair open module ModuleBody ModuleDirective requires transitive exports to opens uses provides with PackageDeclaration package ImportDeclaration import Asterisk ExpressionStatement LabeledStatement Label IfStatement if else WhileStatement while ForStatement for ForSpec LocalVariableDeclaration var EnhancedForStatement ForSpec AssertStatement assert SwitchStatement switch SwitchBlock SwitchLabel case DoStatement do BreakStatement break ContinueStatement continue ReturnStatement return SynchronizedStatement ThrowStatement throw TryStatement try CatchClause catch CatchFormalParameter CatchType FinallyClause finally TryWithResourcesStatement ResourceSpecification Resource",
  maxTerm: 274,
  nodeProps: [
    ["group", -26, 4, 47, 76, 77, 82, 87, 92, 144, 146, 149, 150, 152, 155, 157, 160, 162, 164, 166, 171, 173, 175, 177, 179, 180, 182, 190, "Statement", -25, 6, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 39, 40, 41, 99, 100, 102, 103, 106, 117, 119, 121, 124, 126, 129, "Expression", -7, 23, 24, 25, 26, 27, 29, 34, "Type"],
    ["openedBy", 10, "(", 44, "{"],
    ["closedBy", 11, ")", 45, "}"]
  ],
  propSources: [S7],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 28,
  tokenData: "#$f_R!_OX%QXY'fYZ)bZ^'f^p%Qpq'fqr*|rs,^st%Qtu4euv5qvw7Rwx8ixyAQyzAnz{B[{|CQ|}Dh}!OEU!O!PFo!P!Q! i!Q!R!,_!R![!0V![!]!>g!]!^!?w!^!_!@e!_!`!BO!`!a!Br!a!b!D`!b!c!EO!c!}!Kz!}#O!MW#O#P%Q#P#Q!Mt#Q#R!Nb#R#S4e#S#T%Q#T#o4e#o#p# U#p#q# r#q#r##[#r#s##x#s#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%QS%VV&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS%qO&WSS%tVOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZS&^VOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS&vP;=`<%l%QS&|UOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZS'cP;=`<%l&Z_'mk&WS%wZOX%QXY'fYZ)bZ^'f^p%Qpq'fqr%Qrs%qs#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%Q_)iY&WS%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XZ*^Y%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XV+TX#sP&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QU+wV#_Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT,aXOY,|YZ%lZr,|rs3Ys#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T-PXOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT-qX&WSOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT.cVcPOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZT.}V&WSOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT/iW&WSOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0UWOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0sOcPP0vTOY0RYZ0RZ;'S0R;'S;=`1V<%lO0RP1YP;=`<%l0RT1`XOY,|YZ%lZr,|rs1{s#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T2QUcPOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZT2gVOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT3PP;=`<%l-lT3VP;=`<%l,|T3_VcPOY&ZYZ%lZr&Zrs3ts;'S&Z;'S;=`'`<%lO&ZT3yR&USXY4SYZ4`pq4SP4VRXY4SYZ4`pq4SP4eO&VP_4la%}Z&WSOY%QYZ%lZr%Qrs%qst%Qtu4eu!Q%Q!Q![4e![!c%Q!c!}4e!}#R%Q#R#S4e#S#T%Q#T#o4e#o;'S%Q;'S;=`&s<%lO%QU5xX#gQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU6lV#]Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV7YZ&lR&WSOY%QYZ%lZr%Qrs%qsv%Qvw7{w!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU8SV#aQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT8nZ&WSOY9aYZ%lZr9ars:osw9awx%Qx#O9a#O#P;y#P;'S9a;'S;=`@z<%lO9aT9fX&WSOY%QYZ%lZr%Qrs%qsw%Qwx:Rx;'S%Q;'S;=`&s<%lO%QT:YVbP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT:rXOY&ZYZ%lZr&Zrs&ysw&Zwx;_x;'S&Z;'S;=`'`<%lO&ZT;dVbPOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT<OZ&WSOY<qYZ%lZr<qrs=isw<qwx9ax#O<q#O#P9a#P;'S<q;'S;=`?T<%lO<qT<vZ&WSOY<qYZ%lZr<qrs=isw<qwx:Rx#O<q#O#P%Q#P;'S<q;'S;=`?T<%lO<qT=lZOY>_YZ%lZr>_rs?Zsw>_wx;_x#O>_#O#P&Z#P;'S>_;'S;=`@t<%lO>_T>bZOY<qYZ%lZr<qrs=isw<qwx:Rx#O<q#O#P%Q#P;'S<q;'S;=`?T<%lO<qT?WP;=`<%l<qT?^ZOY>_YZ%lZr>_rs@Psw>_wx;_x#O>_#O#P&Z#P;'S>_;'S;=`@t<%lO>_P@SVOY@PZw@Pwx@ix#O@P#P;'S@P;'S;=`@n<%lO@PP@nObPP@qP;=`<%l@PT@wP;=`<%l>_T@}P;=`<%l9a_AXVZZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVAuVYR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVBeX$YP&WS#fQOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVCXZ#eR&WSOY%QYZ%lZr%Qrs%qs{%Q{|Cz|!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVDRV#qR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVDoVqR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVE][#eR&WSOY%QYZ%lZr%Qrs%qs}%Q}!OCz!O!_%Q!_!`6e!`!aFR!a;'S%Q;'S;=`&s<%lO%QVFYV&vR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_FvZWY&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PGi!P!Q%Q!Q![Hw![;'S%Q;'S;=`&s<%lO%QVGnX&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PHZ!P;'S%Q;'S;=`&s<%lO%QVHbV&oR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTIOc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![!f%Q!f!gJZ!g!hJw!h!iJZ!i#R%Q#R#SNq#S#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QTJbV&WS`POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTJ|]&WSOY%QYZ%lZr%Qrs%qs{%Q{|Ku|}%Q}!OKu!O!Q%Q!Q![Lg![;'S%Q;'S;=`&s<%lO%QTKzX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![;'S%Q;'S;=`&s<%lO%QTLnc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![!f%Q!f!gJZ!g!h%Q!h!iJZ!i#R%Q#R#SMy#S#W%Q#W#XJZ#X#Y%Q#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QTNOZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![#R%Q#R#SMy#S;'S%Q;'S;=`&s<%lO%QTNvZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![#R%Q#R#SNq#S;'S%Q;'S;=`&s<%lO%Q_! p]&WS#fQOY%QYZ%lZr%Qrs%qsz%Qz{!!i{!P%Q!P!Q!)[!Q!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%Q_!!nX&WSOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{;'S!!i;'S;=`!'j<%lO!!i_!#`T&WSOz!#oz{!$R{;'S!#o;'S;=`!$p<%lO!#oZ!#rTOz!#oz{!$R{;'S!#o;'S;=`!$p<%lO!#oZ!$UVOz!#oz{!$R{!P!#o!P!Q!$k!Q;'S!#o;'S;=`!$p<%lO!#oZ!$pOQZZ!$sP;=`<%l!#o_!$yXOY!%fYZ!#ZZr!%frs!'psz!%fz{!(`{;'S!%f;'S;=`!)U<%lO!%f_!%iXOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{;'S!!i;'S;=`!'j<%lO!!i_!&ZZ&WSOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{!P!!i!P!Q!&|!Q;'S!!i;'S;=`!'j<%lO!!i_!'TV&WSQZOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!'mP;=`<%l!!i_!'sXOY!%fYZ!#ZZr!%frs!#osz!%fz{!(`{;'S!%f;'S;=`!)U<%lO!%f_!(cZOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{!P!!i!P!Q!&|!Q;'S!!i;'S;=`!'j<%lO!!i_!)XP;=`<%l!%f_!)cV&WSPZOY!)[YZ%lZr!)[rs!)xs;'S!)[;'S;=`!+O<%lO!)[_!)}VPZOY!*dYZ%lZr!*drs!+Us;'S!*d;'S;=`!,X<%lO!*d_!*iVPZOY!)[YZ%lZr!)[rs!)xs;'S!)[;'S;=`!+O<%lO!)[_!+RP;=`<%l!)[_!+ZVPZOY!*dYZ%lZr!*drs!+ps;'S!*d;'S;=`!,X<%lO!*dZ!+uSPZOY!+pZ;'S!+p;'S;=`!,R<%lO!+pZ!,UP;=`<%l!+p_!,[P;=`<%l!*dT!,fu&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.y!P!Q%Q!Q![!0V![!d%Q!d!e!3a!e!f%Q!f!gJZ!g!hJw!h!iJZ!i!n%Q!n!o!1{!o!q%Q!q!r!5_!r!z%Q!z!{!7V!{#R%Q#R#S!2i#S#U%Q#U#V!3a#V#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z#`%Q#`#a!1{#a#c%Q#c#d!5_#d#l%Q#l#m!7V#m;'S%Q;'S;=`&s<%lO%QT!/Qa&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![!f%Q!f!gJZ!g!hJw!h!iJZ!i#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QT!0^i&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.y!P!Q%Q!Q![!0V![!f%Q!f!gJZ!g!hJw!h!iJZ!i!n%Q!n!o!1{!o#R%Q#R#S!2i#S#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!2SV&WS_POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT!2nZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!0V![#R%Q#R#S!2i#S;'S%Q;'S;=`&s<%lO%QT!3fY&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4U!R!S!4U!S;'S%Q;'S;=`&s<%lO%QT!4]`&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4U!R!S!4U!S!n%Q!n!o!1{!o#R%Q#R#S!3a#S#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!5dX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!6P!Y;'S%Q;'S;=`&s<%lO%QT!6W_&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!6P!Y!n%Q!n!o!1{!o#R%Q#R#S!5_#S#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!7[_&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!P!8Z!P!Q%Q!Q![!:i![!c%Q!c!i!:i!i#T%Q#T#Z!:i#Z;'S%Q;'S;=`&s<%lO%QT!8`]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i#T%Q#T#Z!9X#Z;'S%Q;'S;=`&s<%lO%QT!9^c&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i!r%Q!r!sJw!s#R%Q#R#S!8Z#S#T%Q#T#Z!9X#Z#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!:pi&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!<_!P!Q%Q!Q![!:i![!c%Q!c!i!:i!i!n%Q!n!o!1{!o!r%Q!r!sJw!s#R%Q#R#S!=i#S#T%Q#T#Z!:i#Z#`%Q#`#a!1{#a#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!<da&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i!r%Q!r!sJw!s#T%Q#T#Z!9X#Z#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!=n]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!:i![!c%Q!c!i!:i!i#T%Q#T#Z!:i#Z;'S%Q;'S;=`&s<%lO%QV!>nX#oR&WSOY%QYZ%lZr%Qrs%qs![%Q![!]!?Z!];'S%Q;'S;=`&s<%lO%QV!?bV&tR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!@OV!PR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!@lY&]Z&WSOY%QYZ%lZr%Qrs%qs!^%Q!^!_!A[!_!`+p!`;'S%Q;'S;=`&s<%lO%QU!AcX#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV!BVX!bR&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QV!ByY&[R&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`!a!Ci!a;'S%Q;'S;=`&s<%lO%QU!CpY#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`!a!A[!a;'S%Q;'S;=`&s<%lO%Q_!DiV&`X#nQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!EVX%{Z&WSOY%QYZ%lZr%Qrs%qs#]%Q#]#^!Er#^;'S%Q;'S;=`&s<%lO%QV!EwX&WSOY%QYZ%lZr%Qrs%qs#b%Q#b#c!Fd#c;'S%Q;'S;=`&s<%lO%QV!FiX&WSOY%QYZ%lZr%Qrs%qs#h%Q#h#i!GU#i;'S%Q;'S;=`&s<%lO%QV!GZX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!Gv#Y;'S%Q;'S;=`&s<%lO%QV!G{X&WSOY%QYZ%lZr%Qrs%qs#f%Q#f#g!Hh#g;'S%Q;'S;=`&s<%lO%QV!HmX&WSOY%QYZ%lZr%Qrs%qs#Y%Q#Y#Z!IY#Z;'S%Q;'S;=`&s<%lO%QV!I_X&WSOY%QYZ%lZr%Qrs%qs#T%Q#T#U!Iz#U;'S%Q;'S;=`&s<%lO%QV!JPX&WSOY%QYZ%lZr%Qrs%qs#V%Q#V#W!Jl#W;'S%Q;'S;=`&s<%lO%QV!JqX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!K^#Y;'S%Q;'S;=`&s<%lO%QV!KeV&rR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!LRa&PZ&WSOY%QYZ%lZr%Qrs%qst%Qtu!Kzu!Q%Q!Q![!Kz![!c%Q!c!}!Kz!}#R%Q#R#S!Kz#S#T%Q#T#o!Kz#o;'S%Q;'S;=`&s<%lO%Q_!M_VuZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!M{VsR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QU!NiX#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV# ]V}R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_# {Z&|X#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`#p%Q#p#q#!n#q;'S%Q;'S;=`&s<%lO%QU#!uV#dQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV##cV|R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT#$PV#tP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q",
  tokenizers: [0, 1, 2, 3],
  topRules: { Program: [0, 3] },
  dynamicPrecedences: { 27: 1, 230: -1, 241: -1 },
  specialized: [{ term: 229, get: (t10) => $7[t10] || -1 }],
  tokenPrec: 7067
}), P7 = /* @__PURE__ */ qi.define({
  name: "java",
  parser: /* @__PURE__ */ w7.configure({
    props: [
      /* @__PURE__ */ xa.add({
        IfStatement: /* @__PURE__ */ xi({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ xi({ except: /^\s*({|catch|finally)\b/ }),
        LabeledStatement: UP,
        SwitchBlock: (t10) => {
          let e3 = t10.textAfter, r3 = /^\s*\}/.test(e3), n3 = /^\s*(case|default)\b/.test(e3);
          return t10.baseIndent + (r3 ? 0 : n3 ? 1 : 2) * t10.unit;
        },
        Block: /* @__PURE__ */ yl({ closing: "}" }),
        BlockComment: () => null,
        Statement: /* @__PURE__ */ xi({ except: /^{/ })
      }),
      /* @__PURE__ */ Qa.add({
        "Block SwitchBlock ClassBody ElementValueArrayInitializer ModuleBody EnumBody ConstructorBody InterfaceBody ArrayInitializer": cu,
        BlockComment(t10) {
          return { from: t10.from + 2, to: t10.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\})$/
  }
});
function _7() {
  return new _a(P7);
}
const x7 = Os({
  String: R.string,
  Number: R.number,
  "True False": R.bool,
  PropertyName: R.propertyName,
  Null: R.null,
  ",": R.separator,
  "[ ]": R.squareBracket,
  "{ }": R.brace
}), Q7 = Ci.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [x7],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), T7 = /* @__PURE__ */ qi.define({
  name: "json",
  parser: /* @__PURE__ */ Q7.configure({
    props: [
      /* @__PURE__ */ xa.add({
        Object: /* @__PURE__ */ xi({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ xi({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ Qa.add({
        "Object Array": cu
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function k7() {
  return new _a(T7);
}
const E7 = 1, O_ = 196, m_ = 197, C7 = 198, qv = 199, R7 = 200, A7 = 201, X7 = 202, q7 = 2, D7 = 203, j7 = 204, U7 = 3, I7 = 205, F7 = 206, Z7 = 4, M7 = 207, N7 = 208, W7 = 5, V7 = 209, Y7 = 26, L7 = 27, B7 = 51, z7 = 52, H7 = 57, G7 = 58, K7 = 59, J7 = 61, e6 = 62, t6 = 63, r6 = 64, n6 = 65, i6 = 67, o6 = 246, s6 = 74, a6 = 265, l6 = 129, u6 = 150, c6 = 151, f6 = 154, Zl = 10, Ml = 13, Zg = 32, td = 9, Mg = 35, d6 = 40, h6 = 46, Dv = 123, g_ = 39, y_ = 34, p6 = 92, O6 = /* @__PURE__ */ new Set([
  L7,
  B7,
  z7,
  a6,
  i6,
  l6,
  G7,
  K7,
  o6,
  r6,
  n6,
  s6,
  e6,
  t6,
  u6,
  c6,
  f6
]);
function Eh(t10) {
  return t10 == Zl || t10 == Ml;
}
const m6 = new Wr((t10, e3) => {
  let r3;
  if (t10.next < 0)
    t10.acceptToken(A7);
  else if (e3.context.depth < 0)
    Eh(t10.next) && t10.acceptToken(R7, 1);
  else if (((r3 = t10.peek(-1)) < 0 || Eh(r3)) && e3.canShift(qv)) {
    let n3 = 0;
    for (; t10.next == Zg || t10.next == td; )
      t10.advance(), n3++;
    (t10.next == Zl || t10.next == Ml || t10.next == Mg) && t10.acceptToken(qv, -n3);
  } else
    Eh(t10.next) && t10.acceptToken(C7, 1);
}, { contextual: true }), g6 = new Wr((t10, e3) => {
  let r3 = e3.context.depth;
  if (r3 < 0)
    return;
  let n3 = t10.peek(-1);
  if (n3 == Zl || n3 == Ml) {
    let i3 = 0, o3 = 0;
    for (; ; ) {
      if (t10.next == Zg)
        i3++;
      else if (t10.next == td)
        i3 += 8 - i3 % 8;
      else
        break;
      t10.advance(), o3++;
    }
    i3 != r3 && t10.next != Zl && t10.next != Ml && t10.next != Mg && (i3 < r3 ? t10.acceptToken(m_, -o3) : t10.acceptToken(O_));
  }
});
function $O(t10, e3) {
  this.parent = t10, this.depth = e3, this.hash = (t10 ? t10.hash + t10.hash << 8 : 0) + e3 + (e3 << 4);
}
const y6 = new $O(null, 0);
function v6(t10) {
  let e3 = 0;
  for (let r3 = 0; r3 < t10.length; r3++)
    e3 += t10.charCodeAt(r3) == td ? 8 - e3 % 8 : 1;
  return e3;
}
const b6 = new Sg({
  start: y6,
  reduce(t10, e3) {
    return t10.depth < 0 && O6.has(e3) ? t10.parent : t10;
  },
  shift(t10, e3, r3, n3) {
    return e3 == O_ ? new $O(t10, v6(n3.read(n3.pos, r3.pos))) : e3 == m_ ? t10.parent : e3 == Y7 || e3 == H7 || e3 == J7 ? new $O(t10, -1) : t10;
  },
  hash(t10) {
    return t10.hash;
  }
}), S6 = new Wr((t10) => {
  for (let e3 = 0; e3 < 5; e3++) {
    if (t10.next != "print".charCodeAt(e3))
      return;
    t10.advance();
  }
  if (!/\w/.test(String.fromCharCode(t10.next)))
    for (let e3 = 0; ; e3++) {
      let r3 = t10.peek(e3);
      if (!(r3 == Zg || r3 == td)) {
        r3 != d6 && r3 != h6 && r3 != Zl && r3 != Ml && r3 != Mg && t10.acceptToken(E7);
        return;
      }
    }
});
function rd(t10, e3, r3, n3, i3) {
  return new Wr((o3) => {
    let s3 = o3.pos;
    for (; !(o3.next < 0); )
      if (o3.next == Dv)
        if (o3.peek(1) == Dv)
          o3.advance(2);
        else {
          if (o3.pos == s3) {
            o3.acceptToken(n3, 1);
            return;
          }
          break;
        }
      else if (o3.next == p6)
        o3.advance(), o3.next >= 0 && o3.advance();
      else if (o3.next == t10 && (e3 == 1 || o3.peek(1) == t10 && o3.peek(2) == t10)) {
        if (o3.pos == s3) {
          o3.acceptToken(i3, e3);
          return;
        }
        break;
      } else
        o3.advance();
    o3.pos > s3 && o3.acceptToken(r3);
  });
}
const $6 = rd(g_, 1, X7, q7, D7), w6 = rd(y_, 1, j7, U7, I7), P6 = rd(g_, 3, F7, Z7, M7), _6 = rd(y_, 3, N7, W7, V7), x6 = Os({
  'async "*" "**" FormatConversion FormatSpec': R.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": R.controlKeyword,
  "in not and or is del": R.operatorKeyword,
  "from def class global nonlocal lambda": R.definitionKeyword,
  import: R.moduleKeyword,
  "with as print": R.keyword,
  Boolean: R.bool,
  None: R.null,
  VariableName: R.variableName,
  "CallExpression/VariableName": R.function(R.variableName),
  "FunctionDefinition/VariableName": R.function(R.definition(R.variableName)),
  "ClassDefinition/VariableName": R.definition(R.className),
  PropertyName: R.propertyName,
  "CallExpression/MemberExpression/PropertyName": R.function(R.propertyName),
  Comment: R.lineComment,
  Number: R.number,
  String: R.string,
  FormatString: R.special(R.string),
  UpdateOp: R.updateOperator,
  "ArithOp!": R.arithmeticOperator,
  BitOp: R.bitwiseOperator,
  CompareOp: R.compareOperator,
  AssignOp: R.definitionOperator,
  Ellipsis: R.punctuation,
  At: R.meta,
  "( )": R.paren,
  "[ ]": R.squareBracket,
  "{ }": R.brace,
  ".": R.derefOperator,
  ", ;": R.separator
}), Q6 = { __proto__: null, await: 48, or: 58, and: 60, in: 64, not: 66, is: 68, if: 74, else: 76, lambda: 80, yield: 98, from: 100, async: 106, for: 108, None: 168, True: 170, False: 170, del: 184, pass: 188, break: 192, continue: 196, return: 200, raise: 208, import: 212, as: 214, global: 218, nonlocal: 220, assert: 224, elif: 234, while: 238, try: 244, except: 246, finally: 248, with: 252, def: 256, class: 266, match: 277, case: 283 }, T6 = Ci.deserialize({
  version: 14,
  states: "#!OO`Q#yOOP$_OSOOO%hQ&nO'#H^OOQS'#Cq'#CqOOQS'#Cr'#CrO'WQ#xO'#CpO(yQ&nO'#H]OOQS'#H^'#H^OOQS'#DW'#DWOOQS'#H]'#H]O)gQ#xO'#DaO)zQ#xO'#DhO*[Q#xO'#DlOOQS'#Dw'#DwO*oO,UO'#DwO*wO7[O'#DwO+POWO'#DxO+[O`O'#DxO+gOpO'#DxO+rO!bO'#DxO-tQ&nO'#G}OOQS'#G}'#G}O'WQ#xO'#G|O/WQ&nO'#G|OOQS'#Ee'#EeO/oQ#xO'#EfOOQS'#G{'#G{O/yQ#xO'#GzOOQV'#Gz'#GzO0UQ#xO'#FXOOQS'#G`'#G`O0ZQ#xO'#FWOOQV'#IS'#ISOOQV'#Gy'#GyOOQV'#Fp'#FpQ`Q#yOOO'WQ#xO'#CsO0iQ#xO'#DPO0pQ#xO'#DTO1OQ#xO'#HbO1`Q&nO'#EYO'WQ#xO'#EZOOQS'#E]'#E]OOQS'#E_'#E_OOQS'#Ea'#EaO1tQ#xO'#EcO2[Q#xO'#EgO0UQ#xO'#EiO2oQ&nO'#EiO0UQ#xO'#ElO/oQ#xO'#EoO/oQ#xO'#EsO/oQ#xO'#EvO2zQ#xO'#ExO3RQ#xO'#E}O3^Q#xO'#EyO/oQ#xO'#E}O0UQ#xO'#FPO0UQ#xO'#FUO3cQ#xO'#FZP3jO#xO'#GxPOOO)CBl)CBlOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Ck'#CkOOQS'#Cl'#ClOOQS'#Cn'#CnO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO3uQ#xO'#DqOOQS,5:[,5:[O4YQ#xO'#HlOOQS,5:_,5:_O4gQMlO,5:_O4lQ&nO,59[O0iQ#xO,59dO0iQ#xO,59dO0iQ#xO,59dO7[Q#xO,59dO7aQ#xO,59dO7hQ#xO,59lO7oQ#xO'#H]O8uQ#xO'#H[OOQS'#H['#H[OOQS'#D^'#D^O9^Q#xO,59cO'WQ#xO,59cO9lQ#xO,59cOOQS,59{,59{O9qQ#xO,5:TO'WQ#xO,5:TOOQS,5:S,5:SO:PQ#xO,5:SO:UQ#xO,5:ZO'WQ#xO,5:ZO'WQ#xO,5:XOOQS,5:W,5:WO:gQ#xO,5:WO:lQ#xO,5:YOOOO'#Fx'#FxO:qO,UO,5:cOOQS,5:c,5:cOOOO'#Fy'#FyO:yO7[O,5:cO;RQ#xO'#DyOOOW'#Fz'#FzO;cOWO,5:dOOQS,5:d,5:dO;RQ#xO'#D}OOO`'#F}'#F}O;nO`O,5:dO;RQ#xO'#EOOOOp'#GO'#GOO;yOpO,5:dO;RQ#xO'#EPOOO!b'#GP'#GPO<UO!bO,5:dOOQS'#GQ'#GQO<aQ&nO,5:lO?RQ&nO,5=hO?lQ!LUO,5=hO@]Q&nO,5=hOOQS,5;Q,5;QO@tQ#yO'#GYOBTQ#xO,5;]OOQV,5=f,5=fOB`Q&nO'#IOOBwQ#xO,5;sOOQS-E:^-E:^OOQV,5;r,5;rO3XQ#xO'#FPOOQV-E9n-E9nOCPQ&nO,59_OEWQ&nO,59kOEqQ#xO'#H_OE|Q#xO'#H_O0UQ#xO'#H_OFXQ#xO'#DVOFaQ#xO,59oOFfQ#xO'#HcO'WQ#xO'#HcO/oQ#xO,5=|OOQS,5=|,5=|O/oQ#xO'#EUOOQS'#EV'#EVOGTQ#xO'#GSOGeQ#xO,59OOGeQ#xO,59OO)mQ#xO,5:rOGsQ&nO'#HeOOQS,5:u,5:uOOQS,5:},5:}OHWQ#xO,5;ROHiQ#xO,5;TOOQS'#GV'#GVOHwQ&nO,5;TOIVQ#xO,5;TOI[Q#xO'#IROOQS,5;W,5;WOIjQ#xO'#H}OOQS,5;Z,5;ZO3^Q#xO,5;_O3^Q#xO,5;bOI{Q&nO'#ITO'WQ#xO'#ITOJVQ#xO,5;dO2zQ#xO,5;dO/oQ#xO,5;iO0UQ#xO,5;kOJ[Q#yO'#EtOKeQ#{O,5;eONvQ#xO'#IUO3^Q#xO,5;iO! RQ#xO,5;kO! WQ#xO,5;pO! `Q&nO,5;uO'WQ#xO,5;uPOOO,5=d,5=dP! gOSO,5=dP! lO#xO,5=dO!$aQ&nO1G.lO!$hQ&nO1G.lO!'XQ&nO1G.lO!'cQ&nO1G.lO!)|Q&nO1G.lO!*aQ&nO1G.lO!*tQ#xO'#HkO!+SQ&nO'#G}O/oQ#xO'#HkO!+^Q#xO'#HjOOQS,5:],5:]O!+fQ#xO,5:]O!+kQ#xO'#HmO!+vQ#xO'#HmO!,ZQ#xO,5>WOOQS'#Du'#DuOOQS1G/y1G/yOOQS1G/O1G/OO!-ZQ&nO1G/OO!-bQ&nO1G/OO0iQ#xO1G/OO!-}Q#xO1G/WOOQS'#D]'#D]O/oQ#xO,59vOOQS1G.}1G.}O!.UQ#xO1G/gO!.fQ#xO1G/gO!.nQ#xO1G/hO'WQ#xO'#HdO!.sQ#xO'#HdO!.xQ&nO1G.}O!/YQ#xO,59kO!0`Q#xO,5>SO!0pQ#xO,5>SO!0xQ#xO1G/oO!0}Q&nO1G/oOOQS1G/n1G/nO!1_Q#xO,5=}O!2UQ#xO,5=}O/oQ#xO1G/sO!2sQ#xO1G/uO!2xQ&nO1G/uO!3YQ&nO1G/sOOQS1G/r1G/rOOQS1G/t1G/tOOOO-E9v-E9vOOQS1G/}1G/}OOOO-E9w-E9wO!3jQ#xO'#HwO/oQ#xO'#HwO!3xQ#xO,5:eOOOW-E9x-E9xOOQS1G0O1G0OO!4TQ#xO,5:iOOO`-E9{-E9{O!4`Q#xO,5:jOOOp-E9|-E9|O!4kQ#xO,5:kOOO!b-E9}-E9}OOQS-E:O-E:OO!4vQ!LUO1G3SO!5gQ&nO1G3SO'WQ#xO,5<mOOQS,5<m,5<mOOQS-E:P-E:POOQS,5<t,5<tOOQS-E:W-E:WOOQV1G0w1G0wO0UQ#xO'#GUO!6OQ&nO,5>jOOQS1G1_1G1_O!6gQ#xO1G1_OOQS'#DX'#DXO/oQ#xO,5=yOOQS,5=y,5=yO!6lQ#xO'#FqO!6wQ#xO,59qO!7PQ#xO1G/ZO!7ZQ&nO,5=}OOQS1G3h1G3hOOQS,5:p,5:pO!7zQ#xO'#G|OOQS,5<n,5<nOOQS-E:Q-E:QO!8]Q#xO1G.jOOQS1G0^1G0^O!8kQ#xO,5>PO!8{Q#xO,5>PO/oQ#xO1G0mO/oQ#xO1G0mO0UQ#xO1G0oOOQS-E:T-E:TO!9^Q#xO1G0oO!9iQ#xO1G0oO!9nQ#xO,5>mO!9|Q#xO,5>mO!:[Q#xO,5>iO!:rQ#xO,5>iO!;TQ#{O1G0yO!>cQ#{O1G0|O!AnQ#xO,5>oO!AxQ#xO,5>oO!BQQ&nO,5>oO/oQ#xO1G1OO!B[Q#xO1G1OO3^Q#xO1G1TO! RQ#xO1G1VOOQV,5;`,5;`O!BaQ#zO,5;`O!BfQ#{O1G1PO!EwQ#xO'#G]O3^Q#xO1G1PO3^Q#xO1G1PO!FUQ#xO,5>pO!FcQ#xO,5>pO0UQ#xO,5>pOOQV1G1T1G1TO!FkQ#xO'#FRO!F|QMlO1G1VOOQV1G1[1G1[O3^Q#xO1G1[O!GUQ#xO'#F]OOQV1G1a1G1aO! `Q&nO1G1aPOOO1G3O1G3OP!GZOSO1G3OOOQS,5>V,5>VOOQS'#Dr'#DrO/oQ#xO,5>VO!G`Q#xO,5>UO!GsQ#xO,5>UOOQS1G/w1G/wO!G{Q#xO,5>XO!H]Q#xO,5>XO!HeQ#xO,5>XO!HxQ#xO,5>XO!IYQ#xO,5>XOOQS1G3r1G3rOOQS7+$j7+$jO!7PQ#xO7+$rO!J{Q#xO1G/OO!KSQ#xO1G/OOOQS1G/b1G/bOOQS,5<_,5<_O'WQ#xO,5<_OOQS7+%R7+%RO!KZQ#xO7+%ROOQS-E9q-E9qOOQS7+%S7+%SO!KkQ#xO,5>OO'WQ#xO,5>OOOQS7+$i7+$iO!KpQ#xO7+%RO!KxQ#xO7+%SO!K}Q#xO1G3nOOQS7+%Z7+%ZO!L_Q#xO1G3nO!LgQ#xO7+%ZOOQS,5<^,5<^O'WQ#xO,5<^O!LlQ#xO1G3iOOQS-E9p-E9pO!McQ#xO7+%_OOQS7+%a7+%aO!MqQ#xO1G3iO!N`Q#xO7+%aO!NeQ#xO1G3oO!NuQ#xO1G3oO!N}Q#xO7+%_O# SQ#xO,5>cO# jQ#xO,5>cO# jQ#xO,5>cO# xO$ISO'#D{O#!TO#tO'#HxOOOW1G0P1G0PO#!YQ#xO1G0POOO`1G0T1G0TO#!bQ#xO1G0TOOOp1G0U1G0UO#!jQ#xO1G0UOOO!b1G0V1G0VO#!rQ#xO1G0VO#!zQ!LUO7+(nO##kQ&nO1G2XP#$UQ#xO'#GROOQS,5<p,5<pOOQS-E:S-E:SOOQS7+&y7+&yOOQS1G3e1G3eOOQS,5<],5<]OOQS-E9o-E9oOOQS7+$u7+$uO#$cQ#xO,5=hO#$|Q#xO,5=hO#%_Q&nO,5<`O#%rQ#xO1G3kOOQS-E9r-E9rOOQS7+&X7+&XO#&SQ#xO7+&XOOQS7+&Z7+&ZO#&bQ#xO'#IQO0UQ#xO'#IPO#&vQ#xO7+&ZOOQS,5<s,5<sO#'RQ#xO1G4XOOQS-E:V-E:VOOQS,5<o,5<oO#'aQ#xO1G4TOOQS-E:R-E:RO#'wQ#{O7+&eO!EwQ#xO'#GZO3^Q#xO7+&eO3^Q#xO7+&hO#+VQ&nO,5<vO'WQ#xO,5<vO#+aQ#xO1G4ZOOQS-E:Y-E:YO#+kQ#xO1G4ZO3^Q#xO7+&jO/oQ#xO7+&jOOQV7+&o7+&oO!F|QMlO7+&qO`Q#yO1G0zOOQV-E:Z-E:ZO3^Q#xO7+&kO3^Q#xO7+&kOOQV,5<w,5<wO#+sQ#xO,5<wOOQV7+&k7+&kO#,OQ#{O7+&kO#/ZQ#xO,5<xO#/fQ#xO1G4[OOQS-E:[-E:[O#/sQ#xO1G4[O#/{Q#xO'#IWO#0ZQ#xO'#IWO0UQ#xO'#IWOOQS'#IW'#IWO#0fQ#xO'#IVOOQS,5;m,5;mO#0nQ#xO,5;mO/oQ#xO'#FTOOQV7+&q7+&qO3^Q#xO7+&qOOQV7+&v7+&vO#0sQ#zO,5;wOOQV7+&{7+&{POOO7+(j7+(jOOQS1G3q1G3qOOQS,5<b,5<bO#0xQ#xO1G3pOOQS-E9t-E9tO#1]Q#xO,5<cO#1hQ#xO,5<cO#1{Q#xO1G3sOOQS-E9u-E9uO#2]Q#xO1G3sO#2eQ#xO1G3sO#2uQ#xO1G3sO#2]Q#xO1G3sOOQS<<H^<<H^O#3QQ&nO1G1yOOQS<<Hm<<HmP#3_Q#xO'#FsO7hQ#xO1G3jO#3lQ#xO1G3jO#3qQ#xO<<HmOOQS<<Hn<<HnO#4RQ#xO7+)YOOQS<<Hu<<HuO#4cQ&nO1G1xP#5SQ#xO'#FrO#5aQ#xO7+)ZO#5qQ#xO7+)ZO#5yQ#xO<<HyO#6OQ#xO7+)TOOQS<<H{<<H{O#6uQ#xO,5<aO'WQ#xO,5<aOOQS-E9s-E9sOOQS<<Hy<<HyOOQS,5<g,5<gO/oQ#xO,5<gO#6zQ#xO1G3}OOQS-E9y-E9yO#7bQ#xO1G3}O;RQ#xO'#D|OOOO'#F|'#F|O#7pO$ISO,5:gOOO#l,5>d,5>dOOOW7+%k7+%kOOO`7+%o7+%oOOOp7+%p7+%pOOO!b7+%q7+%qO#7{Q#xO1G3SO#8fQ#xO1G3SP'WQ#xO'#FtO/oQ#xO<<IsO#8wQ#xO,5>lO#9YQ#xO,5>lO0UQ#xO,5>lO#9kQ#xO,5>kOOQS<<Iu<<IuP0UQ#xO'#GXP/oQ#xO'#GTOOQV-E:X-E:XO3^Q#xO<<JPOOQV,5<u,5<uO3^Q#xO,5<uOOQV<<JP<<JPOOQV<<JS<<JSO#9pQ&nO1G2bP#9zQ#xO'#G[O#:RQ#xO7+)uO#:]Q#{O<<JUO3^Q#xO<<JUOOQV<<J]<<J]O3^Q#xO<<J]O#=hQ#{O7+&fOOQV<<JV<<JVO#=rQ#{O<<JVOOQV1G2c1G2cO0UQ#xO1G2cO3^Q#xO<<JVO0UQ#xO1G2dP/oQ#xO'#G^O#@}Q#xO7+)vO#A[Q#xO7+)vOOQS'#FS'#FSO/oQ#xO,5>rO#AdQ#xO,5>rOOQS,5>r,5>rO#AoQ#xO,5>qO#BQQ#xO,5>qOOQS1G1X1G1XOOQS,5;o,5;oO#BYQ#xO1G1cP#B_Q#xO'#FvO#BoQ#xO1G1}O#CSQ#xO1G1}O#CdQ#xO1G1}P#CoQ#xO'#FwO#C|Q#xO7+)_O#D^Q#xO7+)_O#D^Q#xO7+)_O#DfQ#xO7+)_O#DvQ#xO7+)UO7hQ#xO7+)UOOQSAN>XAN>XO#EaQ#xO<<LuOOQSAN>eAN>eO/oQ#xO1G1{O#EqQ&nO1G1{P#E{Q#xO'#FuOOQS1G2R1G2RP#FYQ#xO'#F{O#FgQ#xO7+)iO#F}Q#xO,5:hOOOO-E9z-E9zO#GYQ#xO7+(nOOQSAN?_AN?_O#GsQ#xO,5<rO#HXQ#xO1G4WOOQS-E:U-E:UO#HjQ#xO1G4WOOQS1G4V1G4VOOQVAN?kAN?kOOQV1G2a1G2aO3^Q#xOAN?pO#H{Q#{OAN?pOOQVAN?wAN?wOOQV<<JQ<<JQO3^Q#xOAN?qO3^Q#xO7+'}OOQVAN?qAN?qOOQS7+(O7+(OO#LWQ#xO<<MbOOQS1G4^1G4^O/oQ#xO1G4^OOQS,5<y,5<yO#LeQ#xO1G4]OOQS-E:]-E:]OOQU'#Ga'#GaO#LvQ#zO7+&}O#MRQ#xO'#F^O#MyQ#xO7+'iO#NZQ#xO7+'iOOQS7+'i7+'iO#NfQ#xO<<LyO#NvQ#xO<<LyO#NvQ#xO<<LyO$ OQ#xO'#HfOOQS<<Lp<<LpO$ YQ#xO<<LpOOQS7+'g7+'gOOOO1G0S1G0SO$ sQ#xO1G0SO0UQ#xO1G2^P0UQ#xO'#GWO$ {Q#xO7+)rO$!^Q#xO7+)rOOQVG25[G25[O3^Q#xOG25[OOQVG25]G25]OOQV<<Ki<<KiOOQS7+)x7+)xP$!oQ#xO'#G_OOQU-E:_-E:_OOQV<<Ji<<JiO$#cQ&nO'#F`OOQS'#Fb'#FbO$#sQ#xO'#FaO$$eQ#xO'#FaOOQS'#Fa'#FaO$$jQ#xO'#IYO#MRQ#xO'#FhO#MRQ#xO'#FhO$%RQ#xO'#FiO#MRQ#xO'#FjO$%YQ#xO'#IZOOQS'#IZ'#IZO$%wQ#xO,5;xOOQS<<KT<<KTO$&PQ#xO<<KTO$&aQ#xOANBeO$&qQ#xOANBeO$&yQ#xO'#HgOOQS'#Hg'#HgO0pQ#xO'#DeO$'dQ#xO,5>QOOQSANB[ANB[OOOO7+%n7+%nOOQS7+'x7+'xO$'{Q#xO<<M^OOQVLD*vLD*vO4gQMlO'#GcO$(^Q&nO,5<RO#MRQ#xO'#FlOOQS,5<V,5<VOOQS'#Fc'#FcO$)OQ#xO,5;{O$)TQ#xO,5;{OOQS'#Ff'#FfO#MRQ#xO'#GbO$)uQ#xO,5<PO$*aQ#xO,5>tO$*qQ#xO,5>tO0UQ#xO,5<OO$+SQ#xO,5<SO$+XQ#xO,5<SO#MRQ#xO'#I[O$+^Q#xO'#I[O$+cQ#xO,5<TOOQS,5<U,5<UO'WQ#xO'#FoOOQU1G1d1G1dO3^Q#xO1G1dOOQSAN@oAN@oO$+hQ#xOG28PO$+xQ#xO,5:POOQS1G3l1G3lOOQS,5<},5<}OOQS-E:a-E:aO$+}Q&nO'#F`O$,UQ#xO'#I]O$,dQ#xO'#I]O$,lQ#xO,5<WOOQS1G1g1G1gO$,qQ#xO1G1gO$,vQ#xO,5<|OOQS-E:`-E:`O$-bQ#xO,5=QO$-yQ#xO1G4`OOQS-E:d-E:dOOQS1G1j1G1jOOQS1G1n1G1nO$.ZQ#xO,5>vO#MRQ#xO,5>vOOQS1G1o1G1oO$.iQ&nO,5<ZOOQU7+'O7+'OO$ OQ#xO1G/kO#MRQ#xO,5<XO$.pQ#xO,5>wO$.wQ#xO,5>wOOQS1G1r1G1rOOQS7+'R7+'RP#MRQ#xO'#GfO$/PQ#xO1G4bO$/ZQ#xO1G4bO$/cQ#xO1G4bOOQS7+%V7+%VO$/qQ#xO1G1sO$0PQ&nO'#F`O$0WQ#xO,5=POOQS,5=P,5=PO$0fQ#xO1G4cOOQS-E:c-E:cO#MRQ#xO,5=OO$0mQ#xO,5=OO$0rQ#xO7+)|OOQS-E:b-E:bO$0|Q#xO7+)|O#MRQ#xO,5<YP#MRQ#xO'#GeO$1UQ#xO1G2jO#MRQ#xO1G2jP$1dQ#xO'#GdO$1kQ#xO<<MhO$1uQ#xO1G1tO$2TQ#xO7+(UO7hQ#xO'#DPO7hQ#xO,59dO7hQ#xO,59dO7hQ#xO,59dO$2cQ&nO,5=hO7hQ#xO1G/OO/oQ#xO1G/ZO/oQ#xO7+$rP$2vQ#xO'#GRO'WQ#xO'#G|O$3TQ#xO,59dO$3YQ#xO,59dO$3aQ#xO,59oO$3fQ#xO1G/WO0pQ#xO'#DTO7hQ#xO,59l",
  stateData: "$3w~O%kOS%`OSUOS%_PQ~OPiOXfOhtOjYOquOu!TOxvO!RwO!S!QO!V!WO!W!VO!ZZO!_[O!jeO!ueO!veO!weO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO#k!UO#n!XO#r!YO#t!ZO#y![O#|mO$O!]O%wRO%xRO%|SO%}WO&c]O&d^O&g_O&j`O&naO&obO&pcO~O%_!^O~OX!eOa!eOc!fOj!mO!Z!oO!h!qO%r!`O%s!aO%t!bO%u!cO%v!cO%w!dO%x!dO%y!eO%z!eO%{!eO~Om&QXn&QXo&QXp&QXq&QXr&QXu&QX|&QX}&QX!{&QX#f&QX%^&QX%a&QX&S&QXi&QX!V&QX!W&QX&T&QX!Y&QX!^&QX!S&QX#_&QXv&QX!n&QX~P$dOhtOjYO!ZZO!_[O!jeO!ueO!veO!weO%wRO%xRO%|SO%}WO&c]O&d^O&g_O&j`O&naO&obO&pcO~O|&PX}&PX#f&PX%^&PX%a&PX&S&PX~Om!tOn!uOo!sOp!sOq!vOr!wOu!xO!{&PX~P(eOX#OOi#QOq0VOx0eO!RwO~P'WOX#SOq0VOx0eO!Y#TO~P'WOX#WOc#XOq0VOx0eO!^#YO~P'WO&e#]O&f#_O~O&h#`O&i#_O~OQ#bO%b#cO%c#eO~OR#fO%d#gO%e#eO~OS#iO%f#jO%g#eO~OT#lO%h#mO%i#eO~OX%qXa%qXc%qXj%qXm%qXn%qXo%qXp%qXq%qXr%qXu%qX|%qX!Z%qX!h%qX%r%qX%s%qX%t%qX%u%qX%v%qX%w%qX%x%qX%y%qX%z%qX%{%qXi%qX!V%qX!W%qX~O&c]O&d^O&g_O&j`O&naO&obO&pcO}%qX!{%qX#f%qX%^%qX%a%qX&S%qX&T%qX!Y%qX!^%qX!S%qX#_%qXv%qX!n%qX~P+}O|#rO}%pX!{%pX#f%pX%^%pX%a%pX&S%pX~Oq0VOx0eO~P'WO#f#uO%^#wO%a#wO~O%}WO~O!V#|O#t!ZO#y![O#|mO~OquO~P'WOX$ROc$SO%}WO}yP~OX$WOq0VOx0eO!S$XO~P'WO}$ZO!{$`O&S$[O#f!|X%^!|X%a!|X~OX$WOq0VOx0eO#f#VX%^#VX%a#VX~P'WOq0VOx0eO#f#ZX%^#ZX%a#ZX~P'WO!h$fO!u$fO%}WO~OX$pO~P'WO!W$rO#r$sO#t$tO~O}$uO~OX$|O~P'WOU%OO%^$}O%k%PO~OX%YOc%YOi%[Oq0VOx0eO~P'WOq0VOx0eO}%_O~P'WO&b%aO~Oc!fOj!mO!Z!oO!h!qOXdaadamdandaodapdaqdardauda|da}da!{da#fda%^da%ada%rda%sda%tda%uda%vda%wda%xda%yda%zda%{da&Sdaida!Vda!Wda&Tda!Yda!^da!Sda#_davda!nda~Op%fO~Oq%fO~P'WOq0VO~P'WOm0XOn0YOo0WOp0WOq0aOr0bOu0fOi&PX!V&PX!W&PX&T&PX!Y&PX!^&PX!S&PX#_&PX!n&PX~P(eO&T%hOi&OX|&OX!V&OX!W&OX!Y&OX}&OX~Oi%jO|%kO!V%oO!W%nO~Oi%jO~O|%rO!V%oO!W%nO!Y&[X~O!Y%vO~O|%wO}%yO!V%oO!W%nO!^&VX~O!^%}O~O!^&OO~O&e#]O&f&QO~O&h#`O&i&QO~OX&TOq0VOx0eO!RwO~P'WOQ#bO%b#cO%c&WO~OR#fO%d#gO%e&WO~OS#iO%f#jO%g&WO~OT#lO%h#mO%i&WO~OX!taa!tac!taj!tam!tan!tao!tap!taq!tar!tau!ta|!ta}!ta!Z!ta!h!ta!{!ta#f!ta%^!ta%a!ta%r!ta%s!ta%t!ta%u!ta%v!ta%w!ta%x!ta%y!ta%z!ta%{!ta&S!tai!ta!V!ta!W!ta&T!ta!Y!ta!^!ta!S!ta#_!tav!ta!n!ta~P#vO|&`O}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~P$dOX&bOquOxvO}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~P'WO|&`O}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~OPiOXfOquOxvO!RwO!S!QO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO#f$|X%^$|X%a$|X~P'WO#f#uO%^&gO%a&gO~O!h&hOj&rX%^&rX#_&rX#f&rX%a&rX#^&rX~Oj!mO%^&jO~Omgangaogapgaqgargauga|ga}ga!{ga#fga%^ga%aga&Sgaiga!Vga!Wga&Tga!Yga!^ga!Sga#_gavga!nga~P$dOusa|sa}sa#fsa%^sa%asa&Ssa~Om!tOn!uOo!sOp!sOq!vOr!wO!{sa~PDoO&S&lO|&RX}&RX~O%}WO|&RX}&RX~O|&oO}yX~O}&qO~O|%wO#f&VX%^&VX%a&VXi&VX}&VX!^&VX!n&VX&S&VX~OX0`Oq0VOx0eO!RwO~P'WO&S$[O#fWa%^Wa%aWa~O|&zO#f&XX%^&XX%a&XXp&XX~P$dO|&}O!S&|O#f#Za%^#Za%a#Za~O#_'OO#f#]a%^#]a%a#]a~O!h$fO!u$fO#^'QO%}WO~O#^'QO~O|'SO#f&uX%^&uX%a&uX~O|'UO#f&qX%^&qX%a&qX}&qX~O|'YOp&wX~P$dOp']O~OPiOXfOquOxvO!RwO!S!QO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO%^'bO~P'WOv'fO#o'dO#p'eOP#maX#mah#maj#maq#mau#max#ma!R#ma!S#ma!V#ma!W#ma!Z#ma!_#ma!j#ma!u#ma!v#ma!w#ma#O#ma#Q#ma#S#ma#U#ma#W#ma#[#ma#^#ma#a#ma#b#ma#d#ma#k#ma#n#ma#r#ma#t#ma#y#ma#|#ma$O#ma%Z#ma%w#ma%x#ma%|#ma%}#ma&c#ma&d#ma&g#ma&j#ma&n#ma&o#ma&p#ma%]#ma%a#ma~O|'gO#_'iO}&xX~Oj'kO~Oj!mO}$uO~O}'oO~P$dO%^'rO~OU'sO%^'rO~OX!eOa!eOc!fOj!mO!Z!oO!h!qO%t!bO%u!cO%v!cO%w!dO%x!dO%y!eO%z!eO%{!eOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~O%s!aO~P! tO%sYi~P! tOX!eOa!eOc!fOj!mO!Z!oO!h!qO%w!dO%x!dO%y!eO%z!eO%{!eOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi%sYi%tYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~O%u!cO%v!cO~P!$oO%uYi%vYi~P!$oOc!fOj!mO!Z!oO!h!qOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi%sYi%tYi%uYi%vYi%wYi%xYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~OX!eOa!eO%y!eO%z!eO%{!eO~P!'mOXYiaYi%yYi%zYi%{Yi~P!'mO!V%oO!W%nOi&_X|&_X~O&S'uO&T'uO~P+}O|'wOi&^X~Oi'yO~O|'zO}'|O!Y&aX~Oq0VOx0eO|'zO}'}O!Y&aX~P'WO!Y(PO~Oo!sOp!sOq!vOr!wOmliuli|li}li!{li#fli%^li%ali&Sli~On!uO~P!,`Onli~P!,`Om0XOn0YOo0WOp0WOq0aOr0bO~Ov(RO~P!-iOX(WOi(XOq0VOx0eO~P'WOi(XO|(YO~Oi([O~O!W(^O~Oi(_O|(YO!V%oO!W%nO~P$dOm0XOn0YOo0WOp0WOq0aOr0bOisa!Vsa!Wsa&Tsa!Ysa!^sa!Ssa#_savsa!nsa~PDoOX(WOq0VOx0eO!Y&[a~P'WO|(bO!Y&[a~O!Y(cO~O|(bO!V%oO!W%nO!Y&[a~P$dOX(gOq0VOx0eO!^&Va#f&Va%^&Va%a&Vai&Va}&Va!n&Va&S&Va~P'WO|(hO!^&Va#f&Va%^&Va%a&Vai&Va}&Va!n&Va&S&Va~O!^(kO~O|(hO!V%oO!W%nO!^&Va~P$dO|(nO!V%oO!W%nO!^&]a~P$dO|(qO}&kX!^&kX!n&kX~O}(tO!^(vO!n(wO~O}(tO!^(xO!n(yO~O}(tO!^(zO!n({O~O}(tO!^(|O!n(}O~OX&bOquOxvO}%pi!{%pi#f%pi%^%pi%a%pi&S%pi~P'WO|)OO}%pi!{%pi#f%pi%^%pi%a%pi&S%pi~O!h&hOj&ra%^&ra#_&ra#f&ra%a&ra#^&ra~O%^)TO~OX$ROc$SO%}WO~O|&oO}ya~OquOxvO~P'WO|(hO#f&Va%^&Va%a&Vai&Va}&Va!^&Va!n&Va&S&Va~P$dO|)YO#f%pX%^%pX%a%pX&S%pX~O&S$[O#fWi%^Wi%aWi~O#f&Xa%^&Xa%a&Xap&Xa~P'WO|)]O#f&Xa%^&Xa%a&Xap&Xa~OX)aOj)cO%}WO~O#^)dO~O%}WO#f&ua%^&ua%a&ua~O|)fO#f&ua%^&ua%a&ua~Oq0VOx0eO#f&qa%^&qa%a&qa}&qa~P'WO|)iO#f&qa%^&qa%a&qa}&qa~Ov)mO#i)lOP#giX#gih#gij#giq#giu#gix#gi!R#gi!S#gi!V#gi!W#gi!Z#gi!_#gi!j#gi!u#gi!v#gi!w#gi#O#gi#Q#gi#S#gi#U#gi#W#gi#[#gi#^#gi#a#gi#b#gi#d#gi#k#gi#n#gi#r#gi#t#gi#y#gi#|#gi$O#gi%Z#gi%w#gi%x#gi%|#gi%}#gi&c#gi&d#gi&g#gi&j#gi&n#gi&o#gi&p#gi%]#gi%a#gi~Ov)nOP#jiX#jih#jij#jiq#jiu#jix#ji!R#ji!S#ji!V#ji!W#ji!Z#ji!_#ji!j#ji!u#ji!v#ji!w#ji#O#ji#Q#ji#S#ji#U#ji#W#ji#[#ji#^#ji#a#ji#b#ji#d#ji#k#ji#n#ji#r#ji#t#ji#y#ji#|#ji$O#ji%Z#ji%w#ji%x#ji%|#ji%}#ji&c#ji&d#ji&g#ji&j#ji&n#ji&o#ji&p#ji%]#ji%a#ji~OX)pOp&wa~P'WO|)qOp&wa~O|)qOp&wa~P$dOp)uO~O%[)xO~Ov){O#o'dO#p)zOP#miX#mih#mij#miq#miu#mix#mi!R#mi!S#mi!V#mi!W#mi!Z#mi!_#mi!j#mi!u#mi!v#mi!w#mi#O#mi#Q#mi#S#mi#U#mi#W#mi#[#mi#^#mi#a#mi#b#mi#d#mi#k#mi#n#mi#r#mi#t#mi#y#mi#|#mi$O#mi%Z#mi%w#mi%x#mi%|#mi%}#mi&c#mi&d#mi&g#mi&j#mi&n#mi&o#mi&p#mi%]#mi%a#mi~Oq0VOx0eO}$uO~P'WOq0VOx0eO}&xa~P'WO|*RO}&xa~OX*VOc*WOi*ZO%y*XO%}WO~O}$uO&{*]O~O%^*aO~O%^*cO~OX%YOc%YOq0VOx0eOi&^a~P'WO|*fOi&^a~Oq0VOx0eO}*iO!Y&aa~P'WO|*jO!Y&aa~Oq0VOx0eO|*jO}*mO!Y&aa~P'WOq0VOx0eO|*jO!Y&aa~P'WO|*jO}*mO!Y&aa~Oo0WOp0WOq0aOr0bOilimliuli|li!Vli!Wli&Tli!Yli}li!^li#fli%^li%ali!Sli#_livli!nli&Sli~On0YO~P!IeOnli~P!IeOX(WOi*rOq0VOx0eO~P'WOp*tO~Oi*rO|*vO~Oi*wO~OX(WOq0VOx0eO!Y&[i~P'WO|*xO!Y&[i~O!Y*yO~OX(gOq0VOx0eO!^&Vi#f&Vi%^&Vi%a&Vii&Vi}&Vi!n&Vi&S&Vi~P'WO|*|O!V%oO!W%nO!^&]i~O|+PO!^&Vi#f&Vi%^&Vi%a&Vii&Vi}&Vi!n&Vi&S&Vi~O!^+QO~Oc+SOq0VOx0eO!^&]i~P'WO|*|O!^&]i~O!^+UO~OX+WOq0VOx0eO}&ka!^&ka!n&ka~P'WO|+XO}&ka!^&ka!n&ka~O!_+[O&m+]O!^!oX~O!^+_O~O}(tO!^+`O~O}(tO!^+aO~O}(tO!^+bO~O}(tO!^+cO~OX&bOquOxvO}%pq!{%pq#f%pq%^%pq%a%pq&S%pq~P'WO|$ui}$ui!{$ui#f$ui%^$ui%a$ui&S$ui~P$dOX&bOquOxvO~P'WOX&bOq0VOx0eO#f%pa%^%pa%a%pa&S%pa~P'WO|+dO#f%pa%^%pa%a%pa&S%pa~O|$ha#f$ha%^$ha%a$hap$ha~P$dO#f&Xi%^&Xi%a&Xip&Xi~P'WO|+gO#f#Zq%^#Zq%a#Zq~O|+hO#_+jO#f&tX%^&tX%a&tXi&tX~OX+lOj)cO%}WO~O%}WO#f&ui%^&ui%a&ui~Oq0VOx0eO#f&qi%^&qi%a&qi}&qi~P'WOv+pO#i)lOP#gqX#gqh#gqj#gqq#gqu#gqx#gq!R#gq!S#gq!V#gq!W#gq!Z#gq!_#gq!j#gq!u#gq!v#gq!w#gq#O#gq#Q#gq#S#gq#U#gq#W#gq#[#gq#^#gq#a#gq#b#gq#d#gq#k#gq#n#gq#r#gq#t#gq#y#gq#|#gq$O#gq%Z#gq%w#gq%x#gq%|#gq%}#gq&c#gq&d#gq&g#gq&j#gq&n#gq&o#gq&p#gq%]#gq%a#gq~Op%Oa|%Oa~P$dOX)pOp&wi~P'WO|+wOp&wi~O|,QO}$uO#_,QO~O#p,ROP#mqX#mqh#mqj#mqq#mqu#mqx#mq!R#mq!S#mq!V#mq!W#mq!Z#mq!_#mq!j#mq!u#mq!v#mq!w#mq#O#mq#Q#mq#S#mq#U#mq#W#mq#[#mq#^#mq#a#mq#b#mq#d#mq#k#mq#n#mq#r#mq#t#mq#y#mq#|#mq$O#mq%Z#mq%w#mq%x#mq%|#mq%}#mq&c#mq&d#mq&g#mq&j#mq&n#mq&o#mq&p#mq%]#mq%a#mq~O#_,SO|%Qa}%Qa~Oq0VOx0eO}&xi~P'WO|,UO}&xi~O}$ZO&S,WOi&zX|&zX~O%}WOi&zX|&zX~O|,[Oi&yX~Oi,^O~O%[,`O~OX%YOc%YOq0VOx0eOi&^i~P'WO},bO|$ka!Y$ka~Oq0VOx0eO},cO|$ka!Y$ka~P'WOq0VOx0eO}*iO!Y&ai~P'WO|,fO!Y&ai~Oq0VOx0eO|,fO!Y&ai~P'WO|,fO},iO!Y&ai~Oi$gi|$gi!Y$gi~P$dOX(WOq0VOx0eO~P'WOp,kO~OX(WOi,lOq0VOx0eO~P'WOX(WOq0VOx0eO!Y&[q~P'WO|$fi!^$fi#f$fi%^$fi%a$fii$fi}$fi!n$fi&S$fi~P$dOX(gOq0VOx0eO~P'WOc+SOq0VOx0eO!^&]q~P'WO|,mO!^&]q~O!^,nO~OX(gOq0VOx0eO!^&Vq#f&Vq%^&Vq%a&Vqi&Vq}&Vq!n&Vq&S&Vq~P'WO},oO~OX+WOq0VOx0eO}&ki!^&ki!n&ki~P'WO|,tO}&ki!^&ki!n&ki~O!_+[O&m+]O!^!oa~OX&bOq0VOx0eO#f%pi%^%pi%a%pi&S%pi~P'WO|,wO#f%pi%^%pi%a%pi&S%pi~O%}WO#f&ta%^&ta%a&tai&ta~O|,zO#f&ta%^&ta%a&tai&ta~Oi,}O~Op%Oi|%Oi~P$dOX)pO~P'WOX)pOp&wq~P'WOv-QOP#lyX#lyh#lyj#lyq#lyu#lyx#ly!R#ly!S#ly!V#ly!W#ly!Z#ly!_#ly!j#ly!u#ly!v#ly!w#ly#O#ly#Q#ly#S#ly#U#ly#W#ly#[#ly#^#ly#a#ly#b#ly#d#ly#k#ly#n#ly#r#ly#t#ly#y#ly#|#ly$O#ly%Z#ly%w#ly%x#ly%|#ly%}#ly&c#ly&d#ly&g#ly&j#ly&n#ly&o#ly&p#ly%]#ly%a#ly~O%]-TO%a-TO~P`O#p-UOP#myX#myh#myj#myq#myu#myx#my!R#my!S#my!V#my!W#my!Z#my!_#my!j#my!u#my!v#my!w#my#O#my#Q#my#S#my#U#my#W#my#[#my#^#my#a#my#b#my#d#my#k#my#n#my#r#my#t#my#y#my#|#my$O#my%Z#my%w#my%x#my%|#my%}#my&c#my&d#my&g#my&j#my&n#my&o#my&p#my%]#my%a#my~Oq0VOx0eO}&xq~P'WO|-YO}&xq~O&S,WOi&za|&za~OX*VOc*WO%y*XO%}WOi&ya~O|-^Oi&ya~O$R-bO~OX%YOc%YOq0VOx0eO~P'WOq0VOx0eO}-cO|$ki!Y$ki~P'WOq0VOx0eO|$ki!Y$ki~P'WO}-cO|$ki!Y$ki~Oq0VOx0eO}*iO~P'WOq0VOx0eO}*iO!Y&aq~P'WO|-fO!Y&aq~Oq0VOx0eO|-fO!Y&aq~P'WOu-iO!V%oO!W%nOi&Wq!Y&Wq!^&Wq|&Wq~P!-iOc+SOq0VOx0eO!^&]y~P'WO|$ii!^$ii~P$dOc+SOq0VOx0eO~P'WOX+WOq0VOx0eO~P'WOX+WOq0VOx0eO}&kq!^&kq!n&kq~P'WO}(tO!^-mO!n-nO~OX&bOq0VOx0eO#f%pq%^%pq%a%pq&S%pq~P'WO#_-oO|$za#f$za%^$za%a$zai$za~O%}WO#f&ti%^&ti%a&tii&ti~O|-qO#f&ti%^&ti%a&tii&ti~Ov-tOP#l!RX#l!Rh#l!Rj#l!Rq#l!Ru#l!Rx#l!R!R#l!R!S#l!R!V#l!R!W#l!R!Z#l!R!_#l!R!j#l!R!u#l!R!v#l!R!w#l!R#O#l!R#Q#l!R#S#l!R#U#l!R#W#l!R#[#l!R#^#l!R#a#l!R#b#l!R#d#l!R#k#l!R#n#l!R#r#l!R#t#l!R#y#l!R#|#l!R$O#l!R%Z#l!R%w#l!R%x#l!R%|#l!R%}#l!R&c#l!R&d#l!R&g#l!R&j#l!R&n#l!R&o#l!R&p#l!R%]#l!R%a#l!R~Oq0VOx0eO}&xy~P'WOX*VOc*WO%y*XO%}WOi&yi~O$R-bO%]-zO%a-zO~OX.UOj.SO!Z.RO!_.TO!j-}O!v.PO!w.PO%x-|O%}WO&c]O&d^O&g_O~Oq0VOx0eO|$kq!Y$kq~P'WO}.ZO|$kq!Y$kq~Oq0VOx0eO}*iO!Y&ay~P'WO|.[O!Y&ay~Oq0VOx.`O~P'WOu-iO!V%oO!W%nOi&Wy!Y&Wy!^&Wy|&Wy~P!-iO}(tO!^.cO~O%}WO#f&tq%^&tq%a&tqi&tq~O|.eO#f&tq%^&tq%a&tqi&tq~OX*VOc*WO%y*XO%}WO~Oj.iO!h.gO|$SX#_$SX%r$SXi$SX~Ou$SX}$SX!Y$SX!^$SX~P$!}O%w.kO%x.kOu$TX|$TX}$TX#_$TX%r$TX!Y$TXi$TX!^$TX~O!j.mO~O|.qO#_.sO%r.nOu&|X}&|X!Y&|Xi&|X~Oc.vO~P#M_Oj.iOu&}X|&}X}&}X#_&}X%r&}X!Y&}Xi&}X!^&}X~Ou.zO}$uO~Oq0VOx0eO|$ky!Y$ky~P'WOq0VOx0eO}*iO!Y&a!R~P'WO|/OO!Y&a!R~Oi&ZXu&ZX!V&ZX!W&ZX!Y&ZX!^&ZX|&ZX~P!-iOu-iO!V%oO!W%nOi&Ya!Y&Ya!^&Ya|&Ya~O%}WO#f&ty%^&ty%a&tyi&ty~O!h.gOj$Zau$Za|$Za}$Za#_$Za%r$Za!Y$Zai$Za!^$Za~O!j/XO~O%w.kO%x.kOu$Ta|$Ta}$Ta#_$Ta%r$Ta!Y$Tai$Ta!^$Ta~O%r.nOu$Xa|$Xa}$Xa#_$Xa!Y$Xai$Xa!^$Xa~Ou&|a}&|a!Y&|ai&|a~P#MRO|/^Ou&|a}&|a!Y&|ai&|a~O!Y/aO~Oi/aO~O}/cO~O!^/dO~Oq0VOx0eO}*iO!Y&a!Z~P'WO}/gO~O&S/hO~P$!}O|/iO#_.sO%r.nOi'PX~O|/iOi'PX~Oi/kO~O!j/lO~O#_.sOu%Ua|%Ua}%Ua%r%Ua!Y%Uai%Ua!^%Ua~O#_.sO%r.nOu%Ya|%Ya}%Ya!Y%Yai%Ya~Ou&|i}&|i!Y&|ii&|i~P#MRO|/nO#_.sO%r.nO!^'Oa~O}$ca~P$dOi'Pa~P#MRO|/vOi'Pa~Oc/xO!^'Oi~P#M_O|/zO!^'Oi~O|/zO#_.sO%r.nO!^'Oi~O#_.sO%r.nOi$ai|$ai~O&S/}O~P$!}O#_.sO%r.nOi%Xa|%Xa~Oi'Pi~P#MRO}0QO~Oc/xO!^'Oq~P#M_O|0SO!^'Oq~O#_.sO%r.nO|%Wi!^%Wi~Oc/xO~P#M_Oc/xO!^'Oy~P#M_O#_.sO%r.nOi$bi|$bi~O#_.sO%r.nO|%Wq!^%Wq~O|+dO#f%pa%^%pa%a%pa&S%pa~P$dOX&bOq0VOx0eO~P'WOp0[O~Oq0[O~P'WO}0]O~Ov0^O~P!-iO&d&g&o&p&c&j&n%}&c~",
  goto: "!<w'QPPPPPPPP'RP'Z*s+]+v,b,}-kP.YP'Z.y.y'ZPPP'Z2cPPPPPP2c5VPP5VP7g7p=pPP=s>e>hPP'Z'ZPP?QPP'Z'ZPP'Z'Z'Z'Z'Z?U?{'ZP@OP@UD]GyPG}HZH_HcHg'ZPPPHkHq'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RPHwPIOIUPIOPIOIOPPPIOPKTPK^KdKjKTPIOKpPIOPKwK}PLRLgMUMoLRLRMuNSLRLRLRLRNhNnNqNvNy! T! Z! g! y!!P!!Z!!a!!}!#T!#Z!#a!#k!#q!#w!#}!$T!$Z!$m!$w!$}!%T!%Z!%e!%k!%q!%w!&R!&X!&c!&i!&r!&x!'X!'a!'k!'rPPPPPPPPPPPPPPPPP!'x!'{!(R!([!(f!(qPPPPPPPPPPPP!-e!.y!2s!6TPP!6]!6o!6x!7n!7e!7w!7}!8Q!8T!8W!8`!9PPPPPPPPPP!9S!9cPPPP!:R!:_!:k!:q!:z!:}!;T!;Z!;a!;dP!;l!;u!<q!<t]jOs#u$u)x+|'}eOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0f}!gQ#q$O$a$o${%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!P!hQ#q$O$a$o${%Q%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!R!iQ#q$O$a$o${%Q%R%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!T!jQ#q$O$a$o${%Q%R%S%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!V!kQ#q$O$a$o${%Q%R%S%T%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!X!lQ#q$O$a$o${%Q%R%S%T%U%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!]!lQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z'}TOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0f&cVOYZ[isuw}!O!S!T!U!Y!m!o!s!t!u!w!x#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%f%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[/O/g0V0W0X0Y0[0]0^0_0b0f%mXOYZ[isw}!O!S!T!U!Y!m!o#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,m,o,q,s,t,w-Y-[-c-f.Z.[/O0]0^0_Q$UvQ/P.`R0c0e'teOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fW#xm!P!Q$gW$Qv&o.`0eQ$i!RQ$y!ZQ$z![W%X!m'w*f,aS&n$R$SQ'`$tQ)R&hQ)a'OU)b'Q)c)dU)e'S)f+mQ*T'iW*U'k,[-^-xS,Z*V*WY,y+h,z-p-q.eQ,|+jQ-V,QQ-X,Sl-{-b.R.S.U.o.q.v/^/c/h/m/x/}0QQ.d-oQ.w.TQ/T.iQ/`.sU/s/i/v0OX/y/n/z0R0SR&m$Q!_!{YZ!T!U!o%_%k%r'z'|'}(Y(b)l*i*j*m*s*v*x,b,c,e,f,i-c-f.Z.[/OR%i!zQ#PYQ&U#bQ&X#fQ&Z#iQ&]#lQ&v$]Q&y$`R,u+[T._-i/g![!nQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0ZQ&k#yR'n$zR'v%XQ%b!qR/R.g'|dOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fS#od#p!P.P-b.R.S.T.U.i.o.q.v/^/c/h/i/m/n/v/x/z/}0O0Q0R0S'|dOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fT#od#pT#c`#de(u&U&X&Z&](w(y({(},u-nT+](t+^T#ga#hT#jb#kT#mc#nQ$_xR,Y*UX$]x$^$_&xZlOs$u)x+|XpOs)x+|Q$v!XQ'W$mQ'X$nQ'j$xQ'm$zQ)v'_Q)|'dQ*O'eQ*P'fQ*^'lQ*`'nQ+q)lQ+s)mQ+t)nQ+x)tS+z)w*_Q+})zQ,O){Q,P)}Q-O+pQ-P+rQ-R+yQ-S+{Q-W,RQ-s-QQ-u-UQ-v-VQ.f-tQ.{.XR/f.|WpOs)x+|R#{oQ'l$yR)w'`Q,X*UR-[,YQ*_'lR+{)wZnOos)x+|Q'p${R*b'qT-`,`-au.W-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0Qt.W-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0QQ.w.TX/y/n/z0R0S!P.O-b.R.S.T.U.i.o.q.v/^/c/h/i/m/n/v/x/z/}0O0Q0R0SQ.l-}R/Y.mg.o.Q.p/U/]/b/p/r/t0P0T0Uu.V-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0QX.j-{.V/T/sR/V.iV/u/i/v0OR.|.XQsOS#}s+|R+|)xQ&p$TR)W&pS%x#V$VS(i%x(lT(l%{&rQ%l!}Q%s#RW(Z%l%s(`(dQ(`%pR(d%uQ&{$aR)^&{Q(o%|Q*}(jT+T(o*}Q'x%ZR*g'xS'{%^%_Y*k'{*l,g-g.]U*l'|'}(OU,g*m*n*oS-g,h,iR.]-hQ#^^R&P#^Q#a_R&R#aQ#d`R&V#dQ(r&SS+Y(r+ZR+Z(sQ+^(tR,v+^Q#haR&Y#hQ#kbR&[#kQ#ncR&^#nQ#pdR&_#pQ#sgQ&a#qW&d#s&a)Z+eQ)Z&uR+e0ZQ$^xS&w$^&xR&x$_Q'V$kR)j'VQ&i#xR)S&iQ$g!QR'P$gQ+i)bS,{+i-rR-r,|Q'T$iR)g'TQ#vkR&f#vQ)k'WR+o)kQ'Z$oS)r'Z)sR)s'[Q'c$vR)y'cQ'h$wS*S'h,VR,V*TQ,]*YR-_,]WoOs)x+|R#zoQ-a,`R-y-ad.p.Q/U/]/b/p/r/t0P0T0UR/[.pU.h-{/T/sR/S.hQ/o/bS/{/o/|R/|/pS/j/U/VR/w/jQ.r.QR/_.rR!_PXrOs)x+|WqOs)x+|R'a$uYkOs$u)x+|R&e#u[xOs#u$u)x+|R&v$]&bQOYZ[isuw}!O!S!T!U!Y!m!o!s!t!u!w!x#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%f%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[/O/g0V0W0X0Y0[0]0^0_0b0fQ!rTQ#qfQ$OtU$ay%n(^S$o!V$rQ${!]Q%Q!gQ%R!hQ%S!iQ%T!jQ%U!kQ%V!lQ%p#OQ%u#SQ%{#WQ%|#XQ&r$WQ'[$pQ'q$|Q)P&bU)[&z)]+fW)o'Y)q+v+wQ*q(WQ*z(gQ+u)pQ,p+SQ/e.zR0Z0`Q!}YQ#RZQ$m!TQ$n!UQ%^!oQ(O%_^(V%k%r(Y(b*s*v*x^*h'z*j,e,f-f.[/OQ*n'|Q*o'}Q+r)lQ,d*iQ,h*mQ-d,bQ-e,cQ-h,iQ.Y-cR.}.Z[gOs#u$u)x+|!^!zYZ!T!U!o%_%k%r'z'|'}(Y(b)l*i*j*m*s*v*x,b,c,e,f,i-c-f.Z.[/OQ#V[Q#tiS$Vw}Q$d!OW$k!S$`'])uS$w!Y$sW%W!m'w*f,aY&S#b#f#i#l+[`&c#r&`)O)Q)Y+d,w0_Q&s$XQ&t$ZQ&u$]Q't%YQ(U%iW(f%w(h*{+PQ(j%yQ(s&TQ)U&mS)X&q0]Q)_&|Q)`&}U)h'U)i+nQ)}'dY*Q'g*R,T,U-YQ*d'vS*p(R0^W+R(n*|,m,qW+V(q+X,s,tQ,_*]Q,r+WQ,x+gQ-Z,XQ-l,oR-w-[hUOs#r#u$u&`&q(R)O)Q)x+|%S!yYZ[iw}!O!S!T!U!Y!m!o#b#f#i#l$X$Z$]$`$s%Y%_%i%k%r%w%y&T&m&|&}'U']'d'g'v'w'z'|'}(Y(b(h(n(q)Y)i)l)u*R*]*f*i*j*m*s*v*x*{*|+P+W+X+[+d+g+n,T,U,X,a,b,c,e,f,i,m,o,q,s,t,w-Y-[-c-f.Z.[/O0]0^0_Q$PuW%c!s!w0W0bQ%d!tQ%e!uQ%g!xQ%q0VS(Q%f0[Q(S0XQ(T0YQ,j*tQ-k,kS.^-i/gR0d0fU$Tv.`0eR)V&o[hOs#u$u)x+|a!|Y#b#f#i#l$]$`+[Q#[[Q$YwR$c}Q%m!}Q%t#RQ%z#VQ't%WQ(a%pQ(e%uQ(m%{Q(p%|Q+O(jQ-j,jQ.b-kR/Q.aQ$byQ(]%nR*u(^Q.a-iR/q/gR#UZR#Z[R%]!mQ%Z!mV*e'w*f,a!]!pQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0ZR%`!oQ&U#bQ&X#fQ&Z#iQ&]#lR,u+[Q(v&UQ(x&XQ(z&ZQ(|&]Q+`(wQ+a(yQ+b({Q+c(}Q-m,uR.c-nQ$l!SQ&y$`Q)t']R+y)uQ#ymQ$e!PQ$h!QR'R$gQ)a'QR+l)dQ)a'QQ+k)cR+l)dR$j!RXqOs)x+|Q$q!VR'^$rQ$x!YR'_$sR*['kQ*Y'kV-],[-^-xQ.X-bQ.t.RR.u.SU.Q-b.R.SQ.y.UQ/U.iQ/Z.oU/].q/^/mQ/b.vQ/p/cQ/r/hU/t/i/v0OQ0P/xQ0T/}R0U0QR.x.TR/W.i",
  nodeNames: "⚠ print { { { { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec FormatReplacement FormatReplacement FormatReplacement FormatReplacement ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 277,
  context: b6,
  nodeProps: [
    ["group", -14, 8, 88, 90, 91, 93, 95, 97, 99, 101, 102, 103, 105, 108, 111, "Statement Statement", -22, 10, 20, 23, 27, 42, 51, 52, 58, 59, 62, 63, 64, 65, 66, 69, 72, 73, 74, 82, 83, 84, 85, "Expression", -10, 113, 115, 118, 120, 121, 125, 127, 132, 134, 137, "Statement", -9, 142, 143, 146, 147, 149, 150, 151, 152, 153, "Pattern"],
    ["openedBy", 25, "(", 56, "[", 60, "{"],
    ["closedBy", 26, ")", 57, "]", 61, "}"]
  ],
  propSources: [x6],
  skippedNodes: [0, 6],
  repeatNodeCount: 37,
  tokenData: "%-W#sR!`OX%TXY=|Y[%T[]=|]p%Tpq=|qr@_rsDOst!+|tu%Tuv!Nnvw#!|wx#$Wxy#:Uyz#;Yz{#<^{|#>x|}#@S}!O#AW!O!P#Ci!P!Q#N_!Q!R$!y!R![$&w![!]$1e!]!^$3s!^!_$4w!_!`$7c!`!a$8m!a!b%T!b!c$;U!c!d$<b!d!e$>W!e!h$<b!h!i$H[!i!t$<b!t!u%#r!u!w$<b!w!x$Fl!x!}$<b!}#O%%z#O#P?d#P#Q%'O#Q#R%(S#R#S$<b#S#T%T#T#U$<b#U#V$>W#V#Y$<b#Y#Z$H[#Z#f$<b#f#g%#r#g#i$<b#i#j$Fl#j#o$<b#o#p%)^#p#q%*S#q#r%+^#r#s%,S#s$g%T$g;'S$<b;'S;=`$>Q<%lO$<b!n%^]&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n&^]&m!b&eSOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n'^]&m!b&eSOr%Trs(Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!f(^Z&m!b&eSOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)UZ&m!bOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)|Z&m!bOw(Vwx*ox#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!b*tT&m!bO#o*o#p#q*o#r;'S*o;'S;=`+T<%lO*o!b+WP;=`<%l*o!f+`W&m!bO#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`.d;=`<%l+x<%lO(VS+}V&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS,gVOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-PUOw+xx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-fRO;'S+x;'S;=`-o;=`O+xS-tW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l+x<%lO+xS.aP;=`<%l+x!f.iW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l(V<%lO+x!f/UP;=`<%l(V!n/`]&m!b&hWOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n0`]&m!b&hWOr%Trs&Vsw%Twx1Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!j1`Z&m!b&hWOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j2WZ&m!bOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3OZ&m!bOr1Xrs*os#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3vW&m!bO#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`6z;=`<%l4`<%lO1XW4eV&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W4}VOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5gUOr4`s#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5|RO;'S4`;'S;=`6V;=`O4`W6[W&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l4`<%lO4`W6wP;=`<%l4`!j7PW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l1X<%lO4`!j7lP;=`<%l1X!n7tW&m!bO#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T[8eX&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9VX&eSOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9wX&eSOr8^rs+xsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[:iX&hWOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;ZX&hWOr8^rs9Qsw8^wx4`x#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;yRO;'S8^;'S;=`<S;=`O8^[<ZY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l8^<%lO8^[<|P;=`<%l8^!n=WY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l%T<%lO8^!n=yP;=`<%l%T#s>Xc&m!b&eS&hW%k!TOX%TXY=|Y[%T[]=|]p%Tpq=|qr%Trs&Vsw%Twx/Xx#O%T#O#P?d#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s?i[&m!bOY%TYZ=|Z]%T]^=|^#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T!q@hd&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#T%T#T#UBz#U#f%T#f#gBz#g#hBz#h#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qBR]oR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qCV]!nR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cDXa&m!b&eS&csOYE^YZ%TZ]E^]^%T^rE^rs!)|swE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cEia&m!b&eS&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cFw]&m!b&eS&csOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cGya&m!b&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxIOx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cIXa&m!b&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxJ^x#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#_Jg_&m!b&hW&csOYJ^YZ1XZ]J^]^1X^rJ^rsKfs#OJ^#O#PL`#P#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`!!o<%lOJ^#_KmZ&m!b&csOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#_LeW&m!bO#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`! r;=`<%lL}<%lOJ^{MUZ&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l<%lOL}{M|V&csOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`{NfRO;'SL};'S;=`No;=`OL}{Nv[&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lL}<%lOL}{! oP;=`<%lL}#_! y[&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lJ^<%lOL}#_!!rP;=`<%lJ^#c!!zW&m!bO#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!(q;=`<%l!#d<%lOE^!P!#m]&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!$mX&eS&csOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P!%a]&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!&Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!&a]&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwxL}x#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!']RO;'S!#d;'S;=`!'f;=`O!#d!P!'o^&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%l!#d<%lO!#d!P!(nP;=`<%l!#d#c!(z^&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%lE^<%lO!#d#c!)yP;=`<%lE^#c!*V]&m!b&eS&csOr%Trs!+Osw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c!+ZZ&iW&m!b&eS&gsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#s!,XaU!T&m!b&eS&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!-gaU!T&m!b&eSOY!+|YZ%TZ]!+|]^%T^r!+|rs!.lsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!.uaU!T&m!b&eSOY!+|YZ%TZ]!+|]^%T^r!+|rs!/zsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#k!0T_U!T&m!b&eSOY!/zYZ(VZ]!/z]^(V^w!/zwx!1Sx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!1Z_U!T&m!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!2Yx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!2a_U!T&m!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!3`x#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#g!3gZU!T&m!bOY!3`YZ*oZ]!3`]^*o^#o!3`#o#p!4Y#p#q!3`#q#r!4Y#r;'S!3`;'S;=`!4t<%lO!3`!T!4_TU!TOY!4YZ]!4Y^;'S!4Y;'S;=`!4n<%lO!4Y!T!4qP;=`<%l!4Y#g!4wP;=`<%l!3`#k!5R[U!T&m!bOY!/zYZ(VZ]!/z]^(V^#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!9s;=`<%l+x<%lO!/z!X!6OZU!T&eSOY!5wYZ+xZ]!5w]^+x^w!5wwx!6qx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!6vZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!7ix#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!7nZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!4Yx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!8fWU!TOY!5wYZ+xZ]!5w]^+x^;'S!5w;'S;=`!9O;=`<%l+x<%lO!5w!X!9TW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!5w<%lO+x!X!9pP;=`<%l!5w#k!9xW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!/z<%lO+x#k!:eP;=`<%l!/z#s!:qaU!T&m!b&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!;vx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!<PaU!T&m!b&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!=Ux#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#o!=__U!T&m!b&hWOY!=UYZ1XZ]!=U]^1X^r!=Urs!>^s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!>e_U!T&m!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!?ds#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!?k_U!T&m!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!3`s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!@q[U!T&m!bOY!=UYZ1XZ]!=U]^1X^#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!Ec;=`<%l4`<%lO!=U!]!AnZU!T&hWOY!AgYZ4`Z]!Ag]^4`^r!Agrs!Bas#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!BfZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!CXs#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!C^ZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!4Ys#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!DUWU!TOY!AgYZ4`Z]!Ag]^4`^;'S!Ag;'S;=`!Dn;=`<%l4`<%lO!Ag!]!DsW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!Ag<%lO4`!]!E`P;=`<%l!Ag#o!EhW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!=U<%lO4`#o!FTP;=`<%l!=U#s!F_[U!T&m!bOY!+|YZ%TZ]!+|]^%T^#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Mq;=`<%l8^<%lO!+|!a!G^]U!T&eS&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!H^]U!T&eSOY!GTYZ8^Z]!GT]^8^^r!GTrs!IVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!I^]U!T&eSOY!GTYZ8^Z]!GT]^8^^r!GTrs!5wsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!J^]U!T&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!KVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!K^]U!T&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!Agx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!L[WU!TOY!GTYZ8^Z]!GT]^8^^;'S!GT;'S;=`!Lt;=`<%l8^<%lO!GT!a!L{Y&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!GT<%lO8^!a!MnP;=`<%l!GT#s!MxY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!+|<%lO8^#s!NkP;=`<%l!+|#b!Ny_%zQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b#!T]!{r&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b##X_%tQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#$aa&m!b&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#8Ux#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#%qa&m!b&eS&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#'Pa&m!b&eS&csOY#%fYZ%TZ]#%f]^%T^r#%frs#(Usw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#(_a&m!b&eS&csOY#%fYZ%TZ]#%f]^%T^r#%frs#)dsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#Z#)m_&m!b&eS&csOY#)dYZ(VZ]#)d]^(V^w#)dwx#*lx#O#)d#O#P#+f#P#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#/u<%lO#)d#Z#*sZ&m!b&csOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#Z#+kW&m!bO#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#.x;=`<%l#,T<%lO#)dw#,[Z&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r<%lO#,Tw#-SV&csOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xw#-lRO;'S#,T;'S;=`#-u;=`O#,Tw#-|[&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#,T<%lO#,Tw#.uP;=`<%l#,T#Z#/P[&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#)d<%lO#,T#Z#/xP;=`<%l#)d#c#0U]&m!b&hW&csOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#1SW&m!bO#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#6y;=`<%l#1l<%lO#%f!P#1u]&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#2u]&eS&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#3nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#3u]&eS&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#,Tsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#4uX&hW&csOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P#5eRO;'S#1l;'S;=`#5n;=`O#1l!P#5w^&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#1l<%lO#1l!P#6vP;=`<%l#1l#c#7S^&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#%f<%lO#1l#c#8RP;=`<%l#%f#c#8_]&m!b&hW&csOr%Trs&Vsw%Twx#9Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#9cZ&fS&m!b&hW&dsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#c#:a]js&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#;e]iR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#<iaXs&m!b&eS&hWOr%Trs&Vsw%Twx/Xxz%Tz{#=n{!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#=y_cR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#?T_%ws&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#@_]|R&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s#Ac`%xs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`!a#Be!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#O#Bp]&{`&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Cta!hQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P#Dy!P!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#ES_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P#FR!P#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#F^]!us&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Gbi!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#GV#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#IYc&m!b&eS&hWOr%Trs&Vsw%Twx/Xx{%T{|#Je|}%T}!O#Je!O!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Jn_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Kxe!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#Km#S#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Mf]!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Nja%yR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!P%T!P!Q$ o!Q!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$ z_%{Q&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$#Uw!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!d%T!d!e$(w!e!g%T!g!h#IP!h!l%T!l!m#MZ!m!q%T!q!r$+m!r!z%T!z!{$.]!{#O%T#O#P7o#P#R%T#R#S$&w#S#U%T#U#V$(w#V#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#c%T#c#d$+m#d#l%T#l#m$.]#m#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$%x_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$'Sk!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S$&w#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$)Qb&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$*eb!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$+va&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$-Wa!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$.fe&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$0Se!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$1p_}!T&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`$2o!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q$2z]&TR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$4O]#fs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$5SaoR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!^%T!^!_$6X!_!`Av!`!aAv!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$6d_%uQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$7n_&Ss&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$8x`oR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`!a$9z!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$:V_%vQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$;c_aQ#|P&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$<oe&m!b&eS&hW&b`%}sOr%Trs&Vsw%Twx/Xx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$>TP;=`<%l$<b#s$>ei&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g$Fl#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$@]a&m!b&eS&csOYE^YZ%TZ]E^]^%T^rE^rs$AbswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#c$Ak]&m!b&eS&csOr%Trs$Bdsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$BmZ&m!b&eS&gsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$Cia&m!b&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx$Dnx#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c$Dw]&m!b&hW&csOr%Trs&Vsw%Twx$Epx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_$EyZ&m!b&hW&dsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s$Fye&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$Hii&m!b&eS&hW&b`%}sOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!t$<b!t!u%!S!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g%!S#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$Ja]&m!b&eS&nsOr%Trs$KYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$Ka]&m!b&eSOr%Trs$LYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$LcZ&m!b&eS&psOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$M_]&m!b&hW&jsOr%Trs&Vsw%Twx$NWx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$N_]&m!b&hWOr%Trs&Vsw%Twx% Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_% aZ&m!b&hW&osOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s%!ae&m!b&eS&hW&b`%}sOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s%$Pm&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!h$<b!h!i%!S!i!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#U$<b#U#V$Fl#V#Y$<b#Y#Z%!S#Z#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c%&V]!Zs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%'Z]!YR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b%(__%sQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a%)gX!_#T&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#c%*__%rR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%+gX!^!e&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#a%,_]%|q&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T",
  tokenizers: [S6, g6, m6, $6, w6, P6, _6, 0, 1, 2, 3, 4, 5, 6],
  topRules: { Script: [0, 7] },
  specialized: [{ term: 229, get: (t10) => Q6[t10] || -1 }],
  tokenPrec: 7205
}), jv = /* @__PURE__ */ new vg(), v_ = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function Ku(t10) {
  return (e3, r3, n3) => {
    if (n3)
      return false;
    let i3 = e3.node.getChild("VariableName");
    return i3 && r3(i3, t10), true;
  };
}
const k6 = {
  FunctionDefinition: /* @__PURE__ */ Ku("function"),
  ClassDefinition: /* @__PURE__ */ Ku("class"),
  ForStatement(t10, e3, r3) {
    if (r3) {
      for (let n3 = t10.node.firstChild; n3; n3 = n3.nextSibling)
        if (n3.name == "VariableName")
          e3(n3, "variable");
        else if (n3.name == "in")
          break;
    }
  },
  ImportStatement(t10, e3) {
    var r3, n3;
    let { node: i3 } = t10, o3 = ((r3 = i3.firstChild) === null || r3 === void 0 ? void 0 : r3.name) == "from";
    for (let s3 = i3.getChild("import"); s3; s3 = s3.nextSibling)
      s3.name == "VariableName" && ((n3 = s3.nextSibling) === null || n3 === void 0 ? void 0 : n3.name) != "as" && e3(s3, o3 ? "variable" : "namespace");
  },
  AssignStatement(t10, e3) {
    for (let r3 = t10.node.firstChild; r3; r3 = r3.nextSibling)
      if (r3.name == "VariableName")
        e3(r3, "variable");
      else if (r3.name == ":" || r3.name == "AssignOp")
        break;
  },
  ParamList(t10, e3) {
    for (let r3 = null, n3 = t10.node.firstChild; n3; n3 = n3.nextSibling)
      n3.name == "VariableName" && (!r3 || !/\*|AssignOp/.test(r3.name)) && e3(n3, "variable"), r3 = n3;
  },
  CapturePattern: /* @__PURE__ */ Ku("variable"),
  AsPattern: /* @__PURE__ */ Ku("variable"),
  __proto__: null
};
function b_(t10, e3) {
  let r3 = jv.get(e3);
  if (r3)
    return r3;
  let n3 = [], i3 = true;
  function o3(s3, a3) {
    let l3 = t10.sliceString(s3.from, s3.to);
    n3.push({ label: l3, type: a3 });
  }
  return e3.cursor(vt.IncludeAnonymous).iterate((s3) => {
    if (s3.name) {
      let a3 = k6[s3.name];
      if (a3 && a3(s3, o3, i3) || !i3 && v_.has(s3.name))
        return false;
      i3 = false;
    } else if (s3.to - s3.from > 8192) {
      for (let a3 of b_(t10, s3.node))
        n3.push(a3);
      return false;
    }
  }), jv.set(e3, n3), n3;
}
const Uv = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/, S_ = ["String", "FormatString", "Comment", "PropertyName"];
function E6(t10) {
  let e3 = tn(t10.state).resolveInner(t10.pos, -1);
  if (S_.indexOf(e3.name) > -1)
    return null;
  let r3 = e3.name == "VariableName" || e3.to - e3.from < 20 && Uv.test(t10.state.sliceDoc(e3.from, e3.to));
  if (!r3 && !t10.explicit)
    return null;
  let n3 = [];
  for (let i3 = e3; i3; i3 = i3.parent)
    v_.has(i3.name) && (n3 = n3.concat(b_(t10.state.doc, i3)));
  return {
    options: n3,
    from: r3 ? e3.from : t10.pos,
    validFor: Uv
  };
}
const C6 = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((t10) => ({ label: t10, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((t10) => ({ label: t10, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((t10) => ({ label: t10, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((t10) => ({ label: t10, type: "function" }))), R6 = [
  /* @__PURE__ */ At("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ At("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ At("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ At("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ At(`if \${}:
	
`, {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ At("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ At("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ At("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ At("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
], A6 = /* @__PURE__ */ zP(S_, /* @__PURE__ */ BP(/* @__PURE__ */ C6.concat(R6)));
function Iv(t10, e3) {
  let r3 = t10.baseIndentFor(e3), n3 = t10.lineAt(t10.pos, -1), i3 = n3.from + n3.text.length;
  return /^\s*($|#)/.test(n3.text) && t10.node.to < i3 + 100 && !/\S/.test(t10.state.sliceDoc(i3, t10.node.to)) && t10.lineIndent(t10.pos, -1) <= r3 || /^\s*(else:|elif |except |finally:)/.test(t10.textAfter) && t10.lineIndent(t10.pos, -1) > r3 ? null : r3 + t10.unit;
}
const Ch = /* @__PURE__ */ qi.define({
  name: "python",
  parser: /* @__PURE__ */ T6.configure({
    props: [
      /* @__PURE__ */ xa.add({
        Body: (t10) => {
          var e3;
          return (e3 = Iv(t10, t10.node)) !== null && e3 !== void 0 ? e3 : t10.continue();
        },
        IfStatement: (t10) => /^\s*(else:|elif )/.test(t10.textAfter) ? t10.baseIndent : t10.continue(),
        TryStatement: (t10) => /^\s*(except |finally:|else:)/.test(t10.textAfter) ? t10.baseIndent : t10.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ yl({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ yl({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ yl({ closing: "]" }),
        "String FormatString": () => null,
        Script: (t10) => {
          if (t10.pos + /\s*/.exec(t10.textAfter)[0].length >= t10.node.to) {
            let e3 = null;
            for (let r3 = t10.node, n3 = r3.to; r3 = r3.lastChild, !(!r3 || r3.to != n3); )
              r3.type.name == "Body" && (e3 = r3);
            if (e3) {
              let r3 = Iv(t10, e3);
              if (r3 != null)
                return r3;
            }
          }
          return t10.continue();
        }
      }),
      /* @__PURE__ */ Qa.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": cu,
        Body: (t10, e3) => ({ from: t10.from + 1, to: t10.to - (t10.to == e3.doc.length ? 0 : 1) })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
  }
});
function X6() {
  return new _a(Ch, [
    Ch.data.of({ autocomplete: E6 }),
    Ch.data.of({ autocomplete: A6 })
  ]);
}
function Ng(t10, e3, r3, n3, i3, o3) {
  this.indented = t10, this.column = e3, this.type = r3, this.info = n3, this.align = i3, this.prev = o3;
}
function Ju(t10, e3, r3, n3) {
  var i3 = t10.indented;
  return t10.context && t10.context.type == "statement" && r3 != "statement" && (i3 = t10.context.indented), t10.context = new Ng(i3, e3, r3, n3, null, t10.context);
}
function za(t10) {
  var e3 = t10.context.type;
  return (e3 == ")" || e3 == "]" || e3 == "}") && (t10.indented = t10.context.indented), t10.context = t10.context.prev;
}
function Fv(t10, e3, r3) {
  if (e3.prevToken == "variable" || e3.prevToken == "type" || /\S(?:[^- ]>|[*\]])\s*$|\*$/.test(t10.string.slice(0, r3)) || e3.typeAtEndOfLine && t10.column() == t10.indentation())
    return true;
}
function Rh(t10) {
  for (; ; ) {
    if (!t10 || t10.type == "top")
      return true;
    if (t10.type == "}" && t10.prev.info != "namespace")
      return false;
    t10 = t10.prev;
  }
}
function rn(t10) {
  var e3 = t10.statementIndentUnit, r3 = t10.dontAlignCalls, n3 = t10.keywords || {}, i3 = t10.types || {}, o3 = t10.builtin || {}, s3 = t10.blockKeywords || {}, a3 = t10.defKeywords || {}, l3 = t10.atoms || {}, u3 = t10.hooks || {}, c3 = t10.multiLineStrings, f3 = t10.indentStatements !== false, d3 = t10.indentSwitch !== false, p10 = t10.namespaceSeparator, h10 = t10.isPunctuationChar || /[\[\]{}\(\),;\:\.]/, m10 = t10.numberStart || /[\d\.]/, O10 = t10.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i, g = t10.isOperatorChar || /[+\-*&%=<>!?|\/]/, v10 = t10.isIdentifierChar || /[\w\$_\xa1-\uffff]/, S10 = t10.isReservedIdentifier || false, $10, _10;
  function P10(H10, ne) {
    var re2 = H10.next();
    if (u3[re2]) {
      var fe = u3[re2](H10, ne);
      if (fe !== false)
        return fe;
    }
    if (re2 == '"' || re2 == "'")
      return ne.tokenize = q5(re2), ne.tokenize(H10, ne);
    if (m10.test(re2)) {
      if (H10.backUp(1), H10.match(O10))
        return "number";
      H10.next();
    }
    if (h10.test(re2))
      return $10 = re2, null;
    if (re2 == "/") {
      if (H10.eat("*"))
        return ne.tokenize = N5, N5(H10, ne);
      if (H10.eat("/"))
        return H10.skipToEnd(), "comment";
    }
    if (g.test(re2)) {
      for (; !H10.match(/^\/[\/*]/, false) && H10.eat(g); )
        ;
      return "operator";
    }
    if (H10.eatWhile(v10), p10)
      for (; H10.match(p10); )
        H10.eatWhile(v10);
    var pe = H10.current();
    return mi(n3, pe) ? (mi(s3, pe) && ($10 = "newstatement"), mi(a3, pe) && (_10 = true), "keyword") : mi(i3, pe) ? "type" : mi(o3, pe) || S10 && S10(pe) ? (mi(s3, pe) && ($10 = "newstatement"), "builtin") : mi(l3, pe) ? "atom" : "variable";
  }
  function q5(H10) {
    return function(ne, re2) {
      for (var fe = false, pe, Ee2 = false; (pe = ne.next()) != null; ) {
        if (pe == H10 && !fe) {
          Ee2 = true;
          break;
        }
        fe = !fe && pe == "\\";
      }
      return (Ee2 || !(fe || c3)) && (re2.tokenize = null), "string";
    };
  }
  function N5(H10, ne) {
    for (var re2 = false, fe; fe = H10.next(); ) {
      if (fe == "/" && re2) {
        ne.tokenize = null;
        break;
      }
      re2 = fe == "*";
    }
    return "comment";
  }
  function B5(H10, ne) {
    t10.typeFirstDefinitions && H10.eol() && Rh(ne.context) && (ne.typeAtEndOfLine = Fv(H10, ne, H10.pos));
  }
  return {
    name: t10.name,
    startState: function(H10) {
      return {
        tokenize: null,
        context: new Ng(-H10, 0, "top", null, false),
        indented: 0,
        startOfLine: true,
        prevToken: null
      };
    },
    token: function(H10, ne) {
      var re2 = ne.context;
      if (H10.sol() && (re2.align == null && (re2.align = false), ne.indented = H10.indentation(), ne.startOfLine = true), H10.eatSpace())
        return B5(H10, ne), null;
      $10 = _10 = null;
      var fe = (ne.tokenize || P10)(H10, ne);
      if (fe == "comment" || fe == "meta")
        return fe;
      if (re2.align == null && (re2.align = true), $10 == ";" || $10 == ":" || $10 == "," && H10.match(/^\s*(?:\/\/.*)?$/, false))
        for (; ne.context.type == "statement"; )
          za(ne);
      else if ($10 == "{")
        Ju(ne, H10.column(), "}");
      else if ($10 == "[")
        Ju(ne, H10.column(), "]");
      else if ($10 == "(")
        Ju(ne, H10.column(), ")");
      else if ($10 == "}") {
        for (; re2.type == "statement"; )
          re2 = za(ne);
        for (re2.type == "}" && (re2 = za(ne)); re2.type == "statement"; )
          re2 = za(ne);
      } else
        $10 == re2.type ? za(ne) : f3 && ((re2.type == "}" || re2.type == "top") && $10 != ";" || re2.type == "statement" && $10 == "newstatement") && Ju(ne, H10.column(), "statement", H10.current());
      if (fe == "variable" && (ne.prevToken == "def" || t10.typeFirstDefinitions && Fv(H10, ne, H10.start) && Rh(ne.context) && H10.match(/^\s*\(/, false)) && (fe = "def"), u3.token) {
        var pe = u3.token(H10, ne, fe);
        pe !== void 0 && (fe = pe);
      }
      return fe == "def" && t10.styleDefs === false && (fe = "variable"), ne.startOfLine = false, ne.prevToken = _10 ? "def" : fe || $10, B5(H10, ne), fe;
    },
    indent: function(H10, ne, re2) {
      if (H10.tokenize != P10 && H10.tokenize != null || H10.typeAtEndOfLine && Rh(H10.context))
        return null;
      var fe = H10.context, pe = ne && ne.charAt(0), Ee2 = pe == fe.type;
      if (fe.type == "statement" && pe == "}" && (fe = fe.prev), t10.dontIndentStatements)
        for (; fe.type == "statement" && t10.dontIndentStatements.test(fe.info); )
          fe = fe.prev;
      if (u3.indent) {
        var qe = u3.indent(H10, fe, ne, re2.unit);
        if (typeof qe == "number")
          return qe;
      }
      var _e = fe.prev && fe.prev.info == "switch";
      if (t10.allmanIndentation && /[{(]/.test(pe)) {
        for (; fe.type != "top" && fe.type != "}"; )
          fe = fe.prev;
        return fe.indented;
      }
      return fe.type == "statement" ? fe.indented + (pe == "{" ? 0 : e3 || re2.unit) : fe.align && (!r3 || fe.type != ")") ? fe.column + (Ee2 ? 0 : 1) : fe.type == ")" && !Ee2 ? fe.indented + (e3 || re2.unit) : fe.indented + (Ee2 ? 0 : re2.unit) + (!Ee2 && _e && !/^(?:case|default)\b/.test(ne) ? re2.unit : 0);
    },
    languageData: {
      indentOnInput: d3 ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
      commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
      autocomplete: Object.keys(n3).concat(Object.keys(i3)).concat(Object.keys(o3)).concat(Object.keys(l3)),
      ...t10.languageData
    }
  };
}
function we(t10) {
  for (var e3 = {}, r3 = t10.split(" "), n3 = 0; n3 < r3.length; ++n3)
    e3[r3[n3]] = true;
  return e3;
}
function mi(t10, e3) {
  return typeof t10 == "function" ? t10(e3) : t10.propertyIsEnumerable(e3);
}
var du = "auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile inline restrict asm fortran", $_ = "alignas alignof and and_eq audit axiom bitand bitor catch class compl concept constexpr const_cast decltype delete dynamic_cast explicit export final friend import module mutable namespace new noexcept not not_eq operator or or_eq override private protected public reinterpret_cast requires static_assert static_cast template this thread_local throw try typeid typename using virtual xor xor_eq", w_ = "bycopy byref in inout oneway out self super atomic nonatomic retain copy readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd @interface @implementation @end @protocol @encode @property @synthesize @dynamic @class @public @package @private @protected @required @optional @try @catch @finally @import @selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available", P_ = "FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION  NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT", q6 = we("int long char short double float unsigned signed void bool"), D6 = we("SEL instancetype id Class Protocol BOOL");
function hu(t10) {
  return mi(q6, t10) || /.+_t$/.test(t10);
}
function __(t10) {
  return hu(t10) || mi(D6, t10);
}
var pu = "case do else for if switch while struct enum union", nd = "struct enum union";
function bo(t10, e3) {
  if (!e3.startOfLine)
    return false;
  for (var r3, n3 = null; r3 = t10.peek(); ) {
    if (r3 == "\\" && t10.match(/^.$/)) {
      n3 = bo;
      break;
    } else if (r3 == "/" && t10.match(/^\/[\/\*]/, false))
      break;
    t10.next();
  }
  return e3.tokenize = n3, "meta";
}
function id(t10, e3) {
  return e3.prevToken == "type" ? "type" : false;
}
function od(t10) {
  return !t10 || t10.length < 2 || t10[0] != "_" ? false : t10[1] == "_" || t10[1] !== t10[1].toLowerCase();
}
function Vt(t10) {
  return t10.eatWhile(/[\w\.']/), "number";
}
function ro(t10, e3) {
  if (t10.backUp(1), t10.match(/^(?:R|u8R|uR|UR|LR)/)) {
    var r3 = t10.match(/^"([^\s\\()]{0,16})\(/);
    return r3 ? (e3.cpp11RawStringDelim = r3[1], e3.tokenize = Mv, Mv(t10, e3)) : false;
  }
  return t10.match(/^(?:u8|u|U|L)/) ? t10.match(
    /^["']/,
    /* eat */
    false
  ) ? "string" : false : (t10.next(), false);
}
function x_(t10) {
  var e3 = /(\w+)::~?(\w+)$/.exec(t10);
  return e3 && e3[1] == e3[2];
}
function Zv(t10, e3) {
  for (var r3; (r3 = t10.next()) != null; )
    if (r3 == '"' && !t10.eat('"')) {
      e3.tokenize = null;
      break;
    }
  return "string";
}
function Mv(t10, e3) {
  var r3 = e3.cpp11RawStringDelim.replace(/[^\w\s]/g, "\\$&"), n3 = t10.match(new RegExp(".*?\\)" + r3 + '"'));
  return n3 ? e3.tokenize = null : t10.skipToEnd(), "string";
}
const j6 = rn({
  name: "c",
  keywords: we(du),
  types: hu,
  blockKeywords: we(pu),
  defKeywords: we(nd),
  typeFirstDefinitions: true,
  atoms: we("NULL true false"),
  isReservedIdentifier: od,
  hooks: {
    "#": bo,
    "*": id
  }
});
rn({
  name: "cpp",
  keywords: we(du + " " + $_),
  types: hu,
  blockKeywords: we(pu + " class try catch"),
  defKeywords: we(nd + " class namespace"),
  typeFirstDefinitions: true,
  atoms: we("true false NULL nullptr"),
  dontIndentStatements: /^template$/,
  isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
  isReservedIdentifier: od,
  hooks: {
    "#": bo,
    "*": id,
    u: ro,
    U: ro,
    L: ro,
    R: ro,
    0: Vt,
    1: Vt,
    2: Vt,
    3: Vt,
    4: Vt,
    5: Vt,
    6: Vt,
    7: Vt,
    8: Vt,
    9: Vt,
    token: function(t10, e3, r3) {
      if (r3 == "variable" && t10.peek() == "(" && (e3.prevToken == ";" || e3.prevToken == null || e3.prevToken == "}") && x_(t10.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
});
rn({
  name: "java",
  keywords: we("abstract assert break case catch class const continue default do else enum extends final finally for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),
  types: we("var byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),
  blockKeywords: we("catch class do else finally for if switch try while"),
  defKeywords: we("class interface enum @interface"),
  typeFirstDefinitions: true,
  atoms: we("true false null"),
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  hooks: {
    "@": function(t10) {
      return t10.match("interface", false) ? false : (t10.eatWhile(/[\w\$_]/), "meta");
    },
    '"': function(t10, e3) {
      return t10.match(/""$/) ? (e3.tokenize = Q_, e3.tokenize(t10, e3)) : false;
    }
  }
});
const U6 = rn({
  name: "csharp",
  keywords: we("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in init interface internal is lock namespace new operator out override params private protected public readonly record ref required return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),
  types: we("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),
  blockKeywords: we("catch class do else finally for foreach if struct switch try while"),
  defKeywords: we("class interface namespace record struct var"),
  typeFirstDefinitions: true,
  atoms: we("true false null"),
  hooks: {
    "@": function(t10, e3) {
      return t10.eat('"') ? (e3.tokenize = Zv, Zv(t10, e3)) : (t10.eatWhile(/[\w\$_]/), "meta");
    }
  }
});
function Q_(t10, e3) {
  for (var r3 = false; !t10.eol(); ) {
    if (!r3 && t10.match('"""')) {
      e3.tokenize = null;
      break;
    }
    r3 = t10.next() == "\\" && !r3;
  }
  return "string";
}
function Nl(t10) {
  return function(e3, r3) {
    for (var n3; n3 = e3.next(); )
      if (n3 == "*" && e3.eat("/"))
        if (t10 == 1) {
          r3.tokenize = null;
          break;
        } else
          return r3.tokenize = Nl(t10 - 1), r3.tokenize(e3, r3);
      else if (n3 == "/" && e3.eat("*"))
        return r3.tokenize = Nl(t10 + 1), r3.tokenize(e3, r3);
    return "comment";
  };
}
rn({
  name: "scala",
  keywords: we(
    /* scala */
    "abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"
  ),
  types: we(
    "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"
  ),
  multiLineStrings: true,
  blockKeywords: we("catch class enum do else finally for forSome if match switch try while"),
  defKeywords: we("class enum def object package trait type val var"),
  atoms: we("true false null"),
  indentStatements: false,
  indentSwitch: false,
  isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
  hooks: {
    "@": function(t10) {
      return t10.eatWhile(/[\w\$_]/), "meta";
    },
    '"': function(t10, e3) {
      return t10.match('""') ? (e3.tokenize = Q_, e3.tokenize(t10, e3)) : false;
    },
    "'": function(t10) {
      return t10.match(/^(\\[^'\s]+|[^\\'])'/) ? "character" : (t10.eatWhile(/[\w\$_\xa1-\uffff]/), "atom");
    },
    "=": function(t10, e3) {
      var r3 = e3.context;
      return r3.type == "}" && r3.align && t10.eat(">") ? (e3.context = new Ng(r3.indented, r3.column, r3.type, r3.info, null, r3.prev), "operator") : false;
    },
    "/": function(t10, e3) {
      return t10.eat("*") ? (e3.tokenize = Nl(1), e3.tokenize(t10, e3)) : false;
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
function I6(t10) {
  return function(e3, r3) {
    for (var n3 = false, i3, o3 = false; !e3.eol(); ) {
      if (!t10 && !n3 && e3.match('"')) {
        o3 = true;
        break;
      }
      if (t10 && e3.match('"""')) {
        o3 = true;
        break;
      }
      i3 = e3.next(), !n3 && i3 == "$" && e3.match("{") && e3.skipTo("}"), n3 = !n3 && i3 == "\\" && !t10;
    }
    return (o3 || !t10) && (r3.tokenize = null), "string";
  };
}
const F6 = rn({
  name: "kotlin",
  keywords: we(
    /*keywords*/
    "package as typealias class interface this super val operator var fun for is in This throw return annotation break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend actual expect setparam"
  ),
  types: we(
    /* package java.lang */
    "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy LazyThreadSafetyMode LongArray Nothing ShortArray Unit"
  ),
  intendSwitch: false,
  indentStatements: false,
  multiLineStrings: true,
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  blockKeywords: we("catch class do else finally for if where try while enum"),
  defKeywords: we("class val var object interface fun"),
  atoms: we("true false null this"),
  hooks: {
    "@": function(t10) {
      return t10.eatWhile(/[\w\$_]/), "meta";
    },
    "*": function(t10, e3) {
      return e3.prevToken == "." ? "variable" : "operator";
    },
    '"': function(t10, e3) {
      return e3.tokenize = I6(t10.match('""')), e3.tokenize(t10, e3);
    },
    "/": function(t10, e3) {
      return t10.eat("*") ? (e3.tokenize = Nl(1), e3.tokenize(t10, e3)) : false;
    },
    indent: function(t10, e3, r3, n3) {
      var i3 = r3 && r3.charAt(0);
      if ((t10.prevToken == "}" || t10.prevToken == ")") && r3 == "")
        return t10.indented;
      if (t10.prevToken == "operator" && r3 != "}" && t10.context.type != "}" || t10.prevToken == "variable" && i3 == "." || (t10.prevToken == "}" || t10.prevToken == ")") && i3 == ".")
        return n3 * 2 + e3.indented;
      if (e3.align && e3.type == "}")
        return e3.indented + (t10.context.type == (r3 || "").charAt(0) ? 0 : n3);
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
rn({
  name: "shader",
  keywords: we("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),
  types: we("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),
  blockKeywords: we("for while do if else struct"),
  builtin: we("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),
  atoms: we("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),
  indentSwitch: false,
  hooks: { "#": bo }
});
rn({
  name: "nesc",
  keywords: we(du + " as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),
  types: hu,
  blockKeywords: we(pu),
  atoms: we("null true false"),
  hooks: { "#": bo }
});
const Z6 = rn({
  name: "objectivec",
  keywords: we(du + " " + w_),
  types: __,
  builtin: we(P_),
  blockKeywords: we(pu + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),
  defKeywords: we(nd + " @interface @implementation @protocol @class"),
  dontIndentStatements: /^@.*$/,
  typeFirstDefinitions: true,
  atoms: we("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: od,
  hooks: {
    "#": bo,
    "*": id
  }
});
rn({
  name: "objectivecpp",
  keywords: we(du + " " + w_ + " " + $_),
  types: __,
  builtin: we(P_),
  blockKeywords: we(pu + " @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),
  defKeywords: we(nd + " @interface @implementation @protocol @class class namespace"),
  dontIndentStatements: /^@.*$|^template$/,
  typeFirstDefinitions: true,
  atoms: we("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: od,
  hooks: {
    "#": bo,
    "*": id,
    u: ro,
    U: ro,
    L: ro,
    R: ro,
    0: Vt,
    1: Vt,
    2: Vt,
    3: Vt,
    4: Vt,
    5: Vt,
    6: Vt,
    7: Vt,
    8: Vt,
    9: Vt,
    token: function(t10, e3, r3) {
      if (r3 == "variable" && t10.peek() == "(" && (e3.prevToken == ";" || e3.prevToken == null || e3.prevToken == "}") && x_(t10.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
});
rn({
  name: "squirrel",
  keywords: we("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),
  types: hu,
  blockKeywords: we("case catch class else for foreach if switch try while"),
  defKeywords: we("function local class"),
  typeFirstDefinitions: true,
  atoms: we("true false null"),
  hooks: { "#": bo }
});
var _c = null;
function T_(t10) {
  return function(e3, r3) {
    for (var n3 = false, i3, o3 = false; !e3.eol(); ) {
      if (!n3 && e3.match('"') && (t10 == "single" || e3.match('""'))) {
        o3 = true;
        break;
      }
      if (!n3 && e3.match("``")) {
        _c = T_(t10), o3 = true;
        break;
      }
      i3 = e3.next(), n3 = t10 == "single" && !n3 && i3 == "\\";
    }
    return o3 && (r3.tokenize = null), "string";
  };
}
rn({
  name: "ceylon",
  keywords: we("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),
  types: function(t10) {
    var e3 = t10.charAt(0);
    return e3 === e3.toUpperCase() && e3 !== e3.toLowerCase();
  },
  blockKeywords: we("case catch class dynamic else finally for function if interface module new object switch try while"),
  defKeywords: we("class dynamic function interface module object package value"),
  builtin: we("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),
  isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
  isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
  numberStart: /[\d#$]/,
  number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
  multiLineStrings: true,
  typeFirstDefinitions: true,
  atoms: we("true false null larger smaller equal empty finished"),
  indentSwitch: false,
  styleDefs: false,
  hooks: {
    "@": function(t10) {
      return t10.eatWhile(/[\w\$_]/), "meta";
    },
    '"': function(t10, e3) {
      return e3.tokenize = T_(t10.match('""') ? "triple" : "single"), e3.tokenize(t10, e3);
    },
    "`": function(t10, e3) {
      return !_c || !t10.match("`") ? false : (e3.tokenize = _c, _c = null, e3.tokenize(t10, e3));
    },
    "'": function(t10) {
      return t10.match(/^(\\[^'\s]+|[^\\'])'/) ? "string.special" : (t10.eatWhile(/[\w\$_\xa1-\uffff]/), "atom");
    },
    token: function(t10, e3, r3) {
      if ((r3 == "variable" || r3 == "type") && e3.prevToken == ".")
        return "variableName.special";
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
function M6(t10) {
  (t10.interpolationStack || (t10.interpolationStack = [])).push(t10.tokenize);
}
function k_(t10) {
  return (t10.interpolationStack || (t10.interpolationStack = [])).pop();
}
function N6(t10) {
  return t10.interpolationStack ? t10.interpolationStack.length : 0;
}
function Ah(t10, e3, r3, n3) {
  var i3 = false;
  if (e3.eat(t10))
    if (e3.eat(t10))
      i3 = true;
    else
      return "string";
  function o3(s3, a3) {
    for (var l3 = false; !s3.eol(); ) {
      if (!n3 && !l3 && s3.peek() == "$")
        return M6(a3), a3.tokenize = W6, "string";
      var u3 = s3.next();
      if (u3 == t10 && !l3 && (!i3 || s3.match(t10 + t10))) {
        a3.tokenize = null;
        break;
      }
      l3 = !n3 && !l3 && u3 == "\\";
    }
    return "string";
  }
  return r3.tokenize = o3, o3(e3, r3);
}
function W6(t10, e3) {
  return t10.eat("$"), t10.eat("{") ? e3.tokenize = null : e3.tokenize = V6, null;
}
function V6(t10, e3) {
  return t10.eatWhile(/[\w_]/), e3.tokenize = k_(e3), "variable";
}
rn({
  name: "dart",
  keywords: we("this super static final const abstract class extends external factory implements mixin get native set typedef with enum throw rethrow assert break case continue default in return new deferred async await covariant try catch finally do else for if switch while import library export part of show hide is as extension on yield late required sealed base interface when inline"),
  blockKeywords: we("try catch finally do else for if switch while"),
  builtin: we("void bool num int double dynamic var String Null Never"),
  atoms: we("true false null"),
  hooks: {
    "@": function(t10) {
      return t10.eatWhile(/[\w\$_\.]/), "meta";
    },
    // custom string handling to deal with triple-quoted strings and string interpolation
    "'": function(t10, e3) {
      return Ah("'", t10, e3, false);
    },
    '"': function(t10, e3) {
      return Ah('"', t10, e3, false);
    },
    r: function(t10, e3) {
      var r3 = t10.peek();
      return r3 == "'" || r3 == '"' ? Ah(t10.next(), t10, e3, true) : false;
    },
    "}": function(t10, e3) {
      return N6(e3) > 0 ? (e3.tokenize = k_(e3), null) : false;
    },
    "/": function(t10, e3) {
      return t10.eat("*") ? (e3.tokenize = Nl(1), e3.tokenize(t10, e3)) : false;
    },
    token: function(t10, e3, r3) {
      if (r3 == "variable") {
        var n3 = RegExp("^[_$]*[A-Z][a-zA-Z0-9_$]*$", "g");
        if (n3.test(t10.current()))
          return "type";
      }
    }
  }
});
var E_ = ["false", "nil", "true"], C_ = [
  ".",
  "catch",
  "def",
  "do",
  "if",
  "monitor-enter",
  "monitor-exit",
  "new",
  "quote",
  "recur",
  "set!",
  "throw",
  "try",
  "var"
], R_ = [
  "*",
  "*'",
  "*1",
  "*2",
  "*3",
  "*agent*",
  "*allow-unresolved-vars*",
  "*assert*",
  "*clojure-version*",
  "*command-line-args*",
  "*compile-files*",
  "*compile-path*",
  "*compiler-options*",
  "*data-readers*",
  "*default-data-reader-fn*",
  "*e",
  "*err*",
  "*file*",
  "*flush-on-newline*",
  "*fn-loader*",
  "*in*",
  "*math-context*",
  "*ns*",
  "*out*",
  "*print-dup*",
  "*print-length*",
  "*print-level*",
  "*print-meta*",
  "*print-namespace-maps*",
  "*print-readably*",
  "*read-eval*",
  "*reader-resolver*",
  "*source-path*",
  "*suppress-read*",
  "*unchecked-math*",
  "*use-context-classloader*",
  "*verbose-defrecords*",
  "*warn-on-reflection*",
  "+",
  "+'",
  "-",
  "-'",
  "->",
  "->>",
  "->ArrayChunk",
  "->Eduction",
  "->Vec",
  "->VecNode",
  "->VecSeq",
  "-cache-protocol-fn",
  "-reset-methods",
  "..",
  "/",
  "<",
  "<=",
  "=",
  "==",
  ">",
  ">=",
  "EMPTY-NODE",
  "Inst",
  "StackTraceElement->vec",
  "Throwable->map",
  "accessor",
  "aclone",
  "add-classpath",
  "add-watch",
  "agent",
  "agent-error",
  "agent-errors",
  "aget",
  "alength",
  "alias",
  "all-ns",
  "alter",
  "alter-meta!",
  "alter-var-root",
  "amap",
  "ancestors",
  "and",
  "any?",
  "apply",
  "areduce",
  "array-map",
  "as->",
  "aset",
  "aset-boolean",
  "aset-byte",
  "aset-char",
  "aset-double",
  "aset-float",
  "aset-int",
  "aset-long",
  "aset-short",
  "assert",
  "assoc",
  "assoc!",
  "assoc-in",
  "associative?",
  "atom",
  "await",
  "await-for",
  "await1",
  "bases",
  "bean",
  "bigdec",
  "bigint",
  "biginteger",
  "binding",
  "bit-and",
  "bit-and-not",
  "bit-clear",
  "bit-flip",
  "bit-not",
  "bit-or",
  "bit-set",
  "bit-shift-left",
  "bit-shift-right",
  "bit-test",
  "bit-xor",
  "boolean",
  "boolean-array",
  "boolean?",
  "booleans",
  "bound-fn",
  "bound-fn*",
  "bound?",
  "bounded-count",
  "butlast",
  "byte",
  "byte-array",
  "bytes",
  "bytes?",
  "case",
  "cast",
  "cat",
  "char",
  "char-array",
  "char-escape-string",
  "char-name-string",
  "char?",
  "chars",
  "chunk",
  "chunk-append",
  "chunk-buffer",
  "chunk-cons",
  "chunk-first",
  "chunk-next",
  "chunk-rest",
  "chunked-seq?",
  "class",
  "class?",
  "clear-agent-errors",
  "clojure-version",
  "coll?",
  "comment",
  "commute",
  "comp",
  "comparator",
  "compare",
  "compare-and-set!",
  "compile",
  "complement",
  "completing",
  "concat",
  "cond",
  "cond->",
  "cond->>",
  "condp",
  "conj",
  "conj!",
  "cons",
  "constantly",
  "construct-proxy",
  "contains?",
  "count",
  "counted?",
  "create-ns",
  "create-struct",
  "cycle",
  "dec",
  "dec'",
  "decimal?",
  "declare",
  "dedupe",
  "default-data-readers",
  "definline",
  "definterface",
  "defmacro",
  "defmethod",
  "defmulti",
  "defn",
  "defn-",
  "defonce",
  "defprotocol",
  "defrecord",
  "defstruct",
  "deftype",
  "delay",
  "delay?",
  "deliver",
  "denominator",
  "deref",
  "derive",
  "descendants",
  "destructure",
  "disj",
  "disj!",
  "dissoc",
  "dissoc!",
  "distinct",
  "distinct?",
  "doall",
  "dorun",
  "doseq",
  "dosync",
  "dotimes",
  "doto",
  "double",
  "double-array",
  "double?",
  "doubles",
  "drop",
  "drop-last",
  "drop-while",
  "eduction",
  "empty",
  "empty?",
  "ensure",
  "ensure-reduced",
  "enumeration-seq",
  "error-handler",
  "error-mode",
  "eval",
  "even?",
  "every-pred",
  "every?",
  "ex-data",
  "ex-info",
  "extend",
  "extend-protocol",
  "extend-type",
  "extenders",
  "extends?",
  "false?",
  "ffirst",
  "file-seq",
  "filter",
  "filterv",
  "find",
  "find-keyword",
  "find-ns",
  "find-protocol-impl",
  "find-protocol-method",
  "find-var",
  "first",
  "flatten",
  "float",
  "float-array",
  "float?",
  "floats",
  "flush",
  "fn",
  "fn?",
  "fnext",
  "fnil",
  "for",
  "force",
  "format",
  "frequencies",
  "future",
  "future-call",
  "future-cancel",
  "future-cancelled?",
  "future-done?",
  "future?",
  "gen-class",
  "gen-interface",
  "gensym",
  "get",
  "get-in",
  "get-method",
  "get-proxy-class",
  "get-thread-bindings",
  "get-validator",
  "group-by",
  "halt-when",
  "hash",
  "hash-combine",
  "hash-map",
  "hash-ordered-coll",
  "hash-set",
  "hash-unordered-coll",
  "ident?",
  "identical?",
  "identity",
  "if-let",
  "if-not",
  "if-some",
  "ifn?",
  "import",
  "in-ns",
  "inc",
  "inc'",
  "indexed?",
  "init-proxy",
  "inst-ms",
  "inst-ms*",
  "inst?",
  "instance?",
  "int",
  "int-array",
  "int?",
  "integer?",
  "interleave",
  "intern",
  "interpose",
  "into",
  "into-array",
  "ints",
  "io!",
  "isa?",
  "iterate",
  "iterator-seq",
  "juxt",
  "keep",
  "keep-indexed",
  "key",
  "keys",
  "keyword",
  "keyword?",
  "last",
  "lazy-cat",
  "lazy-seq",
  "let",
  "letfn",
  "line-seq",
  "list",
  "list*",
  "list?",
  "load",
  "load-file",
  "load-reader",
  "load-string",
  "loaded-libs",
  "locking",
  "long",
  "long-array",
  "longs",
  "loop",
  "macroexpand",
  "macroexpand-1",
  "make-array",
  "make-hierarchy",
  "map",
  "map-entry?",
  "map-indexed",
  "map?",
  "mapcat",
  "mapv",
  "max",
  "max-key",
  "memfn",
  "memoize",
  "merge",
  "merge-with",
  "meta",
  "method-sig",
  "methods",
  "min",
  "min-key",
  "mix-collection-hash",
  "mod",
  "munge",
  "name",
  "namespace",
  "namespace-munge",
  "nat-int?",
  "neg-int?",
  "neg?",
  "newline",
  "next",
  "nfirst",
  "nil?",
  "nnext",
  "not",
  "not-any?",
  "not-empty",
  "not-every?",
  "not=",
  "ns",
  "ns-aliases",
  "ns-imports",
  "ns-interns",
  "ns-map",
  "ns-name",
  "ns-publics",
  "ns-refers",
  "ns-resolve",
  "ns-unalias",
  "ns-unmap",
  "nth",
  "nthnext",
  "nthrest",
  "num",
  "number?",
  "numerator",
  "object-array",
  "odd?",
  "or",
  "parents",
  "partial",
  "partition",
  "partition-all",
  "partition-by",
  "pcalls",
  "peek",
  "persistent!",
  "pmap",
  "pop",
  "pop!",
  "pop-thread-bindings",
  "pos-int?",
  "pos?",
  "pr",
  "pr-str",
  "prefer-method",
  "prefers",
  "primitives-classnames",
  "print",
  "print-ctor",
  "print-dup",
  "print-method",
  "print-simple",
  "print-str",
  "printf",
  "println",
  "println-str",
  "prn",
  "prn-str",
  "promise",
  "proxy",
  "proxy-call-with-super",
  "proxy-mappings",
  "proxy-name",
  "proxy-super",
  "push-thread-bindings",
  "pvalues",
  "qualified-ident?",
  "qualified-keyword?",
  "qualified-symbol?",
  "quot",
  "rand",
  "rand-int",
  "rand-nth",
  "random-sample",
  "range",
  "ratio?",
  "rational?",
  "rationalize",
  "re-find",
  "re-groups",
  "re-matcher",
  "re-matches",
  "re-pattern",
  "re-seq",
  "read",
  "read-line",
  "read-string",
  "reader-conditional",
  "reader-conditional?",
  "realized?",
  "record?",
  "reduce",
  "reduce-kv",
  "reduced",
  "reduced?",
  "reductions",
  "ref",
  "ref-history-count",
  "ref-max-history",
  "ref-min-history",
  "ref-set",
  "refer",
  "refer-clojure",
  "reify",
  "release-pending-sends",
  "rem",
  "remove",
  "remove-all-methods",
  "remove-method",
  "remove-ns",
  "remove-watch",
  "repeat",
  "repeatedly",
  "replace",
  "replicate",
  "require",
  "reset!",
  "reset-meta!",
  "reset-vals!",
  "resolve",
  "rest",
  "restart-agent",
  "resultset-seq",
  "reverse",
  "reversible?",
  "rseq",
  "rsubseq",
  "run!",
  "satisfies?",
  "second",
  "select-keys",
  "send",
  "send-off",
  "send-via",
  "seq",
  "seq?",
  "seqable?",
  "seque",
  "sequence",
  "sequential?",
  "set",
  "set-agent-send-executor!",
  "set-agent-send-off-executor!",
  "set-error-handler!",
  "set-error-mode!",
  "set-validator!",
  "set?",
  "short",
  "short-array",
  "shorts",
  "shuffle",
  "shutdown-agents",
  "simple-ident?",
  "simple-keyword?",
  "simple-symbol?",
  "slurp",
  "some",
  "some->",
  "some->>",
  "some-fn",
  "some?",
  "sort",
  "sort-by",
  "sorted-map",
  "sorted-map-by",
  "sorted-set",
  "sorted-set-by",
  "sorted?",
  "special-symbol?",
  "spit",
  "split-at",
  "split-with",
  "str",
  "string?",
  "struct",
  "struct-map",
  "subs",
  "subseq",
  "subvec",
  "supers",
  "swap!",
  "swap-vals!",
  "symbol",
  "symbol?",
  "sync",
  "tagged-literal",
  "tagged-literal?",
  "take",
  "take-last",
  "take-nth",
  "take-while",
  "test",
  "the-ns",
  "thread-bound?",
  "time",
  "to-array",
  "to-array-2d",
  "trampoline",
  "transduce",
  "transient",
  "tree-seq",
  "true?",
  "type",
  "unchecked-add",
  "unchecked-add-int",
  "unchecked-byte",
  "unchecked-char",
  "unchecked-dec",
  "unchecked-dec-int",
  "unchecked-divide-int",
  "unchecked-double",
  "unchecked-float",
  "unchecked-inc",
  "unchecked-inc-int",
  "unchecked-int",
  "unchecked-long",
  "unchecked-multiply",
  "unchecked-multiply-int",
  "unchecked-negate",
  "unchecked-negate-int",
  "unchecked-remainder-int",
  "unchecked-short",
  "unchecked-subtract",
  "unchecked-subtract-int",
  "underive",
  "unquote",
  "unquote-splicing",
  "unreduced",
  "unsigned-bit-shift-right",
  "update",
  "update-in",
  "update-proxy",
  "uri?",
  "use",
  "uuid?",
  "val",
  "vals",
  "var-get",
  "var-set",
  "var?",
  "vary-meta",
  "vec",
  "vector",
  "vector-of",
  "vector?",
  "volatile!",
  "volatile?",
  "vreset!",
  "vswap!",
  "when",
  "when-first",
  "when-let",
  "when-not",
  "when-some",
  "while",
  "with-bindings",
  "with-bindings*",
  "with-in-str",
  "with-loading-context",
  "with-local-vars",
  "with-meta",
  "with-open",
  "with-out-str",
  "with-precision",
  "with-redefs",
  "with-redefs-fn",
  "xml-seq",
  "zero?",
  "zipmap"
], Y6 = [
  "->",
  "->>",
  "as->",
  "binding",
  "bound-fn",
  "case",
  "catch",
  "comment",
  "cond",
  "cond->",
  "cond->>",
  "condp",
  "def",
  "definterface",
  "defmethod",
  "defn",
  "defmacro",
  "defprotocol",
  "defrecord",
  "defstruct",
  "deftype",
  "do",
  "doseq",
  "dotimes",
  "doto",
  "extend",
  "extend-protocol",
  "extend-type",
  "fn",
  "for",
  "future",
  "if",
  "if-let",
  "if-not",
  "if-some",
  "let",
  "letfn",
  "locking",
  "loop",
  "ns",
  "proxy",
  "reify",
  "struct-map",
  "some->",
  "some->>",
  "try",
  "when",
  "when-first",
  "when-let",
  "when-not",
  "when-some",
  "while",
  "with-bindings",
  "with-bindings*",
  "with-in-str",
  "with-loading-context",
  "with-local-vars",
  "with-meta",
  "with-open",
  "with-out-str",
  "with-precision",
  "with-redefs",
  "with-redefs-fn"
], L6 = sd(E_), B6 = sd(C_), z6 = sd(R_), H6 = sd(Y6), G6 = /^(?:[\\\[\]\s"(),;@^`{}~]|$)/, K6 = /^(?:[+\-]?\d+(?:(?:N|(?:[eE][+\-]?\d+))|(?:\.?\d*(?:M|(?:[eE][+\-]?\d+))?)|\/\d+|[xX][0-9a-fA-F]+|r[0-9a-zA-Z]+)?(?=[\\\[\]\s"#'(),;@^`{}~]|$))/, J6 = /^(?:\\(?:backspace|formfeed|newline|return|space|tab|o[0-7]{3}|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{4}|.)?(?=[\\\[\]\s"(),;@^`{}~]|$))/, e9 = /^(?:(?:[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*(?:\.[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*)*\/)?(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)*(?=[\\\[\]\s"(),;@^`{}~]|$))/;
function Wg(t10, e3) {
  if (t10.eatSpace() || t10.eat(","))
    return ["space", null];
  if (t10.match(K6))
    return [null, "number"];
  if (t10.match(J6))
    return [null, "string.special"];
  if (t10.eat(/^"/))
    return (e3.tokenize = t9)(t10, e3);
  if (t10.eat(/^[(\[{]/))
    return ["open", "bracket"];
  if (t10.eat(/^[)\]}]/))
    return ["close", "bracket"];
  if (t10.eat(/^;/))
    return t10.skipToEnd(), ["space", "comment"];
  if (t10.eat(/^[#'@^`~]/))
    return [null, "meta"];
  var r3 = t10.match(e9), n3 = r3 && r3[0];
  return n3 ? n3 === "comment" && e3.lastToken === "(" ? (e3.tokenize = r9)(t10, e3) : ul(n3, L6) || n3.charAt(0) === ":" ? ["symbol", "atom"] : ul(n3, B6) || ul(n3, z6) ? ["symbol", "keyword"] : e3.lastToken === "(" ? ["symbol", "builtin"] : ["symbol", "variable"] : (t10.next(), t10.eatWhile(function(i3) {
    return !ul(i3, G6);
  }), [null, "error"]);
}
function t9(t10, e3) {
  for (var r3 = false, n3; n3 = t10.next(); ) {
    if (n3 === '"' && !r3) {
      e3.tokenize = Wg;
      break;
    }
    r3 = !r3 && n3 === "\\";
  }
  return [null, "string"];
}
function r9(t10, e3) {
  for (var r3 = 1, n3; n3 = t10.next(); )
    if (n3 === ")" && r3--, n3 === "(" && r3++, r3 === 0) {
      t10.backUp(1), e3.tokenize = Wg;
      break;
    }
  return ["space", "comment"];
}
function sd(t10) {
  for (var e3 = {}, r3 = 0; r3 < t10.length; ++r3)
    e3[t10[r3]] = true;
  return e3;
}
function ul(t10, e3) {
  if (e3 instanceof RegExp)
    return e3.test(t10);
  if (e3 instanceof Object)
    return e3.propertyIsEnumerable(t10);
}
const n9 = {
  name: "clojure",
  startState: function() {
    return {
      ctx: { prev: null, start: 0, indentTo: 0 },
      lastToken: null,
      tokenize: Wg
    };
  },
  token: function(t10, e3) {
    t10.sol() && typeof e3.ctx.indentTo != "number" && (e3.ctx.indentTo = e3.ctx.start + 1);
    var r3 = e3.tokenize(t10, e3), n3 = r3[0], i3 = r3[1], o3 = t10.current();
    return n3 !== "space" && (e3.lastToken === "(" && e3.ctx.indentTo === null ? n3 === "symbol" && ul(o3, H6) ? e3.ctx.indentTo = e3.ctx.start + t10.indentUnit : e3.ctx.indentTo = "next" : e3.ctx.indentTo === "next" && (e3.ctx.indentTo = t10.column()), e3.lastToken = o3), n3 === "open" ? e3.ctx = { prev: e3.ctx, start: t10.column(), indentTo: null } : n3 === "close" && (e3.ctx = e3.ctx.prev || e3.ctx), i3;
  },
  indent: function(t10) {
    var e3 = t10.ctx.indentTo;
    return typeof e3 == "number" ? e3 : t10.ctx.start + 1;
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", '"'] },
    commentTokens: { line: ";;" },
    autocomplete: [].concat(E_, C_, R_)
  }
};
var i9 = {
  break: true,
  case: true,
  chan: true,
  const: true,
  continue: true,
  default: true,
  defer: true,
  else: true,
  fallthrough: true,
  for: true,
  func: true,
  go: true,
  goto: true,
  if: true,
  import: true,
  interface: true,
  map: true,
  package: true,
  range: true,
  return: true,
  select: true,
  struct: true,
  switch: true,
  type: true,
  var: true,
  bool: true,
  byte: true,
  complex64: true,
  complex128: true,
  float32: true,
  float64: true,
  int8: true,
  int16: true,
  int32: true,
  int64: true,
  string: true,
  uint8: true,
  uint16: true,
  uint32: true,
  uint64: true,
  int: true,
  uint: true,
  uintptr: true,
  error: true,
  rune: true,
  any: true,
  comparable: true
}, o9 = {
  true: true,
  false: true,
  iota: true,
  nil: true,
  append: true,
  cap: true,
  close: true,
  complex: true,
  copy: true,
  delete: true,
  imag: true,
  len: true,
  make: true,
  new: true,
  panic: true,
  print: true,
  println: true,
  real: true,
  recover: true
}, Nv = /[+\-*&^%:=<>!|\/]/, gi;
function cf(t10, e3) {
  var r3 = t10.next();
  if (r3 == '"' || r3 == "'" || r3 == "`")
    return e3.tokenize = s9(r3), e3.tokenize(t10, e3);
  if (/[\d\.]/.test(r3))
    return r3 == "." ? t10.match(/^[0-9]+([eE][\-+]?[0-9]+)?/) : r3 == "0" ? t10.match(/^[xX][0-9a-fA-F]+/) || t10.match(/^0[0-7]+/) : t10.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/), "number";
  if (/[\[\]{}\(\),;\:\.]/.test(r3))
    return gi = r3, null;
  if (r3 == "/") {
    if (t10.eat("*"))
      return e3.tokenize = Wv, Wv(t10, e3);
    if (t10.eat("/"))
      return t10.skipToEnd(), "comment";
  }
  if (Nv.test(r3))
    return t10.eatWhile(Nv), "operator";
  t10.eatWhile(/[\w\$_\xa1-\uffff]/);
  var n3 = t10.current();
  return i9.propertyIsEnumerable(n3) ? ((n3 == "case" || n3 == "default") && (gi = "case"), "keyword") : o9.propertyIsEnumerable(n3) ? "atom" : "variable";
}
function s9(t10) {
  return function(e3, r3) {
    for (var n3 = false, i3, o3 = false; (i3 = e3.next()) != null; ) {
      if (i3 == t10 && !n3) {
        o3 = true;
        break;
      }
      n3 = !n3 && t10 != "`" && i3 == "\\";
    }
    return (o3 || !(n3 || t10 == "`")) && (r3.tokenize = cf), "string";
  };
}
function Wv(t10, e3) {
  for (var r3 = false, n3; n3 = t10.next(); ) {
    if (n3 == "/" && r3) {
      e3.tokenize = cf;
      break;
    }
    r3 = n3 == "*";
  }
  return "comment";
}
function A_(t10, e3, r3, n3, i3) {
  this.indented = t10, this.column = e3, this.type = r3, this.align = n3, this.prev = i3;
}
function Xh(t10, e3, r3) {
  return t10.context = new A_(t10.indented, e3, r3, null, t10.context);
}
function Vv(t10) {
  if (t10.context.prev) {
    var e3 = t10.context.type;
    return (e3 == ")" || e3 == "]" || e3 == "}") && (t10.indented = t10.context.indented), t10.context = t10.context.prev;
  }
}
const a9 = {
  name: "go",
  startState: function(t10) {
    return {
      tokenize: null,
      context: new A_(-t10, 0, "top", false),
      indented: 0,
      startOfLine: true
    };
  },
  token: function(t10, e3) {
    var r3 = e3.context;
    if (t10.sol() && (r3.align == null && (r3.align = false), e3.indented = t10.indentation(), e3.startOfLine = true, r3.type == "case" && (r3.type = "}")), t10.eatSpace())
      return null;
    gi = null;
    var n3 = (e3.tokenize || cf)(t10, e3);
    return n3 == "comment" || (r3.align == null && (r3.align = true), gi == "{" ? Xh(e3, t10.column(), "}") : gi == "[" ? Xh(e3, t10.column(), "]") : gi == "(" ? Xh(e3, t10.column(), ")") : gi == "case" ? r3.type = "case" : (gi == "}" && r3.type == "}" || gi == r3.type) && Vv(e3), e3.startOfLine = false), n3;
  },
  indent: function(t10, e3, r3) {
    if (t10.tokenize != cf && t10.tokenize != null)
      return null;
    var n3 = t10.context, i3 = e3 && e3.charAt(0);
    if (n3.type == "case" && /^(?:case|default)\b/.test(e3))
      return n3.indented;
    var o3 = i3 == n3.type;
    return n3.align ? n3.column + (o3 ? 0 : 1) : n3.indented + (o3 ? 0 : r3.unit);
  },
  languageData: {
    indentOnInput: /^\s([{}]|case |default\s*:)$/,
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } }
  }
};
function Vg(t10, e3) {
  return t10.skipToEnd(), e3.cur = ad, "error";
}
function l9(t10, e3) {
  return t10.match(/^HTTP\/\d\.\d/) ? (e3.cur = u9, "keyword") : t10.match(/^[A-Z]+/) && /[ \t]/.test(t10.peek()) ? (e3.cur = f9, "keyword") : Vg(t10, e3);
}
function u9(t10, e3) {
  var r3 = t10.match(/^\d+/);
  if (!r3)
    return Vg(t10, e3);
  e3.cur = c9;
  var n3 = Number(r3[0]);
  return n3 >= 100 && n3 < 400 ? "atom" : "error";
}
function c9(t10, e3) {
  return t10.skipToEnd(), e3.cur = ad, null;
}
function f9(t10, e3) {
  return t10.eatWhile(/\S/), e3.cur = d9, "string.special";
}
function d9(t10, e3) {
  return t10.match(/^HTTP\/\d\.\d$/) ? (e3.cur = ad, "keyword") : Vg(t10, e3);
}
function ad(t10) {
  return t10.sol() && !t10.eat(/[ \t]/) ? t10.match(/^.*?:/) ? "atom" : (t10.skipToEnd(), "error") : (t10.skipToEnd(), "string");
}
function Yv(t10) {
  return t10.skipToEnd(), null;
}
const h9 = {
  name: "http",
  token: function(t10, e3) {
    var r3 = e3.cur;
    return r3 != ad && r3 != Yv && t10.eatSpace() ? null : r3(t10, e3);
  },
  blankLine: function(t10) {
    t10.cur = Yv;
  },
  startState: function() {
    return { cur: l9 };
  }
};
function Yg(t10) {
  var e3 = {
    as: "keyword",
    do: "keyword",
    else: "keyword",
    end: "keyword",
    exception: "keyword",
    fun: "keyword",
    functor: "keyword",
    if: "keyword",
    in: "keyword",
    include: "keyword",
    let: "keyword",
    of: "keyword",
    open: "keyword",
    rec: "keyword",
    struct: "keyword",
    then: "keyword",
    type: "keyword",
    val: "keyword",
    while: "keyword",
    with: "keyword"
  }, r3 = t10.extraWords || {};
  for (var n3 in r3)
    r3.hasOwnProperty(n3) && (e3[n3] = t10.extraWords[n3]);
  var i3 = [];
  for (var o3 in e3)
    i3.push(o3);
  function s3(c3, f3) {
    var d3 = c3.next();
    if (d3 === '"')
      return f3.tokenize = a3, f3.tokenize(c3, f3);
    if (d3 === "{" && c3.eat("|"))
      return f3.longString = true, f3.tokenize = u3, f3.tokenize(c3, f3);
    if (d3 === "(" && c3.match(/^\*(?!\))/))
      return f3.commentLevel++, f3.tokenize = l3, f3.tokenize(c3, f3);
    if (d3 === "~" || d3 === "?")
      return c3.eatWhile(/\w/), "variableName.special";
    if (d3 === "`")
      return c3.eatWhile(/\w/), "quote";
    if (d3 === "/" && t10.slashComments && c3.eat("/"))
      return c3.skipToEnd(), "comment";
    if (/\d/.test(d3))
      return d3 === "0" && c3.eat(/[bB]/) && c3.eatWhile(/[01]/), d3 === "0" && c3.eat(/[xX]/) && c3.eatWhile(/[0-9a-fA-F]/), d3 === "0" && c3.eat(/[oO]/) ? c3.eatWhile(/[0-7]/) : (c3.eatWhile(/[\d_]/), c3.eat(".") && c3.eatWhile(/[\d]/), c3.eat(/[eE]/) && c3.eatWhile(/[\d\-+]/)), "number";
    if (/[+\-*&%=<>!?|@\.~:]/.test(d3))
      return "operator";
    if (/[\w\xa1-\uffff]/.test(d3)) {
      c3.eatWhile(/[\w\xa1-\uffff]/);
      var p10 = c3.current();
      return e3.hasOwnProperty(p10) ? e3[p10] : "variable";
    }
    return null;
  }
  function a3(c3, f3) {
    for (var d3, p10 = false, h10 = false; (d3 = c3.next()) != null; ) {
      if (d3 === '"' && !h10) {
        p10 = true;
        break;
      }
      h10 = !h10 && d3 === "\\";
    }
    return p10 && !h10 && (f3.tokenize = s3), "string";
  }
  function l3(c3, f3) {
    for (var d3, p10; f3.commentLevel > 0 && (p10 = c3.next()) != null; )
      d3 === "(" && p10 === "*" && f3.commentLevel++, d3 === "*" && p10 === ")" && f3.commentLevel--, d3 = p10;
    return f3.commentLevel <= 0 && (f3.tokenize = s3), "comment";
  }
  function u3(c3, f3) {
    for (var d3, p10; f3.longString && (p10 = c3.next()) != null; )
      d3 === "|" && p10 === "}" && (f3.longString = false), d3 = p10;
    return f3.longString || (f3.tokenize = s3), "string";
  }
  return {
    startState: function() {
      return { tokenize: s3, commentLevel: 0, longString: false };
    },
    token: function(c3, f3) {
      return c3.eatSpace() ? null : f3.tokenize(c3, f3);
    },
    languageData: {
      autocomplete: i3,
      commentTokens: {
        line: t10.slashComments ? "//" : void 0,
        block: { open: "(*", close: "*)" }
      }
    }
  };
}
const p9 = Yg({
  name: "ocaml",
  extraWords: {
    and: "keyword",
    assert: "keyword",
    begin: "keyword",
    class: "keyword",
    constraint: "keyword",
    done: "keyword",
    downto: "keyword",
    external: "keyword",
    function: "keyword",
    initializer: "keyword",
    lazy: "keyword",
    match: "keyword",
    method: "keyword",
    module: "keyword",
    mutable: "keyword",
    new: "keyword",
    nonrec: "keyword",
    object: "keyword",
    private: "keyword",
    sig: "keyword",
    to: "keyword",
    try: "keyword",
    value: "keyword",
    virtual: "keyword",
    when: "keyword",
    // builtins
    raise: "builtin",
    failwith: "builtin",
    true: "builtin",
    false: "builtin",
    // Pervasives builtins
    asr: "builtin",
    land: "builtin",
    lor: "builtin",
    lsl: "builtin",
    lsr: "builtin",
    lxor: "builtin",
    mod: "builtin",
    or: "builtin",
    // More Pervasives
    raise_notrace: "builtin",
    trace: "builtin",
    exit: "builtin",
    print_string: "builtin",
    print_endline: "builtin",
    int: "type",
    float: "type",
    bool: "type",
    char: "type",
    string: "type",
    unit: "type",
    // Modules
    List: "builtin"
  }
});
Yg({
  name: "fsharp",
  extraWords: {
    abstract: "keyword",
    assert: "keyword",
    base: "keyword",
    begin: "keyword",
    class: "keyword",
    default: "keyword",
    delegate: "keyword",
    "do!": "keyword",
    done: "keyword",
    downcast: "keyword",
    downto: "keyword",
    elif: "keyword",
    extern: "keyword",
    finally: "keyword",
    for: "keyword",
    function: "keyword",
    global: "keyword",
    inherit: "keyword",
    inline: "keyword",
    interface: "keyword",
    internal: "keyword",
    lazy: "keyword",
    "let!": "keyword",
    match: "keyword",
    member: "keyword",
    module: "keyword",
    mutable: "keyword",
    namespace: "keyword",
    new: "keyword",
    null: "keyword",
    override: "keyword",
    private: "keyword",
    public: "keyword",
    "return!": "keyword",
    return: "keyword",
    select: "keyword",
    static: "keyword",
    to: "keyword",
    try: "keyword",
    upcast: "keyword",
    "use!": "keyword",
    use: "keyword",
    void: "keyword",
    when: "keyword",
    "yield!": "keyword",
    yield: "keyword",
    // Reserved words
    atomic: "keyword",
    break: "keyword",
    checked: "keyword",
    component: "keyword",
    const: "keyword",
    constraint: "keyword",
    constructor: "keyword",
    continue: "keyword",
    eager: "keyword",
    event: "keyword",
    external: "keyword",
    fixed: "keyword",
    method: "keyword",
    mixin: "keyword",
    object: "keyword",
    parallel: "keyword",
    process: "keyword",
    protected: "keyword",
    pure: "keyword",
    sealed: "keyword",
    tailcall: "keyword",
    trait: "keyword",
    virtual: "keyword",
    volatile: "keyword",
    // builtins
    List: "builtin",
    Seq: "builtin",
    Map: "builtin",
    Set: "builtin",
    Option: "builtin",
    int: "builtin",
    string: "builtin",
    not: "builtin",
    true: "builtin",
    false: "builtin",
    raise: "builtin",
    failwith: "builtin"
  },
  slashComments: true
});
Yg({
  name: "sml",
  extraWords: {
    abstype: "keyword",
    and: "keyword",
    andalso: "keyword",
    case: "keyword",
    datatype: "keyword",
    fn: "keyword",
    handle: "keyword",
    infix: "keyword",
    infixr: "keyword",
    local: "keyword",
    nonfix: "keyword",
    op: "keyword",
    orelse: "keyword",
    raise: "keyword",
    withtype: "keyword",
    eqtype: "keyword",
    sharing: "keyword",
    sig: "keyword",
    signature: "keyword",
    structure: "keyword",
    where: "keyword",
    true: "keyword",
    false: "keyword",
    // types
    int: "builtin",
    real: "builtin",
    string: "builtin",
    char: "builtin",
    bool: "builtin"
  },
  slashComments: true
});
function ka(t10, e3) {
  e3 = e3 || {};
  for (var r3 = e3.prefix !== void 0 ? e3.prefix : "^", n3 = e3.suffix !== void 0 ? e3.suffix : "\\b", i3 = 0; i3 < t10.length; i3++)
    t10[i3] instanceof RegExp ? t10[i3] = t10[i3].source : t10[i3] = t10[i3].replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  return new RegExp(r3 + "(" + t10.join("|") + ")" + n3, "i");
}
var X_ = "(?=[^A-Za-z\\d\\-_]|$)", wO = /[\w\-:]/, O9 = ka([
  /begin|break|catch|continue|data|default|do|dynamicparam/,
  /else|elseif|end|exit|filter|finally|for|foreach|from|function|if|in/,
  /param|process|return|switch|throw|trap|try|until|where|while/
], { suffix: X_ }), m9 = /[\[\]{},;`\\\.]|@[({]/, g9 = ka([
  "f",
  /b?not/,
  /[ic]?split/,
  "join",
  /is(not)?/,
  "as",
  /[ic]?(eq|ne|[gl][te])/,
  /[ic]?(not)?(like|match|contains)/,
  /[ic]?replace/,
  /b?(and|or|xor)/
], { prefix: "-" }), y9 = /[+\-*\/%]=|\+\+|--|\.\.|[+\-*&^%:=!|\/]|<(?!#)|(?!#)>/, v9 = ka([g9, y9], { suffix: "" }), b9 = /^((0x[\da-f]+)|((\d+\.\d+|\d\.|\.\d+|\d+)(e[\+\-]?\d+)?))[ld]?([kmgtp]b)?/i, S9 = /^[A-Za-z\_][A-Za-z\-\_\d]*\b/, $9 = /[A-Z]:|%|\?/i, w9 = ka([
  /Add-(Computer|Content|History|Member|PSSnapin|Type)/,
  /Checkpoint-Computer/,
  /Clear-(Content|EventLog|History|Host|Item(Property)?|Variable)/,
  /Compare-Object/,
  /Complete-Transaction/,
  /Connect-PSSession/,
  /ConvertFrom-(Csv|Json|SecureString|StringData)/,
  /Convert-Path/,
  /ConvertTo-(Csv|Html|Json|SecureString|Xml)/,
  /Copy-Item(Property)?/,
  /Debug-Process/,
  /Disable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)/,
  /Disconnect-PSSession/,
  /Enable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)/,
  /(Enter|Exit)-PSSession/,
  /Export-(Alias|Clixml|Console|Counter|Csv|FormatData|ModuleMember|PSSession)/,
  /ForEach-Object/,
  /Format-(Custom|List|Table|Wide)/,
  new RegExp("Get-(Acl|Alias|AuthenticodeSignature|ChildItem|Command|ComputerRestorePoint|Content|ControlPanelItem|Counter|Credential|Culture|Date|Event|EventLog|EventSubscriber|ExecutionPolicy|FormatData|Help|History|Host|HotFix|Item|ItemProperty|Job|Location|Member|Module|PfxCertificate|Process|PSBreakpoint|PSCallStack|PSDrive|PSProvider|PSSession|PSSessionConfiguration|PSSnapin|Random|Service|TraceSource|Transaction|TypeData|UICulture|Unique|Variable|Verb|WinEvent|WmiObject)"),
  /Group-Object/,
  /Import-(Alias|Clixml|Counter|Csv|LocalizedData|Module|PSSession)/,
  /ImportSystemModules/,
  /Invoke-(Command|Expression|History|Item|RestMethod|WebRequest|WmiMethod)/,
  /Join-Path/,
  /Limit-EventLog/,
  /Measure-(Command|Object)/,
  /Move-Item(Property)?/,
  new RegExp("New-(Alias|Event|EventLog|Item(Property)?|Module|ModuleManifest|Object|PSDrive|PSSession|PSSessionConfigurationFile|PSSessionOption|PSTransportOption|Service|TimeSpan|Variable|WebServiceProxy|WinEvent)"),
  /Out-(Default|File|GridView|Host|Null|Printer|String)/,
  /Pause/,
  /(Pop|Push)-Location/,
  /Read-Host/,
  /Receive-(Job|PSSession)/,
  /Register-(EngineEvent|ObjectEvent|PSSessionConfiguration|WmiEvent)/,
  /Remove-(Computer|Event|EventLog|Item(Property)?|Job|Module|PSBreakpoint|PSDrive|PSSession|PSSnapin|TypeData|Variable|WmiObject)/,
  /Rename-(Computer|Item(Property)?)/,
  /Reset-ComputerMachinePassword/,
  /Resolve-Path/,
  /Restart-(Computer|Service)/,
  /Restore-Computer/,
  /Resume-(Job|Service)/,
  /Save-Help/,
  /Select-(Object|String|Xml)/,
  /Send-MailMessage/,
  new RegExp("Set-(Acl|Alias|AuthenticodeSignature|Content|Date|ExecutionPolicy|Item(Property)?|Location|PSBreakpoint|PSDebug|PSSessionConfiguration|Service|StrictMode|TraceSource|Variable|WmiInstance)"),
  /Show-(Command|ControlPanelItem|EventLog)/,
  /Sort-Object/,
  /Split-Path/,
  /Start-(Job|Process|Service|Sleep|Transaction|Transcript)/,
  /Stop-(Computer|Job|Process|Service|Transcript)/,
  /Suspend-(Job|Service)/,
  /TabExpansion2/,
  /Tee-Object/,
  /Test-(ComputerSecureChannel|Connection|ModuleManifest|Path|PSSessionConfigurationFile)/,
  /Trace-Command/,
  /Unblock-File/,
  /Undo-Transaction/,
  /Unregister-(Event|PSSessionConfiguration)/,
  /Update-(FormatData|Help|List|TypeData)/,
  /Use-Transaction/,
  /Wait-(Event|Job|Process)/,
  /Where-Object/,
  /Write-(Debug|Error|EventLog|Host|Output|Progress|Verbose|Warning)/,
  /cd|help|mkdir|more|oss|prompt/,
  /ac|asnp|cat|cd|chdir|clc|clear|clhy|cli|clp|cls|clv|cnsn|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|dnsn|ebp/,
  /echo|epal|epcsv|epsn|erase|etsn|exsn|fc|fl|foreach|ft|fw|gal|gbp|gc|gci|gcm|gcs|gdr|ghy|gi|gjb|gl|gm|gmo|gp|gps/,
  /group|gsn|gsnp|gsv|gu|gv|gwmi|h|history|icm|iex|ihy|ii|ipal|ipcsv|ipmo|ipsn|irm|ise|iwmi|iwr|kill|lp|ls|man|md/,
  /measure|mi|mount|move|mp|mv|nal|ndr|ni|nmo|npssc|nsn|nv|ogv|oh|popd|ps|pushd|pwd|r|rbp|rcjb|rcsn|rd|rdr|ren|ri/,
  /rjb|rm|rmdir|rmo|rni|rnp|rp|rsn|rsnp|rujb|rv|rvpa|rwmi|sajb|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls/,
  /sort|sp|spjb|spps|spsv|start|sujb|sv|swmi|tee|trcm|type|where|wjb|write/
], { prefix: "", suffix: "" }), P9 = ka([
  /[$?^_]|Args|ConfirmPreference|ConsoleFileName|DebugPreference|Error|ErrorActionPreference|ErrorView|ExecutionContext/,
  /FormatEnumerationLimit|Home|Host|Input|MaximumAliasCount|MaximumDriveCount|MaximumErrorCount|MaximumFunctionCount/,
  /MaximumHistoryCount|MaximumVariableCount|MyInvocation|NestedPromptLevel|OutputEncoding|Pid|Profile|ProgressPreference/,
  /PSBoundParameters|PSCommandPath|PSCulture|PSDefaultParameterValues|PSEmailServer|PSHome|PSScriptRoot|PSSessionApplicationName/,
  /PSSessionConfigurationName|PSSessionOption|PSUICulture|PSVersionTable|Pwd|ShellId|StackTrace|VerbosePreference/,
  /WarningPreference|WhatIfPreference/,
  /Event|EventArgs|EventSubscriber|Sender/,
  /Matches|Ofs|ForEach|LastExitCode|PSCmdlet|PSItem|PSSenderInfo|This/,
  /true|false|null/
], { prefix: "\\$", suffix: "" }), _9 = ka([$9, w9, P9], { suffix: X_ }), Lv = {
  keyword: O9,
  number: b9,
  operator: v9,
  builtin: _9,
  punctuation: m9,
  variable: S9
};
function Di(t10, e3) {
  var r3 = e3.returnStack[e3.returnStack.length - 1];
  if (r3 && r3.shouldReturnFrom(e3))
    return e3.tokenize = r3.tokenize, e3.returnStack.pop(), e3.tokenize(t10, e3);
  if (t10.eatSpace())
    return null;
  if (t10.eat("("))
    return e3.bracketNesting += 1, "punctuation";
  if (t10.eat(")"))
    return e3.bracketNesting -= 1, "punctuation";
  for (var n3 in Lv)
    if (t10.match(Lv[n3]))
      return n3;
  var i3 = t10.next();
  if (i3 === "'")
    return x9(t10, e3);
  if (i3 === "$")
    return PO(t10, e3);
  if (i3 === '"')
    return q_(t10, e3);
  if (i3 === "<" && t10.eat("#"))
    return e3.tokenize = Bv, Bv(t10, e3);
  if (i3 === "#")
    return t10.skipToEnd(), "comment";
  if (i3 === "@") {
    var o3 = t10.eat(/["']/);
    if (o3 && t10.eol())
      return e3.tokenize = ff, e3.startQuote = o3[0], ff(t10, e3);
    if (t10.eol())
      return "error";
    if (t10.peek().match(/[({]/))
      return "punctuation";
    if (t10.peek().match(wO))
      return PO(t10, e3);
  }
  return "error";
}
function x9(t10, e3) {
  for (var r3; (r3 = t10.peek()) != null; )
    if (t10.next(), r3 === "'" && !t10.eat("'"))
      return e3.tokenize = Di, "string";
  return "error";
}
function q_(t10, e3) {
  for (var r3; (r3 = t10.peek()) != null; ) {
    if (r3 === "$")
      return e3.tokenize = Q9, "string";
    if (t10.next(), r3 === "`") {
      t10.next();
      continue;
    }
    if (r3 === '"' && !t10.eat('"'))
      return e3.tokenize = Di, "string";
  }
  return "error";
}
function Q9(t10, e3) {
  return D_(t10, e3, q_);
}
function T9(t10, e3) {
  return e3.tokenize = ff, e3.startQuote = '"', ff(t10, e3);
}
function k9(t10, e3) {
  return D_(t10, e3, T9);
}
function D_(t10, e3, r3) {
  if (t10.match("$(")) {
    var n3 = e3.bracketNesting;
    return e3.returnStack.push({
      /*jshint loopfunc:true */
      shouldReturnFrom: function(i3) {
        return i3.bracketNesting === n3;
      },
      tokenize: r3
    }), e3.tokenize = Di, e3.bracketNesting += 1, "punctuation";
  } else
    return t10.next(), e3.returnStack.push({
      shouldReturnFrom: function() {
        return true;
      },
      tokenize: r3
    }), e3.tokenize = PO, e3.tokenize(t10, e3);
}
function Bv(t10, e3) {
  for (var r3 = false, n3; (n3 = t10.next()) != null; ) {
    if (r3 && n3 == ">") {
      e3.tokenize = Di;
      break;
    }
    r3 = n3 === "#";
  }
  return "comment";
}
function PO(t10, e3) {
  var r3 = t10.peek();
  return t10.eat("{") ? (e3.tokenize = zv, zv(t10, e3)) : r3 != null && r3.match(wO) ? (t10.eatWhile(wO), e3.tokenize = Di, "variable") : (e3.tokenize = Di, "error");
}
function zv(t10, e3) {
  for (var r3; (r3 = t10.next()) != null; )
    if (r3 === "}") {
      e3.tokenize = Di;
      break;
    }
  return "variable";
}
function ff(t10, e3) {
  var r3 = e3.startQuote;
  if (t10.sol() && t10.match(new RegExp(r3 + "@")))
    e3.tokenize = Di;
  else if (r3 === '"')
    for (; !t10.eol(); ) {
      var n3 = t10.peek();
      if (n3 === "$")
        return e3.tokenize = k9, "string";
      t10.next(), n3 === "`" && t10.next();
    }
  else
    t10.skipToEnd();
  return "string";
}
const E9 = {
  name: "powershell",
  startState: function() {
    return {
      returnStack: [],
      bracketNesting: 0,
      tokenize: Di
    };
  },
  token: function(t10, e3) {
    return e3.tokenize(t10, e3);
  },
  languageData: {
    commentTokens: { line: "#", block: { open: "<#", close: "#>" } }
  }
};
function ld(t10) {
  for (var e3 = {}, r3 = 0; r3 < t10.length; ++r3)
    e3[t10[r3]] = true;
  return e3;
}
var j_ = ["NULL", "NA", "Inf", "NaN", "NA_integer_", "NA_real_", "NA_complex_", "NA_character_", "TRUE", "FALSE"], U_ = ["list", "quote", "bquote", "eval", "return", "call", "parse", "deparse"], I_ = ["if", "else", "repeat", "while", "function", "for", "in", "next", "break"], C9 = ["if", "else", "repeat", "while", "function", "for"], R9 = ld(j_), A9 = ld(U_), X9 = ld(I_), q9 = ld(C9), Hv = /[+\-*\/^<>=!&|~$:]/, $n;
function _O(t10, e3) {
  $n = null;
  var r3 = t10.next();
  if (r3 == "#")
    return t10.skipToEnd(), "comment";
  if (r3 == "0" && t10.eat("x"))
    return t10.eatWhile(/[\da-f]/i), "number";
  if (r3 == "." && t10.eat(/\d/))
    return t10.match(/\d*(?:e[+\-]?\d+)?/), "number";
  if (/\d/.test(r3))
    return t10.match(/\d*(?:\.\d+)?(?:e[+\-]\d+)?L?/), "number";
  if (r3 == "'" || r3 == '"')
    return e3.tokenize = D9(r3), "string";
  if (r3 == "`")
    return t10.match(/[^`]+`/), "string.special";
  if (r3 == "." && t10.match(/.(?:[.]|\d+)/))
    return "keyword";
  if (/[a-zA-Z\.]/.test(r3)) {
    t10.eatWhile(/[\w\.]/);
    var n3 = t10.current();
    return R9.propertyIsEnumerable(n3) ? "atom" : X9.propertyIsEnumerable(n3) ? (q9.propertyIsEnumerable(n3) && !t10.match(/\s*if(\s+|$)/, false) && ($n = "block"), "keyword") : A9.propertyIsEnumerable(n3) ? "builtin" : "variable";
  } else
    return r3 == "%" ? (t10.skipTo("%") && t10.next(), "variableName.special") : r3 == "<" && t10.eat("-") || r3 == "<" && t10.match("<-") || r3 == "-" && t10.match(/>>?/) || r3 == "=" && e3.ctx.argList ? "operator" : Hv.test(r3) ? (r3 == "$" || t10.eatWhile(Hv), "operator") : /[\(\){}\[\];]/.test(r3) ? ($n = r3, r3 == ";" ? "punctuation" : null) : null;
}
function D9(t10) {
  return function(e3, r3) {
    if (e3.eat("\\")) {
      var n3 = e3.next();
      return n3 == "x" ? e3.match(/^[a-f0-9]{2}/i) : (n3 == "u" || n3 == "U") && e3.eat("{") && e3.skipTo("}") ? e3.next() : n3 == "u" ? e3.match(/^[a-f0-9]{4}/i) : n3 == "U" ? e3.match(/^[a-f0-9]{8}/i) : /[0-7]/.test(n3) && e3.match(/^[0-7]{1,2}/), "string.special";
    } else {
      for (var i3; (i3 = e3.next()) != null; ) {
        if (i3 == t10) {
          r3.tokenize = _O;
          break;
        }
        if (i3 == "\\") {
          e3.backUp(1);
          break;
        }
      }
      return "string";
    }
  };
}
var Gv = 1, qh = 2, Dh = 4;
function ec(t10, e3, r3) {
  t10.ctx = {
    type: e3,
    indent: t10.indent,
    flags: 0,
    column: r3.column(),
    prev: t10.ctx
  };
}
function Kv(t10, e3) {
  var r3 = t10.ctx;
  t10.ctx = {
    type: r3.type,
    indent: r3.indent,
    flags: r3.flags | e3,
    column: r3.column,
    prev: r3.prev
  };
}
function jh(t10) {
  t10.indent = t10.ctx.indent, t10.ctx = t10.ctx.prev;
}
const j9 = {
  name: "r",
  startState: function(t10) {
    return {
      tokenize: _O,
      ctx: {
        type: "top",
        indent: -t10,
        flags: qh
      },
      indent: 0,
      afterIdent: false
    };
  },
  token: function(t10, e3) {
    if (t10.sol() && (e3.ctx.flags & 3 || (e3.ctx.flags |= qh), e3.ctx.flags & Dh && jh(e3), e3.indent = t10.indentation()), t10.eatSpace())
      return null;
    var r3 = e3.tokenize(t10, e3);
    return r3 != "comment" && !(e3.ctx.flags & qh) && Kv(e3, Gv), ($n == ";" || $n == "{" || $n == "}") && e3.ctx.type == "block" && jh(e3), $n == "{" ? ec(e3, "}", t10) : $n == "(" ? (ec(e3, ")", t10), e3.afterIdent && (e3.ctx.argList = true)) : $n == "[" ? ec(e3, "]", t10) : $n == "block" ? ec(e3, "block", t10) : $n == e3.ctx.type ? jh(e3) : e3.ctx.type == "block" && r3 != "comment" && Kv(e3, Dh), e3.afterIdent = r3 == "variable" || r3 == "keyword", r3;
  },
  indent: function(t10, e3, r3) {
    if (t10.tokenize != _O)
      return 0;
    var n3 = e3 && e3.charAt(0), i3 = t10.ctx, o3 = n3 == i3.type;
    return i3.flags & Dh && (i3 = i3.prev), i3.type == "block" ? i3.indent + (n3 == "{" ? 0 : r3.unit) : i3.flags & Gv ? i3.column + (o3 ? 0 : 1) : i3.indent + (o3 ? 0 : r3.unit);
  },
  languageData: {
    wordChars: ".",
    commentTokens: { line: "#" },
    autocomplete: j_.concat(U_, I_)
  }
};
function Lg(t10) {
  for (var e3 = {}, r3 = 0, n3 = t10.length; r3 < n3; ++r3)
    e3[t10[r3]] = true;
  return e3;
}
var F_ = [
  "alias",
  "and",
  "BEGIN",
  "begin",
  "break",
  "case",
  "class",
  "def",
  "defined?",
  "do",
  "else",
  "elsif",
  "END",
  "end",
  "ensure",
  "false",
  "for",
  "if",
  "in",
  "module",
  "next",
  "not",
  "or",
  "redo",
  "rescue",
  "retry",
  "return",
  "self",
  "super",
  "then",
  "true",
  "undef",
  "unless",
  "until",
  "when",
  "while",
  "yield",
  "nil",
  "raise",
  "throw",
  "catch",
  "fail",
  "loop",
  "callcc",
  "caller",
  "lambda",
  "proc",
  "public",
  "protected",
  "private",
  "require",
  "load",
  "require_relative",
  "extend",
  "autoload",
  "__END__",
  "__FILE__",
  "__LINE__",
  "__dir__"
], U9 = Lg(F_), I9 = Lg([
  "def",
  "class",
  "case",
  "for",
  "while",
  "until",
  "module",
  "catch",
  "loop",
  "proc",
  "begin"
]), F9 = Lg(["end", "until"]), Jv = { "[": "]", "{": "}", "(": ")" }, Z9 = { "]": "[", "}": "{", ")": "(" }, wn;
function Ps(t10, e3, r3) {
  return r3.tokenize.push(t10), t10(e3, r3);
}
function df(t10, e3) {
  if (t10.sol() && t10.match("=begin") && t10.eol())
    return e3.tokenize.push(V9), "comment";
  if (t10.eatSpace())
    return null;
  var r3 = t10.next(), n3;
  if (r3 == "`" || r3 == "'" || r3 == '"')
    return Ps(Ha(r3, "string", r3 == '"' || r3 == "`"), t10, e3);
  if (r3 == "/")
    return M9(t10) ? Ps(Ha(r3, "string.special", true), t10, e3) : "operator";
  if (r3 == "%") {
    var i3 = "string", o3 = true;
    t10.eat("s") ? i3 = "atom" : t10.eat(/[WQ]/) ? i3 = "string" : t10.eat(/[r]/) ? i3 = "string.special" : t10.eat(/[wxq]/) && (i3 = "string", o3 = false);
    var s3 = t10.eat(/[^\w\s=]/);
    return s3 ? (Jv.propertyIsEnumerable(s3) && (s3 = Jv[s3]), Ps(Ha(s3, i3, o3, true), t10, e3)) : "operator";
  } else {
    if (r3 == "#")
      return t10.skipToEnd(), "comment";
    if (r3 == "<" && (n3 = t10.match(/^<([-~])[\`\"\']?([a-zA-Z_?]\w*)[\`\"\']?(?:;|$)/)))
      return Ps(W9(n3[2], n3[1]), t10, e3);
    if (r3 == "0")
      return t10.eat("x") ? t10.eatWhile(/[\da-fA-F]/) : t10.eat("b") ? t10.eatWhile(/[01]/) : t10.eatWhile(/[0-7]/), "number";
    if (/\d/.test(r3))
      return t10.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+\-]?[\d_]+)?/), "number";
    if (r3 == "?") {
      for (; t10.match(/^\\[CM]-/); )
        ;
      return t10.eat("\\") ? t10.eatWhile(/\w/) : t10.next(), "string";
    } else {
      if (r3 == ":")
        return t10.eat("'") ? Ps(Ha("'", "atom", false), t10, e3) : t10.eat('"') ? Ps(Ha('"', "atom", true), t10, e3) : t10.eat(/[\<\>]/) ? (t10.eat(/[\<\>]/), "atom") : t10.eat(/[\+\-\*\/\&\|\:\!]/) ? "atom" : t10.eat(/[a-zA-Z$@_\xa1-\uffff]/) ? (t10.eatWhile(/[\w$\xa1-\uffff]/), t10.eat(/[\?\!\=]/), "atom") : "operator";
      if (r3 == "@" && t10.match(/^@?[a-zA-Z_\xa1-\uffff]/))
        return t10.eat("@"), t10.eatWhile(/[\w\xa1-\uffff]/), "propertyName";
      if (r3 == "$")
        return t10.eat(/[a-zA-Z_]/) ? t10.eatWhile(/[\w]/) : t10.eat(/\d/) ? t10.eat(/\d/) : t10.next(), "variableName.special";
      if (/[a-zA-Z_\xa1-\uffff]/.test(r3))
        return t10.eatWhile(/[\w\xa1-\uffff]/), t10.eat(/[\?\!]/), t10.eat(":") ? "atom" : "variable";
      if (r3 == "|" && (e3.varList || e3.lastTok == "{" || e3.lastTok == "do"))
        return wn = "|", null;
      if (/[\(\)\[\]{}\\;]/.test(r3))
        return wn = r3, null;
      if (r3 == "-" && t10.eat(">"))
        return "operator";
      if (/[=+\-\/*:\.^%<>~|]/.test(r3)) {
        var a3 = t10.eatWhile(/[=+\-\/*:\.^%<>~|]/);
        return r3 == "." && !a3 && (wn = "."), "operator";
      } else
        return null;
    }
  }
}
function M9(t10) {
  for (var e3 = t10.pos, r3 = 0, n3, i3 = false, o3 = false; (n3 = t10.next()) != null; )
    if (o3)
      o3 = false;
    else {
      if ("[{(".indexOf(n3) > -1)
        r3++;
      else if ("]})".indexOf(n3) > -1) {
        if (r3--, r3 < 0)
          break;
      } else if (n3 == "/" && r3 == 0) {
        i3 = true;
        break;
      }
      o3 = n3 == "\\";
    }
  return t10.backUp(t10.pos - e3), i3;
}
function xO(t10) {
  return t10 || (t10 = 1), function(e3, r3) {
    if (e3.peek() == "}") {
      if (t10 == 1)
        return r3.tokenize.pop(), r3.tokenize[r3.tokenize.length - 1](e3, r3);
      r3.tokenize[r3.tokenize.length - 1] = xO(t10 - 1);
    } else
      e3.peek() == "{" && (r3.tokenize[r3.tokenize.length - 1] = xO(t10 + 1));
    return df(e3, r3);
  };
}
function N9() {
  var t10 = false;
  return function(e3, r3) {
    return t10 ? (r3.tokenize.pop(), r3.tokenize[r3.tokenize.length - 1](e3, r3)) : (t10 = true, df(e3, r3));
  };
}
function Ha(t10, e3, r3, n3) {
  return function(i3, o3) {
    var s3 = false, a3;
    for (o3.context.type === "read-quoted-paused" && (o3.context = o3.context.prev, i3.eat("}")); (a3 = i3.next()) != null; ) {
      if (a3 == t10 && (n3 || !s3)) {
        o3.tokenize.pop();
        break;
      }
      if (r3 && a3 == "#" && !s3) {
        if (i3.eat("{")) {
          t10 == "}" && (o3.context = { prev: o3.context, type: "read-quoted-paused" }), o3.tokenize.push(xO());
          break;
        } else if (/[@\$]/.test(i3.peek())) {
          o3.tokenize.push(N9());
          break;
        }
      }
      s3 = !s3 && a3 == "\\";
    }
    return e3;
  };
}
function W9(t10, e3) {
  return function(r3, n3) {
    return e3 && r3.eatSpace(), r3.match(t10) ? n3.tokenize.pop() : r3.skipToEnd(), "string";
  };
}
function V9(t10, e3) {
  return t10.sol() && t10.match("=end") && t10.eol() && e3.tokenize.pop(), t10.skipToEnd(), "comment";
}
const Y9 = {
  name: "ruby",
  startState: function(t10) {
    return {
      tokenize: [df],
      indented: 0,
      context: { type: "top", indented: -t10 },
      continuedLine: false,
      lastTok: null,
      varList: false
    };
  },
  token: function(t10, e3) {
    wn = null, t10.sol() && (e3.indented = t10.indentation());
    var r3 = e3.tokenize[e3.tokenize.length - 1](t10, e3), n3, i3 = wn;
    if (r3 == "variable") {
      var o3 = t10.current();
      r3 = e3.lastTok == "." ? "property" : U9.propertyIsEnumerable(t10.current()) ? "keyword" : /^[A-Z]/.test(o3) ? "tag" : e3.lastTok == "def" || e3.lastTok == "class" || e3.varList ? "def" : "variable", r3 == "keyword" && (i3 = o3, I9.propertyIsEnumerable(o3) ? n3 = "indent" : F9.propertyIsEnumerable(o3) ? n3 = "dedent" : ((o3 == "if" || o3 == "unless") && t10.column() == t10.indentation() || o3 == "do" && e3.context.indented < e3.indented) && (n3 = "indent"));
    }
    return (wn || r3 && r3 != "comment") && (e3.lastTok = i3), wn == "|" && (e3.varList = !e3.varList), n3 == "indent" || /[\(\[\{]/.test(wn) ? e3.context = { prev: e3.context, type: wn || r3, indented: e3.indented } : (n3 == "dedent" || /[\)\]\}]/.test(wn)) && e3.context.prev && (e3.context = e3.context.prev), t10.eol() && (e3.continuedLine = wn == "\\" || r3 == "operator"), r3;
  },
  indent: function(t10, e3, r3) {
    if (t10.tokenize[t10.tokenize.length - 1] != df)
      return null;
    var n3 = e3 && e3.charAt(0), i3 = t10.context, o3 = i3.type == Z9[n3] || i3.type == "keyword" && /^(?:end|until|else|elsif|when|rescue)\b/.test(e3);
    return i3.indented + (o3 ? 0 : r3.unit) + (t10.continuedLine ? r3.unit : 0);
  },
  languageData: {
    indentOnInput: /^\s*(?:end|rescue|elsif|else|\})$/,
    commentTokens: { line: "#" },
    autocomplete: F_
  }
};
var QO = {};
function Bg(t10, e3) {
  for (var r3 = 0; r3 < e3.length; r3++)
    QO[e3[r3]] = t10;
}
var Z_ = ["true", "false"], M_ = [
  "if",
  "then",
  "do",
  "else",
  "elif",
  "while",
  "until",
  "for",
  "in",
  "esac",
  "fi",
  "fin",
  "fil",
  "done",
  "exit",
  "set",
  "unset",
  "export",
  "function"
], N_ = [
  "ab",
  "awk",
  "bash",
  "beep",
  "cat",
  "cc",
  "cd",
  "chown",
  "chmod",
  "chroot",
  "clear",
  "cp",
  "curl",
  "cut",
  "diff",
  "echo",
  "find",
  "gawk",
  "gcc",
  "get",
  "git",
  "grep",
  "hg",
  "kill",
  "killall",
  "ln",
  "ls",
  "make",
  "mkdir",
  "openssl",
  "mv",
  "nc",
  "nl",
  "node",
  "npm",
  "ping",
  "ps",
  "restart",
  "rm",
  "rmdir",
  "sed",
  "service",
  "sh",
  "shopt",
  "shred",
  "source",
  "sort",
  "sleep",
  "ssh",
  "start",
  "stop",
  "su",
  "sudo",
  "svn",
  "tee",
  "telnet",
  "top",
  "touch",
  "vi",
  "vim",
  "wall",
  "wc",
  "wget",
  "who",
  "write",
  "yes",
  "zsh"
];
Bg("atom", Z_);
Bg("keyword", M_);
Bg("builtin", N_);
function L9(t10, e3) {
  if (t10.eatSpace())
    return null;
  var r3 = t10.sol(), n3 = t10.next();
  if (n3 === "\\")
    return t10.next(), null;
  if (n3 === "'" || n3 === '"' || n3 === "`")
    return e3.tokens.unshift(ud(n3, n3 === "`" ? "quote" : "string")), pa(t10, e3);
  if (n3 === "#")
    return r3 && t10.eat("!") ? (t10.skipToEnd(), "meta") : (t10.skipToEnd(), "comment");
  if (n3 === "$")
    return e3.tokens.unshift(W_), pa(t10, e3);
  if (n3 === "+" || n3 === "=")
    return "operator";
  if (n3 === "-")
    return t10.eat("-"), t10.eatWhile(/\w/), "attribute";
  if (n3 == "<") {
    if (t10.match("<<"))
      return "operator";
    var i3 = t10.match(/^<-?\s*(?:['"]([^'"]*)['"]|([^'"\s]*))/);
    if (i3)
      return e3.tokens.unshift(z9(i3[1] || i3[2])), "string.special";
  }
  if (/\d/.test(n3) && (t10.eatWhile(/\d/), t10.eol() || !/\w/.test(t10.peek())))
    return "number";
  t10.eatWhile(/[\w-]/);
  var o3 = t10.current();
  return t10.peek() === "=" && /\w+/.test(o3) ? "def" : QO.hasOwnProperty(o3) ? QO[o3] : null;
}
function ud(t10, e3) {
  var r3 = t10 == "(" ? ")" : t10 == "{" ? "}" : t10;
  return function(n3, i3) {
    for (var o3, s3 = false; (o3 = n3.next()) != null; ) {
      if (o3 === r3 && !s3) {
        i3.tokens.shift();
        break;
      } else if (o3 === "$" && !s3 && t10 !== "'" && n3.peek() != r3) {
        s3 = true, n3.backUp(1), i3.tokens.unshift(W_);
        break;
      } else {
        if (!s3 && t10 !== r3 && o3 === t10)
          return i3.tokens.unshift(ud(t10, e3)), pa(n3, i3);
        if (!s3 && /['"]/.test(o3) && !/['"]/.test(t10)) {
          i3.tokens.unshift(B9(o3, "string")), n3.backUp(1);
          break;
        }
      }
      s3 = !s3 && o3 === "\\";
    }
    return e3;
  };
}
function B9(t10, e3) {
  return function(r3, n3) {
    return n3.tokens[0] = ud(t10, e3), r3.next(), pa(r3, n3);
  };
}
var W_ = function(t10, e3) {
  e3.tokens.length > 1 && t10.eat("$");
  var r3 = t10.next();
  return /['"({]/.test(r3) ? (e3.tokens[0] = ud(r3, r3 == "(" ? "quote" : r3 == "{" ? "def" : "string"), pa(t10, e3)) : (/\d/.test(r3) || t10.eatWhile(/\w/), e3.tokens.shift(), "def");
};
function z9(t10) {
  return function(e3, r3) {
    return e3.sol() && e3.string == t10 && r3.tokens.shift(), e3.skipToEnd(), "string.special";
  };
}
function pa(t10, e3) {
  return (e3.tokens[0] || L9)(t10, e3);
}
const H9 = {
  name: "shell",
  startState: function() {
    return { tokens: [] };
  },
  token: function(t10, e3) {
    return pa(t10, e3);
  },
  languageData: {
    autocomplete: Z_.concat(M_, N_),
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "#" }
  }
};
function cd(t10) {
  for (var e3 = {}, r3 = 0; r3 < t10.length; r3++)
    e3[t10[r3]] = true;
  return e3;
}
var G9 = cd([
  "_",
  "var",
  "let",
  "actor",
  "class",
  "enum",
  "extension",
  "import",
  "protocol",
  "struct",
  "func",
  "typealias",
  "associatedtype",
  "open",
  "public",
  "internal",
  "fileprivate",
  "private",
  "deinit",
  "init",
  "new",
  "override",
  "self",
  "subscript",
  "super",
  "convenience",
  "dynamic",
  "final",
  "indirect",
  "lazy",
  "required",
  "static",
  "unowned",
  "unowned(safe)",
  "unowned(unsafe)",
  "weak",
  "as",
  "is",
  "break",
  "case",
  "continue",
  "default",
  "else",
  "fallthrough",
  "for",
  "guard",
  "if",
  "in",
  "repeat",
  "switch",
  "where",
  "while",
  "defer",
  "return",
  "inout",
  "mutating",
  "nonmutating",
  "isolated",
  "nonisolated",
  "catch",
  "do",
  "rethrows",
  "throw",
  "throws",
  "async",
  "await",
  "try",
  "didSet",
  "get",
  "set",
  "willSet",
  "assignment",
  "associativity",
  "infix",
  "left",
  "none",
  "operator",
  "postfix",
  "precedence",
  "precedencegroup",
  "prefix",
  "right",
  "Any",
  "AnyObject",
  "Type",
  "dynamicType",
  "Self",
  "Protocol",
  "__COLUMN__",
  "__FILE__",
  "__FUNCTION__",
  "__LINE__"
]), K9 = cd(["var", "let", "actor", "class", "enum", "extension", "import", "protocol", "struct", "func", "typealias", "associatedtype", "for"]), J9 = cd(["true", "false", "nil", "self", "super", "_"]), eX = cd([
  "Array",
  "Bool",
  "Character",
  "Dictionary",
  "Double",
  "Float",
  "Int",
  "Int8",
  "Int16",
  "Int32",
  "Int64",
  "Never",
  "Optional",
  "Set",
  "String",
  "UInt8",
  "UInt16",
  "UInt32",
  "UInt64",
  "Void"
]), tX = "+-/*%=|&<>~^?!", rX = ":;,.(){}[]", nX = /^\-?0b[01][01_]*/, iX = /^\-?0o[0-7][0-7_]*/, oX = /^\-?0x[\dA-Fa-f][\dA-Fa-f_]*(?:(?:\.[\dA-Fa-f][\dA-Fa-f_]*)?[Pp]\-?\d[\d_]*)?/, sX = /^\-?\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee]\-?\d[\d_]*)?/, aX = /^\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1/, lX = /^\.(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/, uX = /^\#[A-Za-z]+/, cX = /^@(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/;
function V_(t10, e3, r3) {
  if (t10.sol() && (e3.indented = t10.indentation()), t10.eatSpace())
    return null;
  var n3 = t10.peek();
  if (n3 == "/") {
    if (t10.match("//"))
      return t10.skipToEnd(), "comment";
    if (t10.match("/*"))
      return e3.tokenize.push(TO), TO(t10, e3);
  }
  if (t10.match(uX))
    return "builtin";
  if (t10.match(cX))
    return "attribute";
  if (t10.match(nX) || t10.match(iX) || t10.match(oX) || t10.match(sX))
    return "number";
  if (t10.match(lX))
    return "property";
  if (tX.indexOf(n3) > -1)
    return t10.next(), "operator";
  if (rX.indexOf(n3) > -1)
    return t10.next(), t10.match(".."), "punctuation";
  var i3;
  if (i3 = t10.match(/("""|"|')/)) {
    var o3 = dX.bind(null, i3[0]);
    return e3.tokenize.push(o3), o3(t10, e3);
  }
  if (t10.match(aX)) {
    var s3 = t10.current();
    return eX.hasOwnProperty(s3) ? "type" : J9.hasOwnProperty(s3) ? "atom" : G9.hasOwnProperty(s3) ? (K9.hasOwnProperty(s3) && (e3.prev = "define"), "keyword") : r3 == "define" ? "def" : "variable";
  }
  return t10.next(), null;
}
function fX() {
  var t10 = 0;
  return function(e3, r3, n3) {
    var i3 = V_(e3, r3, n3);
    if (i3 == "punctuation") {
      if (e3.current() == "(")
        ++t10;
      else if (e3.current() == ")") {
        if (t10 == 0)
          return e3.backUp(1), r3.tokenize.pop(), r3.tokenize[r3.tokenize.length - 1](e3, r3);
        --t10;
      }
    }
    return i3;
  };
}
function dX(t10, e3, r3) {
  for (var n3 = t10.length == 1, i3, o3 = false; i3 = e3.peek(); )
    if (o3) {
      if (e3.next(), i3 == "(")
        return r3.tokenize.push(fX()), "string";
      o3 = false;
    } else {
      if (e3.match(t10))
        return r3.tokenize.pop(), "string";
      e3.next(), o3 = i3 == "\\";
    }
  return n3 && r3.tokenize.pop(), "string";
}
function TO(t10, e3) {
  for (var r3; r3 = t10.next(); )
    if (r3 === "/" && t10.eat("*"))
      e3.tokenize.push(TO);
    else if (r3 === "*" && t10.eat("/")) {
      e3.tokenize.pop();
      break;
    }
  return "comment";
}
function hX(t10, e3, r3) {
  this.prev = t10, this.align = e3, this.indented = r3;
}
function pX(t10, e3) {
  var r3 = e3.match(/^\s*($|\/[\/\*]|[)}\]])/, false) ? null : e3.column() + 1;
  t10.context = new hX(t10.context, r3, t10.indented);
}
function OX(t10) {
  t10.context && (t10.indented = t10.context.indented, t10.context = t10.context.prev);
}
const mX = {
  name: "swift",
  startState: function() {
    return {
      prev: null,
      context: null,
      indented: 0,
      tokenize: []
    };
  },
  token: function(t10, e3) {
    var r3 = e3.prev;
    e3.prev = null;
    var n3 = e3.tokenize[e3.tokenize.length - 1] || V_, i3 = n3(t10, e3, r3);
    if (!i3 || i3 == "comment" ? e3.prev = r3 : e3.prev || (e3.prev = i3), i3 == "punctuation") {
      var o3 = /[\(\[\{]|([\]\)\}])/.exec(t10.current());
      o3 && (o3[1] ? OX : pX)(e3, t10);
    }
    return i3;
  },
  indent: function(t10, e3, r3) {
    var n3 = t10.context;
    if (!n3)
      return 0;
    var i3 = /^[\]\}\)]/.test(e3);
    return n3.align != null ? n3.align - (i3 ? 1 : 0) : n3.indented + (i3 ? 0 : r3.unit);
  },
  languageData: {
    indentOnInput: /^\s*[\)\}\]]$/,
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
  }
};
var gX = ["true", "false", "on", "off", "yes", "no"], yX = new RegExp("\\b((" + gX.join(")|(") + "))$", "i");
const vX = {
  name: "yaml",
  token: function(t10, e3) {
    var r3 = t10.peek(), n3 = e3.escaped;
    if (e3.escaped = false, r3 == "#" && (t10.pos == 0 || /\s/.test(t10.string.charAt(t10.pos - 1))))
      return t10.skipToEnd(), "comment";
    if (t10.match(/^('([^']|\\.)*'?|"([^"]|\\.)*"?)/))
      return "string";
    if (e3.literal && t10.indentation() > e3.keyCol)
      return t10.skipToEnd(), "string";
    if (e3.literal && (e3.literal = false), t10.sol()) {
      if (e3.keyCol = 0, e3.pair = false, e3.pairStart = false, t10.match("---") || t10.match("..."))
        return "def";
      if (t10.match(/^\s*-\s+/))
        return "meta";
    }
    if (t10.match(/^(\{|\}|\[|\])/))
      return r3 == "{" ? e3.inlinePairs++ : r3 == "}" ? e3.inlinePairs-- : r3 == "[" ? e3.inlineList++ : e3.inlineList--, "meta";
    if (e3.inlineList > 0 && !n3 && r3 == ",")
      return t10.next(), "meta";
    if (e3.inlinePairs > 0 && !n3 && r3 == ",")
      return e3.keyCol = 0, e3.pair = false, e3.pairStart = false, t10.next(), "meta";
    if (e3.pairStart) {
      if (t10.match(/^\s*(\||\>)\s*/))
        return e3.literal = true, "meta";
      if (t10.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i))
        return "variable";
      if (e3.inlinePairs == 0 && t10.match(/^\s*-?[0-9\.\,]+\s?$/) || e3.inlinePairs > 0 && t10.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/))
        return "number";
      if (t10.match(yX))
        return "keyword";
    }
    return !e3.pair && t10.match(/^\s*(?:[,\[\]{}&*!|>'"%@`][^\s'":]|[^,\[\]{}#&*!|>'"%@`])[^#]*?(?=\s*:($|\s))/) ? (e3.pair = true, e3.keyCol = t10.indentation(), "atom") : e3.pair && t10.match(/^:\s*/) ? (e3.pairStart = true, "meta") : (e3.pairStart = false, e3.escaped = r3 == "\\", t10.next(), null);
  },
  startState: function() {
    return {
      pair: false,
      pairStart: false,
      keyCol: 0,
      inlinePairs: 0,
      inlineList: 0,
      literal: false,
      escaped: false
    };
  },
  languageData: {
    commentTokens: { line: "#" }
  }
};
var Y_ = (t10) => {
  var {
    theme: e3,
    settings: r3 = {},
    styles: n3 = []
  } = t10, i3 = {
    ".cm-gutters": {}
  }, o3 = {};
  r3.background && (o3.backgroundColor = r3.background), r3.foreground && (o3.color = r3.foreground), (r3.background || r3.foreground) && (i3["&"] = o3), r3.fontFamily && (i3["&.cm-editor .cm-scroller"] = {
    fontFamily: r3.fontFamily
  }), r3.gutterBackground && (i3[".cm-gutters"].backgroundColor = r3.gutterBackground), r3.gutterForeground && (i3[".cm-gutters"].color = r3.gutterForeground), r3.gutterBorder && (i3[".cm-gutters"].borderRightColor = r3.gutterBorder), r3.caret && (i3[".cm-content"] = {
    caretColor: r3.caret
  }, i3[".cm-cursor, .cm-dropCursor"] = {
    borderLeftColor: r3.caret
  });
  var s3 = {};
  r3.gutterActiveForeground && (s3.color = r3.gutterActiveForeground), r3.lineHighlight && (i3[".cm-activeLine"] = {
    backgroundColor: r3.lineHighlight
  }, s3.backgroundColor = r3.lineHighlight), i3[".cm-activeLineGutter"] = s3, r3.selection && (i3["&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
    background: r3.selection + " !important"
  }), r3.selectionMatch && (i3["& .cm-selectionMatch"] = {
    backgroundColor: r3.selectionMatch
  });
  var a3 = Be.theme(i3, {
    dark: e3 === "dark"
  }), l3 = ed.define(n3), u3 = [a3, i8(l3)];
  return u3;
};
const eb = Y_({
  theme: "light",
  settings: {
    background: "var(--theme-background-2, var(--default-theme-background-2))",
    foreground: "var(--theme-color-1, var(--default-theme-color-1))",
    caret: "var(--theme-color-1, var(--default-theme-color-1))",
    selection: "var(--theme-background-3, var(--default-theme-background-3))",
    selectionMatch: "#e3dcce",
    gutterBackground: "var(--theme-background-2, var(--default-theme-background-2))",
    gutterForeground: "var(--theme-color-3, var(--default-theme-color-3))",
    gutterBorder: "transparent",
    lineHighlight: "var(--theme-background-3, var(--default-theme-background-3))",
    fontFamily: "var(--theme-font-code, var(--default-theme-font-code))"
  },
  styles: [
    {
      tag: [R.standard(R.tagName), R.tagName],
      color: "var(--theme-color-purple, var(--default-theme-color-purple))"
    },
    {
      tag: [R.comment],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [R.className],
      color: "var(--theme-color-orange, var(--default-theme-color-orange))"
    },
    {
      tag: [R.variableName, R.propertyName, R.attributeName],
      color: "var(--theme-color-1, var(--default-theme-color-1))"
    },
    {
      tag: [R.operator],
      color: "var(--theme-color-2, var(--default-theme-color-2))"
    },
    {
      tag: [R.keyword, R.typeName, R.typeOperator],
      color: "var(--theme-color-green, var(--default-theme-color-green))"
    },
    {
      tag: [R.string],
      color: "var(--theme-color-blue, var(--default-theme-color-blue))"
    },
    {
      tag: [R.bracket, R.regexp, R.meta],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [R.number],
      color: "var(--theme-color-blue, var(--default-theme-color-blue))"
    },
    {
      tag: [R.name, R.quote],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [R.heading],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      fontWeight: "bold"
    },
    {
      tag: [R.emphasis],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      fontStyle: "italic"
    },
    {
      tag: [R.deleted],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      backgroundColor: "transparent"
    },
    {
      tag: [R.atom, R.bool, R.special(R.variableName)],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [R.url, R.escape, R.regexp, R.link],
      color: "var(--theme-color-1, var(--default-theme-color-1))"
    },
    { tag: R.link, textDecoration: "underline" },
    { tag: R.strikethrough, textDecoration: "line-through" },
    {
      tag: R.invalid,
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    }
  ]
}), tb = Y_({
  theme: "dark",
  settings: {
    background: "var(--theme-background-2, var(--default-theme-background-2))",
    foreground: "var(--theme-color-1, var(--default-theme-color-1))",
    caret: "var(--theme-color-1, var(--default-theme-color-1))",
    selection: "var(--theme-background-3, var(--default-theme-background-3))",
    selectionMatch: "#e3dcce",
    gutterBackground: "var(--theme-background-2, var(--default-theme-background-2))",
    gutterForeground: "var(--theme-color-3, var(--default-theme-color-3))",
    gutterBorder: "transparent",
    lineHighlight: "var(--theme-background-3, var(--default-theme-background-3))",
    fontFamily: "var(--theme-font-code, var(--default-theme-font-code))"
  },
  styles: [
    {
      tag: [R.standard(R.tagName), R.tagName],
      color: "var(--theme-color-purple, var(--default-theme-color-purple))"
    },
    {
      tag: [R.comment],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [R.className],
      color: "var(--theme-color-orange, var(--default-theme-color-orange))"
    },
    {
      tag: [R.variableName, R.propertyName, R.attributeName],
      color: "var(--theme-color-1, var(--default-theme-color-1))"
    },
    {
      tag: [R.operator],
      color: "var(--theme-color-2, var(--default-theme-color-2))"
    },
    {
      tag: [R.keyword, R.typeName, R.typeOperator],
      color: "var(--theme-color-green, var(--default-theme-color-green))"
    },
    {
      tag: [R.string],
      color: "var(--theme-color-blue, var(--default-theme-color-blue))"
    },
    {
      tag: [R.bracket, R.regexp, R.meta],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [R.number],
      color: "var(--theme-color-blue, var(--default-theme-color-blue))"
    },
    {
      tag: [R.name, R.quote],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [R.heading],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      fontWeight: "bold"
    },
    {
      tag: [R.emphasis],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      fontStyle: "italic"
    },
    {
      tag: [R.deleted],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      backgroundColor: "transparent"
    },
    {
      tag: [R.atom, R.bool, R.special(R.variableName)],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [R.url, R.escape, R.regexp, R.link],
      color: "var(--theme-color-1, var(--default-theme-color-1))"
    },
    { tag: R.link, textDecoration: "underline" },
    { tag: R.strikethrough, textDecoration: "line-through" },
    {
      tag: R.invalid,
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    }
  ]
}), Uh = ref(false), bX = (t10) => {
  const { extensions: e3, content: r3, forceDarkMode: n3, forceLightMode: i3, withoutTheme: o3 } = t10, s3 = ref(r3 ?? ""), a3 = ref(null), l3 = ref(null);
  watch(a3, () => {
    d3(), u3(e3);
  });
  const u3 = (O10) => {
    if (a3.value) {
      const g = {
        parent: a3.value,
        extensions: f3(O10)
      };
      r3 && (g.doc = r3), l3.value = new Be(g);
    }
  }, c3 = () => o3 ? null : n3 ? tb : i3 ? eb : Uh.value ? tb : eb, f3 = (O10 = []) => {
    const g = {
      key: "Mod-a",
      run: (S10) => (S10.dispatch({
        selection: { anchor: 0, head: S10.state.doc.length },
        scrollIntoView: false
      }), true)
    };
    return [...[
      Be.theme(
        {
          ".cm-line": {
            lineHeight: "20px"
          },
          ".cm-gutterElement": {
            lineHeight: "20px"
          }
        },
        { dark: n3 ? false : Uh.value }
      ),
      Jf.of([g]),
      c3()
    ].filter((S10) => S10 !== null), O10];
  };
  watch(Uh, () => {
    const { extensions: O10 } = t10;
    n3 || h10(O10);
  });
  const d3 = () => {
    var O10;
    (O10 = l3.value) == null || O10.destroy();
  }, p10 = (O10) => {
    l3.value && s3.value !== O10 && (s3.value = O10, l3.value.state.doc.toString() !== O10 && l3.value.dispatch({
      changes: {
        from: 0,
        to: l3.value.state.doc.length,
        insert: O10
      },
      selection: {
        anchor: Math.min(
          l3.value.state.selection.main.anchor,
          O10.length
        )
      }
    }));
  }, h10 = (O10) => {
    l3.value && l3.value.dispatch({
      effects: Dt.reconfigure.of(f3(O10))
    });
  };
  return {
    /**
     * The current value
     */
    value: s3,
    /**
     * An empty reference used to mount CodeMirror when bound to the DOM.
     */
    codeMirrorRef: a3,
    /**
     * The CodeMirror instance.
     */
    // @ts-ignore
    codeMirror: l3,
    /**
     * Replaces the current content with the given value.
     */
    setCodeMirrorContent: p10,
    /**
     * Reconfigure the used extensions.
     */
    reconfigureCodeMirror: h10,
    /**
     * Restarts CodeMirror (destroy + mount)
     */
    restartCodeMirror: (O10) => {
      d3(), u3(O10);
    }
  };
}, rb = new VA({
  regexp: /(\{[^}]+\})/g,
  decoration: () => nr.mark({
    attributes: {
      class: "scalar-api-client__variable"
    }
  })
}), SX = () => Xi.fromClass(
  class {
    constructor(t10) {
      I1(this, "variables");
      this.variables = rb.createDeco(t10);
    }
    update(t10) {
      this.variables = rb.updateDeco(
        t10,
        this.variables
      );
    }
  },
  {
    decorations: (t10) => t10.variables,
    provide: (t10) => Be.atomicRanges.of(
      (e3) => {
        var r3;
        return ((r3 = e3.plugin(t10)) == null ? void 0 : r3.variables) || nr.none;
      }
    )
  }
), Pn = /* @__PURE__ */ defineComponent({
  __name: "CodeMirror",
  props: {
    name: {},
    extensions: {},
    content: {},
    readOnly: { type: Boolean },
    languages: {},
    withVariables: { type: Boolean },
    lineNumbers: { type: Boolean },
    withoutTheme: { type: Boolean },
    disableEnter: { type: Boolean, default: false },
    forceDarkMode: { type: Boolean, default: false }
  },
  emits: ["change"],
  setup(t10, { expose: e3, emit: r3 }) {
    const n3 = t10, i3 = {
      c: pr.define(j6),
      clojure: pr.define(n9),
      csharp: pr.define(U6),
      go: pr.define(a9),
      http: pr.define(h9),
      html: v7(),
      java: _7(),
      javascript: SO(),
      json: k7(),
      kotlin: pr.define(F6),
      node: SO(),
      objc: pr.define(Z6),
      ocaml: pr.define(p9),
      powershell: pr.define(E9),
      python: X6(),
      r: pr.define(j9),
      ruby: pr.define(Y9),
      shell: pr.define(H9),
      swift: pr.define(mX),
      yaml: pr.define(vX)
    }, o3 = ["scalar-api-client__codemirror"];
    n3.readOnly && o3.push("scalar-api-client__codemirror--read-only");
    const s3 = () => {
      const f3 = [];
      return f3.push(Be.editorAttributes.of({ class: o3.join(" ") })), n3.extensions && n3.extensions.forEach((d3) => {
        f3.push(toRaw(d3));
      }), n3.readOnly && f3.push(Be.editable.of(false)), n3.languages && n3.languages.filter((d3) => typeof i3[d3] < "u").forEach((d3) => {
        f3.push(i3[d3]);
      }), n3.lineNumbers && f3.push(KA()), n3.withVariables && f3.push(SX()), n3.disableEnter && f3.push(
        Jf.of([
          {
            key: "Enter",
            run: () => true
          },
          {
            key: "Ctrl-Enter",
            mac: "Cmd-Enter",
            run: () => true
          },
          {
            key: "Shift-Enter",
            run: () => true
          }
        ])
      ), f3.push(
        Be.updateListener.of((d3) => {
          d3.docChanged && r3("change", d3.state.doc.toString());
        })
      ), f3;
    }, {
      codeMirrorRef: a3,
      setCodeMirrorContent: l3,
      reconfigureCodeMirror: u3,
      restartCodeMirror: c3
    } = bX({
      content: n3.content ?? "",
      extensions: s3(),
      withoutTheme: n3.withoutTheme,
      forceDarkMode: n3.forceDarkMode
    });
    return watch(
      () => n3.content,
      () => {
        var f3;
        (f3 = n3.content) != null && f3.length && l3(n3.content);
      }
    ), watch(
      () => n3.name,
      () => {
        c3(s3());
      }
    ), watch(
      [
        () => n3.disableEnter,
        () => n3.forceDarkMode,
        () => n3.languages,
        () => n3.lineNumbers,
        () => n3.readOnly,
        () => n3.withoutTheme,
        () => n3.withVariables
      ],
      () => {
        u3(s3());
      }
    ), e3({
      setCodeMirrorContent: l3
    }), (f3, d3) => (openBlock(), createElementBlock("div", {
      ref_key: "codeMirrorRef",
      ref: a3,
      class: "scalar-api-client__codemirror__wrapper"
    }, null, 512));
  }
});
const Re = (t10, e3) => {
  const r3 = t10.__vccOpts || t10;
  for (const [n3, i3] of e3)
    r3[n3] = i3;
  return r3;
};
function RO(t10) {
  "@babel/helpers - typeof";
  return RO = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e3) {
    return typeof e3;
  } : function(e3) {
    return e3 && typeof Symbol == "function" && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
  }, RO(t10);
}
function KX() {
  var t10 = (typeof Intl > "u" ? "undefined" : RO(Intl)) === "object";
  return t10 && typeof Intl.DateTimeFormat == "function";
}
var vi = 60;
const pq = [{
  formatAs: "now"
}, {
  formatAs: "second"
}, {
  formatAs: "minute"
}, {
  formatAs: "hour"
}, {
  formatAs: "day"
}, {
  formatAs: "week"
}, {
  formatAs: "month"
}, {
  formatAs: "year"
}], jO = {
  steps: pq,
  labels: "long"
};
function vb(t10, e3) {
  var r3 = Object.keys(t10);
  if (Object.getOwnPropertySymbols) {
    var n3 = Object.getOwnPropertySymbols(t10);
    e3 && (n3 = n3.filter(function(i3) {
      return Object.getOwnPropertyDescriptor(t10, i3).enumerable;
    })), r3.push.apply(r3, n3);
  }
  return r3;
}
function bb(t10) {
  for (var e3 = 1; e3 < arguments.length; e3++) {
    var r3 = arguments[e3] != null ? arguments[e3] : {};
    e3 % 2 ? vb(Object(r3), true).forEach(function(n3) {
      Oq(t10, n3, r3[n3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t10, Object.getOwnPropertyDescriptors(r3)) : vb(Object(r3)).forEach(function(n3) {
      Object.defineProperty(t10, n3, Object.getOwnPropertyDescriptor(r3, n3));
    });
  }
  return t10;
}
function Oq(t10, e3, r3) {
  return e3 in t10 ? Object.defineProperty(t10, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t10[e3] = r3, t10;
}
bb(bb({}, jO), {}, {
  // Skip "seconds".
  steps: jO.steps.filter(function(t10) {
    return t10.formatAs !== "second";
  })
});
function sx(t10) {
  return t10 instanceof Date ? t10 : new Date(t10);
}
var IO = [{
  formatAs: "second"
}, {
  formatAs: "minute"
}, {
  formatAs: "hour"
}], Hn = {}, gq = {
  minTime: function(e3, r3) {
    r3.future;
    var n3 = r3.getMinTimeForUnit;
    return n3("day");
  },
  format: function(e3, r3) {
    return Hn[r3] || (Hn[r3] = {}), Hn[r3].dayMonth || (Hn[r3].dayMonth = new Intl.DateTimeFormat(r3, {
      month: "short",
      day: "numeric"
    })), Hn[r3].dayMonth.format(sx(e3));
  }
}, yq = {
  minTime: function(e3, r3) {
    var n3 = r3.future;
    if (n3) {
      var i3 = new Date(new Date(e3).getFullYear(), 0).getTime() - 1;
      return (e3 - i3) / 1e3;
    } else {
      var o3 = new Date(new Date(e3).getFullYear() + 1, 0).getTime();
      return (o3 - e3) / 1e3;
    }
  },
  format: function(e3, r3) {
    return Hn[r3] || (Hn[r3] = {}), Hn[r3].dayMonthYear || (Hn[r3].dayMonthYear = new Intl.DateTimeFormat(r3, {
      year: "numeric",
      month: "short",
      day: "numeric"
    })), Hn[r3].dayMonthYear.format(sx(e3));
  }
};
KX() ? IO.push(gq, yq) : IO.push({
  formatAs: "day"
}, {
  formatAs: "week"
}, {
  formatAs: "month"
}, {
  formatAs: "year"
});
const os = {
  steps: IO,
  labels: [
    // "mini" labels are only defined for a few languages.
    "mini",
    // "short-time" labels are only defined for a few languages.
    "short-time",
    // "narrow" and "short" labels are defined for all languages.
    // "narrow" labels can sometimes be weird (like "+5d."),
    // but "short" labels have the " ago" part, so "narrow" seem
    // more appropriate.
    // "short" labels would have been more appropriate if they
    // didn't have the " ago" part, hence the "short-time" above.
    "narrow",
    // Since "narrow" labels are always present, "short" element
    // of this array can be removed.
    "short"
  ]
};
function $b(t10, e3) {
  var r3 = Object.keys(t10);
  if (Object.getOwnPropertySymbols) {
    var n3 = Object.getOwnPropertySymbols(t10);
    e3 && (n3 = n3.filter(function(i3) {
      return Object.getOwnPropertyDescriptor(t10, i3).enumerable;
    })), r3.push.apply(r3, n3);
  }
  return r3;
}
function wb(t10) {
  for (var e3 = 1; e3 < arguments.length; e3++) {
    var r3 = arguments[e3] != null ? arguments[e3] : {};
    e3 % 2 ? $b(Object(r3), true).forEach(function(n3) {
      vq(t10, n3, r3[n3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t10, Object.getOwnPropertyDescriptors(r3)) : $b(Object(r3)).forEach(function(n3) {
      Object.defineProperty(t10, n3, Object.getOwnPropertyDescriptor(r3, n3));
    });
  }
  return t10;
}
function vq(t10, e3, r3) {
  return e3 in t10 ? Object.defineProperty(t10, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t10[e3] = r3, t10;
}
wb(wb({}, os), {}, {
  // Add "now".
  steps: [{
    formatAs: "now"
  }].concat(os.steps)
});
function Pb(t10, e3) {
  var r3 = Object.keys(t10);
  if (Object.getOwnPropertySymbols) {
    var n3 = Object.getOwnPropertySymbols(t10);
    e3 && (n3 = n3.filter(function(i3) {
      return Object.getOwnPropertyDescriptor(t10, i3).enumerable;
    })), r3.push.apply(r3, n3);
  }
  return r3;
}
function _b(t10) {
  for (var e3 = 1; e3 < arguments.length; e3++) {
    var r3 = arguments[e3] != null ? arguments[e3] : {};
    e3 % 2 ? Pb(Object(r3), true).forEach(function(n3) {
      Sq(t10, n3, r3[n3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t10, Object.getOwnPropertyDescriptors(r3)) : Pb(Object(r3)).forEach(function(n3) {
      Object.defineProperty(t10, n3, Object.getOwnPropertyDescriptor(r3, n3));
    });
  }
  return t10;
}
function Sq(t10, e3, r3) {
  return e3 in t10 ? Object.defineProperty(t10, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t10[e3] = r3, t10;
}
const FO = _b(_b({}, os), {}, {
  // Skip "seconds".
  steps: os.steps.filter(function(t10) {
    return t10.formatAs !== "second";
  })
});
function xb(t10, e3) {
  var r3 = Object.keys(t10);
  if (Object.getOwnPropertySymbols) {
    var n3 = Object.getOwnPropertySymbols(t10);
    e3 && (n3 = n3.filter(function(i3) {
      return Object.getOwnPropertyDescriptor(t10, i3).enumerable;
    })), r3.push.apply(r3, n3);
  }
  return r3;
}
function Qb(t10) {
  for (var e3 = 1; e3 < arguments.length; e3++) {
    var r3 = arguments[e3] != null ? arguments[e3] : {};
    e3 % 2 ? xb(Object(r3), true).forEach(function(n3) {
      $q(t10, n3, r3[n3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t10, Object.getOwnPropertyDescriptors(r3)) : xb(Object(r3)).forEach(function(n3) {
      Object.defineProperty(t10, n3, Object.getOwnPropertyDescriptor(r3, n3));
    });
  }
  return t10;
}
function $q(t10, e3, r3) {
  return e3 in t10 ? Object.defineProperty(t10, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t10[e3] = r3, t10;
}
Qb(Qb({}, FO), {}, {
  // Add "now".
  steps: [{
    formatAs: "now"
  }].concat(FO.steps)
});
function Tb(t10, e3) {
  var r3 = Object.keys(t10);
  if (Object.getOwnPropertySymbols) {
    var n3 = Object.getOwnPropertySymbols(t10);
    e3 && (n3 = n3.filter(function(i3) {
      return Object.getOwnPropertyDescriptor(t10, i3).enumerable;
    })), r3.push.apply(r3, n3);
  }
  return r3;
}
function tc(t10) {
  for (var e3 = 1; e3 < arguments.length; e3++) {
    var r3 = arguments[e3] != null ? arguments[e3] : {};
    e3 % 2 ? Tb(Object(r3), true).forEach(function(n3) {
      Pq(t10, n3, r3[n3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t10, Object.getOwnPropertyDescriptors(r3)) : Tb(Object(r3)).forEach(function(n3) {
      Object.defineProperty(t10, n3, Object.getOwnPropertyDescriptor(r3, n3));
    });
  }
  return t10;
}
function Pq(t10, e3, r3) {
  return e3 in t10 ? Object.defineProperty(t10, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t10[e3] = r3, t10;
}
tc(tc({}, os), {}, {
  // Skip "seconds".
  steps: os.steps.filter(function(t10) {
    return t10.formatAs !== "second";
  }).map(function(t10) {
    return t10.formatAs === "minute" ? tc(tc({}, t10), {}, {
      minTime: vi
    }) : t10;
  })
});
const Vl = {
  steps: [{
    formatAs: "second"
  }, {
    formatAs: "minute"
  }, {
    formatAs: "hour"
  }, {
    formatAs: "day"
  }, {
    formatAs: "month"
  }, {
    formatAs: "year"
  }],
  labels: [
    // "mini" labels are only defined for a few languages.
    "mini",
    // "short-time" labels are only defined for a few languages.
    "short-time",
    // "narrow" and "short" labels are defined for all languages.
    // "narrow" labels can sometimes be weird (like "+5d."),
    // but "short" labels have the " ago" part, so "narrow" seem
    // more appropriate.
    // "short" labels would have been more appropriate if they
    // didn't have the " ago" part, hence the "short-time" above.
    "narrow",
    // Since "narrow" labels are always present, "short" element
    // of this array can be removed.
    "short"
  ]
};
function kb(t10, e3) {
  var r3 = Object.keys(t10);
  if (Object.getOwnPropertySymbols) {
    var n3 = Object.getOwnPropertySymbols(t10);
    e3 && (n3 = n3.filter(function(i3) {
      return Object.getOwnPropertyDescriptor(t10, i3).enumerable;
    })), r3.push.apply(r3, n3);
  }
  return r3;
}
function Eb(t10) {
  for (var e3 = 1; e3 < arguments.length; e3++) {
    var r3 = arguments[e3] != null ? arguments[e3] : {};
    e3 % 2 ? kb(Object(r3), true).forEach(function(n3) {
      xq(t10, n3, r3[n3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t10, Object.getOwnPropertyDescriptors(r3)) : kb(Object(r3)).forEach(function(n3) {
      Object.defineProperty(t10, n3, Object.getOwnPropertyDescriptor(r3, n3));
    });
  }
  return t10;
}
function xq(t10, e3, r3) {
  return e3 in t10 ? Object.defineProperty(t10, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t10[e3] = r3, t10;
}
Eb(Eb({}, Vl), {}, {
  // Add "now".
  steps: [{
    formatAs: "now"
  }].concat(Vl.steps)
});
function Cb(t10, e3) {
  var r3 = Object.keys(t10);
  if (Object.getOwnPropertySymbols) {
    var n3 = Object.getOwnPropertySymbols(t10);
    e3 && (n3 = n3.filter(function(i3) {
      return Object.getOwnPropertyDescriptor(t10, i3).enumerable;
    })), r3.push.apply(r3, n3);
  }
  return r3;
}
function Rb(t10) {
  for (var e3 = 1; e3 < arguments.length; e3++) {
    var r3 = arguments[e3] != null ? arguments[e3] : {};
    e3 % 2 ? Cb(Object(r3), true).forEach(function(n3) {
      Tq(t10, n3, r3[n3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t10, Object.getOwnPropertyDescriptors(r3)) : Cb(Object(r3)).forEach(function(n3) {
      Object.defineProperty(t10, n3, Object.getOwnPropertyDescriptor(r3, n3));
    });
  }
  return t10;
}
function Tq(t10, e3, r3) {
  return e3 in t10 ? Object.defineProperty(t10, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t10[e3] = r3, t10;
}
const ZO = Rb(Rb({}, Vl), {}, {
  // Skip "seconds".
  steps: Vl.steps.filter(function(t10) {
    return t10.formatAs !== "second";
  })
});
function Ab(t10, e3) {
  var r3 = Object.keys(t10);
  if (Object.getOwnPropertySymbols) {
    var n3 = Object.getOwnPropertySymbols(t10);
    e3 && (n3 = n3.filter(function(i3) {
      return Object.getOwnPropertyDescriptor(t10, i3).enumerable;
    })), r3.push.apply(r3, n3);
  }
  return r3;
}
function Xb(t10) {
  for (var e3 = 1; e3 < arguments.length; e3++) {
    var r3 = arguments[e3] != null ? arguments[e3] : {};
    e3 % 2 ? Ab(Object(r3), true).forEach(function(n3) {
      kq(t10, n3, r3[n3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t10, Object.getOwnPropertyDescriptors(r3)) : Ab(Object(r3)).forEach(function(n3) {
      Object.defineProperty(t10, n3, Object.getOwnPropertyDescriptor(r3, n3));
    });
  }
  return t10;
}
function kq(t10, e3, r3) {
  return e3 in t10 ? Object.defineProperty(t10, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t10[e3] = r3, t10;
}
Xb(Xb({}, ZO), {}, {
  // Add "now".
  steps: [{
    formatAs: "now"
  }].concat(ZO.steps)
});
const Vq = (t10) => {
  var r3;
  const e3 = new RegExp("(?<=\\{)\\s*\\w+\\s*(?=\\})", "g");
  return ((r3 = t10.match(e3)) == null ? void 0 : r3.map((n3) => n3.trim())) || [];
};
function cl(t10, e3, r3) {
  const n3 = {};
  return t10.forEach((i3) => {
    n3[i3[e3]] = i3[r3];
  }), n3;
}
function cx(t10, e3) {
  return function() {
    return t10.apply(e3, arguments);
  };
}
const { toString: eD } = Object.prototype, { getPrototypeOf: Gg } = Object, fd = ((t10) => (e3) => {
  const r3 = eD.call(e3);
  return t10[r3] || (t10[r3] = r3.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), ui = (t10) => (t10 = t10.toLowerCase(), (e3) => fd(e3) === t10), dd = (t10) => (e3) => typeof e3 === t10, { isArray: Ea } = Array, Yl = dd("undefined");
function tD(t10) {
  return t10 !== null && !Yl(t10) && t10.constructor !== null && !Yl(t10.constructor) && dn(t10.constructor.isBuffer) && t10.constructor.isBuffer(t10);
}
const fx = ui("ArrayBuffer");
function rD(t10) {
  let e3;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e3 = ArrayBuffer.isView(t10) : e3 = t10 && t10.buffer && fx(t10.buffer), e3;
}
const nD = dd("string"), dn = dd("function"), dx = dd("number"), hd = (t10) => t10 !== null && typeof t10 == "object", iD = (t10) => t10 === true || t10 === false, xc = (t10) => {
  if (fd(t10) !== "object")
    return false;
  const e3 = Gg(t10);
  return (e3 === null || e3 === Object.prototype || Object.getPrototypeOf(e3) === null) && !(Symbol.toStringTag in t10) && !(Symbol.iterator in t10);
}, oD = ui("Date"), sD = ui("File"), aD = ui("Blob"), lD = ui("FileList"), uD = (t10) => hd(t10) && dn(t10.pipe), cD = (t10) => {
  let e3;
  return t10 && (typeof FormData == "function" && t10 instanceof FormData || dn(t10.append) && ((e3 = fd(t10)) === "formdata" || // detect form-data instance
  e3 === "object" && dn(t10.toString) && t10.toString() === "[object FormData]"));
}, fD = ui("URLSearchParams"), dD = (t10) => t10.trim ? t10.trim() : t10.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Ou(t10, e3, { allOwnKeys: r3 = false } = {}) {
  if (t10 === null || typeof t10 > "u")
    return;
  let n3, i3;
  if (typeof t10 != "object" && (t10 = [t10]), Ea(t10))
    for (n3 = 0, i3 = t10.length; n3 < i3; n3++)
      e3.call(null, t10[n3], n3, t10);
  else {
    const o3 = r3 ? Object.getOwnPropertyNames(t10) : Object.keys(t10), s3 = o3.length;
    let a3;
    for (n3 = 0; n3 < s3; n3++)
      a3 = o3[n3], e3.call(null, t10[a3], a3, t10);
  }
}
function hx(t10, e3) {
  e3 = e3.toLowerCase();
  const r3 = Object.keys(t10);
  let n3 = r3.length, i3;
  for (; n3-- > 0; )
    if (i3 = r3[n3], e3 === i3.toLowerCase())
      return i3;
  return null;
}
const px = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : $e.global)(), Ox = (t10) => !Yl(t10) && t10 !== px;
function NO() {
  const { caseless: t10 } = Ox(this) && this || {}, e3 = {}, r3 = (n3, i3) => {
    const o3 = t10 && hx(e3, i3) || i3;
    xc(e3[o3]) && xc(n3) ? e3[o3] = NO(e3[o3], n3) : xc(n3) ? e3[o3] = NO({}, n3) : Ea(n3) ? e3[o3] = n3.slice() : e3[o3] = n3;
  };
  for (let n3 = 0, i3 = arguments.length; n3 < i3; n3++)
    arguments[n3] && Ou(arguments[n3], r3);
  return e3;
}
const hD = (t10, e3, r3, { allOwnKeys: n3 } = {}) => (Ou(e3, (i3, o3) => {
  r3 && dn(i3) ? t10[o3] = cx(i3, r3) : t10[o3] = i3;
}, { allOwnKeys: n3 }), t10), pD = (t10) => (t10.charCodeAt(0) === 65279 && (t10 = t10.slice(1)), t10), OD = (t10, e3, r3, n3) => {
  t10.prototype = Object.create(e3.prototype, n3), t10.prototype.constructor = t10, Object.defineProperty(t10, "super", {
    value: e3.prototype
  }), r3 && Object.assign(t10.prototype, r3);
}, mD = (t10, e3, r3, n3) => {
  let i3, o3, s3;
  const a3 = {};
  if (e3 = e3 || {}, t10 == null)
    return e3;
  do {
    for (i3 = Object.getOwnPropertyNames(t10), o3 = i3.length; o3-- > 0; )
      s3 = i3[o3], (!n3 || n3(s3, t10, e3)) && !a3[s3] && (e3[s3] = t10[s3], a3[s3] = true);
    t10 = r3 !== false && Gg(t10);
  } while (t10 && (!r3 || r3(t10, e3)) && t10 !== Object.prototype);
  return e3;
}, gD = (t10, e3, r3) => {
  t10 = String(t10), (r3 === void 0 || r3 > t10.length) && (r3 = t10.length), r3 -= e3.length;
  const n3 = t10.indexOf(e3, r3);
  return n3 !== -1 && n3 === r3;
}, yD = (t10) => {
  if (!t10)
    return null;
  if (Ea(t10))
    return t10;
  let e3 = t10.length;
  if (!dx(e3))
    return null;
  const r3 = new Array(e3);
  for (; e3-- > 0; )
    r3[e3] = t10[e3];
  return r3;
}, vD = ((t10) => (e3) => t10 && e3 instanceof t10)(typeof Uint8Array < "u" && Gg(Uint8Array)), bD = (t10, e3) => {
  const n3 = (t10 && t10[Symbol.iterator]).call(t10);
  let i3;
  for (; (i3 = n3.next()) && !i3.done; ) {
    const o3 = i3.value;
    e3.call(t10, o3[0], o3[1]);
  }
}, SD = (t10, e3) => {
  let r3;
  const n3 = [];
  for (; (r3 = t10.exec(e3)) !== null; )
    n3.push(r3);
  return n3;
}, $D = ui("HTMLFormElement"), wD = (t10) => t10.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r3, n3, i3) {
    return n3.toUpperCase() + i3;
  }
), Ub = (({ hasOwnProperty: t10 }) => (e3, r3) => t10.call(e3, r3))(Object.prototype), PD = ui("RegExp"), mx = (t10, e3) => {
  const r3 = Object.getOwnPropertyDescriptors(t10), n3 = {};
  Ou(r3, (i3, o3) => {
    let s3;
    (s3 = e3(i3, o3, t10)) !== false && (n3[o3] = s3 || i3);
  }), Object.defineProperties(t10, n3);
}, _D = (t10) => {
  mx(t10, (e3, r3) => {
    if (dn(t10) && ["arguments", "caller", "callee"].indexOf(r3) !== -1)
      return false;
    const n3 = t10[r3];
    if (dn(n3)) {
      if (e3.enumerable = false, "writable" in e3) {
        e3.writable = false;
        return;
      }
      e3.set || (e3.set = () => {
        throw Error("Can not rewrite read-only method '" + r3 + "'");
      });
    }
  });
}, xD = (t10, e3) => {
  const r3 = {}, n3 = (i3) => {
    i3.forEach((o3) => {
      r3[o3] = true;
    });
  };
  return Ea(t10) ? n3(t10) : n3(String(t10).split(e3)), r3;
}, QD = () => {
}, TD = (t10, e3) => (t10 = +t10, Number.isFinite(t10) ? t10 : e3), Fh = "abcdefghijklmnopqrstuvwxyz", Ib = "0123456789", gx = {
  DIGIT: Ib,
  ALPHA: Fh,
  ALPHA_DIGIT: Fh + Fh.toUpperCase() + Ib
}, kD = (t10 = 16, e3 = gx.ALPHA_DIGIT) => {
  let r3 = "";
  const { length: n3 } = e3;
  for (; t10--; )
    r3 += e3[Math.random() * n3 | 0];
  return r3;
};
function ED(t10) {
  return !!(t10 && dn(t10.append) && t10[Symbol.toStringTag] === "FormData" && t10[Symbol.iterator]);
}
const CD = (t10) => {
  const e3 = new Array(10), r3 = (n3, i3) => {
    if (hd(n3)) {
      if (e3.indexOf(n3) >= 0)
        return;
      if (!("toJSON" in n3)) {
        e3[i3] = n3;
        const o3 = Ea(n3) ? [] : {};
        return Ou(n3, (s3, a3) => {
          const l3 = r3(s3, i3 + 1);
          !Yl(l3) && (o3[a3] = l3);
        }), e3[i3] = void 0, o3;
      }
    }
    return n3;
  };
  return r3(t10, 0);
}, RD = ui("AsyncFunction"), AD = (t10) => t10 && (hd(t10) || dn(t10)) && dn(t10.then) && dn(t10.catch), ue = {
  isArray: Ea,
  isArrayBuffer: fx,
  isBuffer: tD,
  isFormData: cD,
  isArrayBufferView: rD,
  isString: nD,
  isNumber: dx,
  isBoolean: iD,
  isObject: hd,
  isPlainObject: xc,
  isUndefined: Yl,
  isDate: oD,
  isFile: sD,
  isBlob: aD,
  isRegExp: PD,
  isFunction: dn,
  isStream: uD,
  isURLSearchParams: fD,
  isTypedArray: vD,
  isFileList: lD,
  forEach: Ou,
  merge: NO,
  extend: hD,
  trim: dD,
  stripBOM: pD,
  inherits: OD,
  toFlatObject: mD,
  kindOf: fd,
  kindOfTest: ui,
  endsWith: gD,
  toArray: yD,
  forEachEntry: bD,
  matchAll: SD,
  isHTMLForm: $D,
  hasOwnProperty: Ub,
  hasOwnProp: Ub,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: mx,
  freezeMethods: _D,
  toObjectSet: xD,
  toCamelCase: wD,
  noop: QD,
  toFiniteNumber: TD,
  findKey: hx,
  global: px,
  isContextDefined: Ox,
  ALPHABET: gx,
  generateString: kD,
  isSpecCompliantForm: ED,
  toJSONObject: CD,
  isAsyncFn: RD,
  isThenable: AD
};
function st(t10, e3, r3, n3, i3) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t10, this.name = "AxiosError", e3 && (this.code = e3), r3 && (this.config = r3), n3 && (this.request = n3), i3 && (this.response = i3);
}
ue.inherits(st, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ue.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const yx = st.prototype, vx = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t10) => {
  vx[t10] = { value: t10 };
});
Object.defineProperties(st, vx);
Object.defineProperty(yx, "isAxiosError", { value: true });
st.from = (t10, e3, r3, n3, i3, o3) => {
  const s3 = Object.create(yx);
  return ue.toFlatObject(t10, s3, function(l3) {
    return l3 !== Error.prototype;
  }, (a3) => a3 !== "isAxiosError"), st.call(s3, t10.message, e3, r3, n3, i3), s3.cause = t10, s3.name = t10.name, o3 && Object.assign(s3, o3), s3;
};
const XD = null;
function WO(t10) {
  return ue.isPlainObject(t10) || ue.isArray(t10);
}
function bx(t10) {
  return ue.endsWith(t10, "[]") ? t10.slice(0, -2) : t10;
}
function Fb(t10, e3, r3) {
  return t10 ? t10.concat(e3).map(function(i3, o3) {
    return i3 = bx(i3), !r3 && o3 ? "[" + i3 + "]" : i3;
  }).join(r3 ? "." : "") : e3;
}
function qD(t10) {
  return ue.isArray(t10) && !t10.some(WO);
}
const DD = ue.toFlatObject(ue, {}, null, function(e3) {
  return /^is[A-Z]/.test(e3);
});
function pd(t10, e3, r3) {
  if (!ue.isObject(t10))
    throw new TypeError("target must be an object");
  e3 = e3 || new FormData(), r3 = ue.toFlatObject(r3, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function(m10, O10) {
    return !ue.isUndefined(O10[m10]);
  });
  const n3 = r3.metaTokens, i3 = r3.visitor || c3, o3 = r3.dots, s3 = r3.indexes, l3 = (r3.Blob || typeof Blob < "u" && Blob) && ue.isSpecCompliantForm(e3);
  if (!ue.isFunction(i3))
    throw new TypeError("visitor must be a function");
  function u3(h10) {
    if (h10 === null)
      return "";
    if (ue.isDate(h10))
      return h10.toISOString();
    if (!l3 && ue.isBlob(h10))
      throw new st("Blob is not supported. Use a Buffer instead.");
    return ue.isArrayBuffer(h10) || ue.isTypedArray(h10) ? l3 && typeof Blob == "function" ? new Blob([h10]) : $e.Buffer.from(h10) : h10;
  }
  function c3(h10, m10, O10) {
    let g = h10;
    if (h10 && !O10 && typeof h10 == "object") {
      if (ue.endsWith(m10, "{}"))
        m10 = n3 ? m10 : m10.slice(0, -2), h10 = JSON.stringify(h10);
      else if (ue.isArray(h10) && qD(h10) || (ue.isFileList(h10) || ue.endsWith(m10, "[]")) && (g = ue.toArray(h10)))
        return m10 = bx(m10), g.forEach(function(S10, $10) {
          !(ue.isUndefined(S10) || S10 === null) && e3.append(
            // eslint-disable-next-line no-nested-ternary
            s3 === true ? Fb([m10], $10, o3) : s3 === null ? m10 : m10 + "[]",
            u3(S10)
          );
        }), false;
    }
    return WO(h10) ? true : (e3.append(Fb(O10, m10, o3), u3(h10)), false);
  }
  const f3 = [], d3 = Object.assign(DD, {
    defaultVisitor: c3,
    convertValue: u3,
    isVisitable: WO
  });
  function p10(h10, m10) {
    if (!ue.isUndefined(h10)) {
      if (f3.indexOf(h10) !== -1)
        throw Error("Circular reference detected in " + m10.join("."));
      f3.push(h10), ue.forEach(h10, function(g, v10) {
        (!(ue.isUndefined(g) || g === null) && i3.call(
          e3,
          g,
          ue.isString(v10) ? v10.trim() : v10,
          m10,
          d3
        )) === true && p10(g, m10 ? m10.concat(v10) : [v10]);
      }), f3.pop();
    }
  }
  if (!ue.isObject(t10))
    throw new TypeError("data must be an object");
  return p10(t10), e3;
}
function Zb(t10) {
  const e3 = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t10).replace(/[!'()~]|%20|%00/g, function(n3) {
    return e3[n3];
  });
}
function Kg(t10, e3) {
  this._pairs = [], t10 && pd(t10, this, e3);
}
const Sx = Kg.prototype;
Sx.append = function(e3, r3) {
  this._pairs.push([e3, r3]);
};
Sx.toString = function(e3) {
  const r3 = e3 ? function(n3) {
    return e3.call(this, n3, Zb);
  } : Zb;
  return this._pairs.map(function(i3) {
    return r3(i3[0]) + "=" + r3(i3[1]);
  }, "").join("&");
};
function jD(t10) {
  return encodeURIComponent(t10).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function $x(t10, e3, r3) {
  if (!e3)
    return t10;
  const n3 = r3 && r3.encode || jD, i3 = r3 && r3.serialize;
  let o3;
  if (i3 ? o3 = i3(e3, r3) : o3 = ue.isURLSearchParams(e3) ? e3.toString() : new Kg(e3, r3).toString(n3), o3) {
    const s3 = t10.indexOf("#");
    s3 !== -1 && (t10 = t10.slice(0, s3)), t10 += (t10.indexOf("?") === -1 ? "?" : "&") + o3;
  }
  return t10;
}
class UD {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e3, r3, n3) {
    return this.handlers.push({
      fulfilled: e3,
      rejected: r3,
      synchronous: n3 ? n3.synchronous : false,
      runWhen: n3 ? n3.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e3) {
    this.handlers[e3] && (this.handlers[e3] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e3) {
    ue.forEach(this.handlers, function(n3) {
      n3 !== null && e3(n3);
    });
  }
}
const Mb = UD, wx = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
}, ID = typeof URLSearchParams < "u" ? URLSearchParams : Kg, FD = typeof FormData < "u" ? FormData : null, ZD = typeof Blob < "u" ? Blob : null, MD = {
  isBrowser: true,
  classes: {
    URLSearchParams: ID,
    FormData: FD,
    Blob: ZD
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Px = typeof window < "u" && typeof document < "u", ND = ((t10) => Px && ["ReactNative", "NativeScript", "NS"].indexOf(t10) < 0)(typeof navigator < "u" && navigator.product), WD = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), VD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Px,
  hasStandardBrowserEnv: ND,
  hasStandardBrowserWebWorkerEnv: WD
}, Symbol.toStringTag, { value: "Module" })), ei = {
  ...VD,
  ...MD
};
function YD(t10, e3) {
  return pd(t10, new ei.classes.URLSearchParams(), Object.assign({
    visitor: function(r3, n3, i3, o3) {
      return ei.isNode && ue.isBuffer(r3) ? (this.append(n3, r3.toString("base64")), false) : o3.defaultVisitor.apply(this, arguments);
    }
  }, e3));
}
function LD(t10) {
  return ue.matchAll(/\w+|\[(\w*)]/g, t10).map((e3) => e3[0] === "[]" ? "" : e3[1] || e3[0]);
}
function BD(t10) {
  const e3 = {}, r3 = Object.keys(t10);
  let n3;
  const i3 = r3.length;
  let o3;
  for (n3 = 0; n3 < i3; n3++)
    o3 = r3[n3], e3[o3] = t10[o3];
  return e3;
}
function _x(t10) {
  function e3(r3, n3, i3, o3) {
    let s3 = r3[o3++];
    const a3 = Number.isFinite(+s3), l3 = o3 >= r3.length;
    return s3 = !s3 && ue.isArray(i3) ? i3.length : s3, l3 ? (ue.hasOwnProp(i3, s3) ? i3[s3] = [i3[s3], n3] : i3[s3] = n3, !a3) : ((!i3[s3] || !ue.isObject(i3[s3])) && (i3[s3] = []), e3(r3, n3, i3[s3], o3) && ue.isArray(i3[s3]) && (i3[s3] = BD(i3[s3])), !a3);
  }
  if (ue.isFormData(t10) && ue.isFunction(t10.entries)) {
    const r3 = {};
    return ue.forEachEntry(t10, (n3, i3) => {
      e3(LD(n3), i3, r3, 0);
    }), r3;
  }
  return null;
}
function zD(t10, e3, r3) {
  if (ue.isString(t10))
    try {
      return (e3 || JSON.parse)(t10), ue.trim(t10);
    } catch (n3) {
      if (n3.name !== "SyntaxError")
        throw n3;
    }
  return (r3 || JSON.stringify)(t10);
}
const Jg = {
  transitional: wx,
  adapter: ["xhr", "http"],
  transformRequest: [function(e3, r3) {
    const n3 = r3.getContentType() || "", i3 = n3.indexOf("application/json") > -1, o3 = ue.isObject(e3);
    if (o3 && ue.isHTMLForm(e3) && (e3 = new FormData(e3)), ue.isFormData(e3))
      return i3 && i3 ? JSON.stringify(_x(e3)) : e3;
    if (ue.isArrayBuffer(e3) || ue.isBuffer(e3) || ue.isStream(e3) || ue.isFile(e3) || ue.isBlob(e3))
      return e3;
    if (ue.isArrayBufferView(e3))
      return e3.buffer;
    if (ue.isURLSearchParams(e3))
      return r3.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e3.toString();
    let a3;
    if (o3) {
      if (n3.indexOf("application/x-www-form-urlencoded") > -1)
        return YD(e3, this.formSerializer).toString();
      if ((a3 = ue.isFileList(e3)) || n3.indexOf("multipart/form-data") > -1) {
        const l3 = this.env && this.env.FormData;
        return pd(
          a3 ? { "files[]": e3 } : e3,
          l3 && new l3(),
          this.formSerializer
        );
      }
    }
    return o3 || i3 ? (r3.setContentType("application/json", false), zD(e3)) : e3;
  }],
  transformResponse: [function(e3) {
    const r3 = this.transitional || Jg.transitional, n3 = r3 && r3.forcedJSONParsing, i3 = this.responseType === "json";
    if (e3 && ue.isString(e3) && (n3 && !this.responseType || i3)) {
      const s3 = !(r3 && r3.silentJSONParsing) && i3;
      try {
        return JSON.parse(e3);
      } catch (a3) {
        if (s3)
          throw a3.name === "SyntaxError" ? st.from(a3, st.ERR_BAD_RESPONSE, this, null, this.response) : a3;
      }
    }
    return e3;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: ei.classes.FormData,
    Blob: ei.classes.Blob
  },
  validateStatus: function(e3) {
    return e3 >= 200 && e3 < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ue.forEach(["delete", "get", "head", "post", "put", "patch"], (t10) => {
  Jg.headers[t10] = {};
});
const e0 = Jg, HD = ue.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), GD = (t10) => {
  const e3 = {};
  let r3, n3, i3;
  return t10 && t10.split(`
`).forEach(function(s3) {
    i3 = s3.indexOf(":"), r3 = s3.substring(0, i3).trim().toLowerCase(), n3 = s3.substring(i3 + 1).trim(), !(!r3 || e3[r3] && HD[r3]) && (r3 === "set-cookie" ? e3[r3] ? e3[r3].push(n3) : e3[r3] = [n3] : e3[r3] = e3[r3] ? e3[r3] + ", " + n3 : n3);
  }), e3;
}, Nb = Symbol("internals");
function Ga(t10) {
  return t10 && String(t10).trim().toLowerCase();
}
function Qc(t10) {
  return t10 === false || t10 == null ? t10 : ue.isArray(t10) ? t10.map(Qc) : String(t10);
}
function KD(t10) {
  const e3 = /* @__PURE__ */ Object.create(null), r3 = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n3;
  for (; n3 = r3.exec(t10); )
    e3[n3[1]] = n3[2];
  return e3;
}
const JD = (t10) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t10.trim());
function Zh(t10, e3, r3, n3, i3) {
  if (ue.isFunction(n3))
    return n3.call(this, e3, r3);
  if (i3 && (e3 = r3), !!ue.isString(e3)) {
    if (ue.isString(n3))
      return e3.indexOf(n3) !== -1;
    if (ue.isRegExp(n3))
      return n3.test(e3);
  }
}
function ej(t10) {
  return t10.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e3, r3, n3) => r3.toUpperCase() + n3);
}
function tj(t10, e3) {
  const r3 = ue.toCamelCase(" " + e3);
  ["get", "set", "has"].forEach((n3) => {
    Object.defineProperty(t10, n3 + r3, {
      value: function(i3, o3, s3) {
        return this[n3].call(this, e3, i3, o3, s3);
      },
      configurable: true
    });
  });
}
let Od = class {
  constructor(e3) {
    e3 && this.set(e3);
  }
  set(e3, r3, n3) {
    const i3 = this;
    function o3(a3, l3, u3) {
      const c3 = Ga(l3);
      if (!c3)
        throw new Error("header name must be a non-empty string");
      const f3 = ue.findKey(i3, c3);
      (!f3 || i3[f3] === void 0 || u3 === true || u3 === void 0 && i3[f3] !== false) && (i3[f3 || l3] = Qc(a3));
    }
    const s3 = (a3, l3) => ue.forEach(a3, (u3, c3) => o3(u3, c3, l3));
    return ue.isPlainObject(e3) || e3 instanceof this.constructor ? s3(e3, r3) : ue.isString(e3) && (e3 = e3.trim()) && !JD(e3) ? s3(GD(e3), r3) : e3 != null && o3(r3, e3, n3), this;
  }
  get(e3, r3) {
    if (e3 = Ga(e3), e3) {
      const n3 = ue.findKey(this, e3);
      if (n3) {
        const i3 = this[n3];
        if (!r3)
          return i3;
        if (r3 === true)
          return KD(i3);
        if (ue.isFunction(r3))
          return r3.call(this, i3, n3);
        if (ue.isRegExp(r3))
          return r3.exec(i3);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e3, r3) {
    if (e3 = Ga(e3), e3) {
      const n3 = ue.findKey(this, e3);
      return !!(n3 && this[n3] !== void 0 && (!r3 || Zh(this, this[n3], n3, r3)));
    }
    return false;
  }
  delete(e3, r3) {
    const n3 = this;
    let i3 = false;
    function o3(s3) {
      if (s3 = Ga(s3), s3) {
        const a3 = ue.findKey(n3, s3);
        a3 && (!r3 || Zh(n3, n3[a3], a3, r3)) && (delete n3[a3], i3 = true);
      }
    }
    return ue.isArray(e3) ? e3.forEach(o3) : o3(e3), i3;
  }
  clear(e3) {
    const r3 = Object.keys(this);
    let n3 = r3.length, i3 = false;
    for (; n3--; ) {
      const o3 = r3[n3];
      (!e3 || Zh(this, this[o3], o3, e3, true)) && (delete this[o3], i3 = true);
    }
    return i3;
  }
  normalize(e3) {
    const r3 = this, n3 = {};
    return ue.forEach(this, (i3, o3) => {
      const s3 = ue.findKey(n3, o3);
      if (s3) {
        r3[s3] = Qc(i3), delete r3[o3];
        return;
      }
      const a3 = e3 ? ej(o3) : String(o3).trim();
      a3 !== o3 && delete r3[o3], r3[a3] = Qc(i3), n3[a3] = true;
    }), this;
  }
  concat(...e3) {
    return this.constructor.concat(this, ...e3);
  }
  toJSON(e3) {
    const r3 = /* @__PURE__ */ Object.create(null);
    return ue.forEach(this, (n3, i3) => {
      n3 != null && n3 !== false && (r3[i3] = e3 && ue.isArray(n3) ? n3.join(", ") : n3);
    }), r3;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e3, r3]) => e3 + ": " + r3).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e3) {
    return e3 instanceof this ? e3 : new this(e3);
  }
  static concat(e3, ...r3) {
    const n3 = new this(e3);
    return r3.forEach((i3) => n3.set(i3)), n3;
  }
  static accessor(e3) {
    const n3 = (this[Nb] = this[Nb] = {
      accessors: {}
    }).accessors, i3 = this.prototype;
    function o3(s3) {
      const a3 = Ga(s3);
      n3[a3] || (tj(i3, s3), n3[a3] = true);
    }
    return ue.isArray(e3) ? e3.forEach(o3) : o3(e3), this;
  }
};
Od.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ue.reduceDescriptors(Od.prototype, ({ value: t10 }, e3) => {
  let r3 = e3[0].toUpperCase() + e3.slice(1);
  return {
    get: () => t10,
    set(n3) {
      this[r3] = n3;
    }
  };
});
ue.freezeMethods(Od);
const Qi = Od;
function Mh(t10, e3) {
  const r3 = this || e0, n3 = e3 || r3, i3 = Qi.from(n3.headers);
  let o3 = n3.data;
  return ue.forEach(t10, function(a3) {
    o3 = a3.call(r3, o3, i3.normalize(), e3 ? e3.status : void 0);
  }), i3.normalize(), o3;
}
function xx(t10) {
  return !!(t10 && t10.__CANCEL__);
}
function mu(t10, e3, r3) {
  st.call(this, t10 ?? "canceled", st.ERR_CANCELED, e3, r3), this.name = "CanceledError";
}
ue.inherits(mu, st, {
  __CANCEL__: true
});
function rj(t10, e3, r3) {
  const n3 = r3.config.validateStatus;
  !r3.status || !n3 || n3(r3.status) ? t10(r3) : e3(new st(
    "Request failed with status code " + r3.status,
    [st.ERR_BAD_REQUEST, st.ERR_BAD_RESPONSE][Math.floor(r3.status / 100) - 4],
    r3.config,
    r3.request,
    r3
  ));
}
const nj = ei.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function() {
    return {
      write: function(r3, n3, i3, o3, s3, a3) {
        const l3 = [];
        l3.push(r3 + "=" + encodeURIComponent(n3)), ue.isNumber(i3) && l3.push("expires=" + new Date(i3).toGMTString()), ue.isString(o3) && l3.push("path=" + o3), ue.isString(s3) && l3.push("domain=" + s3), a3 === true && l3.push("secure"), document.cookie = l3.join("; ");
      },
      read: function(r3) {
        const n3 = document.cookie.match(new RegExp("(^|;\\s*)(" + r3 + ")=([^;]*)"));
        return n3 ? decodeURIComponent(n3[3]) : null;
      },
      remove: function(r3) {
        this.write(r3, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }()
);
function ij(t10) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t10);
}
function oj(t10, e3) {
  return e3 ? t10.replace(/\/+$/, "") + "/" + e3.replace(/^\/+/, "") : t10;
}
function Qx(t10, e3) {
  return t10 && !ij(e3) ? oj(t10, e3) : e3;
}
const sj = ei.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const e3 = /(msie|trident)/i.test(navigator.userAgent), r3 = document.createElement("a");
    let n3;
    function i3(o3) {
      let s3 = o3;
      return e3 && (r3.setAttribute("href", s3), s3 = r3.href), r3.setAttribute("href", s3), {
        href: r3.href,
        protocol: r3.protocol ? r3.protocol.replace(/:$/, "") : "",
        host: r3.host,
        search: r3.search ? r3.search.replace(/^\?/, "") : "",
        hash: r3.hash ? r3.hash.replace(/^#/, "") : "",
        hostname: r3.hostname,
        port: r3.port,
        pathname: r3.pathname.charAt(0) === "/" ? r3.pathname : "/" + r3.pathname
      };
    }
    return n3 = i3(window.location.href), function(s3) {
      const a3 = ue.isString(s3) ? i3(s3) : s3;
      return a3.protocol === n3.protocol && a3.host === n3.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return true;
    };
  }()
);
function aj(t10) {
  const e3 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t10);
  return e3 && e3[1] || "";
}
function lj(t10, e3) {
  t10 = t10 || 10;
  const r3 = new Array(t10), n3 = new Array(t10);
  let i3 = 0, o3 = 0, s3;
  return e3 = e3 !== void 0 ? e3 : 1e3, function(l3) {
    const u3 = Date.now(), c3 = n3[o3];
    s3 || (s3 = u3), r3[i3] = l3, n3[i3] = u3;
    let f3 = o3, d3 = 0;
    for (; f3 !== i3; )
      d3 += r3[f3++], f3 = f3 % t10;
    if (i3 = (i3 + 1) % t10, i3 === o3 && (o3 = (o3 + 1) % t10), u3 - s3 < e3)
      return;
    const p10 = c3 && u3 - c3;
    return p10 ? Math.round(d3 * 1e3 / p10) : void 0;
  };
}
function Wb(t10, e3) {
  let r3 = 0;
  const n3 = lj(50, 250);
  return (i3) => {
    const o3 = i3.loaded, s3 = i3.lengthComputable ? i3.total : void 0, a3 = o3 - r3, l3 = n3(a3), u3 = o3 <= s3;
    r3 = o3;
    const c3 = {
      loaded: o3,
      total: s3,
      progress: s3 ? o3 / s3 : void 0,
      bytes: a3,
      rate: l3 || void 0,
      estimated: l3 && s3 && u3 ? (s3 - o3) / l3 : void 0,
      event: i3
    };
    c3[e3 ? "download" : "upload"] = true, t10(c3);
  };
}
const uj = typeof XMLHttpRequest < "u", cj = uj && function(t10) {
  return new Promise(function(r3, n3) {
    let i3 = t10.data;
    const o3 = Qi.from(t10.headers).normalize(), s3 = t10.responseType;
    let a3;
    function l3() {
      t10.cancelToken && t10.cancelToken.unsubscribe(a3), t10.signal && t10.signal.removeEventListener("abort", a3);
    }
    let u3;
    if (ue.isFormData(i3)) {
      if (ei.hasStandardBrowserEnv || ei.hasStandardBrowserWebWorkerEnv)
        o3.setContentType(false);
      else if ((u3 = o3.getContentType()) !== false) {
        const [h10, ...m10] = u3 ? u3.split(";").map((O10) => O10.trim()).filter(Boolean) : [];
        o3.setContentType([h10 || "multipart/form-data", ...m10].join("; "));
      }
    }
    let c3 = new XMLHttpRequest();
    if (t10.auth) {
      const h10 = t10.auth.username || "", m10 = t10.auth.password ? unescape(encodeURIComponent(t10.auth.password)) : "";
      o3.set("Authorization", "Basic " + btoa(h10 + ":" + m10));
    }
    const f3 = Qx(t10.baseURL, t10.url);
    c3.open(t10.method.toUpperCase(), $x(f3, t10.params, t10.paramsSerializer), true), c3.timeout = t10.timeout;
    function d3() {
      if (!c3)
        return;
      const h10 = Qi.from(
        "getAllResponseHeaders" in c3 && c3.getAllResponseHeaders()
      ), O10 = {
        data: !s3 || s3 === "text" || s3 === "json" ? c3.responseText : c3.response,
        status: c3.status,
        statusText: c3.statusText,
        headers: h10,
        config: t10,
        request: c3
      };
      rj(function(v10) {
        r3(v10), l3();
      }, function(v10) {
        n3(v10), l3();
      }, O10), c3 = null;
    }
    if ("onloadend" in c3 ? c3.onloadend = d3 : c3.onreadystatechange = function() {
      !c3 || c3.readyState !== 4 || c3.status === 0 && !(c3.responseURL && c3.responseURL.indexOf("file:") === 0) || setTimeout(d3);
    }, c3.onabort = function() {
      c3 && (n3(new st("Request aborted", st.ECONNABORTED, t10, c3)), c3 = null);
    }, c3.onerror = function() {
      n3(new st("Network Error", st.ERR_NETWORK, t10, c3)), c3 = null;
    }, c3.ontimeout = function() {
      let m10 = t10.timeout ? "timeout of " + t10.timeout + "ms exceeded" : "timeout exceeded";
      const O10 = t10.transitional || wx;
      t10.timeoutErrorMessage && (m10 = t10.timeoutErrorMessage), n3(new st(
        m10,
        O10.clarifyTimeoutError ? st.ETIMEDOUT : st.ECONNABORTED,
        t10,
        c3
      )), c3 = null;
    }, ei.hasStandardBrowserEnv) {
      const h10 = sj(f3) && t10.xsrfCookieName && nj.read(t10.xsrfCookieName);
      h10 && o3.set(t10.xsrfHeaderName, h10);
    }
    i3 === void 0 && o3.setContentType(null), "setRequestHeader" in c3 && ue.forEach(o3.toJSON(), function(m10, O10) {
      c3.setRequestHeader(O10, m10);
    }), ue.isUndefined(t10.withCredentials) || (c3.withCredentials = !!t10.withCredentials), s3 && s3 !== "json" && (c3.responseType = t10.responseType), typeof t10.onDownloadProgress == "function" && c3.addEventListener("progress", Wb(t10.onDownloadProgress, true)), typeof t10.onUploadProgress == "function" && c3.upload && c3.upload.addEventListener("progress", Wb(t10.onUploadProgress)), (t10.cancelToken || t10.signal) && (a3 = (h10) => {
      c3 && (n3(!h10 || h10.type ? new mu(null, t10, c3) : h10), c3.abort(), c3 = null);
    }, t10.cancelToken && t10.cancelToken.subscribe(a3), t10.signal && (t10.signal.aborted ? a3() : t10.signal.addEventListener("abort", a3)));
    const p10 = aj(f3);
    if (p10 && ei.protocols.indexOf(p10) === -1) {
      n3(new st("Unsupported protocol " + p10 + ":", st.ERR_BAD_REQUEST, t10));
      return;
    }
    c3.send(i3 || null);
  });
}, VO = {
  http: XD,
  xhr: cj
};
ue.forEach(VO, (t10, e3) => {
  if (t10) {
    try {
      Object.defineProperty(t10, "name", { value: e3 });
    } catch {
    }
    Object.defineProperty(t10, "adapterName", { value: e3 });
  }
});
const Vb = (t10) => `- ${t10}`, fj = (t10) => ue.isFunction(t10) || t10 === null || t10 === false, Tx = {
  getAdapter: (t10) => {
    t10 = ue.isArray(t10) ? t10 : [t10];
    const { length: e3 } = t10;
    let r3, n3;
    const i3 = {};
    for (let o3 = 0; o3 < e3; o3++) {
      r3 = t10[o3];
      let s3;
      if (n3 = r3, !fj(r3) && (n3 = VO[(s3 = String(r3)).toLowerCase()], n3 === void 0))
        throw new st(`Unknown adapter '${s3}'`);
      if (n3)
        break;
      i3[s3 || "#" + o3] = n3;
    }
    if (!n3) {
      const o3 = Object.entries(i3).map(
        ([a3, l3]) => `adapter ${a3} ` + (l3 === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s3 = e3 ? o3.length > 1 ? `since :
` + o3.map(Vb).join(`
`) : " " + Vb(o3[0]) : "as no adapter specified";
      throw new st(
        "There is no suitable adapter to dispatch the request " + s3,
        "ERR_NOT_SUPPORT"
      );
    }
    return n3;
  },
  adapters: VO
};
function Nh(t10) {
  if (t10.cancelToken && t10.cancelToken.throwIfRequested(), t10.signal && t10.signal.aborted)
    throw new mu(null, t10);
}
function Yb(t10) {
  return Nh(t10), t10.headers = Qi.from(t10.headers), t10.data = Mh.call(
    t10,
    t10.transformRequest
  ), ["post", "put", "patch"].indexOf(t10.method) !== -1 && t10.headers.setContentType("application/x-www-form-urlencoded", false), Tx.getAdapter(t10.adapter || e0.adapter)(t10).then(function(n3) {
    return Nh(t10), n3.data = Mh.call(
      t10,
      t10.transformResponse,
      n3
    ), n3.headers = Qi.from(n3.headers), n3;
  }, function(n3) {
    return xx(n3) || (Nh(t10), n3 && n3.response && (n3.response.data = Mh.call(
      t10,
      t10.transformResponse,
      n3.response
    ), n3.response.headers = Qi.from(n3.response.headers))), Promise.reject(n3);
  });
}
const Lb = (t10) => t10 instanceof Qi ? t10.toJSON() : t10;
function Oa(t10, e3) {
  e3 = e3 || {};
  const r3 = {};
  function n3(u3, c3, f3) {
    return ue.isPlainObject(u3) && ue.isPlainObject(c3) ? ue.merge.call({ caseless: f3 }, u3, c3) : ue.isPlainObject(c3) ? ue.merge({}, c3) : ue.isArray(c3) ? c3.slice() : c3;
  }
  function i3(u3, c3, f3) {
    if (ue.isUndefined(c3)) {
      if (!ue.isUndefined(u3))
        return n3(void 0, u3, f3);
    } else
      return n3(u3, c3, f3);
  }
  function o3(u3, c3) {
    if (!ue.isUndefined(c3))
      return n3(void 0, c3);
  }
  function s3(u3, c3) {
    if (ue.isUndefined(c3)) {
      if (!ue.isUndefined(u3))
        return n3(void 0, u3);
    } else
      return n3(void 0, c3);
  }
  function a3(u3, c3, f3) {
    if (f3 in e3)
      return n3(u3, c3);
    if (f3 in t10)
      return n3(void 0, u3);
  }
  const l3 = {
    url: o3,
    method: o3,
    data: o3,
    baseURL: s3,
    transformRequest: s3,
    transformResponse: s3,
    paramsSerializer: s3,
    timeout: s3,
    timeoutMessage: s3,
    withCredentials: s3,
    adapter: s3,
    responseType: s3,
    xsrfCookieName: s3,
    xsrfHeaderName: s3,
    onUploadProgress: s3,
    onDownloadProgress: s3,
    decompress: s3,
    maxContentLength: s3,
    maxBodyLength: s3,
    beforeRedirect: s3,
    transport: s3,
    httpAgent: s3,
    httpsAgent: s3,
    cancelToken: s3,
    socketPath: s3,
    responseEncoding: s3,
    validateStatus: a3,
    headers: (u3, c3) => i3(Lb(u3), Lb(c3), true)
  };
  return ue.forEach(Object.keys(Object.assign({}, t10, e3)), function(c3) {
    const f3 = l3[c3] || i3, d3 = f3(t10[c3], e3[c3], c3);
    ue.isUndefined(d3) && f3 !== a3 || (r3[c3] = d3);
  }), r3;
}
const kx = "1.6.1", t0 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t10, e3) => {
  t0[t10] = function(n3) {
    return typeof n3 === t10 || "a" + (e3 < 1 ? "n " : " ") + t10;
  };
});
const Bb = {};
t0.transitional = function(e3, r3, n3) {
  function i3(o3, s3) {
    return "[Axios v" + kx + "] Transitional option '" + o3 + "'" + s3 + (n3 ? ". " + n3 : "");
  }
  return (o3, s3, a3) => {
    if (e3 === false)
      throw new st(
        i3(s3, " has been removed" + (r3 ? " in " + r3 : "")),
        st.ERR_DEPRECATED
      );
    return r3 && !Bb[s3] && (Bb[s3] = true, console.warn(
      i3(
        s3,
        " has been deprecated since v" + r3 + " and will be removed in the near future"
      )
    )), e3 ? e3(o3, s3, a3) : true;
  };
};
function dj(t10, e3, r3) {
  if (typeof t10 != "object")
    throw new st("options must be an object", st.ERR_BAD_OPTION_VALUE);
  const n3 = Object.keys(t10);
  let i3 = n3.length;
  for (; i3-- > 0; ) {
    const o3 = n3[i3], s3 = e3[o3];
    if (s3) {
      const a3 = t10[o3], l3 = a3 === void 0 || s3(a3, o3, t10);
      if (l3 !== true)
        throw new st("option " + o3 + " must be " + l3, st.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r3 !== true)
      throw new st("Unknown option " + o3, st.ERR_BAD_OPTION);
  }
}
const YO = {
  assertOptions: dj,
  validators: t0
}, Yi = YO.validators;
let mf = class {
  constructor(e3) {
    this.defaults = e3, this.interceptors = {
      request: new Mb(),
      response: new Mb()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(e3, r3) {
    typeof e3 == "string" ? (r3 = r3 || {}, r3.url = e3) : r3 = e3 || {}, r3 = Oa(this.defaults, r3);
    const { transitional: n3, paramsSerializer: i3, headers: o3 } = r3;
    n3 !== void 0 && YO.assertOptions(n3, {
      silentJSONParsing: Yi.transitional(Yi.boolean),
      forcedJSONParsing: Yi.transitional(Yi.boolean),
      clarifyTimeoutError: Yi.transitional(Yi.boolean)
    }, false), i3 != null && (ue.isFunction(i3) ? r3.paramsSerializer = {
      serialize: i3
    } : YO.assertOptions(i3, {
      encode: Yi.function,
      serialize: Yi.function
    }, true)), r3.method = (r3.method || this.defaults.method || "get").toLowerCase();
    let s3 = o3 && ue.merge(
      o3.common,
      o3[r3.method]
    );
    o3 && ue.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (h10) => {
        delete o3[h10];
      }
    ), r3.headers = Qi.concat(s3, o3);
    const a3 = [];
    let l3 = true;
    this.interceptors.request.forEach(function(m10) {
      typeof m10.runWhen == "function" && m10.runWhen(r3) === false || (l3 = l3 && m10.synchronous, a3.unshift(m10.fulfilled, m10.rejected));
    });
    const u3 = [];
    this.interceptors.response.forEach(function(m10) {
      u3.push(m10.fulfilled, m10.rejected);
    });
    let c3, f3 = 0, d3;
    if (!l3) {
      const h10 = [Yb.bind(this), void 0];
      for (h10.unshift.apply(h10, a3), h10.push.apply(h10, u3), d3 = h10.length, c3 = Promise.resolve(r3); f3 < d3; )
        c3 = c3.then(h10[f3++], h10[f3++]);
      return c3;
    }
    d3 = a3.length;
    let p10 = r3;
    for (f3 = 0; f3 < d3; ) {
      const h10 = a3[f3++], m10 = a3[f3++];
      try {
        p10 = h10(p10);
      } catch (O10) {
        m10.call(this, O10);
        break;
      }
    }
    try {
      c3 = Yb.call(this, p10);
    } catch (h10) {
      return Promise.reject(h10);
    }
    for (f3 = 0, d3 = u3.length; f3 < d3; )
      c3 = c3.then(u3[f3++], u3[f3++]);
    return c3;
  }
  getUri(e3) {
    e3 = Oa(this.defaults, e3);
    const r3 = Qx(e3.baseURL, e3.url);
    return $x(r3, e3.params, e3.paramsSerializer);
  }
};
ue.forEach(["delete", "get", "head", "options"], function(e3) {
  mf.prototype[e3] = function(r3, n3) {
    return this.request(Oa(n3 || {}, {
      method: e3,
      url: r3,
      data: (n3 || {}).data
    }));
  };
});
ue.forEach(["post", "put", "patch"], function(e3) {
  function r3(n3) {
    return function(o3, s3, a3) {
      return this.request(Oa(a3 || {}, {
        method: e3,
        headers: n3 ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o3,
        data: s3
      }));
    };
  }
  mf.prototype[e3] = r3(), mf.prototype[e3 + "Form"] = r3(true);
});
const Tc = mf;
let hj = class Ex {
  constructor(e3) {
    if (typeof e3 != "function")
      throw new TypeError("executor must be a function.");
    let r3;
    this.promise = new Promise(function(o3) {
      r3 = o3;
    });
    const n3 = this;
    this.promise.then((i3) => {
      if (!n3._listeners)
        return;
      let o3 = n3._listeners.length;
      for (; o3-- > 0; )
        n3._listeners[o3](i3);
      n3._listeners = null;
    }), this.promise.then = (i3) => {
      let o3;
      const s3 = new Promise((a3) => {
        n3.subscribe(a3), o3 = a3;
      }).then(i3);
      return s3.cancel = function() {
        n3.unsubscribe(o3);
      }, s3;
    }, e3(function(o3, s3, a3) {
      n3.reason || (n3.reason = new mu(o3, s3, a3), r3(n3.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e3) {
    if (this.reason) {
      e3(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e3) : this._listeners = [e3];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e3) {
    if (!this._listeners)
      return;
    const r3 = this._listeners.indexOf(e3);
    r3 !== -1 && this._listeners.splice(r3, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e3;
    return {
      token: new Ex(function(i3) {
        e3 = i3;
      }),
      cancel: e3
    };
  }
};
const pj = hj;
function Oj(t10) {
  return function(r3) {
    return t10.apply(null, r3);
  };
}
function mj(t10) {
  return ue.isObject(t10) && t10.isAxiosError === true;
}
const LO = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(LO).forEach(([t10, e3]) => {
  LO[e3] = t10;
});
const gj = LO;
function Cx(t10) {
  const e3 = new Tc(t10), r3 = cx(Tc.prototype.request, e3);
  return ue.extend(r3, Tc.prototype, e3, { allOwnKeys: true }), ue.extend(r3, e3, null, { allOwnKeys: true }), r3.create = function(i3) {
    return Cx(Oa(t10, i3));
  }, r3;
}
const zt = Cx(e0);
zt.Axios = Tc;
zt.CanceledError = mu;
zt.CancelToken = pj;
zt.isCancel = xx;
zt.VERSION = kx;
zt.toFormData = pd;
zt.AxiosError = st;
zt.Cancel = zt.CanceledError;
zt.all = function(e3) {
  return Promise.all(e3);
};
zt.spread = Oj;
zt.isAxiosError = mj;
zt.mergeConfig = Oa;
zt.AxiosHeaders = Qi;
zt.formToJSON = (t10) => _x(ue.isHTMLForm(t10) ? new FormData(t10) : t10);
zt.getAdapter = Tx.getAdapter;
zt.HttpStatusCode = gj;
zt.default = zt;
const Rx = zt, {
  Axios: tpe,
  AxiosError: rpe,
  CanceledError: npe,
  isCancel: ipe,
  CancelToken: ope,
  VERSION: spe,
  all: ape,
  Cancel: lpe,
  isAxiosError: upe,
  spread: cpe,
  toFormData: fpe,
  AxiosHeaders: yj,
  HttpStatusCode: dpe,
  formToJSON: hpe,
  getAdapter: ppe,
  mergeConfig: Ope
} = Rx;
let Ax = (t10 = 21) => crypto.getRandomValues(new Uint8Array(t10)).reduce((e3, r3) => (r3 &= 63, r3 < 36 ? e3 += r3.toString(36) : r3 < 62 ? e3 += (r3 - 26).toString(36).toUpperCase() : r3 > 62 ? e3 += "-" : e3 += "_", e3), "");
function Ux(t10, e3) {
  for (const [r3, n3] of Object.entries(t10))
    n3 !== null && typeof n3 == "object" ? (e3[r3] ?? (e3[r3] = new n3.__proto__.constructor()), Ux(n3, e3[r3])) : typeof n3 < "u" && (e3[r3] = n3);
  return e3;
}
function zO({
  serverState: t10,
  authenticationState: e3,
  operation: r3
}) {
  var o3;
  const n3 = Ix(
    {
      url: KO(t10)
    },
    GO(r3),
    Mx(e3)
  ), i3 = GO(r3);
  return {
    id: r3.operationId,
    name: r3.name,
    type: n3.method,
    path: i3.path ?? "",
    parameters: (r3.information.parameters ?? []).map((s3) => ({
      name: s3.name,
      value: ""
    })),
    cookies: n3.cookies,
    query: n3.queryString,
    headers: n3.headers,
    url: KO(t10) ?? "",
    body: (o3 = n3.postData) == null ? void 0 : o3.text
  };
}
const Hr = (t10, e3, r3 = 0) => {
  if (r3 > 10)
    return null;
  if (t10.type === "string")
    return t10.example !== void 0 ? t10.example : (e3 == null ? void 0 : e3.emptyString) ?? "";
  if (t10.type === "array")
    return t10.example !== void 0 ? t10.example : t10.items.type === "object" ? [Hr(t10.items, e3, r3 + 1)] : [];
  const n3 = {};
  return typeof t10.properties != "object" || Object.keys(t10.properties).forEach((i3) => {
    var d3, p10, h10, m10, O10;
    const o3 = t10.properties[i3], s3 = e3 != null && e3.xml ? (d3 = o3.xml) == null ? void 0 : d3.name : void 0;
    if (o3.example !== void 0) {
      n3[s3 ?? i3] = o3.example;
      return;
    }
    if (o3.default !== void 0) {
      n3[s3 ?? i3] = o3.default;
      return;
    }
    if (o3.enum !== void 0) {
      n3[s3 ?? i3] = o3.enum[0];
      return;
    }
    if (o3.properties !== void 0) {
      n3[s3 ?? i3] = Hr(
        o3,
        e3,
        r3 + 1
      );
      return;
    }
    if (((p10 = o3.items) == null ? void 0 : p10.properties) !== void 0) {
      const g = Hr(o3.items, e3, r3 + 1);
      (o3 == null ? void 0 : o3.type) === "array" ? n3[s3 ?? i3] = [g] : n3[s3 ?? i3] = null;
      return;
    }
    const a3 = (m10 = (h10 = o3 == null ? void 0 : o3.items) == null ? void 0 : h10.xml) == null ? void 0 : m10.name, l3 = (e3 == null ? void 0 : e3.xml) && ((O10 = o3.xml) == null ? void 0 : O10.wrapped) && a3, u3 = o3.items ? Hr(o3.items, e3, r3 + 1) : [], c3 = u3 ? Array.isArray(u3) ? u3 : [u3] : [], f3 = {
      array: l3 ? { [a3]: c3 } : c3,
      string: (e3 == null ? void 0 : e3.emptyString) ?? "",
      boolean: true,
      integer: 1,
      number: o3.min ?? 0,
      // TODO: Need to check the schema and add a default value
      object: {}
    };
    if (f3[o3.type] !== void 0) {
      n3[s3 ?? i3] = f3[o3.type];
      return;
    }
    if (Array.isArray(o3.oneOf)) {
      const g = o3.oneOf[0];
      if (f3[g.type] !== void 0) {
        n3[s3 ?? i3] = Hr(
          g,
          e3,
          r3 + 1
        );
        return;
      }
    }
    if (Array.isArray(o3.allOf)) {
      o3.allOf.forEach((g) => {
        const v10 = Hr(g, e3, r3 + 1);
        n3[s3 ?? i3] = typeof v10 == "object" ? {
          ...n3[s3 ?? i3] ?? {},
          ...v10
        } : v10;
      });
      return;
    }
    console.warn(
      `[getExampleFromSchema] Unknown property type "${o3.type}" for property "${i3}".`
    ), n3[s3 ?? i3] = null;
  }), n3;
}, Ix = (...t10) => {
  let e3 = {
    httpVersion: "1.1",
    method: "GET",
    url: "",
    path: "",
    headers: [],
    headersSize: -1,
    queryString: [],
    cookies: [],
    bodySize: -1
  };
  t10.forEach((i3) => {
    e3 = {
      ...e3,
      ...i3,
      headers: [...e3.headers, ...i3.headers ?? []],
      queryString: [
        ...e3.queryString,
        ...i3.queryString ?? []
      ],
      cookies: [...e3.cookies, ...i3.cookies ?? []]
    };
  }), e3.headers = o0(
    yj.from(
      cl(e3.headers, "name", "value")
    ).normalize(true),
    "name"
  );
  const { path: r3, ...n3 } = e3;
  return r3 ? {
    ...n3,
    url: `${e3.url}${r3}`
  } : n3;
}, Fx = (t10) => t10.slug ? `description/${t10.slug}` : "", $F = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g, wF = Object.hasOwnProperty;
class i0 {
  /**
   * Create a new slug class.
   */
  constructor() {
    this.occurrences, this.reset();
  }
  /**
   * Generate a unique slug.
  *
  * Tracks previously generated slugs: repeated calls with the same value
  * will result in different slugs.
  * Use the `slug` function to get same slugs.
   *
   * @param  {string} value
   *   String of text to slugify
   * @param  {boolean} [maintainCase=false]
   *   Keep the current case, otherwise make all lowercase
   * @return {string}
   *   A unique slug string
   */
  slug(e3, r3) {
    const n3 = this;
    let i3 = PF(e3, r3 === true);
    const o3 = i3;
    for (; wF.call(n3.occurrences, i3); )
      n3.occurrences[o3]++, i3 = o3 + "-" + n3.occurrences[o3];
    return n3.occurrences[i3] = 0, i3;
  }
  /**
   * Reset - Forget all previous slugs
   *
   * @return void
   */
  reset() {
    this.occurrences = /* @__PURE__ */ Object.create(null);
  }
}
function PF(t10, e3) {
  return typeof t10 != "string" ? "" : (e3 || (t10 = t10.toLowerCase()), t10.replace($F, "").replace(/ /g, "-"));
}
const _F = new i0(), HO = async (t10) => (await M$3(t10)).map((r3) => ({
  ...r3,
  slug: _F.slug(r3.value)
})), Zx = (t10) => {
  const e3 = Math.min(...t10.map((r3) => r3.depth));
  return e3 >= 1 && e3 <= 6 ? e3 : 1;
}, Wo = (t10) => t10 ? `model/${new i0().slug(t10)}` : "models", Tn = (t10) => `tag/${new i0().slug(t10.name)}`, ss = (t10, e3) => `${Tn(e3)}/[${t10.httpVerb}]${t10.path}`;
function Mx(t10) {
  var i3;
  const e3 = [], r3 = [], n3 = [];
  if (t10.securitySchemeKey) {
    const o3 = (i3 = t10.securitySchemes) == null ? void 0 : i3[t10.securitySchemeKey];
    o3 && (o3.type === "apiKey" ? o3.in === "header" ? e3.push({
      name: o3.name,
      value: t10.apiKey.token
    }) : o3.in === "cookie" ? n3.push({
      name: o3.name,
      value: t10.apiKey.token
    }) : o3.in === "query" && r3.push({
      name: o3.name,
      value: t10.apiKey.token
    }) : (o3.type === "http" || o3.type === "basic") && (o3.type === "basic" || o3.scheme === "basic" ? e3.push({
      name: "Authorization",
      value: `Basic ${$e.Buffer.from(
        `${t10.http.basic.username}:${t10.http.basic.password}`
      ).toString("base64")}`
    }) : o3.scheme === "bearer" && e3.push({
      name: "Authorization",
      value: `Bearer ${t10.http.bearer.token}`
    })));
  }
  return { headers: e3, queryString: r3, cookies: n3 };
}
function xF(t10, e3) {
  const r3 = function(i3, o3, s3) {
    let a3 = "";
    if (i3 instanceof Array)
      for (let l3 = 0, u3 = i3.length; l3 < u3; l3++)
        a3 += s3 + r3(i3[l3], o3, s3 + "	") + `
`;
    else if (typeof i3 == "object") {
      let l3 = false;
      a3 += s3 + "<" + o3;
      for (const u3 in i3)
        u3.charAt(0) == "@" ? a3 += " " + u3.substr(1) + '="' + i3[u3].toString() + '"' : l3 = true;
      if (a3 += l3 ? ">" : "/>", l3) {
        for (const u3 in i3)
          u3 == "#text" ? a3 += i3[u3] : u3 == "#cdata" ? a3 += "<![CDATA[" + i3[u3] + "]]>" : u3.charAt(0) != "@" && (a3 += r3(i3[u3], u3, s3 + "	"));
        a3 += (a3.charAt(a3.length - 1) == `
` ? s3 : "") + "</" + o3 + ">";
      }
    } else
      a3 += s3 + "<" + o3 + ">" + i3.toString() + "</" + o3 + ">";
    return a3;
  };
  let n3 = "";
  for (const i3 in t10)
    n3 += r3(t10[i3], i3, "");
  return e3 ? n3.replace(/\t/g, e3) : n3.replace(/\t|\n/g, "");
}
const GO = (t10, e3) => {
  let r3 = t10.path;
  if ((e3 == null ? void 0 : e3.replaceVariables) === true) {
    const i3 = r3.match(/{(.*?)}/g);
    i3 && i3.forEach((o3) => {
      const s3 = o3.replace(/{|}/g, "");
      r3 = r3.replace(o3, `__${s3.toUpperCase()}__`);
    });
  }
  const n3 = QF(t10);
  return {
    method: t10.httpVerb.toUpperCase(),
    path: r3,
    headers: n3 == null ? void 0 : n3.headers,
    postData: n3 == null ? void 0 : n3.postData
  };
};
function QF(t10) {
  var s3, a3, l3;
  const r3 = [
    "application/json",
    "application/octet-stream",
    "application/x-www-form-urlencoded",
    "application/xml",
    "multipart/form-data",
    "text/plain"
  ].find(
    (u3) => {
      var c3, f3, d3;
      return !!((d3 = (f3 = (c3 = t10.information) == null ? void 0 : c3.requestBody) == null ? void 0 : f3.content) != null && d3[u3]);
    }
  );
  if (!r3)
    return null;
  const n3 = (l3 = (a3 = (s3 = t10.information) == null ? void 0 : s3.requestBody) == null ? void 0 : a3.content) == null ? void 0 : l3[r3], i3 = [
    {
      name: "Content-Type",
      value: r3
    }
  ], o3 = n3 != null && n3.example ? n3 == null ? void 0 : n3.example : void 0;
  if (r3 === "application/json") {
    const u3 = n3 != null && n3.schema ? Hr(n3 == null ? void 0 : n3.schema) : null;
    return {
      headers: i3,
      postData: {
        mimeType: r3,
        text: o3 ?? JSON.stringify(u3, null, 2)
      }
    };
  }
  if (r3 === "application/xml") {
    const u3 = n3 != null && n3.schema ? Hr(n3 == null ? void 0 : n3.schema, {
      xml: true
    }) : null;
    return {
      headers: i3,
      postData: {
        mimeType: r3,
        text: o3 ?? xF(u3, "  ")
      }
    };
  }
  if (r3 === "application/octet-stream")
    return {
      headers: i3,
      postData: {
        mimeType: r3,
        text: "BINARY"
      }
    };
  if (r3 === "text/plain") {
    const u3 = n3 != null && n3.schema ? Hr(n3 == null ? void 0 : n3.schema, {
      xml: true
    }) : null;
    return {
      headers: i3,
      postData: {
        mimeType: r3,
        text: o3 ?? u3 ?? ""
      }
    };
  }
  if (r3 === "application/x-www-form-urlencoded")
    return {
      headers: i3,
      postData: {
        mimeType: r3
        // TODO: We have an object, but how do we get that kind of array from the object?
        // Don’t forget to include nested properties … :|
        // params: [
        //   {
        //     name: 'foo',
        //     value: 'bar',
        //   },
        // ],
      }
    };
  if (r3 === "multipart/form-data")
    return {
      headers: i3,
      postData: {
        mimeType: r3
        // TODO: We have an object, but how do we get that kind of array from the object?
        // Don’t forget to include nested properties … :|
        // params: [
        //   {
        //     name: 'foo',
        //     value: 'bar',
        //   },
        // ],
      }
    };
}
function Nx(t10, e3) {
  const r3 = /{{\s*([\w.-]+)\s*}}/g, n3 = /{\s*([\w.-]+)\s*}/g, i3 = (o3, s3) => {
    if (typeof e3 == "function")
      return e3(s3);
    {
      const a3 = e3 == null ? void 0 : e3.find(
        (l3) => l3.name === s3
      );
      return ((a3 == null ? void 0 : a3.value) ?? "").toString();
    }
  };
  return t10.replace(r3, i3).replace(n3, i3);
}
function KO(t10) {
  var r3, n3, i3, o3;
  const e3 = t10.selectedServer === null ? ((n3 = (r3 = t10 == null ? void 0 : t10.servers) == null ? void 0 : r3[0]) == null ? void 0 : n3.url) ?? void 0 : (o3 = (i3 = t10 == null ? void 0 : t10.servers) == null ? void 0 : i3[t10.selectedServer]) == null ? void 0 : o3.url;
  return e3 ? Nx(e3, t10 == null ? void 0 : t10.variables) : void 0;
}
const Wx = (t10) => {
  var e3;
  return !!Object.keys(((e3 = t10 == null ? void 0 : t10.components) == null ? void 0 : e3.schemas) ?? {}).length;
}, TF = (t10) => {
  var e3;
  return !!Object.keys(((e3 = t10 == null ? void 0 : t10.components) == null ? void 0 : e3.securitySchemes) ?? {}).length;
}, tS = (t10) => {
  if (typeof t10 != "string")
    return false;
  try {
    JSON.parse(t10);
  } catch {
    return false;
  }
  return true;
}, o0 = (t10, e3) => Object.keys(t10).map((r3) => ({
  [e3 ?? r3]: r3,
  value: t10[r3]
}));
function kF(t10, e3) {
  return Object.keys(t10).forEach((r3) => {
    Object.hasOwn(e3, r3) || delete t10[r3];
  }), Object.assign(t10, e3), t10;
}
const _s = (t10) => {
  try {
    return JSON.stringify(typeof t10 == "string" ? JSON.parse(t10) : t10, null, 2);
  } catch {
    return console.log("[prettyPrintJson] Error parsing JSON", t10), t10;
  }
}, Js = async (t10) => {
  var e3;
  (e3 = document.getElementById(t10)) == null || e3.scrollIntoView();
};
function EF(t10, e3 = 1) {
  const r3 = new RegExp(`^(?=#{${e3}} )`, "m");
  return t10.split(r3).map((n3) => n3.trim()).filter(Boolean);
}
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function Vx(t10) {
  return typeof t10 > "u" || t10 === null;
}
function CF(t10) {
  return typeof t10 == "object" && t10 !== null;
}
function RF(t10) {
  return Array.isArray(t10) ? t10 : Vx(t10) ? [] : [t10];
}
function AF(t10, e3) {
  var r3, n3, i3, o3;
  if (e3)
    for (o3 = Object.keys(e3), r3 = 0, n3 = o3.length; r3 < n3; r3 += 1)
      i3 = o3[r3], t10[i3] = e3[i3];
  return t10;
}
function XF(t10, e3) {
  var r3 = "", n3;
  for (n3 = 0; n3 < e3; n3 += 1)
    r3 += t10;
  return r3;
}
function qF(t10) {
  return t10 === 0 && Number.NEGATIVE_INFINITY === 1 / t10;
}
var DF = Vx, jF = CF, UF = RF, IF = XF, FF = qF, ZF = AF, Kt = {
  isNothing: DF,
  isObject: jF,
  toArray: UF,
  repeat: IF,
  isNegativeZero: FF,
  extend: ZF
};
function Yx(t10, e3) {
  var r3 = "", n3 = t10.reason || "(unknown reason)";
  return t10.mark ? (t10.mark.name && (r3 += 'in "' + t10.mark.name + '" '), r3 += "(" + (t10.mark.line + 1) + ":" + (t10.mark.column + 1) + ")", !e3 && t10.mark.snippet && (r3 += `

` + t10.mark.snippet), n3 + " " + r3) : n3;
}
function Ll(t10, e3) {
  Error.call(this), this.name = "YAMLException", this.reason = t10, this.mark = e3, this.message = Yx(this, false), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
Ll.prototype = Object.create(Error.prototype);
Ll.prototype.constructor = Ll;
Ll.prototype.toString = function(e3) {
  return this.name + ": " + Yx(this, e3);
};
var Er = Ll;
var WF = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], VF = [
  "scalar",
  "sequence",
  "mapping"
];
function YF(t10) {
  var e3 = {};
  return t10 !== null && Object.keys(t10).forEach(function(r3) {
    t10[r3].forEach(function(n3) {
      e3[String(n3)] = r3;
    });
  }), e3;
}
function LF(t10, e3) {
  if (e3 = e3 || {}, Object.keys(e3).forEach(function(r3) {
    if (WF.indexOf(r3) === -1)
      throw new Er('Unknown option "' + r3 + '" is met in definition of "' + t10 + '" YAML type.');
  }), this.options = e3, this.tag = t10, this.kind = e3.kind || null, this.resolve = e3.resolve || function() {
    return true;
  }, this.construct = e3.construct || function(r3) {
    return r3;
  }, this.instanceOf = e3.instanceOf || null, this.predicate = e3.predicate || null, this.represent = e3.represent || null, this.representName = e3.representName || null, this.defaultStyle = e3.defaultStyle || null, this.multi = e3.multi || false, this.styleAliases = YF(e3.styleAliases || null), VF.indexOf(this.kind) === -1)
    throw new Er('Unknown kind "' + this.kind + '" is specified for "' + t10 + '" YAML type.');
}
var dr = LF;
function rS(t10, e3) {
  var r3 = [];
  return t10[e3].forEach(function(n3) {
    var i3 = r3.length;
    r3.forEach(function(o3, s3) {
      o3.tag === n3.tag && o3.kind === n3.kind && o3.multi === n3.multi && (i3 = s3);
    }), r3[i3] = n3;
  }), r3;
}
function BF() {
  var t10 = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, e3, r3;
  function n3(i3) {
    i3.multi ? (t10.multi[i3.kind].push(i3), t10.multi.fallback.push(i3)) : t10[i3.kind][i3.tag] = t10.fallback[i3.tag] = i3;
  }
  for (e3 = 0, r3 = arguments.length; e3 < r3; e3 += 1)
    arguments[e3].forEach(n3);
  return t10;
}
function JO(t10) {
  return this.extend(t10);
}
JO.prototype.extend = function(e3) {
  var r3 = [], n3 = [];
  if (e3 instanceof dr)
    n3.push(e3);
  else if (Array.isArray(e3))
    n3 = n3.concat(e3);
  else if (e3 && (Array.isArray(e3.implicit) || Array.isArray(e3.explicit)))
    e3.implicit && (r3 = r3.concat(e3.implicit)), e3.explicit && (n3 = n3.concat(e3.explicit));
  else
    throw new Er("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  r3.forEach(function(o3) {
    if (!(o3 instanceof dr))
      throw new Er("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (o3.loadKind && o3.loadKind !== "scalar")
      throw new Er("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (o3.multi)
      throw new Er("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), n3.forEach(function(o3) {
    if (!(o3 instanceof dr))
      throw new Er("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i3 = Object.create(JO.prototype);
  return i3.implicit = (this.implicit || []).concat(r3), i3.explicit = (this.explicit || []).concat(n3), i3.compiledImplicit = rS(i3, "implicit"), i3.compiledExplicit = rS(i3, "explicit"), i3.compiledTypeMap = BF(i3.compiledImplicit, i3.compiledExplicit), i3;
};
var Lx = JO, Bx = new dr("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(t10) {
    return t10 !== null ? t10 : "";
  }
}), zx = new dr("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(t10) {
    return t10 !== null ? t10 : [];
  }
}), Hx = new dr("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(t10) {
    return t10 !== null ? t10 : {};
  }
}), Gx = new Lx({
  explicit: [
    Bx,
    zx,
    Hx
  ]
});
function zF(t10) {
  if (t10 === null)
    return true;
  var e3 = t10.length;
  return e3 === 1 && t10 === "~" || e3 === 4 && (t10 === "null" || t10 === "Null" || t10 === "NULL");
}
function HF() {
  return null;
}
function GF(t10) {
  return t10 === null;
}
var Kx = new dr("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: zF,
  construct: HF,
  predicate: GF,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function KF(t10) {
  if (t10 === null)
    return false;
  var e3 = t10.length;
  return e3 === 4 && (t10 === "true" || t10 === "True" || t10 === "TRUE") || e3 === 5 && (t10 === "false" || t10 === "False" || t10 === "FALSE");
}
function JF(t10) {
  return t10 === "true" || t10 === "True" || t10 === "TRUE";
}
function eZ(t10) {
  return Object.prototype.toString.call(t10) === "[object Boolean]";
}
var Jx = new dr("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: KF,
  construct: JF,
  predicate: eZ,
  represent: {
    lowercase: function(t10) {
      return t10 ? "true" : "false";
    },
    uppercase: function(t10) {
      return t10 ? "TRUE" : "FALSE";
    },
    camelcase: function(t10) {
      return t10 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function tZ(t10) {
  return 48 <= t10 && t10 <= 57 || 65 <= t10 && t10 <= 70 || 97 <= t10 && t10 <= 102;
}
function rZ(t10) {
  return 48 <= t10 && t10 <= 55;
}
function nZ(t10) {
  return 48 <= t10 && t10 <= 57;
}
function iZ(t10) {
  if (t10 === null)
    return false;
  var e3 = t10.length, r3 = 0, n3 = false, i3;
  if (!e3)
    return false;
  if (i3 = t10[r3], (i3 === "-" || i3 === "+") && (i3 = t10[++r3]), i3 === "0") {
    if (r3 + 1 === e3)
      return true;
    if (i3 = t10[++r3], i3 === "b") {
      for (r3++; r3 < e3; r3++)
        if (i3 = t10[r3], i3 !== "_") {
          if (i3 !== "0" && i3 !== "1")
            return false;
          n3 = true;
        }
      return n3 && i3 !== "_";
    }
    if (i3 === "x") {
      for (r3++; r3 < e3; r3++)
        if (i3 = t10[r3], i3 !== "_") {
          if (!tZ(t10.charCodeAt(r3)))
            return false;
          n3 = true;
        }
      return n3 && i3 !== "_";
    }
    if (i3 === "o") {
      for (r3++; r3 < e3; r3++)
        if (i3 = t10[r3], i3 !== "_") {
          if (!rZ(t10.charCodeAt(r3)))
            return false;
          n3 = true;
        }
      return n3 && i3 !== "_";
    }
  }
  if (i3 === "_")
    return false;
  for (; r3 < e3; r3++)
    if (i3 = t10[r3], i3 !== "_") {
      if (!nZ(t10.charCodeAt(r3)))
        return false;
      n3 = true;
    }
  return !(!n3 || i3 === "_");
}
function oZ(t10) {
  var e3 = t10, r3 = 1, n3;
  if (e3.indexOf("_") !== -1 && (e3 = e3.replace(/_/g, "")), n3 = e3[0], (n3 === "-" || n3 === "+") && (n3 === "-" && (r3 = -1), e3 = e3.slice(1), n3 = e3[0]), e3 === "0")
    return 0;
  if (n3 === "0") {
    if (e3[1] === "b")
      return r3 * parseInt(e3.slice(2), 2);
    if (e3[1] === "x")
      return r3 * parseInt(e3.slice(2), 16);
    if (e3[1] === "o")
      return r3 * parseInt(e3.slice(2), 8);
  }
  return r3 * parseInt(e3, 10);
}
function sZ(t10) {
  return Object.prototype.toString.call(t10) === "[object Number]" && t10 % 1 === 0 && !Kt.isNegativeZero(t10);
}
var eQ = new dr("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: iZ,
  construct: oZ,
  predicate: sZ,
  represent: {
    binary: function(t10) {
      return t10 >= 0 ? "0b" + t10.toString(2) : "-0b" + t10.toString(2).slice(1);
    },
    octal: function(t10) {
      return t10 >= 0 ? "0o" + t10.toString(8) : "-0o" + t10.toString(8).slice(1);
    },
    decimal: function(t10) {
      return t10.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(t10) {
      return t10 >= 0 ? "0x" + t10.toString(16).toUpperCase() : "-0x" + t10.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), aZ = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function lZ(t10) {
  return !(t10 === null || !aZ.test(t10) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  t10[t10.length - 1] === "_");
}
function uZ(t10) {
  var e3, r3;
  return e3 = t10.replace(/_/g, "").toLowerCase(), r3 = e3[0] === "-" ? -1 : 1, "+-".indexOf(e3[0]) >= 0 && (e3 = e3.slice(1)), e3 === ".inf" ? r3 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e3 === ".nan" ? NaN : r3 * parseFloat(e3, 10);
}
var cZ = /^[-+]?[0-9]+e/;
function fZ(t10, e3) {
  var r3;
  if (isNaN(t10))
    switch (e3) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t10)
    switch (e3) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t10)
    switch (e3) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (Kt.isNegativeZero(t10))
    return "-0.0";
  return r3 = t10.toString(10), cZ.test(r3) ? r3.replace("e", ".e") : r3;
}
function dZ(t10) {
  return Object.prototype.toString.call(t10) === "[object Number]" && (t10 % 1 !== 0 || Kt.isNegativeZero(t10));
}
var tQ = new dr("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: lZ,
  construct: uZ,
  predicate: dZ,
  represent: fZ,
  defaultStyle: "lowercase"
}), rQ = Gx.extend({
  implicit: [
    Kx,
    Jx,
    eQ,
    tQ
  ]
}), nQ = rQ, iQ = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), oQ = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function hZ(t10) {
  return t10 === null ? false : iQ.exec(t10) !== null || oQ.exec(t10) !== null;
}
function pZ(t10) {
  var e3, r3, n3, i3, o3, s3, a3, l3 = 0, u3 = null, c3, f3, d3;
  if (e3 = iQ.exec(t10), e3 === null && (e3 = oQ.exec(t10)), e3 === null)
    throw new Error("Date resolve error");
  if (r3 = +e3[1], n3 = +e3[2] - 1, i3 = +e3[3], !e3[4])
    return new Date(Date.UTC(r3, n3, i3));
  if (o3 = +e3[4], s3 = +e3[5], a3 = +e3[6], e3[7]) {
    for (l3 = e3[7].slice(0, 3); l3.length < 3; )
      l3 += "0";
    l3 = +l3;
  }
  return e3[9] && (c3 = +e3[10], f3 = +(e3[11] || 0), u3 = (c3 * 60 + f3) * 6e4, e3[9] === "-" && (u3 = -u3)), d3 = new Date(Date.UTC(r3, n3, i3, o3, s3, a3, l3)), u3 && d3.setTime(d3.getTime() - u3), d3;
}
function OZ(t10) {
  return t10.toISOString();
}
var sQ = new dr("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: hZ,
  construct: pZ,
  instanceOf: Date,
  represent: OZ
});
function mZ(t10) {
  return t10 === "<<" || t10 === null;
}
var aQ = new dr("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: mZ
}), s0 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function gZ(t10) {
  if (t10 === null)
    return false;
  var e3, r3, n3 = 0, i3 = t10.length, o3 = s0;
  for (r3 = 0; r3 < i3; r3++)
    if (e3 = o3.indexOf(t10.charAt(r3)), !(e3 > 64)) {
      if (e3 < 0)
        return false;
      n3 += 6;
    }
  return n3 % 8 === 0;
}
function yZ(t10) {
  var e3, r3, n3 = t10.replace(/[\r\n=]/g, ""), i3 = n3.length, o3 = s0, s3 = 0, a3 = [];
  for (e3 = 0; e3 < i3; e3++)
    e3 % 4 === 0 && e3 && (a3.push(s3 >> 16 & 255), a3.push(s3 >> 8 & 255), a3.push(s3 & 255)), s3 = s3 << 6 | o3.indexOf(n3.charAt(e3));
  return r3 = i3 % 4 * 6, r3 === 0 ? (a3.push(s3 >> 16 & 255), a3.push(s3 >> 8 & 255), a3.push(s3 & 255)) : r3 === 18 ? (a3.push(s3 >> 10 & 255), a3.push(s3 >> 2 & 255)) : r3 === 12 && a3.push(s3 >> 4 & 255), new Uint8Array(a3);
}
function vZ(t10) {
  var e3 = "", r3 = 0, n3, i3, o3 = t10.length, s3 = s0;
  for (n3 = 0; n3 < o3; n3++)
    n3 % 3 === 0 && n3 && (e3 += s3[r3 >> 18 & 63], e3 += s3[r3 >> 12 & 63], e3 += s3[r3 >> 6 & 63], e3 += s3[r3 & 63]), r3 = (r3 << 8) + t10[n3];
  return i3 = o3 % 3, i3 === 0 ? (e3 += s3[r3 >> 18 & 63], e3 += s3[r3 >> 12 & 63], e3 += s3[r3 >> 6 & 63], e3 += s3[r3 & 63]) : i3 === 2 ? (e3 += s3[r3 >> 10 & 63], e3 += s3[r3 >> 4 & 63], e3 += s3[r3 << 2 & 63], e3 += s3[64]) : i3 === 1 && (e3 += s3[r3 >> 2 & 63], e3 += s3[r3 << 4 & 63], e3 += s3[64], e3 += s3[64]), e3;
}
function bZ(t10) {
  return Object.prototype.toString.call(t10) === "[object Uint8Array]";
}
var lQ = new dr("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: gZ,
  construct: yZ,
  predicate: bZ,
  represent: vZ
}), SZ = Object.prototype.hasOwnProperty, $Z = Object.prototype.toString;
function wZ(t10) {
  if (t10 === null)
    return true;
  var e3 = [], r3, n3, i3, o3, s3, a3 = t10;
  for (r3 = 0, n3 = a3.length; r3 < n3; r3 += 1) {
    if (i3 = a3[r3], s3 = false, $Z.call(i3) !== "[object Object]")
      return false;
    for (o3 in i3)
      if (SZ.call(i3, o3))
        if (!s3)
          s3 = true;
        else
          return false;
    if (!s3)
      return false;
    if (e3.indexOf(o3) === -1)
      e3.push(o3);
    else
      return false;
  }
  return true;
}
function PZ(t10) {
  return t10 !== null ? t10 : [];
}
var uQ = new dr("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: wZ,
  construct: PZ
}), _Z = Object.prototype.toString;
function xZ(t10) {
  if (t10 === null)
    return true;
  var e3, r3, n3, i3, o3, s3 = t10;
  for (o3 = new Array(s3.length), e3 = 0, r3 = s3.length; e3 < r3; e3 += 1) {
    if (n3 = s3[e3], _Z.call(n3) !== "[object Object]" || (i3 = Object.keys(n3), i3.length !== 1))
      return false;
    o3[e3] = [i3[0], n3[i3[0]]];
  }
  return true;
}
function QZ(t10) {
  if (t10 === null)
    return [];
  var e3, r3, n3, i3, o3, s3 = t10;
  for (o3 = new Array(s3.length), e3 = 0, r3 = s3.length; e3 < r3; e3 += 1)
    n3 = s3[e3], i3 = Object.keys(n3), o3[e3] = [i3[0], n3[i3[0]]];
  return o3;
}
var cQ = new dr("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: xZ,
  construct: QZ
}), TZ = Object.prototype.hasOwnProperty;
function kZ(t10) {
  if (t10 === null)
    return true;
  var e3, r3 = t10;
  for (e3 in r3)
    if (TZ.call(r3, e3) && r3[e3] !== null)
      return false;
  return true;
}
function EZ(t10) {
  return t10 !== null ? t10 : {};
}
var fQ = new dr("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: kZ,
  construct: EZ
});
nQ.extend({
  implicit: [
    sQ,
    aQ
  ],
  explicit: [
    lQ,
    uQ,
    cQ,
    fQ
  ]
});
function oS(t10) {
  return t10 === 48 ? "\0" : t10 === 97 ? "\x07" : t10 === 98 ? "\b" : t10 === 116 || t10 === 9 ? "	" : t10 === 110 ? `
` : t10 === 118 ? "\v" : t10 === 102 ? "\f" : t10 === 114 ? "\r" : t10 === 101 ? "\x1B" : t10 === 32 ? " " : t10 === 34 ? '"' : t10 === 47 ? "/" : t10 === 92 ? "\\" : t10 === 78 ? "" : t10 === 95 ? " " : t10 === 76 ? "\u2028" : t10 === 80 ? "\u2029" : "";
}
var mQ = new Array(256), gQ = new Array(256);
for (var xs = 0; xs < 256; xs++)
  mQ[xs] = oS(xs) ? 1 : 0, gQ[xs] = oS(xs);
const KM = {
  spec: {
    content: void 0,
    url: void 0,
    preparsedContent: void 0
  },
  proxy: void 0,
  theme: "default",
  tabs: {
    initialContent: "Getting Started"
  },
  showSidebar: true,
  isEditable: false,
  hocuspocusConfiguration: void 0,
  withApiClient: true
}, RQ = reactive({}), gS = (t10) => {
  t10 && Object.assign(RQ, t10);
}, JM = computed(
  () => Ux(RQ ?? {}, { ...KM })
), eN = () => ({
  securitySchemeKey: null,
  http: {
    basic: {
      username: "",
      password: ""
    },
    bearer: {
      token: ""
    }
  },
  apiKey: {
    token: ""
  }
}), im = reactive(
  eN()
), tN = (t10) => {
  Object.assign(im, {
    ...im,
    ...t10
  });
}, rN = () => ({
  selectedServer: null,
  servers: [],
  variables: []
}), om = reactive(rN()), nN = (t10) => {
  Object.assign(om, {
    ...om,
    ...t10
  });
}, Ui = (t10) => (t10 != null && t10.configuration && watch(
  () => t10.configuration,
  (e3) => {
    gS(e3);
  },
  { immediate: true, deep: true }
), {
  setConfiguration: gS,
  configuration: JM,
  authentication: im,
  setAuthentication: tN,
  server: om,
  setServer: nN
}), iN = function() {
  return typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : window;
}(), { FormData: oN, Blob: sN, File: mpe } = iN;
/**
 * @license https://raw.githubusercontent.com/node-fetch/node-fetch/master/LICENSE.md
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 - 2020 Node Fetch Team
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Extracted from https://github.com/node-fetch/node-fetch/blob/64c5c296a0250b852010746c76144cb9e14698d9/src/utils/form-data.js
 */
const vl = `\r
`, sm = "-".repeat(2), aN = Symbol.toStringTag, lN = (t10) => typeof t10 == "object" && typeof t10.arrayBuffer == "function" && typeof t10.type == "string" && typeof t10.stream == "function" && typeof t10.constructor == "function" && /^(Blob|File)$/.test(t10[aN]), uN = (t10) => `${sm}${t10}${sm}${vl.repeat(1)}`, cN = (t10, e3, r3) => {
  let n3 = "";
  return n3 += `${sm}${t10}${vl}`, n3 += `Content-Disposition: form-data; name="${e3}"`, typeof r3 != "string" && r3.name !== "blob" && (n3 += `; filename="${r3.name}"${vl}`, n3 += `Content-Type: ${r3.type || "application/octet-stream"}`), `${n3}${vl.repeat(2)}`;
}, fN = async function* (t10, e3) {
  for (const [r3, n3] of t10)
    yield cN(e3, r3, n3), typeof n3 == "string" ? yield n3 : yield await n3.text(), yield vl;
  yield uN(e3);
}, yr = (t10, e3) => Object.keys(t10).find((r3) => r3.toLowerCase() === e3.toLowerCase()), Cn = (t10, e3) => {
  const r3 = yr(t10, e3);
  if (r3)
    return t10[r3];
}, gd = (t10, e3) => !!yr(t10, e3), dN = [
  "application/json",
  "application/x-json",
  "text/json",
  "text/x-json",
  "+json"
], hN = (t10) => dN.some((e3) => t10.includes(e3)), yS = (t10, e3) => {
  if (e3.value === void 0)
    return t10;
  const r3 = t10[e3.name];
  return r3 === void 0 ? (t10[e3.name] = e3.value, t10) : Array.isArray(r3) ? (r3.push(e3.value), t10) : (t10[e3.name] = [r3, e3.value], t10);
};
function vS(t10) {
  return new URLSearchParams(Object.entries(t10).map(([e3, r3]) => Array.isArray(r3) ? r3.map((n3) => [e3, n3]) : [[e3, r3]]).flat(1));
}
class pN extends URL {
  get path() {
    return this.pathname + this.search;
  }
}
const bS = "", SS = `
`;
class et {
  /**
   * Helper object to format and aggragate lines of code.
   * Lines are aggregated in a `code` array, and need to be joined to obtain a proper code snippet.
   */
  constructor({ indent: e3, join: r3 } = {}) {
    this.postProcessors = [], this.code = [], this.indentationCharacter = bS, this.lineJoin = SS, this.indentLine = (n3, i3 = 0) => `${this.indentationCharacter.repeat(i3)}${n3}`, this.unshift = (n3, i3) => {
      const o3 = this.indentLine(n3, i3);
      this.code.unshift(o3);
    }, this.push = (n3, i3) => {
      const o3 = this.indentLine(n3, i3);
      this.code.push(o3);
    }, this.blank = () => {
      this.code.push("");
    }, this.join = () => {
      const n3 = this.code.join(this.lineJoin);
      return this.postProcessors.reduce((o3, s3) => s3(o3), n3);
    }, this.addPostProcessor = (n3) => {
      this.postProcessors = [...this.postProcessors, n3];
    }, this.indentationCharacter = e3 || bS, this.lineJoin = r3 ?? SS;
  }
}
function Gl(t10, e3 = {}) {
  const { delimiter: r3 = '"', escapeChar: n3 = "\\", escapeNewlines: i3 = true } = e3;
  return [...t10.toString()].map((s3) => s3 === "\b" ? `${n3}b` : s3 === "	" ? `${n3}t` : s3 === `
` ? i3 ? `${n3}n` : s3 : s3 === "\f" ? `${n3}f` : s3 === "\r" ? i3 ? `${n3}r` : s3 : s3 === n3 ? n3 + n3 : s3 === r3 ? n3 + r3 : s3 < " " || s3 > "~" ? JSON.stringify(s3).slice(1, -1) : s3).join("");
}
const Kl = (t10) => Gl(t10, { delimiter: "'" }), Bt = (t10) => Gl(t10, { delimiter: '"' }), ON = {
  info: {
    key: "libcurl",
    title: "Libcurl",
    link: "http://curl.haxx.se/libcurl",
    description: "Simple REST and HTTP API Client for C"
  },
  convert: ({ method: t10, fullUrl: e3, headersObj: r3, allHeaders: n3, postData: i3 }) => {
    const { push: o3, blank: s3, join: a3 } = new et();
    o3("CURL *hnd = curl_easy_init();"), s3(), o3(`curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "${t10.toUpperCase()}");`), o3(`curl_easy_setopt(hnd, CURLOPT_URL, "${e3}");`);
    const l3 = Object.keys(r3);
    return l3.length && (s3(), o3("struct curl_slist *headers = NULL;"), l3.forEach((u3) => {
      o3(`headers = curl_slist_append(headers, "${u3}: ${Bt(r3[u3])}");`);
    }), o3("curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);")), n3.cookie && (s3(), o3(`curl_easy_setopt(hnd, CURLOPT_COOKIE, "${n3.cookie}");`)), i3 != null && i3.text && (s3(), o3(`curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, ${JSON.stringify(i3.text)});`)), s3(), o3("CURLcode ret = curl_easy_perform(hnd);"), a3();
  }
}, mN = {
  info: {
    key: "c",
    title: "C",
    extname: ".c",
    default: "libcurl"
  },
  clientsById: {
    libcurl: ON
  }
};
class $S {
  constructor(e3) {
    this.name = "", this.toString = () => `:${this.name}`, this.name = e3;
  }
}
class gN {
  constructor(e3) {
    this.path = "", this.toString = () => `(clojure.java.io/file "${this.path}")`, this.path = e3;
  }
}
const AQ = (t10) => t10 === void 0 ? null : t10 === null ? "null" : t10.constructor.name.toLowerCase(), XQ = (t10) => AQ(t10) === "object" ? Object.keys(t10).length === 0 : false, wS = (t10) => (Object.keys(t10).filter((e3) => XQ(t10[e3])).forEach((e3) => {
  delete t10[e3];
}), t10), kc = (t10, e3) => {
  const r3 = " ".repeat(t10);
  return e3.replace(/\n/g, `
${r3}`);
}, am = (t10) => {
  switch (AQ(t10)) {
    case "string":
      return `"${t10.replace(/"/g, '\\"')}"`;
    case "file":
      return t10.toString();
    case "keyword":
      return t10.toString();
    case "null":
      return "nil";
    case "regexp":
      return `#"${t10.source}"`;
    case "object": {
      const e3 = Object.keys(t10).reduce((r3, n3) => {
        const i3 = kc(n3.length + 2, am(t10[n3]));
        return `${r3}:${n3} ${i3}
 `;
      }, "").trim();
      return `{${kc(1, e3)}}`;
    }
    case "array": {
      const e3 = t10.reduce((r3, n3) => `${r3} ${am(n3)}`, "").trim();
      return `[${kc(1, e3)}]`;
    }
    default:
      return t10.toString();
  }
}, yN = {
  info: {
    key: "clj_http",
    title: "clj-http",
    link: "https://github.com/dakrone/clj-http",
    description: "An idiomatic clojure http client wrapping the apache client."
  },
  convert: ({ queryObj: t10, method: e3, postData: r3, url: n3, allHeaders: i3 }, o3) => {
    const { push: s3, join: a3 } = new et({ indent: o3 == null ? void 0 : o3.indent }), l3 = ["get", "post", "put", "delete", "patch", "head", "options"];
    if (e3 = e3.toLowerCase(), !l3.includes(e3))
      return s3("Method not supported"), a3();
    const u3 = {
      headers: i3,
      "query-params": t10
    };
    switch (r3 == null ? void 0 : r3.mimeType) {
      case "application/json":
        {
          u3["content-type"] = new $S("json"), u3["form-params"] = r3.jsonObj;
          const c3 = yr(u3.headers, "content-type");
          c3 && delete u3.headers[c3];
        }
        break;
      case "application/x-www-form-urlencoded":
        {
          u3["form-params"] = r3.paramsObj;
          const c3 = yr(u3.headers, "content-type");
          c3 && delete u3.headers[c3];
        }
        break;
      case "text/plain":
        {
          u3.body = r3.text;
          const c3 = yr(u3.headers, "content-type");
          c3 && delete u3.headers[c3];
        }
        break;
      case "multipart/form-data": {
        if (r3.params) {
          u3.multipart = r3.params.map((f3) => f3.fileName && !f3.value ? {
            name: f3.name,
            content: new gN(f3.fileName)
          } : {
            name: f3.name,
            content: f3.value
          });
          const c3 = yr(u3.headers, "content-type");
          c3 && delete u3.headers[c3];
        }
        break;
      }
    }
    switch (Cn(u3.headers, "accept")) {
      case "application/json":
        {
          u3.accept = new $S("json");
          const c3 = yr(u3.headers, "accept");
          c3 && delete u3.headers[c3];
        }
        break;
    }
    if (s3(`(require '[clj-http.client :as client])
`), XQ(wS(u3)))
      s3(`(client/${e3} "${n3}")`);
    else {
      const c3 = 11 + e3.length + n3.length, f3 = kc(c3, am(wS(u3)));
      s3(`(client/${e3} "${n3}" ${f3})`);
    }
    return a3();
  }
}, vN = {
  info: {
    key: "clojure",
    title: "Clojure",
    extname: ".clj",
    default: "clj_http"
  },
  clientsById: {
    clj_http: yN
  }
}, bN = (t10) => {
  let e3 = Cn(t10, "accept-encoding");
  if (!e3)
    return [];
  const r3 = {
    gzip: "DecompressionMethods.GZip",
    deflate: "DecompressionMethods.Deflate"
  }, n3 = [];
  return typeof e3 == "string" && (e3 = [e3]), e3.forEach((i3) => {
    i3.split(",").forEach((o3) => {
      const s3 = /\s*([^;\s]+)/.exec(o3);
      if (s3) {
        const a3 = r3[s3[1]];
        a3 && n3.push(a3);
      }
    });
  }), n3;
}, SN = {
  info: {
    key: "httpclient",
    title: "HttpClient",
    link: "https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient",
    description: ".NET Standard HTTP Client"
  },
  convert: ({ allHeaders: t10, postData: e3, method: r3, fullUrl: n3 }, i3) => {
    var o3, s3;
    const a3 = {
      indent: "    ",
      ...i3
    }, { push: l3, join: u3 } = new et({ indent: a3.indent });
    l3("using System.Net.Http.Headers;");
    let c3 = "";
    const f3 = !!t10.cookie, d3 = bN(t10);
    (f3 || d3.length) && (c3 = "clientHandler", l3("var clientHandler = new HttpClientHandler"), l3("{"), f3 && l3("UseCookies = false,", 1), d3.length && l3(`AutomaticDecompression = ${d3.join(" | ")},`, 1), l3("};")), l3(`var client = new HttpClient(${c3});`), l3("var request = new HttpRequestMessage"), l3("{");
    const p10 = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS", "TRACE"];
    r3 = r3.toUpperCase(), r3 && p10.includes(r3) ? r3 = `HttpMethod.${r3[0]}${r3.substring(1).toLowerCase()}` : r3 = `new HttpMethod("${r3}")`, l3(`Method = ${r3},`, 1), l3(`RequestUri = new Uri("${n3}"),`, 1);
    const h10 = Object.keys(t10).filter((m10) => {
      switch (m10.toLowerCase()) {
        case "content-type":
        case "content-length":
        case "accept-encoding":
          return false;
        default:
          return true;
      }
    });
    if (h10.length && (l3("Headers =", 1), l3("{", 1), h10.forEach((m10) => {
      l3(`{ "${m10}", "${Bt(t10[m10])}" },`, 2);
    }), l3("},", 1)), e3 != null && e3.text) {
      const m10 = e3.mimeType;
      switch (m10) {
        case "application/x-www-form-urlencoded":
          l3("Content = new FormUrlEncodedContent(new Dictionary<string, string>", 1), l3("{", 1), (o3 = e3.params) === null || o3 === void 0 || o3.forEach((O10) => {
            l3(`{ "${O10.name}", "${O10.value}" },`, 2);
          }), l3("}),", 1);
          break;
        case "multipart/form-data":
          l3("Content = new MultipartFormDataContent", 1), l3("{", 1), (s3 = e3.params) === null || s3 === void 0 || s3.forEach((O10) => {
            l3(`new StringContent(${JSON.stringify(O10.value || "")})`, 2), l3("{", 2), l3("Headers =", 3), l3("{", 3), O10.contentType && l3(`ContentType = new MediaTypeHeaderValue("${O10.contentType}"),`, 4), l3('ContentDisposition = new ContentDispositionHeaderValue("form-data")', 4), l3("{", 4), l3(`Name = "${O10.name}",`, 5), O10.fileName && l3(`FileName = "${O10.fileName}",`, 5), l3("}", 4), l3("}", 3), l3("},", 2);
          }), l3("},", 1);
          break;
        default:
          l3(`Content = new StringContent(${JSON.stringify((e3 == null ? void 0 : e3.text) || "")})`, 1), l3("{", 1), l3("Headers =", 2), l3("{", 2), l3(`ContentType = new MediaTypeHeaderValue("${m10}")`, 3), l3("}", 2), l3("}", 1);
          break;
      }
    }
    return l3("};"), l3("using (var response = await client.SendAsync(request))"), l3("{"), l3("response.EnsureSuccessStatusCode();", 1), l3("var body = await response.Content.ReadAsStringAsync();", 1), l3("Console.WriteLine(body);", 1), l3("}"), u3();
  }
}, $N = {
  info: {
    key: "restsharp",
    title: "RestSharp",
    link: "http://restsharp.org/",
    description: "Simple REST and HTTP API Client for .NET"
  },
  convert: ({ allHeaders: t10, method: e3, fullUrl: r3, headersObj: n3, cookies: i3, postData: o3 }) => {
    const { push: s3, join: a3 } = new et();
    if (!["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"].includes(e3.toUpperCase()))
      return "Method not supported";
    if (s3(`var client = new RestClient("${r3}");`), s3(`var request = new RestRequest(Method.${e3.toUpperCase()});`), Object.keys(n3).forEach((u3) => {
      s3(`request.AddHeader("${u3}", "${Bt(n3[u3])}");`);
    }), i3 == null || i3.forEach(({ name: u3, value: c3 }) => {
      s3(`request.AddCookie("${u3}", "${c3}");`);
    }), o3 != null && o3.text) {
      const u3 = Cn(t10, "content-type"), c3 = JSON.stringify(o3.text);
      s3(`request.AddParameter("${u3}", ${c3}, ParameterType.RequestBody);`);
    }
    return s3("IRestResponse response = client.Execute(request);"), a3();
  }
}, wN = {
  info: {
    key: "csharp",
    title: "C#",
    extname: ".cs",
    default: "restsharp"
  },
  clientsById: {
    httpclient: SN,
    restsharp: $N
  }
}, PN = {
  info: {
    key: "native",
    title: "NewRequest",
    link: "http://golang.org/pkg/net/http/#NewRequest",
    description: "Golang HTTP client request"
  },
  convert: ({ postData: t10, method: e3, allHeaders: r3, fullUrl: n3 }, i3 = {}) => {
    const { blank: o3, push: s3, join: a3 } = new et({ indent: "	" }), { showBoilerplate: l3 = true, checkErrors: u3 = false, printBody: c3 = true, timeout: f3 = -1, insecureSkipVerify: d3 = false } = i3, p10 = u3 ? "err" : "_", h10 = l3 ? 1 : 0, m10 = () => {
      u3 && (s3("if err != nil {", h10), s3("panic(err)", h10 + 1), s3("}", h10));
    };
    l3 && (s3("package main"), o3(), s3("import ("), s3('"fmt"', h10), f3 > 0 && s3('"time"', h10), d3 && s3('"crypto/tls"', h10), t10 != null && t10.text && s3('"strings"', h10), s3('"net/http"', h10), c3 && s3('"io"', h10), s3(")"), o3(), s3("func main() {"), o3()), d3 && (s3("insecureTransport := http.DefaultTransport.(*http.Transport).Clone()", h10), s3("insecureTransport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}", h10));
    const O10 = f3 > 0, g = O10 || d3, v10 = g ? "client" : "http.DefaultClient";
    return g && (s3("client := http.Client{", h10), O10 && s3(`Timeout: time.Duration(${f3} * time.Second),`, h10 + 1), d3 && s3("Transport: insecureTransport,", h10 + 1), s3("}", h10), o3()), s3(`url := "${n3}"`, h10), o3(), t10 != null && t10.text ? (s3(`payload := strings.NewReader(${JSON.stringify(t10.text)})`, h10), o3(), s3(`req, ${p10} := http.NewRequest("${e3}", url, payload)`, h10), o3()) : (s3(`req, ${p10} := http.NewRequest("${e3}", url, nil)`, h10), o3()), m10(), Object.keys(r3).length && (Object.keys(r3).forEach((S10) => {
      s3(`req.Header.Add("${S10}", "${Bt(r3[S10])}")`, h10);
    }), o3()), s3(`res, ${p10} := ${v10}.Do(req)`, h10), m10(), c3 && (o3(), s3("defer res.Body.Close()", h10), s3(`body, ${p10} := io.ReadAll(res.Body)`, h10), m10()), o3(), s3("fmt.Println(res)", h10), c3 && s3("fmt.Println(string(body))", h10), l3 && (o3(), s3("}")), a3();
  }
}, _N = {
  info: {
    key: "go",
    title: "Go",
    extname: ".go",
    default: "native"
  },
  clientsById: {
    native: PN
  }
}, PS = `\r
`, xN = {
  info: {
    key: "http1.1",
    title: "HTTP/1.1",
    link: "https://tools.ietf.org/html/rfc7230",
    description: "HTTP/1.1 request string in accordance with RFC 7230"
  },
  convert: ({ method: t10, fullUrl: e3, uriObj: r3, httpVersion: n3, allHeaders: i3, postData: o3 }, s3) => {
    const a3 = {
      absoluteURI: false,
      autoContentLength: true,
      autoHost: true,
      ...s3
    }, { blank: l3, push: u3, join: c3 } = new et({ indent: "", join: PS }), f3 = a3.absoluteURI ? e3 : r3.path;
    u3(`${t10} ${f3} ${n3}`);
    const d3 = Object.keys(i3);
    d3.forEach((m10) => {
      const O10 = m10.toLowerCase().replace(/(^|-)(\w)/g, (g) => g.toUpperCase());
      u3(`${O10}: ${i3[m10]}`);
    }), a3.autoHost && !d3.includes("host") && u3(`Host: ${r3.host}`), a3.autoContentLength && (o3 != null && o3.text) && !d3.includes("content-length") && u3(`Content-Length: ${o3.text.length}`), l3();
    const p10 = c3(), h10 = (o3 == null ? void 0 : o3.text) || "";
    return `${p10}${PS}${h10}`;
  }
}, QN = {
  info: {
    key: "http",
    title: "HTTP",
    extname: null,
    default: "1.1"
  },
  clientsById: {
    "http1.1": xN
  }
}, TN = {
  info: {
    key: "asynchttp",
    title: "AsyncHttp",
    link: "https://github.com/AsyncHttpClient/async-http-client",
    description: "Asynchronous Http and WebSocket Client library for Java"
  },
  convert: ({ method: t10, allHeaders: e3, postData: r3, fullUrl: n3 }, i3) => {
    const o3 = {
      indent: "  ",
      ...i3
    }, { blank: s3, push: a3, join: l3 } = new et({ indent: o3.indent });
    return a3("AsyncHttpClient client = new DefaultAsyncHttpClient();"), a3(`client.prepare("${t10.toUpperCase()}", "${n3}")`), Object.keys(e3).forEach((u3) => {
      a3(`.setHeader("${u3}", "${Bt(e3[u3])}")`, 1);
    }), r3 != null && r3.text && a3(`.setBody(${JSON.stringify(r3.text)})`, 1), a3(".execute()", 1), a3(".toCompletableFuture()", 1), a3(".thenAccept(System.out::println)", 1), a3(".join();", 1), s3(), a3("client.close();"), l3();
  }
}, kN = {
  info: {
    key: "nethttp",
    title: "java.net.http",
    link: "https://openjdk.java.net/groups/net/httpclient/intro.html",
    description: "Java Standardized HTTP Client API"
  },
  convert: ({ allHeaders: t10, fullUrl: e3, method: r3, postData: n3 }, i3) => {
    const o3 = {
      indent: "  ",
      ...i3
    }, { push: s3, join: a3 } = new et({ indent: o3.indent });
    return s3("HttpRequest request = HttpRequest.newBuilder()"), s3(`.uri(URI.create("${e3}"))`, 2), Object.keys(t10).forEach((l3) => {
      s3(`.header("${l3}", "${Bt(t10[l3])}")`, 2);
    }), n3 != null && n3.text ? s3(`.method("${r3.toUpperCase()}", HttpRequest.BodyPublishers.ofString(${JSON.stringify(n3.text)}))`, 2) : s3(`.method("${r3.toUpperCase()}", HttpRequest.BodyPublishers.noBody())`, 2), s3(".build();", 2), s3("HttpResponse<String> response = HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());"), s3("System.out.println(response.body());"), a3();
  }
}, EN = {
  info: {
    key: "okhttp",
    title: "OkHttp",
    link: "http://square.github.io/okhttp/",
    description: "An HTTP Request Client Library"
  },
  convert: ({ postData: t10, method: e3, fullUrl: r3, allHeaders: n3 }, i3) => {
    const o3 = {
      indent: "  ",
      ...i3
    }, { push: s3, blank: a3, join: l3 } = new et({ indent: o3.indent }), u3 = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"], c3 = ["POST", "PUT", "DELETE", "PATCH"];
    return s3("OkHttpClient client = new OkHttpClient();"), a3(), t10 != null && t10.text && (t10.boundary ? s3(`MediaType mediaType = MediaType.parse("${t10.mimeType}; boundary=${t10.boundary}");`) : s3(`MediaType mediaType = MediaType.parse("${t10.mimeType}");`), s3(`RequestBody body = RequestBody.create(mediaType, ${JSON.stringify(t10.text)});`)), s3("Request request = new Request.Builder()"), s3(`.url("${r3}")`, 1), u3.includes(e3.toUpperCase()) ? c3.includes(e3.toUpperCase()) ? t10 != null && t10.text ? s3(`.${e3.toLowerCase()}(body)`, 1) : s3(`.${e3.toLowerCase()}(null)`, 1) : s3(`.${e3.toLowerCase()}()`, 1) : t10 != null && t10.text ? s3(`.method("${e3.toUpperCase()}", body)`, 1) : s3(`.method("${e3.toUpperCase()}", null)`, 1), Object.keys(n3).forEach((f3) => {
      s3(`.addHeader("${f3}", "${Bt(n3[f3])}")`, 1);
    }), s3(".build();", 1), a3(), s3("Response response = client.newCall(request).execute();"), l3();
  }
}, CN = {
  info: {
    key: "unirest",
    title: "Unirest",
    link: "http://unirest.io/java.html",
    description: "Lightweight HTTP Request Client Library"
  },
  convert: ({ method: t10, allHeaders: e3, postData: r3, fullUrl: n3 }, i3) => {
    const o3 = {
      indent: "  ",
      ...i3
    }, { join: s3, push: a3 } = new et({ indent: o3.indent });
    return ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"].includes(t10.toUpperCase()) ? a3(`HttpResponse<String> response = Unirest.${t10.toLowerCase()}("${n3}")`) : a3(`HttpResponse<String> response = Unirest.customMethod("${t10.toUpperCase()}","${n3}")`), Object.keys(e3).forEach((u3) => {
      a3(`.header("${u3}", "${Bt(e3[u3])}")`, 1);
    }), r3 != null && r3.text && a3(`.body(${JSON.stringify(r3.text)})`, 1), a3(".asString();", 1), s3();
  }
}, RN = {
  info: {
    key: "java",
    title: "Java",
    extname: ".java",
    default: "unirest"
  },
  clientsById: {
    asynchttp: TN,
    nethttp: kN,
    okhttp: EN,
    unirest: CN
  }
};
var AN = function(t10) {
  return Object.prototype.toString.call(t10) === "[object RegExp]";
}, XN = function(t10) {
  var e3 = typeof t10;
  return t10 !== null && (e3 === "object" || e3 === "function");
}, d0 = {};
Object.defineProperty(d0, "__esModule", { value: true });
d0.default = (t10) => Object.getOwnPropertySymbols(t10).filter((e3) => Object.prototype.propertyIsEnumerable.call(t10, e3));
const qN = AN, DN = XN, jN = d0.default;
var UN = (t10, e3, r3) => {
  const n3 = [];
  return function i3(o3, s3, a3) {
    s3 = s3 || {}, s3.indent = s3.indent || "	", a3 = a3 || "";
    let l3;
    s3.inlineCharacterLimit === void 0 ? l3 = {
      newLine: `
`,
      newLineOrSpace: `
`,
      pad: a3,
      indent: a3 + s3.indent
    } : l3 = {
      newLine: "@@__STRINGIFY_OBJECT_NEW_LINE__@@",
      newLineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@",
      pad: "@@__STRINGIFY_OBJECT_PAD__@@",
      indent: "@@__STRINGIFY_OBJECT_INDENT__@@"
    };
    const u3 = (c3) => {
      if (s3.inlineCharacterLimit === void 0)
        return c3;
      const f3 = c3.replace(new RegExp(l3.newLine, "g"), "").replace(new RegExp(l3.newLineOrSpace, "g"), " ").replace(new RegExp(l3.pad + "|" + l3.indent, "g"), "");
      return f3.length <= s3.inlineCharacterLimit ? f3 : c3.replace(new RegExp(l3.newLine + "|" + l3.newLineOrSpace, "g"), `
`).replace(new RegExp(l3.pad, "g"), a3).replace(new RegExp(l3.indent, "g"), a3 + s3.indent);
    };
    if (n3.indexOf(o3) !== -1)
      return '"[Circular]"';
    if (o3 == null || typeof o3 == "number" || typeof o3 == "boolean" || typeof o3 == "function" || typeof o3 == "symbol" || qN(o3))
      return String(o3);
    if (o3 instanceof Date)
      return `new Date('${o3.toISOString()}')`;
    if (Array.isArray(o3)) {
      if (o3.length === 0)
        return "[]";
      n3.push(o3);
      const c3 = "[" + l3.newLine + o3.map((f3, d3) => {
        const p10 = o3.length - 1 === d3 ? l3.newLine : "," + l3.newLineOrSpace;
        let h10 = i3(f3, s3, a3 + s3.indent);
        return s3.transform && (h10 = s3.transform(o3, d3, h10)), l3.indent + h10 + p10;
      }).join("") + l3.pad + "]";
      return n3.pop(), u3(c3);
    }
    if (DN(o3)) {
      let c3 = Object.keys(o3).concat(jN(o3));
      if (s3.filter && (c3 = c3.filter((d3) => s3.filter(o3, d3))), c3.length === 0)
        return "{}";
      n3.push(o3);
      const f3 = "{" + l3.newLine + c3.map((d3, p10) => {
        const h10 = c3.length - 1 === p10 ? l3.newLine : "," + l3.newLineOrSpace, m10 = typeof d3 == "symbol", O10 = !m10 && /^[a-z$_][a-z$_0-9]*$/i.test(d3), g = m10 || O10 ? d3 : i3(d3, s3);
        let v10 = i3(o3[d3], s3, a3 + s3.indent);
        return s3.transform && (v10 = s3.transform(o3, d3, v10)), l3.indent + String(g) + ": " + v10 + h10;
      }).join("") + l3.pad + "}";
      return n3.pop(), u3(f3);
    }
    return o3 = String(o3).replace(/[\r\n]/g, (c3) => c3 === `
` ? "\\n" : "\\r"), s3.singleQuotes === false ? (o3 = o3.replace(/"/g, '\\"'), `"${o3}"`) : (o3 = o3.replace(/\\?'/g, "\\'"), `'${o3}'`);
  }(t10, e3, r3);
};
const cr = /* @__PURE__ */ lg(UN), IN = {
  info: {
    key: "axios",
    title: "Axios",
    link: "https://github.com/axios/axios",
    description: "Promise based HTTP client for the browser and node.js"
  },
  convert: ({ allHeaders: t10, method: e3, url: r3, queryObj: n3, postData: i3 }, o3) => {
    const s3 = {
      indent: "  ",
      ...o3
    }, { blank: a3, push: l3, join: u3, addPostProcessor: c3 } = new et({ indent: s3.indent });
    l3("import axios from 'axios';"), a3();
    const f3 = {
      method: e3,
      url: r3
    };
    switch (Object.keys(n3).length && (f3.params = n3), Object.keys(t10).length && (f3.headers = t10), i3 == null ? void 0 : i3.mimeType) {
      case "application/x-www-form-urlencoded":
        i3.params && (l3("const encodedParams = new URLSearchParams();"), i3.params.forEach((p10) => {
          l3(`encodedParams.set('${p10.name}', '${p10.value}');`);
        }), a3(), f3.data = "encodedParams,", c3((p10) => p10.replace(/'encodedParams,'/, "encodedParams,")));
        break;
      case "application/json":
        i3.jsonObj && (f3.data = i3.jsonObj);
        break;
      case "multipart/form-data":
        if (!i3.params)
          break;
        l3("const form = new FormData();"), i3.params.forEach((p10) => {
          l3(`form.append('${p10.name}', '${p10.value || p10.fileName || ""}');`);
        }), a3(), f3.data = "[form]";
        break;
      default:
        i3 != null && i3.text && (f3.data = i3.text);
    }
    const d3 = cr(f3, {
      indent: "  ",
      inlineCharacterLimit: 80
    }).replace('"[form]"', "form");
    return l3(`const options = ${d3};`), a3(), l3("try {"), l3("const { data } = await axios.request(options);", 1), l3("console.log(data);", 1), l3("} catch (error) {"), l3("console.error(error);", 1), l3("}"), u3();
  }
}, FN = {
  info: {
    key: "fetch",
    title: "fetch",
    link: "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
    description: "Perform asynchronous HTTP requests with the Fetch API"
  },
  convert: ({ method: t10, allHeaders: e3, postData: r3, fullUrl: n3 }, i3) => {
    const o3 = {
      indent: "  ",
      credentials: null,
      ...i3
    }, { blank: s3, join: a3, push: l3 } = new et({ indent: o3.indent }), u3 = {
      method: t10
    };
    switch (Object.keys(e3).length && (u3.headers = e3), o3.credentials !== null && (u3.credentials = o3.credentials), l3(`const url = '${n3}';`), r3 == null ? void 0 : r3.mimeType) {
      case "application/x-www-form-urlencoded":
        u3.body = r3.paramsObj ? r3.paramsObj : r3.text;
        break;
      case "application/json":
        u3.body = JSON.stringify(r3.jsonObj);
        break;
      case "multipart/form-data":
        if (!r3.params)
          break;
        const c3 = yr(e3, "content-type");
        c3 && delete e3[c3], l3("const form = new FormData();"), r3.params.forEach((f3) => {
          l3(`form.append('${f3.name}', '${f3.value || f3.fileName || ""}');`);
        }), s3();
        break;
      default:
        r3 != null && r3.text && (u3.body = r3.text);
    }
    return u3.headers && !Object.keys(u3.headers).length && delete u3.headers, l3(`const options = ${cr(u3, {
      indent: o3.indent,
      inlineCharacterLimit: 80,
      transform: (c3, f3, d3) => f3 === "body" && r3 && r3.mimeType === "application/x-www-form-urlencoded" ? `new URLSearchParams(${d3})` : d3
    })};`), s3(), r3 != null && r3.params && r3.mimeType === "multipart/form-data" && (l3("options.body = form;"), s3()), l3("try {"), l3("const response = await fetch(url, options);", 1), l3("const data = await response.json();", 1), l3("console.log(data);", 1), l3("} catch (error) {"), l3("console.error(error);", 1), l3("}"), a3();
  }
}, ZN = {
  info: {
    key: "jquery",
    title: "jQuery",
    link: "http://api.jquery.com/jquery.ajax/",
    description: "Perform an asynchronous HTTP (Ajax) requests with jQuery"
  },
  convert: ({ fullUrl: t10, method: e3, allHeaders: r3, postData: n3 }, i3) => {
    var o3;
    const s3 = {
      indent: "  ",
      ...i3
    }, { blank: a3, push: l3, join: u3 } = new et({ indent: s3.indent }), c3 = {
      async: true,
      crossDomain: true,
      url: t10,
      method: e3,
      headers: r3
    };
    switch (n3 == null ? void 0 : n3.mimeType) {
      case "application/x-www-form-urlencoded":
        c3.data = n3.paramsObj ? n3.paramsObj : n3.text;
        break;
      case "application/json":
        c3.processData = false, c3.data = n3.text;
        break;
      case "multipart/form-data":
        if (!n3.params)
          break;
        if (l3("const form = new FormData();"), n3.params.forEach((d3) => {
          l3(`form.append('${d3.name}', '${d3.value || d3.fileName || ""}');`);
        }), c3.processData = false, c3.contentType = false, c3.mimeType = "multipart/form-data", c3.data = "[form]", gd(r3, "content-type") && !((o3 = Cn(r3, "content-type")) === null || o3 === void 0) && o3.includes("boundary")) {
          const d3 = yr(r3, "content-type");
          d3 && delete c3.headers[d3];
        }
        a3();
        break;
      default:
        n3 != null && n3.text && (c3.data = n3.text);
    }
    const f3 = cr(c3, { indent: s3.indent }).replace("'[form]'", "form");
    return l3(`const settings = ${f3};`), a3(), l3("$.ajax(settings).done(function (response) {"), l3("console.log(response);", 1), l3("});"), u3();
  }
}, MN = {
  info: {
    key: "xhr",
    title: "XMLHttpRequest",
    link: "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest",
    description: "W3C Standard API that provides scripted client functionality"
  },
  convert: ({ postData: t10, allHeaders: e3, method: r3, fullUrl: n3 }, i3) => {
    var o3;
    const s3 = {
      indent: "  ",
      cors: true,
      ...i3
    }, { blank: a3, push: l3, join: u3 } = new et({ indent: s3.indent });
    switch (t10 == null ? void 0 : t10.mimeType) {
      case "application/json":
        l3(`const data = JSON.stringify(${cr(t10.jsonObj, {
          indent: s3.indent
        })});`), a3();
        break;
      case "multipart/form-data":
        if (!t10.params)
          break;
        if (l3("const data = new FormData();"), t10.params.forEach((c3) => {
          l3(`data.append('${c3.name}', '${c3.value || c3.fileName || ""}');`);
        }), gd(e3, "content-type") && !((o3 = Cn(e3, "content-type")) === null || o3 === void 0) && o3.includes("boundary")) {
          const c3 = yr(e3, "content-type");
          c3 && delete e3[c3];
        }
        a3();
        break;
      default:
        l3(`const data = ${t10 != null && t10.text ? `'${t10.text}'` : "null"};`), a3();
    }
    return l3("const xhr = new XMLHttpRequest();"), s3.cors && l3("xhr.withCredentials = true;"), a3(), l3("xhr.addEventListener('readystatechange', function () {"), l3("if (this.readyState === this.DONE) {", 1), l3("console.log(this.responseText);", 2), l3("}", 1), l3("});"), a3(), l3(`xhr.open('${r3}', '${n3}');`), Object.keys(e3).forEach((c3) => {
      l3(`xhr.setRequestHeader('${c3}', '${Kl(e3[c3])}');`);
    }), a3(), l3("xhr.send(data);"), u3();
  }
}, NN = {
  info: {
    key: "javascript",
    title: "JavaScript",
    extname: ".js",
    default: "xhr"
  },
  clientsById: {
    xhr: MN,
    axios: IN,
    fetch: FN,
    jquery: ZN
  }
}, WN = {
  info: {
    key: "okhttp",
    title: "OkHttp",
    link: "http://square.github.io/okhttp/",
    description: "An HTTP Request Client Library"
  },
  convert: ({ postData: t10, fullUrl: e3, method: r3, allHeaders: n3 }, i3) => {
    const o3 = {
      indent: "  ",
      ...i3
    }, { blank: s3, join: a3, push: l3 } = new et({ indent: o3.indent }), u3 = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"], c3 = ["POST", "PUT", "DELETE", "PATCH"];
    return l3("val client = OkHttpClient()"), s3(), t10 != null && t10.text && (t10.boundary ? l3(`val mediaType = MediaType.parse("${t10.mimeType}; boundary=${t10.boundary}")`) : l3(`val mediaType = MediaType.parse("${t10.mimeType}")`), l3(`val body = RequestBody.create(mediaType, ${JSON.stringify(t10.text)})`)), l3("val request = Request.Builder()"), l3(`.url("${e3}")`, 1), u3.includes(r3.toUpperCase()) ? c3.includes(r3.toUpperCase()) ? t10 != null && t10.text ? l3(`.${r3.toLowerCase()}(body)`, 1) : l3(`.${r3.toLowerCase()}(null)`, 1) : l3(`.${r3.toLowerCase()}()`, 1) : t10 != null && t10.text ? l3(`.method("${r3.toUpperCase()}", body)`, 1) : l3(`.method("${r3.toUpperCase()}", null)`, 1), Object.keys(n3).forEach((f3) => {
      l3(`.addHeader("${f3}", "${Bt(n3[f3])}")`, 1);
    }), l3(".build()", 1), s3(), l3("val response = client.newCall(request).execute()"), a3();
  }
}, VN = {
  info: {
    key: "kotlin",
    title: "Kotlin",
    extname: ".kt",
    default: "okhttp"
  },
  clientsById: {
    okhttp: WN
  }
}, YN = {
  info: {
    key: "axios",
    title: "Axios",
    link: "https://github.com/axios/axios",
    description: "Promise based HTTP client for the browser and node.js"
  },
  convert: ({ method: t10, url: e3, queryObj: r3, allHeaders: n3, postData: i3 }, o3) => {
    const s3 = {
      indent: "  ",
      ...o3
    }, { blank: a3, join: l3, push: u3, addPostProcessor: c3 } = new et({ indent: s3.indent });
    u3("const axios = require('axios').default;");
    const f3 = {
      method: t10,
      url: e3
    };
    switch (Object.keys(r3).length && (f3.params = r3), Object.keys(n3).length && (f3.headers = n3), i3 == null ? void 0 : i3.mimeType) {
      case "application/x-www-form-urlencoded":
        i3.params && (u3("const { URLSearchParams } = require('url');"), a3(), u3("const encodedParams = new URLSearchParams();"), i3.params.forEach((p10) => {
          u3(`encodedParams.set('${p10.name}', '${p10.value}');`);
        }), a3(), f3.data = "encodedParams,", c3((p10) => p10.replace(/'encodedParams,'/, "encodedParams,")));
        break;
      case "application/json":
        a3(), i3.jsonObj && (f3.data = i3.jsonObj);
        break;
      default:
        a3(), i3 != null && i3.text && (f3.data = i3.text);
    }
    const d3 = cr(f3, { indent: "  ", inlineCharacterLimit: 80 });
    return u3(`const options = ${d3};`), a3(), u3("try {"), u3("const { data } = await axios.request(options);", 1), u3("console.log(data);", 1), u3("} catch (error) {"), u3("console.error(error);", 1), u3("}"), l3();
  }
}, LN = {
  info: {
    key: "fetch",
    title: "Fetch",
    link: "https://github.com/bitinn/node-fetch",
    description: "Simplified HTTP node-fetch client"
  },
  convert: ({ method: t10, fullUrl: e3, postData: r3, headersObj: n3, cookies: i3 }, o3) => {
    var s3;
    const a3 = {
      indent: "  ",
      ...o3
    };
    let l3 = false;
    const { blank: u3, push: c3, join: f3, unshift: d3 } = new et({ indent: a3.indent });
    c3("const fetch = require('node-fetch');"), u3();
    const p10 = {
      method: t10
    };
    switch (Object.keys(n3).length && (p10.headers = n3), r3 == null ? void 0 : r3.mimeType) {
      case "application/x-www-form-urlencoded":
        d3("const { URLSearchParams } = require('url');"), c3("const encodedParams = new URLSearchParams();"), (s3 = r3.params) === null || s3 === void 0 || s3.forEach((O10) => {
          c3(`encodedParams.set('${O10.name}', '${O10.value}');`);
        }), u3(), p10.body = "encodedParams";
        break;
      case "application/json":
        r3.jsonObj && (p10.body = JSON.stringify(r3.jsonObj));
        break;
      case "multipart/form-data":
        if (!r3.params)
          break;
        const m10 = yr(n3, "content-type");
        m10 && delete n3[m10], d3("const FormData = require('form-data');"), c3("const formData = new FormData();"), r3.params.forEach((O10) => {
          if (!O10.fileName && !O10.fileName && !O10.contentType) {
            c3(`formData.append('${O10.name}', '${O10.value}');`);
            return;
          }
          O10.fileName && (l3 = true, c3(`formData.append('${O10.name}', fs.createReadStream('${O10.fileName}'));`));
        }), u3();
        break;
      default:
        r3 != null && r3.text && (p10.body = r3.text);
    }
    if (i3.length) {
      const m10 = i3.map((O10) => `${encodeURIComponent(O10.name)}=${encodeURIComponent(O10.value)}`).join("; ");
      p10.headers || (p10.headers = {}), p10.headers.cookie = m10;
    }
    c3(`const url = '${e3}';`), p10.headers && !Object.keys(p10.headers).length && delete p10.headers;
    const h10 = cr(p10, { indent: "  ", inlineCharacterLimit: 80 });
    return c3(`const options = ${h10};`), l3 && d3("const fs = require('fs');"), r3 != null && r3.params && r3.mimeType === "multipart/form-data" && c3("options.body = formData;"), u3(), c3("try {"), c3("const response = await fetch(url, options);", 1), c3("const data = await response.json();", 1), c3("console.log(data);", 1), c3("} catch (error) {"), c3("console.error(error);", 1), c3("}"), f3().replace(/'encodedParams'/, "encodedParams").replace(/"fs\.createReadStream\(\\"(.+)\\"\)"/, 'fs.createReadStream("$1")');
  }
}, BN = {
  info: {
    key: "native",
    title: "HTTP",
    link: "http://nodejs.org/api/http.html#http_http_request_options_callback",
    description: "Node.js native HTTP interface"
  },
  convert: ({ uriObj: t10, method: e3, allHeaders: r3, postData: n3 }, i3 = {}) => {
    const { indent: o3 = "  ", insecureSkipVerify: s3 = false } = i3, { blank: a3, join: l3, push: u3, unshift: c3 } = new et({ indent: o3 }), f3 = {
      method: e3,
      hostname: t10.hostname,
      port: t10.port === "" ? null : t10.port,
      path: t10.path,
      headers: r3,
      ...s3 ? { rejectUnauthorized: false } : {}
    };
    switch (u3(`const http = require('${t10.protocol.replace(":", "")}');`), a3(), u3(`const options = ${cr(f3, { indent: o3 })};`), a3(), u3("const req = http.request(options, function (res) {"), u3("const chunks = [];", 1), a3(), u3("res.on('data', function (chunk) {", 1), u3("chunks.push(chunk);", 2), u3("});", 1), a3(), u3("res.on('end', function () {", 1), u3("const body = Buffer.concat(chunks);", 2), u3("console.log(body.toString());", 2), u3("});", 1), u3("});"), a3(), n3 == null ? void 0 : n3.mimeType) {
      case "application/x-www-form-urlencoded":
        n3.paramsObj && (c3("const qs = require('querystring');"), u3(`req.write(qs.stringify(${cr(n3.paramsObj, {
          indent: "  ",
          inlineCharacterLimit: 80
        })}));`));
        break;
      case "application/json":
        n3.jsonObj && u3(`req.write(JSON.stringify(${cr(n3.jsonObj, {
          indent: "  ",
          inlineCharacterLimit: 80
        })}));`);
        break;
      default:
        n3 != null && n3.text && u3(`req.write(${cr(n3.text, { indent: o3 })});`);
    }
    return u3("req.end();"), l3();
  }
}, zN = {
  info: {
    key: "request",
    title: "Request",
    link: "https://github.com/request/request",
    description: "Simplified HTTP request client"
  },
  convert: ({ method: t10, url: e3, queryObj: r3, postData: n3, headersObj: i3, cookies: o3 }, s3) => {
    const a3 = {
      indent: "  ",
      ...s3
    };
    let l3 = false;
    const { push: u3, blank: c3, join: f3, unshift: d3 } = new et({ indent: a3.indent });
    u3("const request = require('request');"), c3();
    const p10 = {
      method: t10,
      url: e3
    };
    switch (Object.keys(r3).length && (p10.qs = r3), Object.keys(i3).length && (p10.headers = i3), n3 == null ? void 0 : n3.mimeType) {
      case "application/x-www-form-urlencoded":
        p10.form = n3.paramsObj;
        break;
      case "application/json":
        n3.jsonObj && (p10.body = n3.jsonObj, p10.json = true);
        break;
      case "multipart/form-data":
        if (!n3.params)
          break;
        p10.formData = {}, n3.params.forEach((h10) => {
          if (!h10.fileName && !h10.fileName && !h10.contentType) {
            p10.formData[h10.name] = h10.value;
            return;
          }
          let m10 = {};
          h10.fileName ? (l3 = true, m10 = {
            value: `fs.createReadStream(${h10.fileName})`,
            options: {
              filename: h10.fileName,
              contentType: h10.contentType ? h10.contentType : null
            }
          }) : h10.value && (m10.value = h10.value), p10.formData[h10.name] = m10;
        });
        break;
      default:
        n3 != null && n3.text && (p10.body = n3.text);
    }
    return o3.length && (p10.jar = "JAR", u3("const jar = request.jar();"), o3.forEach((h10) => {
      u3(`jar.setCookie(request.cookie('${encodeURIComponent(h10.name)}=${encodeURIComponent(h10.value)}'), '${e3}');`);
    }), c3()), l3 && d3("const fs = require('fs');"), u3(`const options = ${cr(p10, { indent: "  ", inlineCharacterLimit: 80 })};`), c3(), u3("request(options, function (error, response, body) {"), u3("if (error) throw new Error(error);", 1), c3(), u3("console.log(body);", 1), u3("});"), f3().replace("'JAR'", "jar").replace(/'fs\.createReadStream\((.*)\)'/, "fs.createReadStream('$1')");
  }
}, HN = {
  info: {
    key: "unirest",
    title: "Unirest",
    link: "http://unirest.io/nodejs.html",
    description: "Lightweight HTTP Request Client Library"
  },
  convert: ({ method: t10, url: e3, cookies: r3, queryObj: n3, postData: i3, headersObj: o3 }, s3) => {
    const a3 = {
      indent: "  ",
      ...s3
    };
    let l3 = false;
    const { addPostProcessor: u3, blank: c3, join: f3, push: d3, unshift: p10 } = new et({
      indent: a3.indent
    });
    switch (d3("const unirest = require('unirest');"), c3(), d3(`const req = unirest('${t10}', '${e3}');`), c3(), r3.length && (d3("const CookieJar = unirest.jar();"), r3.forEach((h10) => {
      d3(`CookieJar.add('${encodeURIComponent(h10.name)}=${encodeURIComponent(h10.value)}', '${e3}');`);
    }), d3("req.jar(CookieJar);"), c3()), Object.keys(n3).length && (d3(`req.query(${cr(n3, { indent: a3.indent })});`), c3()), Object.keys(o3).length && (d3(`req.headers(${cr(o3, { indent: a3.indent })});`), c3()), i3 == null ? void 0 : i3.mimeType) {
      case "application/x-www-form-urlencoded":
        i3.paramsObj && (d3(`req.form(${cr(i3.paramsObj, { indent: a3.indent })});`), c3());
        break;
      case "application/json":
        i3.jsonObj && (d3("req.type('json');"), d3(`req.send(${cr(i3.jsonObj, { indent: a3.indent })});`), c3());
        break;
      case "multipart/form-data": {
        if (!i3.params)
          break;
        const h10 = [];
        i3.params.forEach((m10) => {
          const O10 = {};
          m10.fileName && !m10.value ? (l3 = true, O10.body = `fs.createReadStream('${m10.fileName}')`, u3((g) => g.replace(/'fs\.createReadStream\(\\'(.+)\\'\)'/, "fs.createReadStream('$1')"))) : m10.value && (O10.body = m10.value), O10.body && (m10.contentType && (O10["content-type"] = m10.contentType), h10.push(O10));
        }), d3(`req.multipart(${cr(h10, { indent: a3.indent })});`), c3();
        break;
      }
      default:
        i3 != null && i3.text && (d3(`req.send(${cr(i3.text, { indent: a3.indent })});`), c3());
    }
    return l3 && p10("const fs = require('fs');"), d3("req.end(function (res) {"), d3("if (res.error) throw new Error(res.error);", 1), c3(), d3("console.log(res.body);", 1), d3("});"), f3();
  }
}, GN = {
  info: {
    key: "node",
    title: "Node.js",
    extname: ".js",
    default: "native"
  },
  clientsById: {
    native: BN,
    request: zN,
    unirest: HN,
    axios: YN,
    fetch: LN
  }
}, Lh = (t10, e3, r3, n3) => {
  const i3 = `${t10} *${e3} = `, o3 = lm(r3, n3 ? i3.length : void 0);
  return `${i3}${o3};`;
}, lm = (t10, e3) => {
  const r3 = e3 === void 0 ? ", " : `,
   ${" ".repeat(e3)}`;
  switch (Object.prototype.toString.call(t10)) {
    case "[object Number]":
      return `@${t10}`;
    case "[object Array]":
      return `@[ ${t10.map((i3) => lm(i3)).join(r3)} ]`;
    case "[object Object]": {
      const n3 = [];
      for (const i3 in t10)
        n3.push(`@"${i3}": ${lm(t10[i3])}`);
      return `@{ ${n3.join(r3)} }`;
    }
    case "[object Boolean]":
      return t10 ? "@YES" : "@NO";
    default:
      return t10 == null ? "" : `@"${t10.toString().replace(/"/g, '\\"')}"`;
  }
}, KN = {
  info: {
    key: "nsurlsession",
    title: "NSURLSession",
    link: "https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/index.html",
    description: "Foundation's NSURLSession request"
  },
  convert: ({ allHeaders: t10, postData: e3, method: r3, fullUrl: n3 }, i3) => {
    var o3;
    const s3 = {
      indent: "    ",
      pretty: true,
      timeout: 10,
      ...i3
    }, { push: a3, join: l3, blank: u3 } = new et({ indent: s3.indent }), c3 = {
      hasHeaders: false,
      hasBody: false
    };
    if (a3("#import <Foundation/Foundation.h>"), Object.keys(t10).length && (c3.hasHeaders = true, u3(), a3(Lh("NSDictionary", "headers", t10, s3.pretty))), e3 && (e3.text || e3.jsonObj || e3.params))
      switch (c3.hasBody = true, e3.mimeType) {
        case "application/x-www-form-urlencoded":
          if (!((o3 = e3.params) === null || o3 === void 0) && o3.length) {
            u3();
            const [f3, ...d3] = e3.params;
            a3(`NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"${f3.name}=${f3.value}" dataUsingEncoding:NSUTF8StringEncoding]];`), d3.forEach(({ name: p10, value: h10 }) => {
              a3(`[postData appendData:[@"&${p10}=${h10}" dataUsingEncoding:NSUTF8StringEncoding]];`);
            });
          } else
            c3.hasBody = false;
          break;
        case "application/json":
          e3.jsonObj && (a3(Lh("NSDictionary", "parameters", e3.jsonObj, s3.pretty)), u3(), a3("NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];"));
          break;
        case "multipart/form-data":
          a3(Lh("NSArray", "parameters", e3.params || [], s3.pretty)), a3(`NSString *boundary = @"${e3.boundary}";`), u3(), a3("NSError *error;"), a3("NSMutableString *body = [NSMutableString string];"), a3("for (NSDictionary *param in parameters) {"), a3('[body appendFormat:@"--%@\\r\\n", boundary];', 1), a3('if (param[@"fileName"]) {', 1), a3('[body appendFormat:@"Content-Disposition:form-data; name=\\"%@\\"; filename=\\"%@\\"\\r\\n", param[@"name"], param[@"fileName"]];', 2), a3('[body appendFormat:@"Content-Type: %@\\r\\n\\r\\n", param[@"contentType"]];', 2), a3('[body appendFormat:@"%@", [NSString stringWithContentsOfFile:param[@"fileName"] encoding:NSUTF8StringEncoding error:&error]];', 2), a3("if (error) {", 2), a3('NSLog(@"%@", error);', 3), a3("}", 2), a3("} else {", 1), a3('[body appendFormat:@"Content-Disposition:form-data; name=\\"%@\\"\\r\\n\\r\\n", param[@"name"]];', 2), a3('[body appendFormat:@"%@", param[@"value"]];', 2), a3("}", 1), a3("}"), a3('[body appendFormat:@"\\r\\n--%@--\\r\\n", boundary];'), a3("NSData *postData = [body dataUsingEncoding:NSUTF8StringEncoding];");
          break;
        default:
          u3(), a3(`NSData *postData = [[NSData alloc] initWithData:[@"${e3.text}" dataUsingEncoding:NSUTF8StringEncoding]];`);
      }
    return u3(), a3(`NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"${n3}"]`), a3("                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy"), a3(`                                                   timeoutInterval:${s3.timeout.toFixed(1)}];`), a3(`[request setHTTPMethod:@"${r3}"];`), c3.hasHeaders && a3("[request setAllHTTPHeaderFields:headers];"), c3.hasBody && a3("[request setHTTPBody:postData];"), u3(), a3("NSURLSession *session = [NSURLSession sharedSession];"), a3("NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request"), a3("                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {"), a3("                                            if (error) {", 1), a3('                                            NSLog(@"%@", error);', 2), a3("                                            } else {", 1), a3("                                            NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;", 2), a3('                                            NSLog(@"%@", httpResponse);', 2), a3("                                            }", 1), a3("                                            }];"), a3("[dataTask resume];"), l3();
  }
}, JN = {
  info: {
    key: "objc",
    title: "Objective-C",
    extname: ".m",
    default: "nsurlsession"
  },
  clientsById: {
    nsurlsession: KN
  }
}, eW = {
  info: {
    key: "cohttp",
    title: "CoHTTP",
    link: "https://github.com/mirage/ocaml-cohttp",
    description: "Cohttp is a very lightweight HTTP server using Lwt or Async for OCaml"
  },
  convert: ({ fullUrl: t10, allHeaders: e3, postData: r3, method: n3 }, i3) => {
    const o3 = {
      indent: "  ",
      ...i3
    }, s3 = ["get", "post", "head", "delete", "patch", "put", "options"], { push: a3, blank: l3, join: u3 } = new et({ indent: o3.indent });
    a3("open Cohttp_lwt_unix"), a3("open Cohttp"), a3("open Lwt"), l3(), a3(`let uri = Uri.of_string "${t10}" in`);
    const c3 = Object.keys(e3);
    c3.length === 1 ? a3(`let headers = Header.add (Header.init ()) "${c3[0]}" "${Bt(e3[c3[0]])}" in`) : c3.length > 1 && (a3("let headers = Header.add_list (Header.init ()) ["), c3.forEach((h10) => {
      a3(`("${h10}", "${Bt(e3[h10])}");`, 1);
    }), a3("] in")), r3 != null && r3.text && a3(`let body = Cohttp_lwt_body.of_string ${JSON.stringify(r3.text)} in`), l3();
    const f3 = c3.length ? "~headers " : "", d3 = r3 != null && r3.text ? "~body " : "", p10 = s3.includes(n3.toLowerCase()) ? `\`${n3.toUpperCase()}` : `(Code.method_of_string "${n3}")`;
    return a3(`Client.call ${f3}${d3}${p10} uri`), a3(">>= fun (res, body_stream) ->"), a3("(* Do stuff with the result *)", 1), u3();
  }
}, tW = {
  info: {
    key: "ocaml",
    title: "OCaml",
    extname: ".ml",
    default: "cohttp"
  },
  clientsById: {
    cohttp: eW
  }
}, $t = (t10, e3, r3) => {
  switch (r3 = r3 || "", e3 = e3 || "", Object.prototype.toString.call(t10)) {
    case "[object Null]":
      return "null";
    case "[object Undefined]":
      return "null";
    case "[object String]":
      return `'${Gl(t10, { delimiter: "'", escapeNewlines: false })}'`;
    case "[object Number]":
      return t10.toString();
    case "[object Array]": {
      const n3 = t10.map((i3) => $t(i3, `${e3}${e3}`, e3)).join(`,
${e3}`);
      return `[
${e3}${n3}
${r3}]`;
    }
    case "[object Object]": {
      const n3 = [];
      for (const i3 in t10)
        Object.prototype.hasOwnProperty.call(t10, i3) && n3.push(`${$t(i3, e3)} => ${$t(t10[i3], `${e3}${e3}`, e3)}`);
      return `[
${e3}${n3.join(`,
${e3}`)}
${r3}]`;
    }
    default:
      return "null";
  }
}, _S = [
  "ACL",
  "BASELINE_CONTROL",
  "CHECKIN",
  "CHECKOUT",
  "CONNECT",
  "COPY",
  "DELETE",
  "GET",
  "HEAD",
  "LABEL",
  "LOCK",
  "MERGE",
  "MKACTIVITY",
  "MKCOL",
  "MKWORKSPACE",
  "MOVE",
  "OPTIONS",
  "POST",
  "PROPFIND",
  "PROPPATCH",
  "PUT",
  "REPORT",
  "TRACE",
  "UNCHECKOUT",
  "UNLOCK",
  "UPDATE",
  "VERSION_CONTROL"
], rW = {
  info: {
    key: "curl",
    title: "cURL",
    link: "http://php.net/manual/en/book.curl.php",
    description: "PHP with ext-curl"
  },
  convert: ({ uriObj: t10, postData: e3, fullUrl: r3, method: n3, httpVersion: i3, cookies: o3, headersObj: s3 }, a3 = {}) => {
    const { closingTag: l3 = false, indent: u3 = "  ", maxRedirects: c3 = 10, namedErrors: f3 = false, noTags: d3 = false, shortTags: p10 = false, timeout: h10 = 30 } = a3, { push: m10, blank: O10, join: g } = new et({ indent: u3 });
    d3 || (m10(p10 ? "<?" : "<?php"), O10()), m10("$curl = curl_init();"), O10();
    const v10 = [
      {
        escape: true,
        name: "CURLOPT_PORT",
        value: t10.port === "" ? null : t10.port
      },
      {
        escape: true,
        name: "CURLOPT_URL",
        value: r3
      },
      {
        escape: false,
        name: "CURLOPT_RETURNTRANSFER",
        value: "true"
      },
      {
        escape: true,
        name: "CURLOPT_ENCODING",
        value: ""
      },
      {
        escape: false,
        name: "CURLOPT_MAXREDIRS",
        value: c3
      },
      {
        escape: false,
        name: "CURLOPT_TIMEOUT",
        value: h10
      },
      {
        escape: false,
        name: "CURLOPT_HTTP_VERSION",
        value: i3 === "HTTP/1.0" ? "CURL_HTTP_VERSION_1_0" : "CURL_HTTP_VERSION_1_1"
      },
      {
        escape: true,
        name: "CURLOPT_CUSTOMREQUEST",
        value: n3
      },
      {
        escape: !(e3 != null && e3.jsonObj),
        name: "CURLOPT_POSTFIELDS",
        value: e3 ? e3.jsonObj ? `json_encode(${$t(e3.jsonObj, u3.repeat(2), u3)})` : e3.text : void 0
      }
    ];
    m10("curl_setopt_array($curl, [");
    const S10 = new et({ indent: u3, join: `
${u3}` });
    v10.forEach(({ value: P10, name: q5, escape: N5 }) => {
      P10 != null && S10.push(`${q5} => ${N5 ? JSON.stringify(P10) : P10},`);
    });
    const $10 = o3.map((P10) => `${encodeURIComponent(P10.name)}=${encodeURIComponent(P10.value)}`);
    $10.length && S10.push(`CURLOPT_COOKIE => "${$10.join("; ")}",`);
    const _10 = Object.keys(s3).sort().map((P10) => `"${P10}: ${Bt(s3[P10])}"`);
    return _10.length && (S10.push("CURLOPT_HTTPHEADER => ["), S10.push(_10.join(`,
${u3}${u3}`), 1), S10.push("],")), m10(S10.join(), 1), m10("]);"), O10(), m10("$response = curl_exec($curl);"), m10("$err = curl_error($curl);"), O10(), m10("curl_close($curl);"), O10(), m10("if ($err) {"), m10(f3 ? 'echo array_flip(get_defined_constants(true)["curl"])[$err];' : 'echo "cURL Error #:" . $err;', 1), m10("} else {"), m10("echo $response;", 1), m10("}"), !d3 && l3 && (O10(), m10("?>")), g();
  }
}, nW = {
  info: {
    key: "guzzle",
    title: "Guzzle",
    link: "http://docs.guzzlephp.org/en/stable/",
    description: "PHP with Guzzle"
  },
  convert: ({ postData: t10, fullUrl: e3, method: r3, cookies: n3, headersObj: i3 }, o3) => {
    var s3;
    const a3 = {
      closingTag: false,
      indent: "  ",
      noTags: false,
      shortTags: false,
      ...o3
    }, { push: l3, blank: u3, join: c3 } = new et({ indent: a3.indent }), { code: f3, push: d3, join: p10 } = new et({ indent: a3.indent });
    switch (a3.noTags || (l3(a3.shortTags ? "<?" : "<?php"), u3()), t10 == null ? void 0 : t10.mimeType) {
      case "application/x-www-form-urlencoded":
        d3(`'form_params' => ${$t(t10.paramsObj, a3.indent + a3.indent, a3.indent)},`, 1);
        break;
      case "multipart/form-data": {
        const O10 = [];
        if (t10.params && t10.params.forEach(function(g) {
          if (g.fileName) {
            const v10 = {
              name: g.name,
              filename: g.fileName,
              contents: g.value
            };
            g.contentType && (v10.headers = { "Content-Type": g.contentType }), O10.push(v10);
          } else
            g.value && O10.push({
              name: g.name,
              contents: g.value
            });
        }), O10.length && (d3(`'multipart' => ${$t(O10, a3.indent + a3.indent, a3.indent)}`, 1), gd(i3, "content-type") && !((s3 = Cn(i3, "content-type")) === null || s3 === void 0) && s3.indexOf("boundary"))) {
          const g = yr(i3, "content-type");
          g && delete i3[g];
        }
        break;
      }
      default:
        t10 != null && t10.text && d3(`'body' => ${$t(t10.text)},`, 1);
    }
    const h10 = Object.keys(i3).sort().map(function(O10) {
      return `${a3.indent}${a3.indent}'${O10}' => '${Kl(i3[O10])}',`;
    }), m10 = n3.map((O10) => `${encodeURIComponent(O10.name)}=${encodeURIComponent(O10.value)}`).join("; ");
    return m10.length && h10.push(`${a3.indent}${a3.indent}'cookie' => '${Kl(m10)}',`), h10.length && (d3("'headers' => [", 1), d3(h10.join(`
`)), d3("],", 1)), l3("$client = new \\GuzzleHttp\\Client();"), u3(), f3.length ? (l3(`$response = $client->request('${r3}', '${e3}', [`), l3(p10()), l3("]);")) : l3(`$response = $client->request('${r3}', '${e3}');`), u3(), l3("echo $response->getBody();"), !a3.noTags && a3.closingTag && (u3(), l3("?>")), c3();
  }
}, iW = {
  info: {
    key: "http1",
    title: "HTTP v1",
    link: "http://php.net/manual/en/book.http.php",
    description: "PHP with pecl/http v1"
  },
  convert: ({ method: t10, url: e3, postData: r3, queryObj: n3, headersObj: i3, cookiesObj: o3 }, s3 = {}) => {
    const { closingTag: a3 = false, indent: l3 = "  ", noTags: u3 = false, shortTags: c3 = false } = s3, { push: f3, blank: d3, join: p10 } = new et({ indent: l3 });
    switch (u3 || (f3(c3 ? "<?" : "<?php"), d3()), _S.includes(t10.toUpperCase()) || f3(`HttpRequest::methodRegister('${t10}');`), f3("$request = new HttpRequest();"), f3(`$request->setUrl(${$t(e3)});`), _S.includes(t10.toUpperCase()) ? f3(`$request->setMethod(HTTP_METH_${t10.toUpperCase()});`) : f3(`$request->setMethod(HttpRequest::HTTP_METH_${t10.toUpperCase()});`), d3(), Object.keys(n3).length && (f3(`$request->setQueryData(${$t(n3, l3)});`), d3()), Object.keys(i3).length && (f3(`$request->setHeaders(${$t(i3, l3)});`), d3()), Object.keys(o3).length && (f3(`$request->setCookies(${$t(o3, l3)});`), d3()), r3 == null ? void 0 : r3.mimeType) {
      case "application/x-www-form-urlencoded":
        f3(`$request->setContentType(${$t(r3.mimeType)});`), f3(`$request->setPostFields(${$t(r3.paramsObj, l3)});`), d3();
        break;
      case "application/json":
        f3(`$request->setContentType(${$t(r3.mimeType)});`), f3(`$request->setBody(json_encode(${$t(r3.jsonObj, l3)}));`), d3();
        break;
      default:
        r3 != null && r3.text && (f3(`$request->setBody(${$t(r3.text)});`), d3());
    }
    return f3("try {"), f3("$response = $request->send();", 1), d3(), f3("echo $response->getBody();", 1), f3("} catch (HttpException $ex) {"), f3("echo $ex;", 1), f3("}"), !u3 && a3 && (d3(), f3("?>")), p10();
  }
}, oW = {
  info: {
    key: "http2",
    title: "HTTP v2",
    link: "http://devel-m6w6.rhcloud.com/mdref/http",
    description: "PHP with pecl/http v2"
  },
  convert: ({ postData: t10, headersObj: e3, method: r3, queryObj: n3, cookiesObj: i3, url: o3 }, s3 = {}) => {
    var a3;
    const { closingTag: l3 = false, indent: u3 = "  ", noTags: c3 = false, shortTags: f3 = false } = s3, { push: d3, blank: p10, join: h10 } = new et({ indent: u3 });
    let m10 = false;
    switch (c3 || (d3(f3 ? "<?" : "<?php"), p10()), d3("$client = new http\\Client;"), d3("$request = new http\\Client\\Request;"), p10(), t10 == null ? void 0 : t10.mimeType) {
      case "application/x-www-form-urlencoded":
        d3("$body = new http\\Message\\Body;"), d3(`$body->append(new http\\QueryString(${$t(t10.paramsObj, u3)}));`), p10(), m10 = true;
        break;
      case "multipart/form-data": {
        if (!t10.params)
          break;
        const O10 = [], g = {};
        t10.params.forEach(({ name: $10, fileName: _10, value: P10, contentType: q5 }) => {
          if (_10) {
            O10.push({
              name: $10,
              type: q5,
              file: _10,
              data: P10
            });
            return;
          }
          P10 && (g[$10] = P10);
        });
        const v10 = Object.keys(g).length ? $t(g, u3) : "null", S10 = O10.length ? $t(O10, u3) : "null";
        if (d3("$body = new http\\Message\\Body;"), d3(`$body->addForm(${v10}, ${S10});`), gd(e3, "content-type") && !((a3 = Cn(e3, "content-type")) === null || a3 === void 0) && a3.indexOf("boundary")) {
          const $10 = yr(e3, "content-type");
          $10 && delete e3[$10];
        }
        p10(), m10 = true;
        break;
      }
      case "application/json":
        d3("$body = new http\\Message\\Body;"), d3(`$body->append(json_encode(${$t(t10.jsonObj, u3)}));`), m10 = true;
        break;
      default:
        t10 != null && t10.text && (d3("$body = new http\\Message\\Body;"), d3(`$body->append(${$t(t10.text)});`), p10(), m10 = true);
    }
    return d3(`$request->setRequestUrl(${$t(o3)});`), d3(`$request->setRequestMethod(${$t(r3)});`), m10 && (d3("$request->setBody($body);"), p10()), Object.keys(n3).length && (d3(`$request->setQuery(new http\\QueryString(${$t(n3, u3)}));`), p10()), Object.keys(e3).length && (d3(`$request->setHeaders(${$t(e3, u3)});`), p10()), Object.keys(i3).length && (p10(), d3(`$client->setCookies(${$t(i3, u3)});`), p10()), d3("$client->enqueue($request)->send();"), d3("$response = $client->getResponse();"), p10(), d3("echo $response->getBody();"), !c3 && l3 && (p10(), d3("?>")), h10();
  }
}, sW = {
  info: {
    key: "php",
    title: "PHP",
    extname: ".php",
    default: "curl"
  },
  clientsById: {
    curl: rW,
    guzzle: nW,
    http1: iW,
    http2: oW
  }
}, qQ = (t10) => ({ method: r3, headersObj: n3, cookies: i3, uriObj: o3, fullUrl: s3, postData: a3, allHeaders: l3 }) => {
  const { push: u3, join: c3 } = new et();
  if (!["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"].includes(r3.toUpperCase()))
    return "Method not supported";
  const d3 = [], p10 = Object.keys(n3);
  return p10.length && (u3("$headers=@{}"), p10.forEach((h10) => {
    h10 !== "connection" && u3(`$headers.Add("${h10}", "${Gl(n3[h10], { escapeChar: "`" })}")`);
  }), d3.push("-Headers $headers")), i3.length && (u3("$session = New-Object Microsoft.PowerShell.Commands.WebRequestSession"), i3.forEach((h10) => {
    u3("$cookie = New-Object System.Net.Cookie"), u3(`$cookie.Name = '${h10.name}'`), u3(`$cookie.Value = '${h10.value}'`), u3(`$cookie.Domain = '${o3.host}'`), u3("$session.Cookies.Add($cookie)");
  }), d3.push("-WebSession $session")), a3 != null && a3.text && (d3.push(`-ContentType '${Gl(Cn(l3, "content-type"), {
    delimiter: "'",
    escapeChar: "`"
  })}'`), d3.push(`-Body '${a3.text}'`)), u3(`$response = ${t10} -Uri '${s3}' -Method ${r3} ${d3.join(" ")}`), c3();
}, aW = {
  info: {
    key: "restmethod",
    title: "Invoke-RestMethod",
    link: "https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Utility/Invoke-RestMethod",
    description: "Powershell Invoke-RestMethod client"
  },
  convert: qQ("Invoke-RestMethod")
}, lW = {
  info: {
    key: "webrequest",
    title: "Invoke-WebRequest",
    link: "https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Utility/Invoke-WebRequest",
    description: "Powershell Invoke-WebRequest client"
  },
  convert: qQ("Invoke-WebRequest")
}, uW = {
  info: {
    key: "powershell",
    title: "Powershell",
    extname: ".ps1",
    default: "webrequest"
  },
  clientsById: {
    webrequest: lW,
    restmethod: aW
  }
}, cW = {
  info: {
    key: "python3",
    title: "http.client",
    link: "https://docs.python.org/3/library/http.client.html",
    description: "Python3 HTTP Client"
  },
  convert: ({ uriObj: { path: t10, protocol: e3, host: r3 }, postData: n3, allHeaders: i3, method: o3 }, s3 = {}) => {
    const { insecureSkipVerify: a3 = false } = s3, { push: l3, blank: u3, join: c3 } = new et();
    l3("import http.client"), a3 && l3("import ssl"), u3(), e3 === "https:" ? (l3(`conn = http.client.HTTPSConnection("${r3}"${a3 ? ", context = ssl._create_unverified_context()" : ""})`), u3()) : (l3(`conn = http.client.HTTPConnection("${r3}")`), u3());
    const f3 = JSON.stringify(n3 == null ? void 0 : n3.text);
    f3 && (l3(`payload = ${f3}`), u3());
    const d3 = i3, p10 = Object.keys(d3).length;
    if (p10 === 1)
      for (const h10 in d3)
        l3(`headers = { '${h10}': "${Bt(d3[h10])}" }`), u3();
    else if (p10 > 1) {
      let h10 = 1;
      l3("headers = {");
      for (const m10 in d3)
        h10++ !== p10 ? l3(`    '${m10}': "${Bt(d3[m10])}",`) : l3(`    '${m10}': "${Bt(d3[m10])}"`);
      l3("}"), u3();
    }
    return l3(f3 && p10 ? `conn.request("${o3}", "${t10}", payload, headers)` : f3 && !p10 ? `conn.request("${o3}", "${t10}", payload)` : !f3 && p10 ? `conn.request("${o3}", "${t10}", headers=headers)` : `conn.request("${o3}", "${t10}")`), u3(), l3("res = conn.getresponse()"), l3("data = res.read()"), u3(), l3('print(data.decode("utf-8"))'), c3();
  }
};
function xS(t10, e3, r3, n3, i3) {
  const o3 = n3.repeat(i3), s3 = n3.repeat(i3 - 1), a3 = r3 ? `,
${o3}` : ", ", l3 = t10 === "object" ? "{" : "[", u3 = t10 === "object" ? "}" : "]";
  return r3 ? `${l3}
${o3}${e3.join(a3)}
${s3}${u3}` : t10 === "object" && e3.length > 0 ? `${l3} ${e3.join(a3)} ${u3}` : `${l3}${e3.join(a3)}${u3}`;
}
const Fs = (t10, e3, r3) => {
  switch (r3 = r3 === void 0 ? 1 : r3 + 1, Object.prototype.toString.call(t10)) {
    case "[object Number]":
      return t10;
    case "[object Array]": {
      let n3 = false;
      const i3 = t10.map((o3) => (Object.prototype.toString.call(o3) === "[object Object]" && (n3 = Object.keys(o3).length > 1), Fs(o3, e3, r3)));
      return xS("array", i3, n3, e3.indent, r3);
    }
    case "[object Object]": {
      const n3 = [];
      for (const i3 in t10)
        n3.push(`"${i3}": ${Fs(t10[i3], e3, r3)}`);
      return xS("object", n3, e3.pretty && n3.length > 1, e3.indent, r3);
    }
    case "[object Null]":
      return "None";
    case "[object Boolean]":
      return t10 ? "True" : "False";
    default:
      return t10 == null ? "" : `"${t10.toString().replace(/"/g, '\\"')}"`;
  }
}, fW = ["HEAD", "GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"], dW = {
  info: {
    key: "requests",
    title: "Requests",
    link: "http://docs.python-requests.org/en/latest/api/#requests.request",
    description: "Requests HTTP library"
  },
  convert: ({ queryObj: t10, url: e3, postData: r3, allHeaders: n3, method: i3 }, o3) => {
    const s3 = {
      indent: "    ",
      pretty: true,
      ...o3
    }, { push: a3, blank: l3, join: u3 } = new et({ indent: s3.indent });
    a3("import requests"), l3(), a3(`url = "${e3}"`), l3();
    let c3;
    Object.keys(t10).length && (c3 = `querystring = ${JSON.stringify(t10)}`, a3(c3), l3());
    const f3 = n3;
    let d3 = {};
    const p10 = {};
    let h10 = false, m10 = false, O10 = false;
    switch (r3 == null ? void 0 : r3.mimeType) {
      case "application/json":
        r3.jsonObj && (a3(`payload = ${Fs(r3.jsonObj, s3)}`), O10 = true, m10 = true);
        break;
      case "multipart/form-data":
        if (!r3.params)
          break;
        if (d3 = {}, r3.params.forEach((S10) => {
          S10.fileName ? (p10[S10.name] = `open('${S10.fileName}', 'rb')`, h10 = true) : (d3[S10.name] = S10.value, m10 = true);
        }), h10) {
          a3(`files = ${Fs(p10, s3)}`), m10 && a3(`payload = ${Fs(d3, s3)}`);
          const S10 = yr(f3, "content-type");
          S10 && delete f3[S10];
        } else {
          const S10 = JSON.stringify(r3.text);
          S10 && (a3(`payload = ${S10}`), m10 = true);
        }
        break;
      default: {
        if (!r3)
          break;
        if (r3.mimeType === "application/x-www-form-urlencoded" && r3.paramsObj) {
          a3(`payload = ${Fs(r3.paramsObj, s3)}`), m10 = true;
          break;
        }
        const S10 = JSON.stringify(r3.text);
        S10 && (a3(`payload = ${S10}`), m10 = true);
      }
    }
    const g = Object.keys(f3).length;
    if (g === 0 && (m10 || h10))
      l3();
    else if (g === 1)
      for (const S10 in f3)
        a3(`headers = {"${S10}": "${Bt(f3[S10])}"}`), l3();
    else if (g > 1) {
      let S10 = 1;
      a3("headers = {");
      for (const $10 in f3)
        a3(S10 !== g ? `"${$10}": "${Bt(f3[$10])}",` : `"${$10}": "${Bt(f3[$10])}"`, 1), S10 += 1;
      a3("}"), l3();
    }
    let v10 = fW.includes(i3) ? `response = requests.${i3.toLowerCase()}(url` : `response = requests.request("${i3}", url`;
    return m10 && (O10 ? v10 += ", json=payload" : v10 += ", data=payload"), h10 && (v10 += ", files=files"), g > 0 && (v10 += ", headers=headers"), c3 && (v10 += ", params=querystring"), v10 += ")", a3(v10), l3(), a3("print(response.json())"), u3();
  }
}, hW = {
  info: {
    key: "python",
    title: "Python",
    extname: ".py",
    default: "python3"
  },
  clientsById: {
    python3: cW,
    requests: dW
  }
}, pW = {
  info: {
    key: "httr",
    title: "httr",
    link: "https://cran.r-project.org/web/packages/httr/vignettes/quickstart.html",
    description: "httr: Tools for Working with URLs and HTTP"
  },
  convert: ({ url: t10, queryObj: e3, queryString: r3, postData: n3, allHeaders: i3, method: o3 }, s3 = {}) => {
    var a3, l3;
    const { push: u3, blank: c3, join: f3 } = new et({
      indent: (a3 = s3.indent) !== null && a3 !== void 0 ? a3 : "  "
    });
    u3("library(httr)"), c3(), u3(`url <- "${t10}"`), c3();
    const d3 = e3;
    delete e3.key;
    const p10 = Object.entries(d3), h10 = p10.length;
    if (h10 === 1) {
      const B5 = p10[0];
      u3(`queryString <- list(${B5[0]} = "${B5[1]}")`), c3();
    } else
      h10 > 1 && (u3("queryString <- list("), p10.forEach(([B5, H10], ne) => {
        const fe = ne !== h10 - 1 ? "," : "";
        u3(`${B5} = "${H10}"${fe}`, 1);
      }), u3(")"), c3());
    const m10 = JSON.stringify(n3 == null ? void 0 : n3.text);
    if (m10 && (u3(`payload <- ${m10}`), c3()), n3 && (n3.text || n3.jsonObj || n3.params))
      switch (n3.mimeType) {
        case "application/x-www-form-urlencoded":
          u3('encode <- "form"'), c3();
          break;
        case "application/json":
          u3('encode <- "json"'), c3();
          break;
        case "multipart/form-data":
          u3('encode <- "multipart"'), c3();
          break;
        default:
          u3('encode <- "raw"'), c3();
          break;
      }
    const O10 = Cn(i3, "cookie"), g = Cn(i3, "accept"), v10 = O10 ? `set_cookies(\`${String(O10).replace(/;/g, '", `').replace(/` /g, "`").replace(/[=]/g, '` = "')}")` : void 0, S10 = g ? `accept("${Bt(g)}")` : void 0, $10 = `content_type("${Bt((l3 = n3 == null ? void 0 : n3.mimeType) !== null && l3 !== void 0 ? l3 : "application/octet-stream")}")`, _10 = Object.entries(i3).filter(([B5]) => !["cookie", "accept", "content-type"].includes(B5.toLowerCase())).map(([B5, H10]) => `'${B5}' = '${Kl(H10)}'`).join(", "), P10 = _10 ? `add_headers(${_10})` : void 0;
    let q5 = `response <- VERB("${o3}", url`;
    m10 && (q5 += ", body = payload"), r3.length && (q5 += ", query = queryString");
    const N5 = [P10, $10, S10, v10].filter((B5) => !!B5).join(", ");
    return N5 && (q5 += `, ${N5}`), n3 && (n3.text || n3.jsonObj || n3.params) && (q5 += ", encode = encode"), q5 += ")", u3(q5), c3(), u3('content(response, "text")'), f3();
  }
}, OW = {
  info: {
    key: "r",
    title: "R",
    extname: ".r",
    default: "httr"
  },
  clientsById: {
    httr: pW
  }
}, mW = {
  info: {
    key: "native",
    title: "net::http",
    link: "http://ruby-doc.org/stdlib-2.2.1/libdoc/net/http/rdoc/Net/HTTP.html",
    description: "Ruby HTTP client"
  },
  convert: ({ uriObj: t10, method: e3, fullUrl: r3, postData: n3, allHeaders: i3 }, o3 = {}) => {
    const { insecureSkipVerify: s3 = false } = o3, { push: a3, blank: l3, join: u3 } = new et();
    a3("require 'uri'"), a3("require 'net/http'"), l3();
    const c3 = e3.toUpperCase(), f3 = [
      "GET",
      "POST",
      "HEAD",
      "DELETE",
      "PATCH",
      "PUT",
      "OPTIONS",
      "COPY",
      "LOCK",
      "UNLOCK",
      "MOVE",
      "TRACE"
    ], d3 = c3.charAt(0) + c3.substring(1).toLowerCase();
    f3.includes(c3) || (a3(`class Net::HTTP::${d3} < Net::HTTPRequest`), a3(`  METHOD = '${c3.toUpperCase()}'`), a3(`  REQUEST_HAS_BODY = '${n3 != null && n3.text ? "true" : "false"}'`), a3("  RESPONSE_HAS_BODY = true"), a3("end"), l3()), a3(`url = URI("${r3}")`), l3(), a3("http = Net::HTTP.new(url.host, url.port)"), t10.protocol === "https:" && (a3("http.use_ssl = true"), s3 && a3("http.verify_mode = OpenSSL::SSL::VERIFY_NONE")), l3(), a3(`request = Net::HTTP::${d3}.new(url)`);
    const p10 = Object.keys(i3);
    return p10.length && p10.forEach((h10) => {
      a3(`request["${h10}"] = '${Kl(i3[h10])}'`);
    }), n3 != null && n3.text && a3(`request.body = ${JSON.stringify(n3.text)}`), l3(), a3("response = http.request(request)"), a3("puts response.read_body"), u3();
  }
}, gW = {
  info: {
    key: "ruby",
    title: "Ruby",
    extname: ".rb",
    default: "native"
  },
  clientsById: {
    native: mW
  }
}, lr = (t10 = "") => /^[a-z0-9-_/.@%^=:]+$/i.test(t10) ? t10 : `'${t10.replace(/'/g, "'\\''")}'`, yW = (t10) => t10.replace(/\r/g, "\\r").replace(/\n/g, "\\n"), vW = {
  "http1.0": "0",
  "url ": "",
  cookie: "b",
  data: "d",
  form: "F",
  globoff: "g",
  header: "H",
  insecure: "k",
  request: "X"
}, bW = (t10) => (e3) => {
  if (t10) {
    const r3 = vW[e3];
    return r3 ? `-${r3}` : "";
  }
  return `--${e3}`;
}, SW = {
  info: {
    key: "curl",
    title: "cURL",
    link: "http://curl.haxx.se/",
    description: "cURL is a command line tool and library for transferring data with URL syntax"
  },
  convert: ({ fullUrl: t10, method: e3, httpVersion: r3, headersObj: n3, allHeaders: i3, postData: o3 }, s3 = {}) => {
    var a3;
    const { binary: l3 = false, globOff: u3 = false, indent: c3 = "  ", insecureSkipVerify: f3 = false, prettifyJson: d3 = false, short: p10 = false } = s3, { push: h10, join: m10 } = new et({
      ...typeof c3 == "string" ? { indent: c3 } : {},
      join: c3 !== false ? ` \\
${c3}` : " "
    }), O10 = bW(p10);
    let g = lr(t10);
    if (h10(`curl ${O10("request")} ${e3}`), u3 && (g = unescape(g), h10(O10("globoff"))), h10(`${O10("url ")}${g}`), f3 && h10(O10("insecure")), r3 === "HTTP/1.0" && h10(O10("http1.0")), Cn(i3, "accept-encoding") && h10("--compressed"), (o3 == null ? void 0 : o3.mimeType) === "multipart/form-data") {
      const v10 = yr(n3, "content-type");
      if (v10) {
        const S10 = n3[v10];
        if (v10 && S10) {
          const $10 = S10.replace(/; boundary.+?(?=(;|$))/, "");
          n3[v10] = $10, i3[v10] = $10;
        }
      }
    }
    switch (Object.keys(n3).sort().forEach((v10) => {
      const S10 = `${v10}: ${n3[v10]}`;
      h10(`${O10("header")} ${lr(S10)}`);
    }), i3.cookie && h10(`${O10("cookie")} ${lr(i3.cookie)}`), o3 == null ? void 0 : o3.mimeType) {
      case "multipart/form-data":
        (a3 = o3.params) === null || a3 === void 0 || a3.forEach((v10) => {
          let S10 = "";
          v10.fileName ? S10 = `${v10.name}=@${v10.fileName}` : S10 = `${v10.name}=${v10.value}`, h10(`${O10("form")} ${lr(S10)}`);
        });
        break;
      case "application/x-www-form-urlencoded":
        o3.params ? o3.params.forEach((v10) => {
          const S10 = v10.name, $10 = encodeURIComponent(v10.name), _10 = $10 !== S10;
          h10(`${l3 ? "--data-binary" : `--data${_10 ? "-urlencode" : ""}`} ${lr(`${_10 ? $10 : S10}=${v10.value}`)}`);
        }) : h10(`${l3 ? "--data-binary" : O10("data")} ${lr(o3.text)}`);
        break;
      default: {
        if (!o3 || !o3.text)
          break;
        const v10 = l3 ? "--data-binary" : O10("data");
        let S10 = false;
        if (hN(o3.mimeType) && o3.text.length > 2 && d3)
          try {
            const _10 = JSON.parse(o3.text);
            S10 = true;
            const P10 = JSON.stringify(_10, void 0, c3);
            o3.text.indexOf("'") > 0 ? h10(`${v10} @- <<EOF
${P10}
EOF`) : h10(`${v10} '
${P10}
'`);
          } catch {
          }
        S10 || h10(`${v10} ${lr(o3.text)}`);
      }
    }
    return m10();
  }
}, $W = {
  info: {
    key: "httpie",
    title: "HTTPie",
    link: "http://httpie.org/",
    description: "a CLI, cURL-like tool for humans"
  },
  convert: ({ allHeaders: t10, postData: e3, queryObj: r3, fullUrl: n3, method: i3, url: o3 }, s3) => {
    const a3 = {
      body: false,
      cert: false,
      headers: false,
      indent: "  ",
      pretty: false,
      print: false,
      queryParams: false,
      short: false,
      style: false,
      timeout: false,
      verbose: false,
      verify: false,
      ...s3
    }, { push: l3, join: u3, unshift: c3 } = new et({
      indent: a3.indent,
      // @ts-expect-error SEEMS LEGIT
      join: a3.indent !== false ? ` \\
${a3.indent}` : " "
    });
    let f3 = false;
    const d3 = [];
    a3.headers && d3.push(a3.short ? "-h" : "--headers"), a3.body && d3.push(a3.short ? "-b" : "--body"), a3.verbose && d3.push(a3.short ? "-v" : "--verbose"), a3.print && d3.push(`${a3.short ? "-p" : "--print"}=${a3.print}`), a3.verify && d3.push(`--verify=${a3.verify}`), a3.cert && d3.push(`--cert=${a3.cert}`), a3.pretty && d3.push(`--pretty=${a3.pretty}`), a3.style && d3.push(`--style=${a3.style}`), a3.timeout && d3.push(`--timeout=${a3.timeout}`), a3.queryParams && Object.keys(r3).forEach((h10) => {
      const m10 = r3[h10];
      Array.isArray(m10) ? m10.forEach((O10) => {
        l3(`${h10}==${lr(O10)}`);
      }) : l3(`${h10}==${lr(m10)}`);
    }), Object.keys(t10).sort().forEach((h10) => {
      l3(`${h10}:${lr(t10[h10])}`);
    }), (e3 == null ? void 0 : e3.mimeType) === "application/x-www-form-urlencoded" ? e3.params && e3.params.length && (d3.push(a3.short ? "-f" : "--form"), e3.params.forEach((h10) => {
      l3(`${h10.name}=${lr(h10.value)}`);
    })) : f3 = true;
    const p10 = d3.length ? `${d3.join(" ")} ` : "";
    if (o3 = lr(a3.queryParams ? o3 : n3), c3(`http ${p10}${i3} ${o3}`), f3 && (e3 != null && e3.text)) {
      const h10 = lr(e3.text);
      c3(`echo ${h10} | `);
    }
    return u3();
  }
}, wW = {
  info: {
    key: "wget",
    title: "Wget",
    link: "https://www.gnu.org/software/wget/",
    description: "a free software package for retrieving files using HTTP, HTTPS"
  },
  convert: ({ method: t10, postData: e3, allHeaders: r3, fullUrl: n3 }, i3) => {
    const o3 = {
      indent: "  ",
      short: false,
      verbose: false,
      ...i3
    }, { push: s3, join: a3 } = new et({
      indent: o3.indent,
      // @ts-expect-error SEEMS LEGIT
      join: o3.indent !== false ? ` \\
${o3.indent}` : " "
    });
    return o3.verbose ? s3(`wget ${o3.short ? "-v" : "--verbose"}`) : s3(`wget ${o3.short ? "-q" : "--quiet"}`), s3(`--method ${lr(t10)}`), Object.keys(r3).forEach((l3) => {
      const u3 = `${l3}: ${r3[l3]}`;
      s3(`--header ${lr(u3)}`);
    }), e3 != null && e3.text && s3(`--body-data ${yW(lr(e3.text))}`), s3(o3.short ? "-O" : "--output-document"), s3(`- ${lr(n3)}`), a3();
  }
}, PW = {
  info: {
    key: "shell",
    title: "Shell",
    extname: ".sh",
    default: "curl"
  },
  clientsById: {
    curl: SW,
    httpie: $W,
    wget: wW
  }
}, QS = (t10, e3) => e3.repeat(t10), TS = (t10, e3, r3, n3) => {
  const i3 = QS(n3, r3), o3 = QS(n3 - 1, r3), s3 = e3 ? `,
${i3}` : ", ";
  return e3 ? `[
${i3}${t10.join(s3)}
${o3}]` : `[${t10.join(s3)}]`;
}, Bh = (t10, e3, r3) => `let ${t10} = ${um(e3, r3)}`, um = (t10, e3, r3) => {
  switch (r3 = r3 === void 0 ? 1 : r3 + 1, Object.prototype.toString.call(t10)) {
    case "[object Number]":
      return t10;
    case "[object Array]": {
      let n3 = false;
      const i3 = t10.map((o3) => (Object.prototype.toString.call(o3) === "[object Object]" && (n3 = Object.keys(o3).length > 1), um(o3, e3, r3)));
      return TS(i3, n3, e3.indent, r3);
    }
    case "[object Object]": {
      const n3 = [];
      for (const i3 in t10)
        n3.push(`"${i3}": ${um(t10[i3], e3, r3)}`);
      return TS(
        n3,
        // @ts-expect-error needs better types
        e3.pretty && n3.length > 1,
        // @ts-expect-error needs better types
        e3.indent,
        r3
      );
    }
    case "[object Boolean]":
      return t10.toString();
    default:
      return t10 == null ? "" : `"${t10.toString().replace(/"/g, '\\"')}"`;
  }
}, _W = {
  info: {
    key: "nsurlsession",
    title: "NSURLSession",
    link: "https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/index.html",
    description: "Foundation's NSURLSession request"
  },
  convert: ({ allHeaders: t10, postData: e3, fullUrl: r3, method: n3 }, i3) => {
    var o3;
    const s3 = {
      indent: "  ",
      pretty: true,
      timeout: "10",
      ...i3
    }, { push: a3, blank: l3, join: u3 } = new et({ indent: s3.indent }), c3 = {
      hasHeaders: false,
      hasBody: false
    };
    if (a3("import Foundation"), Object.keys(t10).length && (c3.hasHeaders = true, l3(), a3(Bh("headers", t10, s3))), e3 && (e3.text || e3.jsonObj || e3.params))
      switch (c3.hasBody = true, e3.mimeType) {
        case "application/x-www-form-urlencoded":
          if (l3(), !((o3 = e3.params) === null || o3 === void 0) && o3.length) {
            const [f3, ...d3] = e3.params;
            a3(`let postData = NSMutableData(data: "${f3.name}=${f3.value}".data(using: String.Encoding.utf8)!)`), d3.forEach(({ name: p10, value: h10 }) => {
              a3(`postData.append("&${p10}=${h10}".data(using: String.Encoding.utf8)!)`);
            });
          } else
            c3.hasBody = false;
          break;
        case "application/json":
          e3.jsonObj && (a3(`${Bh("parameters", e3.jsonObj, s3)} as [String : Any]`), l3(), a3("let postData = JSONSerialization.data(withJSONObject: parameters, options: [])"));
          break;
        case "multipart/form-data":
          a3(Bh("parameters", e3.params, s3)), l3(), a3(`let boundary = "${e3.boundary}"`), l3(), a3('var body = ""'), a3("var error: NSError? = nil"), a3("for param in parameters {"), a3('let paramName = param["name"]!', 1), a3('body += "--\\(boundary)\\r\\n"', 1), a3('body += "Content-Disposition:form-data; name=\\"\\(paramName)\\""', 1), a3('if let filename = param["fileName"] {', 1), a3('let contentType = param["content-type"]!', 2), a3("let fileContent = String(contentsOfFile: filename, encoding: String.Encoding.utf8)", 2), a3("if (error != nil) {", 2), a3("print(error as Any)", 3), a3("}", 2), a3('body += "; filename=\\"\\(filename)\\"\\r\\n"', 2), a3('body += "Content-Type: \\(contentType)\\r\\n\\r\\n"', 2), a3("body += fileContent", 2), a3('} else if let paramValue = param["value"] {', 1), a3('body += "\\r\\n\\r\\n\\(paramValue)"', 2), a3("}", 1), a3("}");
          break;
        default:
          l3(), a3(`let postData = NSData(data: "${e3.text}".data(using: String.Encoding.utf8)!)`);
      }
    return l3(), a3(`let request = NSMutableURLRequest(url: NSURL(string: "${r3}")! as URL,`), a3("                                        cachePolicy: .useProtocolCachePolicy,"), a3(
      // @ts-expect-error needs better types
      `                                    timeoutInterval: ${parseInt(s3.timeout, 10).toFixed(1)})`
    ), a3(`request.httpMethod = "${n3}"`), c3.hasHeaders && a3("request.allHTTPHeaderFields = headers"), c3.hasBody && a3("request.httpBody = postData as Data"), l3(), a3("let session = URLSession.shared"), a3("let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in"), a3("if (error != nil) {", 1), a3("print(error as Any)", 2), a3("} else {", 1), a3("let httpResponse = response as? HTTPURLResponse", 2), a3("print(httpResponse)", 2), a3("}", 1), a3("})"), l3(), a3("dataTask.resume()"), u3();
  }
}, xW = {
  info: {
    key: "swift",
    title: "Swift",
    extname: ".swift",
    default: "nsurlsession"
  },
  clientsById: {
    nsurlsession: _W
  }
}, dl = {
  c: mN,
  clojure: vN,
  csharp: wN,
  go: _N,
  http: QN,
  java: RN,
  javascript: NN,
  kotlin: VN,
  node: GN,
  objc: JN,
  ocaml: tW,
  php: sW,
  powershell: uW,
  python: hW,
  r: OW,
  ruby: gW,
  shell: PW,
  swift: xW
}, yd = () => Object.keys(dl).map((t10) => ({
  ...dl[t10].info,
  clients: Object.keys(dl[t10].clientsById).map((e3) => dl[t10].clientsById[e3].info)
}));
function QW(t10) {
  const e3 = t10.split("/");
  return e3[e3.length - 1];
}
const TW = (t10) => typeof t10 == "object" && "log" in t10 && typeof t10.log == "object" && "entries" in t10.log && Array.isArray(t10.log.entries);
class kW {
  constructor(e3) {
    let r3 = [];
    TW(e3) ? r3 = e3.log.entries : r3 = [
      {
        request: e3
      }
    ], this.requests = Promise.all(r3.map(({ request: n3 }) => {
      var i3;
      const o3 = {
        bodySize: 0,
        headersSize: 0,
        headers: [],
        cookies: [],
        httpVersion: "HTTP/1.1",
        queryString: [],
        postData: {
          mimeType: ((i3 = n3.postData) === null || i3 === void 0 ? void 0 : i3.mimeType) || "application/octet-stream"
        },
        ...n3
      };
      return this.prepare(o3);
    }));
  }
  async prepare(e3) {
    var r3, n3, i3, o3;
    const s3 = {
      ...e3,
      fullUrl: "",
      queryObj: {},
      headersObj: {},
      cookiesObj: {},
      allHeaders: {}
    };
    if (s3.queryString && s3.queryString.length && (s3.queryObj = s3.queryString.reduce(yS, {})), s3.headers && s3.headers.length) {
      const p10 = /^HTTP\/2/;
      s3.headersObj = s3.headers.reduce((h10, { name: m10, value: O10 }) => {
        const g = p10.exec(s3.httpVersion) ? m10.toLocaleLowerCase() : m10;
        return {
          ...h10,
          [g]: O10
        };
      }, {});
    }
    s3.cookies && s3.cookies.length && (s3.cookiesObj = s3.cookies.reduceRight((p10, { name: h10, value: m10 }) => ({
      ...p10,
      [h10]: m10
    }), {}));
    const a3 = (r3 = s3.cookies) === null || r3 === void 0 ? void 0 : r3.map(({ name: p10, value: h10 }) => `${encodeURIComponent(p10)}=${encodeURIComponent(h10)}`);
    switch (a3 != null && a3.length && (s3.allHeaders.cookie = a3.join("; ")), (n3 = s3.postData) === null || n3 === void 0 ? void 0 : n3.mimeType) {
      case "multipart/mixed":
      case "multipart/related":
      case "multipart/form-data":
      case "multipart/alternative":
        if (s3.postData.text = "", s3.postData.mimeType = "multipart/form-data", !((i3 = s3.postData) === null || i3 === void 0) && i3.params) {
          const p10 = new oN(), h10 = "---011000010111000001101001";
          (o3 = s3.postData) === null || o3 === void 0 || o3.params.forEach((g) => {
            const v10 = g.name, S10 = g.value || "", $10 = g.fileName;
            lN(S10) ? p10.append(v10, S10, $10) : p10.append(v10, new sN([S10], { type: g.contentType }), $10 && QW($10));
          });
          const { postData: m10 } = s3;
          for await (const g of fN(p10, h10))
            m10.text += g;
          s3.postData.boundary = h10;
          const O10 = yr(s3.headersObj, "content-type") || "content-type";
          s3.headersObj[O10] = `multipart/form-data; boundary=${h10}`;
        }
        break;
      case "application/x-www-form-urlencoded":
        s3.postData.params ? (s3.postData.paramsObj = s3.postData.params.reduce(yS, {}), s3.postData.text = vS(s3.postData.paramsObj).toString()) : s3.postData.text = "";
        break;
      case "text/json":
      case "text/x-json":
      case "application/json":
      case "application/x-json":
        if (s3.postData.mimeType = "application/json", s3.postData.text)
          try {
            s3.postData.jsonObj = JSON.parse(s3.postData.text);
          } catch {
            s3.postData.mimeType = "text/plain";
          }
        break;
    }
    const l3 = {
      ...s3.allHeaders,
      ...s3.headersObj
    }, u3 = new URL(s3.url), c3 = Object.fromEntries(u3.searchParams);
    s3.queryObj = {
      ...s3.queryObj,
      ...c3
    };
    const f3 = vS(s3.queryObj), d3 = new URL(s3.url);
    return d3.search = f3.toString(), u3.search = "", {
      ...s3,
      allHeaders: l3,
      fullUrl: d3.toString(),
      url: u3.toString(),
      uriObj: new pN(d3.toString())
    };
  }
  async convert(e3, r3, n3) {
    !n3 && r3 && (n3 = r3);
    const i3 = dl[e3];
    if (!i3)
      return null;
    const { convert: o3 } = i3.clientsById[r3 || i3.info.default], s3 = (await this.requests).map((a3) => o3(a3, n3));
    return s3.length === 1 ? s3[0] : s3;
  }
}
function EW(t10) {
  return function(r3, n3) {
    t10[r3] = n3;
  };
}
function CW(t10) {
  return function(r3) {
    typeof t10[r3] == "boolean" && (t10[r3] = !t10[r3]);
  };
}
const DQ = () => ({
  isDark: false,
  showSearch: false,
  showMobileDrawer: false,
  activeNavState: "Guide",
  collapsedSidebarItems: {},
  selectedClient: {
    targetKey: "shell",
    clientKey: "curl"
  }
}), Ko = reactive(DQ());
function RW() {
  kF(Ko, DQ());
}
function AW(t10) {
  Ko.collapsedSidebarItems[t10] = !Ko.collapsedSidebarItems[t10];
}
function XW(t10, e3) {
  Ko.collapsedSidebarItems[t10] = e3;
}
function qW(t10) {
  var e3;
  return ((e3 = yd().find((r3) => r3.key === t10.targetKey)) == null ? void 0 : e3.title) ?? t10.targetKey;
}
function DW(t10) {
  var e3, r3;
  return ((r3 = (e3 = yd().find((n3) => n3.key === t10.targetKey)) == null ? void 0 : e3.clients.find((n3) => n3.key === t10.clientKey)) == null ? void 0 : r3.title) ?? t10.clientKey;
}
const Zr = () => ({
  state: readonly(Ko),
  resetState: RW,
  setItem: EW(Ko),
  toggleItem: CW(Ko),
  toggleCollapsedSidebarItem: AW,
  setCollapsedSidebarItem: XW,
  getClientTitle: DW,
  getTargetTitle: qW
}), jW = {
  key: 0,
  class: "loader-wrapper"
}, UW = /* @__PURE__ */ createStaticVNode('<path class="svg-path svg-check-mark" d="m 0 60 l 30 30 l 70 -80" data-v-dbcbb0f9></path><path class="svg-path svg-x-mark" d="m 50 50 l 40 -40" data-v-dbcbb0f9></path><path class="svg-path svg-x-mark" d="m 50 50 l 40 40" data-v-dbcbb0f9></path><path class="svg-path svg-x-mark" d="m 50 50 l -40 -40" data-v-dbcbb0f9></path><path class="svg-path svg-x-mark" d="m 50 50 l -40 40" data-v-dbcbb0f9></path>', 5), IW = {
  key: 0,
  class: "circular-loader"
}, FW = /* @__PURE__ */ defineComponent({
  __name: "FlowLoader",
  props: {
    loaderState: {},
    size: { default: "24px" }
  },
  setup(t10) {
    return useCssVars((e3) => ({
      "656643f5": e3.size
    })), (e3, r3) => e3.loaderState ? (openBlock(), createElementBlock("div", jW, [
      (openBlock(), createElementBlock("svg", {
        class: normalizeClass(["svg-loader", {
          "icon-is-valid": e3.loaderState.valid,
          "icon-is-invalid": e3.loaderState.invalid
        }]),
        viewBox: "0 0 100 100",
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink"
      }, [
        UW,
        e3.loaderState.isLoading ? (openBlock(), createElementBlock("g", IW, [
          createElementVNode("circle", {
            class: normalizeClass(["loader-path", {
              "loader-path-off": e3.loaderState.valid || e3.loaderState.invalid
            }]),
            cx: "50",
            cy: "50",
            fill: "none",
            r: "20",
            "stroke-width": "2"
          }, null, 2)
        ])) : createCommentVNode("", true)
      ], 2))
    ])) : createCommentVNode("", true);
  }
});
const ZW = /* @__PURE__ */ Re(FW, [["__scopeId", "data-v-dbcbb0f9"]]), MW = ["title"], NW = {
  key: 0,
  class: "flow-button-decorator"
}, WW = { class: "flow-button-loader" }, VW = /* @__PURE__ */ defineComponent({
  __name: "FlowButton",
  props: {
    label: {},
    error: { type: Boolean },
    loaderState: {},
    variant: {},
    title: {},
    icon: { type: Boolean }
  },
  setup(t10) {
    return (e3, r3) => (openBlock(), createElementBlock("button", {
      class: normalizeClass(["flow-button", {
        "flow-button-outlined": !e3.error && e3.variant === "outlined",
        "flow-button-clear": !e3.error && e3.variant === "clear",
        "flow-button-text": !e3.error && e3.variant === "text",
        "flow-button--delete": e3.error,
        "flow-button-icon-only": e3.icon
      }]),
      title: e3.title || e3.label,
      type: "button"
    }, [
      e3.$slots.default ? (openBlock(), createElementBlock("div", NW, [
        renderSlot(e3.$slots, "default", {}, void 0, true)
      ])) : createCommentVNode("", true),
      createElementVNode("span", {
        class: normalizeClass({ "sr-only": e3.icon })
      }, toDisplayString(e3.label), 3),
      createElementVNode("div", WW, [
        e3.loaderState ? (openBlock(), createBlock(ZW, {
          key: 0,
          loaderState: e3.loaderState
        }, null, 8, ["loaderState"])) : createCommentVNode("", true)
      ])
    ], 10, MW));
  }
});
const YW = /* @__PURE__ */ Re(VW, [["__scopeId", "data-v-262cdfdc"]]), LW = (t10) => Object.fromEntries(Array.from(t10).map((e3) => [e3.name, e3.value])), BW = (t10) => ({ raw: e3 }) => {
  const n3 = new t10().parseFromString(e3, "image/svg+xml");
  if (n3.getElementsByTagName("parsererror").length)
    return;
  const i3 = n3.documentElement, o3 = LW(i3.attributes), { width: s3, height: a3, ...l3 } = o3;
  return h$3("svg", { ...l3, innerHTML: i3.innerHTML });
}, jQ = defineAsyncComponent(async () => {
  const t10 = typeof DOMParser > "u" ? (await import("./assets/index-c5a56f98.js").then((n3) => n3.i)).DOMParser : DOMParser, e3 = BW(t10);
  return e3.props = {
    raw: {
      type: String,
      required: true
    }
  }, e3;
}), zW = `<svg stroke-width="2" viewBox="-0.5 -0.5 15 15" xmlns="http://www.w3.org/2000/svg">
  <g>
    <line fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" x1="13.5" x2="0.5" y1="0.5"
      y2="13.5" />
    <line fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" x1="0.5" x2="13.5" y1="0.5"
      y2="13.5" />
  </g>
</svg>`, HW = `<svg viewBox="0 0 12 16" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M4 5h4c1.7 0 2-1.3 2-3a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V4c0-1.1.9-2 2-2 0 1.7.3 3 2 3Zm0-3V1c0-.6.5-1 1-1h2c.5 0 1 .4 1 1v1.3c0 .6-.4.7-1 .7H5a1 1 0 0 1-1-1Z"
        fill="currentColor" fill-rule="nonzero" />
</svg>`, GW = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path fill="currentColor" d="M0 12a3.25 3.25 0 1 0 6.5 0A3.25 3.25 0 1 0 0 12"></path><path fill="currentColor" d="M8.75 12a3.25 3.25 0 1 0 6.5 0 3.25 3.25 0 1 0-6.5 0"></path><path fill="currentColor" d="M17.5 12a3.25 3.25 0 1 0 6.5 0 3.25 3.25 0 1 0-6.5 0"></path></g></svg>', KW = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path fill="currentColor" d="M8.75 3.25a3.25 3.25 0 1 0 6.5 0 3.25 3.25 0 1 0-6.5 0"></path><path fill="currentColor" d="M8.75 12a3.25 3.25 0 1 0 6.5 0 3.25 3.25 0 1 0-6.5 0"></path><path fill="currentColor" d="M8.75 20.75a3.25 3.25 0 1 0 6.5 0 3.25 3.25 0 1 0-6.5 0"></path></g></svg>', JW = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M17.66 1.143a.75.75 0 0 1 1.451 0c.33 1.262.693 2.037 1.235 2.61.546.577 1.344 1.027 2.705 1.484a.75.75 0 0 1 0 1.422c-1.36.457-2.16.907-2.705 1.484-.542.574-.904 1.348-1.235 2.61a.75.75 0 0 1-1.45 0c-.331-1.262-.694-2.036-1.236-2.61-.545-.577-1.344-1.027-2.705-1.484a.75.75 0 0 1 0-1.422c1.361-.457 2.16-.907 2.705-1.483.542-.574.905-1.35 1.235-2.61ZM8.052 5.322a.75.75 0 0 1 1.451 0c.595 2.283 1.27 3.774 2.33 4.9 1.062 1.129 2.584 1.967 5.031 2.792a.75.75 0 0 1 0 1.422c-2.447.824-3.969 1.663-5.031 2.792-1.06 1.126-1.735 2.617-2.33 4.9a.75.75 0 0 1-1.451 0c-.596-2.283-1.27-3.774-2.33-4.9C4.659 16.099 3.138 15.26.69 14.436a.75.75 0 0 1 0-1.422c2.448-.825 3.97-1.663 5.032-2.792 1.06-1.126 1.734-2.617 2.33-4.9Zm11.85 10.147a.75.75 0 0 0-.725.556c-.24.9-.497 1.421-.863 1.8-.37.384-.926.698-1.923 1.026a.75.75 0 0 0 0 1.425c.997.327 1.553.641 1.923 1.025.366.38.623.9.863 1.8a.75.75 0 0 0 1.45 0c.24-.9.496-1.42.862-1.8.37-.384.926-.698 1.923-1.025a.75.75 0 0 0 0-1.425c-.997-.328-1.553-.642-1.923-1.026-.366-.379-.622-.9-.863-1.8a.75.75 0 0 0-.724-.556Z" clip-rule="evenodd"></path></svg>', eV = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14">
    <path fill="currentColor" fill-rule="evenodd"
        d="M11.8214 0.0977942C12.1097 -0.00745677 12.4219 -0.0286524 12.7219 0.0367783C13.0248 0.102864 13.3024 0.254542 13.5216 0.47378C13.7408 0.693018 13.8925 0.970598 13.9586 1.27352C14.024 1.57344 14.0028 1.88572 13.8976 2.17395L10.3236 12.8859L10.3234 12.8866C10.2363 13.1501 10.083 13.3868 9.8781 13.574C9.6738 13.7606 9.42509 13.8918 9.15572 13.9549C8.8863 14.0206 8.60441 14.0151 8.33774 13.9389C8.07131 13.8628 7.82926 13.7187 7.63529 13.5209L5.71795 11.6124L3.70389 12.6538C3.54684 12.7351 3.35857 12.7273 3.20874 12.6334C3.05892 12.5395 2.96981 12.3735 2.9744 12.1967L3.05697 9.013L10.1019 3.8956C10.3812 3.69273 10.4432 3.30188 10.2403 3.02261C10.0374 2.74333 9.64659 2.68139 9.36731 2.88425L2.20283 8.08846L0.473125 6.35875L0.473067 6.3587L0.472941 6.35857C0.285618 6.17138 0.147716 5.9406 0.0716193 5.68694C-0.00393616 5.43509 -0.0162115 5.16853 0.0358379 4.91085C0.0879545 4.62934 0.213796 4.36664 0.400577 4.14957C0.588637 3.93101 0.83165 3.76664 1.1045 3.67345L1.10787 3.6723L1.10787 3.67231L11.8214 0.0977942Z"
        clip-rule="evenodd"></path>
</svg>`, tV = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M23.25 7.311 12.53 18.03a.749.749 0 0 1-1.06 0L.75 7.311"></path></svg>', rV = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M16.25 23.25 5.53 12.53a.749.749 0 0 1 0-1.06L16.25.75" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', nV = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="m5.5.75 10.72 10.72a.749.749 0 0 1 0 1.06L5.5 23.25" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', iV = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M.75 17.189 11.47 6.47a.749.749 0 0 1 1.06 0l10.72 10.719" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', oV = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M12 .75v22.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M1.5 12.75 12 23.25l10.5-10.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', sV = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M23.25 12H.75" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M11.25 1.5.75 12l10.5 10.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', aV = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M.75 12h22.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M12.75 22.5 23.25 12 12.75 1.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', lV = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M12 23.25V.75" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M22.5 11.25 12 .75 1.5 11.25" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', uV = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M.75 12h22.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M12 .75v22.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', cV = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="m.75 23.249 22.5-22.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M23.25 23.249.75.749" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', fV = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="m7.629 4.5-6.44 6.439a1.5 1.5 0 0 0 0 2.121l6.44 6.44" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="m16.371 4.5 6.44 6.439a1.5 1.5 0 0 1 0 2.121l-6.44 6.44" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', dV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>GitHub</title>
    <path
        d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12" />
</svg>`, hV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Angular</title>
    <path
        d="M9.931 12.645h4.138l-2.07-4.908m0-7.737L.68 3.982l1.726 14.771L12 24l9.596-5.242L23.32 3.984 11.999.001zm7.064 18.31h-2.638l-1.422-3.503H8.996l-1.422 3.504h-2.64L12 2.65z" />
</svg>`, pV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Astro</title>
    <path
        d="M16.074 16.86c-.72.616-2.157 1.035-3.812 1.035-2.032 0-3.735-.632-4.187-1.483-.161.488-.198 1.046-.198 1.402 0 0-.106 1.75 1.111 2.968 0-.632.513-1.145 1.145-1.145 1.083 0 1.082.945 1.081 1.712v.069c0 1.164.711 2.161 1.723 2.582a2.347 2.347 0 0 1-.236-1.029c0-1.11.652-1.523 1.41-2.003.602-.383 1.272-.807 1.733-1.66a3.129 3.129 0 0 0 .378-1.494 3.14 3.14 0 0 0-.148-.954zM15.551.6c.196.244.296.572.496 1.229l4.368 14.347a18.18 18.18 0 0 0-5.222-1.768L12.35 4.8a.37.37 0 0 0-.71.002l-2.81 9.603a18.175 18.175 0 0 0-5.245 1.771L7.974 1.827c.2-.656.3-.984.497-1.227a1.613 1.613 0 0 1 .654-.484C9.415 0 9.757 0 10.443 0h3.135c.686 0 1.03 0 1.32.117A1.614 1.614 0 0 1 15.55.6z" />
</svg>`, OV = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M6.335.83a.75.75 0 0 0-.67 0L1.667 2.827a.754.754 0 0 0-.417.672V18c0 .271.146.52.382.654l7.989 4.493a.753.753 0 0 0 .747.007l8-4.5A.75.75 0 0 0 18.75 18v-4.537l3.585-1.792A.75.75 0 0 0 22.75 11V6a.75.75 0 0 0-.417-.672l-3.998-1.999a.75.75 0 0 0-.67 0l-3.997 1.999a.722.722 0 0 0-.246.194.748.748 0 0 0-.172.478v4.561l-2.5 1.407V3.5a.747.747 0 0 0-.43-.678L6.336.829Zm7.686 11.019 2.38 1.19-6.422 3.612-2.38-1.19 6.422-3.612Zm3.229-.063-2.5-1.25V7.215l2.5 1.25v3.322Zm1.5 0 2.5-1.25V7.215l-2.5 1.25v3.322Zm-9.5 1.025V4.714l-2.5 1.25v8.254l2.5-1.407Zm-1.005 4.65.743.372c.17.091.262.153.262.183v3.202l-6.5-3.657V4.714l2.5 1.25V15.5a.75.75 0 0 0 .415.67s1.122.591 2.108 1.064l.472.227Zm2.505.478 6.5-3.657v3.28l-6.5 3.656v-3.28ZM6 4.66 3.677 3.5 6 2.339 8.323 3.5 6 4.661ZM20.323 6 18 4.839 15.677 6 18 7.161 20.323 6Z" clip-rule="evenodd"></path></svg>', mV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Next.js</title>
    <path
        d="M11.5725 0c-.1763 0-.3098.0013-.3584.0067-.0516.0053-.2159.021-.3636.0328-3.4088.3073-6.6017 2.1463-8.624 4.9728C1.1004 6.584.3802 8.3666.1082 10.255c-.0962.659-.108.8537-.108 1.7474s.012 1.0884.108 1.7476c.652 4.506 3.8591 8.2919 8.2087 9.6945.7789.2511 1.6.4223 2.5337.5255.3636.04 1.9354.04 2.299 0 1.6117-.1783 2.9772-.577 4.3237-1.2643.2065-.1056.2464-.1337.2183-.1573-.0188-.0139-.8987-1.1938-1.9543-2.62l-1.919-2.592-2.4047-3.5583c-1.3231-1.9564-2.4117-3.556-2.4211-3.556-.0094-.0026-.0187 1.5787-.0235 3.509-.0067 3.3802-.0093 3.5162-.0516 3.596-.061.115-.108.1618-.2064.2134-.075.0374-.1408.0445-.495.0445h-.406l-.1078-.068a.4383.4383 0 01-.1572-.1712l-.0493-.1056.0053-4.703.0067-4.7054.0726-.0915c.0376-.0493.1174-.1125.1736-.143.0962-.047.1338-.0517.5396-.0517.4787 0 .5584.0187.6827.1547.0353.0377 1.3373 1.9987 2.895 4.3608a10760.433 10760.433 0 004.7344 7.1706l1.9002 2.8782.096-.0633c.8518-.5536 1.7525-1.3418 2.4657-2.1627 1.5179-1.7429 2.4963-3.868 2.8247-6.134.0961-.6591.1078-.854.1078-1.7475 0-.8937-.012-1.0884-.1078-1.7476-.6522-4.506-3.8592-8.2919-8.2087-9.6945-.7672-.2487-1.5836-.42-2.4985-.5232-.169-.0176-1.0835-.0366-1.6123-.037zm4.0685 7.217c.3473 0 .4082.0053.4857.047.1127.0562.204.1642.237.2767.0186.061.0234 1.3653.0186 4.3044l-.0067 4.2175-.7436-1.14-.7461-1.14v-3.066c0-1.982.0093-3.0963.0234-3.1502.0375-.1313.1196-.2346.2323-.2955.0961-.0494.1313-.054.4997-.054z" />
</svg>`, gV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>React</title>
    <path
        d="M14.23 12.004a2.236 2.236 0 0 1-2.235 2.236 2.236 2.236 0 0 1-2.236-2.236 2.236 2.236 0 0 1 2.235-2.236 2.236 2.236 0 0 1 2.236 2.236zm2.648-10.69c-1.346 0-3.107.96-4.888 2.622-1.78-1.653-3.542-2.602-4.887-2.602-.41 0-.783.093-1.106.278-1.375.793-1.683 3.264-.973 6.365C1.98 8.917 0 10.42 0 12.004c0 1.59 1.99 3.097 5.043 4.03-.704 3.113-.39 5.588.988 6.38.32.187.69.275 1.102.275 1.345 0 3.107-.96 4.888-2.624 1.78 1.654 3.542 2.603 4.887 2.603.41 0 .783-.09 1.106-.275 1.374-.792 1.683-3.263.973-6.365C22.02 15.096 24 13.59 24 12.004c0-1.59-1.99-3.097-5.043-4.032.704-3.11.39-5.587-.988-6.38-.318-.184-.688-.277-1.092-.278zm-.005 1.09v.006c.225 0 .406.044.558.127.666.382.955 1.835.73 3.704-.054.46-.142.945-.25 1.44-.96-.236-2.006-.417-3.107-.534-.66-.905-1.345-1.727-2.035-2.447 1.592-1.48 3.087-2.292 4.105-2.295zm-9.77.02c1.012 0 2.514.808 4.11 2.28-.686.72-1.37 1.537-2.02 2.442-1.107.117-2.154.298-3.113.538-.112-.49-.195-.964-.254-1.42-.23-1.868.054-3.32.714-3.707.19-.09.4-.127.563-.132zm4.882 3.05c.455.468.91.992 1.36 1.564-.44-.02-.89-.034-1.345-.034-.46 0-.915.01-1.36.034.44-.572.895-1.096 1.345-1.565zM12 8.1c.74 0 1.477.034 2.202.093.406.582.802 1.203 1.183 1.86.372.64.71 1.29 1.018 1.946-.308.655-.646 1.31-1.013 1.95-.38.66-.773 1.288-1.18 1.87-.728.063-1.466.098-2.21.098-.74 0-1.477-.035-2.202-.093-.406-.582-.802-1.204-1.183-1.86-.372-.64-.71-1.29-1.018-1.946.303-.657.646-1.313 1.013-1.954.38-.66.773-1.286 1.18-1.868.728-.064 1.466-.098 2.21-.098zm-3.635.254c-.24.377-.48.763-.704 1.16-.225.39-.435.782-.635 1.174-.265-.656-.49-1.31-.676-1.947.64-.15 1.315-.283 2.015-.386zm7.26 0c.695.103 1.365.23 2.006.387-.18.632-.405 1.282-.66 1.933-.2-.39-.41-.783-.64-1.174-.225-.392-.465-.774-.705-1.146zm3.063.675c.484.15.944.317 1.375.498 1.732.74 2.852 1.708 2.852 2.476-.005.768-1.125 1.74-2.857 2.475-.42.18-.88.342-1.355.493-.28-.958-.646-1.956-1.1-2.98.45-1.017.81-2.01 1.085-2.964zm-13.395.004c.278.96.645 1.957 1.1 2.98-.45 1.017-.812 2.01-1.086 2.964-.484-.15-.944-.318-1.37-.5-1.732-.737-2.852-1.706-2.852-2.474 0-.768 1.12-1.742 2.852-2.476.42-.18.88-.342 1.356-.494zm11.678 4.28c.265.657.49 1.312.676 1.948-.64.157-1.316.29-2.016.39.24-.375.48-.762.705-1.158.225-.39.435-.788.636-1.18zm-9.945.02c.2.392.41.783.64 1.175.23.39.465.772.705 1.143-.695-.102-1.365-.23-2.006-.386.18-.63.406-1.282.66-1.933zM17.92 16.32c.112.493.2.968.254 1.423.23 1.868-.054 3.32-.714 3.708-.147.09-.338.128-.563.128-1.012 0-2.514-.807-4.11-2.28.686-.72 1.37-1.536 2.02-2.44 1.107-.118 2.154-.3 3.113-.54zm-11.83.01c.96.234 2.006.415 3.107.532.66.905 1.345 1.727 2.035 2.446-1.595 1.483-3.092 2.295-4.11 2.295-.22-.005-.406-.05-.553-.132-.666-.38-.955-1.834-.73-3.703.054-.46.142-.944.25-1.438zm4.56.64c.44.02.89.034 1.345.034.46 0 .915-.01 1.36-.034-.44.572-.895 1.095-1.345 1.565-.455-.47-.91-.993-1.36-1.565z" />
</svg>`, yV = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M23.94 3a.5.5 0 0 0-.44-.25h-2.31l-8.55 13.91a.75.75 0 0 1-1.28 0L2.81 2.77H.5A.5.5 0 0 0 .06 3a.54.54 0 0 0 0 .51l11.5 19a.51.51 0 0 0 .86 0l11.5-19a.54.54 0 0 0 .02-.51Z" fill="currentColor"></path><path d="m12 14.84 7.43-12.07H16a.47.47 0 0 0-.43.25L12 9.26 8.43 3A.47.47 0 0 0 8 2.77H4.57Z" fill="currentColor"></path></g></svg>', vV = `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">
    <path
        d="M117.5 33.5l.3-.2c-.6-1.1-1.5-2.1-2.4-2.6L67.1 2.9c-.8-.5-1.9-.7-3.1-.7-1.2 0-2.3.3-3.1.7l-48 27.9c-1.7 1-2.9 3.5-2.9 5.4v55.7c0 1.1.2 2.3.9 3.4l-.2.1c.5.8 1.2 1.5 1.9 1.9l48.2 27.9c.8.5 1.9.7 3.1.7 1.2 0 2.3-.3 3.1-.7l48-27.9c1.7-1 2.9-3.5 2.9-5.4V36.1c.1-.8 0-1.7-.4-2.6zM64 88.5c9.1 0 17.1-5 21.3-12.4l12.9 7.6c-6.8 11.8-19.6 19.8-34.2 19.8-21.8 0-39.5-17.7-39.5-39.5S42.2 24.5 64 24.5c14.7 0 27.5 8.1 34.3 20l-13 7.5C81.1 44.5 73.1 39.5 64 39.5c-13.5 0-24.5 11-24.5 24.5s11 24.5 24.5 24.5z"
        fill="currentColor" />
</svg>`, bV = `<svg viewBox="0 0 128 128">
    <path
        d="M60.952.266C27.377.266.065 28.77.065 63.806s27.318 63.54 60.887 63.54c33.576 0 60.893-28.505 60.893-63.54S94.528.266 60.952.266zm0 6.117c30.39 0 55.025 25.712 55.025 57.423 0 2.482-.167 4.924-.46 7.321-1.495 6.214-4.194 10.358-7.412 13.19-4.941 4.336-11.524 5.738-17.62 5.733a41.444 41.444 0 01-4.973-.289C97.506 77.4 99.336 57.866 89.864 43.315 80.39 28.763 62.315 23.338 46.882 30.416a23.787 23.787 0 00-1.68-1.114c-2.41-1.413-7.439-3.482-13.837-3.505-5.361-.022-10.615 1.568-15.133 4.58C26.554 15.317 43.21 6.386 60.952 6.394v-.011zM51.341 84.6c.894-4.07 3.343-10.431 5.548-15.655.623-1.481 1.23-2.872 1.777-4.104 3.451 12.822 5.635 20.449 9.546 25.65a17.884 17.884 0 001.913 2.114 28.056 28.056 0 01-9.173 1.56 28.176 28.176 0 01-10.023-1.86c-.065-.817-.1-1.638-.103-2.459a24.45 24.45 0 01.515-5.24V84.6zm-7.444 3.77c-7.555-5.703-12.031-14.84-12.04-24.57.008-9.88 4.625-19.138 12.375-24.813 1.637.984 3.121 2.143 4.34 3.477 2.395 2.56 5.077 8.214 6.94 13.082.51 1.312.965 2.567 1.36 3.709C50.16 73.502 45.685 80.608 43.898 88.37zm21.802-18.226c-1.501-4.037-2.374-7.079-2.379-7.084l-.005-.012c-2.747-10.984-5.592-21.025-11.497-28.052a27.998 27.998 0 019.134-1.55c16.06.022 29.074 13.602 29.095 30.36-.007 9.673-4.432 18.764-11.914 24.474a14.975 14.975 0 01-2.184-.78c-1.137-.514-2.812-2.267-4.329-4.698-2.313-3.635-4.437-8.622-5.927-12.653l.006-.005zm-4.747 51.08c-30.39 0-55.025-25.707-55.025-57.424 0-2.086.114-4.144.32-6.173 4.508-16 15.338-21.92 25.595-22.02 2.08-.007 4.117.282 6.068.774-13.182 12.081-15.74 32.487-5.979 47.7 9.762 15.213 28.817 20.518 44.544 12.403 2.78 1.023 5.96 1.633 9.812 2.137 1.447.186 3.007.277 4.665.277a61.612 61.612 0 0014.997-2.087c-10.29 15.308-27.088 24.417-45.007 24.407l.01.006z"
        fill="currentColor" />
</svg>`, SV = `<svg fill="currentColor" viewBox="0 0 128 128">
    <path
        d="M117.5 33.5l.3-.2c-.6-1.1-1.5-2.1-2.4-2.6L67.1 2.9c-.8-.5-1.9-.7-3.1-.7-1.2 0-2.3.3-3.1.7l-48 27.9c-1.7 1-2.9 3.5-2.9 5.4v55.7c0 1.1.2 2.3.9 3.4l-.2.1c.5.8 1.2 1.5 1.9 1.9l48.2 27.9c.8.5 1.9.7 3.1.7 1.2 0 2.3-.3 3.1-.7l48-27.9c1.7-1 2.9-3.5 2.9-5.4V36.1c.1-.8 0-1.7-.4-2.6zm-53.5 70c-21.8 0-39.5-17.7-39.5-39.5S42.2 24.5 64 24.5c14.7 0 27.5 8.1 34.3 20l-13 7.5C81.1 44.5 73.1 39.5 64 39.5c-13.5 0-24.5 11-24.5 24.5s11 24.5 24.5 24.5c9.1 0 17.1-5 21.3-12.4l12.9 7.6c-6.8 11.8-19.6 19.8-34.2 19.8zM115 62h-3.2l-.9 4h4.1v5h-5l-1.2 6h-4.9l1.2-6h-3.8l-1.2 6h-4.8l1.2-6H94v-5h3.5l.9-4H94v-5h5.3l1.2-6h4.9l-1.2 6h3.8l1.2-6h4.8l-1.2 6h2.2v5zm-12.7 4h3.8l.9-4h-3.8z" />
</svg>`, $V = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M1.5 0h21l-1.91 21.563L11.977 24l-8.565-2.438L1.5 0zm17.09 4.413L5.41 4.41l.213 2.622 10.125.002-.255 2.716h-6.64l.24 2.573h6.182l-.366 3.523-2.91.804-2.956-.81-.188-2.11h-2.61l.29 3.855L12 19.288l5.373-1.53L18.59 4.414z" />
</svg>`, wV = `<svg fill="currentColor" viewBox="0 0 128 128">
    <path
        d="M108.2 64.8c-.1-.1-.2-.2-.4-.2l-.1-.1c-.1-.1-.2-.1-.2-.2l-.1-.1c-.1 0-.2-.1-.2-.1l-.2-.1c-.1 0-.2-.1-.2-.1l-.2-.1c-.1 0-.2-.1-.2-.1-.1 0-.1 0-.2-.1l-.3-.1c-.1 0-.1 0-.2-.1l-.3-.1h-.1l-.4-.1h-.2c-.1 0-.2 0-.3-.1h-2.3c-.6-13.3.6-26.8-2.8-39.6 12.9-4.6 2.8-22.3-8.4-14.4-7.4-6.4-17.6-7.8-28.3-7.8-10.5.7-20.4 2.9-27.4 8.4-2.8-1.4-5.5-1.8-7.9-1.1v.1c-.1 0-.3.1-.4.2-.1 0-.3.1-.4.2h-.1c-.1 0-.2.1-.4.2h-.1l-.3.2h-.1l-.3.2h-.1l-.3.2s-.1 0-.1.1l-.3.2s-.1 0-.1.1l-.3.2s-.1 0-.1.1l-.3.2-.1.1c-.1.1-.2.1-.2.2l-.1.1-.2.2-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1c.4.3.4.4.4.4v.1l-.1.3v.1c0 .1 0 .2-.1.3v3.1c0 .1 0 .2.1.3v.1l.1.3v.1l.1.3s0 .1.1.1l.1.3s0 .1.1.1l.1.3s0 .1.1.1l.2.3s0 .1.1.1l.2.3s0 .1.1.1l.2.3.1.1.3.3.3.3h.1c1 .9 2 1.6 4 2.2v-.2C23 37.3 26.5 50 26.7 63c-.6 0-.7.4-1.7.5h-.5c-.1 0-.3 0-.5.1-.1 0-.3 0-.4.1l-.4.1h-.1l-.4.1h-.1l-.3.1h-.1l-.3.1s-.1 0-.1.1l-.3.1-.2.1c-.1 0-.2.1-.2.1l-.2.1-.2.1c-.1 0-.2.1-.2.1l-.2.1-.4.3c-.1.1-.2.2-.3.2l-.4.4-.1.1c-.1.2-.3.4-.4.5l-.2.3-.3.6-.1.3v.3c0 .5.2.9.9 1.2.2 3.7 3.9 2 5.6.8l.1-.1c.2-.2.5-.3.6-.3h.1l.2-.1c.1 0 .1 0 .2-.1.2-.1.4-.1.5-.2.1 0 .1-.1.1-.2l.1-.1c.1-.2.2-.6.2-1.2l.1-1.3v1.8c-.5 13.1-4 30.7 3.3 42.5 1.3 2.1 2.9 3.9 4.7 5.4h-.5c-.2.2-.5.4-.8.6l-.9.6-.3.2-.6.4-.9.7-1.1 1c-.2.2-.3.4-.4.5l-.4.6-.2.3c-.1.2-.2.4-.2.6l-.1.3c-.2.8 0 1.7.6 2.7l.4.4h.2c.1 0 .2 0 .4.1.2.4 1.2 2.5 3.9.9 2.8-1.5 4.7-4.6 8.1-5.1l-.5-.6c5.9 2.8 12.8 4 19 4.2 8.7.3 18.6-.9 26.5-5.2 2.2.7 3.9 3.9 5.8 5.4l.1.1.1.1.1.1.1.1s.1 0 .1.1c0 0 .1 0 .1.1 0 0 .1 0 .1.1h2.1s.1 0 .1-.1h.1s.1 0 .1-.1h.1s.1 0 .1-.1c0 0 .1 0 .1-.1l.1-.1s.1 0 .1-.1l.1-.1h.1l.2-.2.2-.1h.1l.1-.1h.1l.1-.1.1-.1.1-.1.1-.1.1-.1.1-.1.1-.1v-.1s0-.1.1-.1v-.1s0-.1.1-.1v-.1s0-.1.1-.1v-1.4s-.3 0-.3-.1l-.3-.1v-.1l.3-.1s.2 0 .2-.1l.1-.1v-2.1s0-.1-.1-.1v-.1s0-.1-.1-.1v-.1s0-.1-.1-.1c0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1l-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1v-.1l-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1c2-1.9 3.8-4.2 5.1-6.9 5.9-11.8 4.9-26.2 4.1-39.2h.1c.1 0 .2.1.2.1h.3s.1 0 .1.1h.1s.1 0 .1.1l.2.1c1.7 1.2 5.4 2.9 5.6-.8 1.6.6-.3-1.8-1.3-2.5zM36 23C32.8 7 58.4 4 59.3 19.6c.8 13-20 16.3-23.3 3.4zm36.1 15c-1.3 1.4-2.7 1.2-4.1.7 0 1.9.4 3.9.1 5.9-.5.9-1.5 1-2.3 1.4-1.2-.2-2.1-.9-2.6-2l-.2-.1c-3.9 5.2-6.3-1.1-5.2-5-1.2.1-2.2-.2-3-1.5-1.4-2.6.7-5.8 3.4-6.3.7 3 8.7 2.6 10.1-.2 3.1 1.5 6.5 4.3 3.8 7.1zm-7-17.5c-.9-13.8 20.3-17.5 23.4-4 3.5 15-20.8 18.9-23.4 4zM41.7 17c-1.9 0-3.5 1.7-3.5 3.8 0 2.1 1.6 3.8 3.5 3.8s3.5-1.7 3.5-3.8c0-2.1-1.5-3.8-3.5-3.8zm1.6 5.7c-.5 0-.8-.4-.8-1 0-.5.4-1 .8-1 .5 0 .8.4.8 1 0 .5-.3 1-.8 1zm27.8-6.6c-1.9 0-3.4 1.7-3.4 3.8 0 2.1 1.5 3.8 3.4 3.8s3.4-1.7 3.4-3.8c0-2.1-1.5-3.8-3.4-3.8zm1.6 5.6c-.4 0-.8-.4-.8-1 0-.5.4-1 .8-1s.8.4.8 1-.4 1-.8 1z" />
</svg>`, PV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M1.5 0h21l-1.91 21.563L11.977 24l-8.564-2.438L1.5 0zm7.031 9.75l-.232-2.718 10.059.003.23-2.622L5.412 4.41l.698 8.01h9.126l-.326 3.426-2.91.804-2.955-.81-.188-2.11H6.248l.33 4.171L12 19.351l5.379-1.443.744-8.157H8.531z" />
</svg>`, _V = `<svg width="373.7" height="200" viewBox="0 0 373.7 200" xmlns="http://www.w3.org/2000/svg">
    <path
        d="m326 0 47.7 100L326 200H47.7L0 100 47.7 0H326Zm-16 16.6H58.3L18.4 100l39.8 83.4h251.9l39.7-83.4L310 16.6ZM87.3 72v23.5h27V71.9h13.9v59.5h-13.8V107h-27v24.4H73.5V72h13.7Zm100.1 0V83h-19v48.3h-13.8V83.1h-19V72h51.8Zm53.4 0V83h-19v48.3h-13.8V83.1h-19V72h51.8Zm47 2.6c3.6 1.6 6.7 4.2 9 7.5 2 3.4 3.2 7.4 3 11.5.2 4-1 8-3 11.4a20 20 0 0 1-9 7.5c-4.4 1.8-9.1 2.7-13.8 2.6h-12v16.4H248V72H274a33 33 0 0 1 13.7 2.6ZM273 83.1H262v20.7H273c4.2 0 7.3-1 9.5-2.7a9.3 9.3 0 0 0 3.2-7.6c0-3.3-1-6-3.2-7.7-2.2-1.8-5.3-2.7-9.5-2.7Z"
        fill="currentColor" fill-rule="nonzero" />
</svg>`, xV = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path
        d="M11.26 15.27c3.37-.15 7.15-1.09 7-2.21a25.93 25.93 0 0 1-4.76.59c-3.62.16-6.58-.24-6.61-.9 0-.2.24-.4.69-.58-2.39-.64-3.67.53-3.69 1.22-.1 1.45 3.22 2.06 7.37 1.88Z"
        fill="currentColor"></path>
    <path
        d="M17.17 16.91a23 23 0 0 1-4.07.5c-3.09.14-5.61-.21-5.64-.77 0-.17.21-.34.59-.49-2-.55-3.13.45-3.15 1-.05 1.24 2.78 1.77 6.33 1.61 2.87-.1 6.25-1 5.94-1.85Z"
        fill="currentColor"></path>
    <path
        d="M3.61 20.8a.93.93 0 0 1 .29-.65c-2.09.1-2.54 1.13-2.51 1.76.07 1.39 4.67 2.31 10 2.05 4.44-.22 9.16-1 9.16-2.34a26.34 26.34 0 0 1-7.2 1.23c-5.35.26-9.67-.66-9.74-2.05Z"
        fill="currentColor"></path>
    <path
        d="M22.4 12.65c-.55-1.48-2.67-2.34-4.74-1.57a2.47 2.47 0 0 0-1 .81c1.94-.56 3.83 0 4.34 1.41.45 1.21-.3 2.64-1.72 3.54a1.37 1.37 0 0 0 .92-.13c2.25-1.05 2.8-2.58 2.2-4.06Z"
        fill="currentColor"></path>
    <path d="M12.52 11.27s-3.1-2.19-1.92-4.35S14.37 2.43 13.38 0c0 0 .12 1-3.12 3.91s-2.14 6.33 2.26 7.36Z"
        fill="currentColor"></path>
    <path d="M15.17 4.83s-4.24 1.51-2.83 3.53c1 1.43 2.13 2 1.42 4 0 0 2.83-1.51.71-3.53s.7-4 .7-4Z"
        fill="currentColor"></path>
    <path
        d="M8.69 19.26c-1.6-.43-2.46.35-2.47.81 0 1 2.18 1.39 5 1.27 2.26-.11 4.73-.95 4.67-1.49a16.59 16.59 0 0 1-3.2.4c-2.43.11-4.41-.16-4.43-.61-.04-.13.13-.26.43-.38Z"
        fill="currentColor"></path>
</svg>`, QV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M0 0h24v24H0V0zm22.034 18.276c-.175-1.095-.888-2.015-3.003-2.873-.736-.345-1.554-.585-1.797-1.14-.091-.33-.105-.51-.046-.705.15-.646.915-.84 1.515-.66.39.12.75.42.976.9 1.034-.676 1.034-.676 1.755-1.125-.27-.42-.404-.601-.586-.78-.63-.705-1.469-1.065-2.834-1.034l-.705.089c-.676.165-1.32.525-1.71 1.005-1.14 1.291-.811 3.541.569 4.471 1.365 1.02 3.361 1.244 3.616 2.205.24 1.17-.87 1.545-1.966 1.41-.811-.18-1.26-.586-1.755-1.336l-1.83 1.051c.21.48.45.689.81 1.109 1.74 1.756 6.09 1.666 6.871-1.004.029-.09.24-.705.074-1.65l.046.067zm-8.983-7.245h-2.248c0 1.938-.009 3.864-.009 5.805 0 1.232.063 2.363-.138 2.711-.33.689-1.18.601-1.566.48-.396-.196-.597-.466-.83-.855-.063-.105-.11-.196-.127-.196l-1.825 1.125c.305.63.75 1.172 1.324 1.517.855.51 2.004.675 3.207.405.783-.226 1.458-.691 1.811-1.411.51-.93.402-2.07.397-3.346.012-2.054 0-4.109 0-6.179l.004-.056z" />
</svg>`, TV = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path
        d="M4.56 18.71c-1.41-4-.65-8.94 1.77-11.48A5.47 5.47 0 0 1 12 5.71h.15a.78.78 0 0 1 .22.12c4 1.65 4.28 8.57 1.28 11.41a4.15 4.15 0 0 0 3.08-1.35c2.12-2.23 2.76-6.62 1.49-10.22A7.75 7.75 0 0 0 12.81.54H12a11.5 11.5 0 0 0-5.42 21.6 10 10 0 0 1-2.02-3.43Z"
        fill="currentColor"></path>
    <path
        d="M23.5 12a11.49 11.49 0 0 0-6.09-10.14 9.86 9.86 0 0 1 2 3.43c1.41 4 .65 9-1.77 11.5a5.42 5.42 0 0 1-4 1.75A6.53 6.53 0 0 1 12 18.3h-.15a.78.78 0 0 1-.22-.12c-4-1.65-4.29-8.57-1.29-11.41a4.14 4.14 0 0 0-3.11 1.32c-2.12 2.22-2.76 6.61-1.49 10.2a7.77 7.77 0 0 0 5.45 5.17H12A11.5 11.5 0 0 0 23.5 12Z"
        fill="currentColor"></path>
</svg>`, kV = `<svg viewBox="0 0 128 128" fill="currentColor">
    <path d="M0 0h61.4L0 60.4zM0 128L128 0H64.6L0 63.7zM128 128L64.6 66.6 3.3 128z" />
</svg>`, EV = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <g>
        <path
            d="M21.75 5.52 13 .28a2 2 0 0 0-2 0L2.25 5.52a2 2 0 0 0-1 1.69v9.58a2 2 0 0 0 1 1.69l2.62 1.57a3.12 3.12 0 0 0 4.73-2.68V8.12a1 1 0 0 0-2 0v9.25a1.13 1.13 0 0 1-.57 1 1.14 1.14 0 0 1-1.13 0l-2.61-1.58V7.24L12 2l8.73 5.21v9.55L12 22l-1.7-1a1 1 0 1 0-1 1.71l1.72 1a2 2 0 0 0 2 0l8.74-5.24a2 2 0 0 0 1-1.69V7.21a2 2 0 0 0-1.01-1.69Z"
            fill="currentColor"></path>
        <path
            d="M15.51 14.76a9.33 9.33 0 0 1-2.24 0 .85.85 0 0 1-.75-.85 1 1 0 0 0-2 0A2.87 2.87 0 0 0 13 16.75a11.84 11.84 0 0 0 1.36.08 12.16 12.16 0 0 0 1.37-.08 2.87 2.87 0 0 0 2.5-2.84A2.68 2.68 0 0 0 16 11.26l-2.91-.49a.69.69 0 0 1-.58-.68.85.85 0 0 1 .75-.85 9.33 9.33 0 0 1 2.24 0 .85.85 0 0 1 .75.85 1 1 0 0 0 2 0 2.87 2.87 0 0 0-2.5-2.84 12.46 12.46 0 0 0-2.73 0 2.87 2.87 0 0 0-2.51 2.84 2.68 2.68 0 0 0 2.25 2.65l2.91.49a.68.68 0 0 1 .58.68.85.85 0 0 1-.74.85Z"
            fill="currentColor"></path>
    </g>
</svg>`, CV = `<svg viewBox="0 0 128 128" fill="currentColor">
    <path
        d="M63.877 125.392c-32.671 0-60.37-27.594-60.627-60.469a59.94 59.94 0 0117.506-42.759 60.939 60.939 0 0143.279-18.36 60.081 60.081 0 0142.647 17.71 60.145 60.145 0 0118.157 42.522c.151 33.604-26.864 61.021-60.469 61.363h-.493zm.19-118.406a57.774 57.774 0 00-41.01 17.427 56.775 56.775 0 00-16.63 40.484c.236 31.159 26.495 57.286 57.43 57.286h.414c31.863-.29 57.504-26.266 57.385-58.128a56.97 56.97 0 00-17.217-40.273A56.7 56.7 0 0064.068 6.986z" />
    <path
        d="M16.89 82.383V46.865h8.64v3.183h-4.583v29.218h4.584v3.183l-8.642-.066zM46.213 64.272c0 6.478-3.933 10.167-9.26 10.167s-8.877-4.156-8.877-9.831c0-5.939 3.722-10.121 9.167-10.121s8.97 4.36 8.97 9.785zm-14.415.29c0 3.932 1.973 7.05 5.36 7.05s5.333-3.183 5.333-7.195c0-3.643-1.796-7.083-5.334-7.083s-5.392 3.328-5.392 7.307l.033-.08zM49.205 55.158c1.69-.29 3.407-.434 5.123-.428a9.17 9.17 0 015.537 1.223 4.062 4.062 0 012.006 3.61 4.48 4.48 0 01-3.183 4.183c2.269.46 3.9 2.46 3.9 4.775a5.016 5.016 0 01-1.861 3.978c-1.368 1.21-3.643 1.796-7.162 1.796a33.966 33.966 0 01-4.327-.257l-.033-18.88zm3.499 7.622h1.795c2.433 0 3.801-1.145 3.801-2.782 0-1.638-1.368-2.644-3.61-2.644a9.779 9.779 0 00-2.006.145l.02 5.28zm0 8.878c.618.065 1.243.092 1.86.078 2.263 0 4.262-.861 4.262-3.182s-1.94-3.183-4.373-3.183h-1.75v6.287zM69.54 54.901h3.517v12.554c0 5.334-2.577 7.116-6.365 7.116a9.313 9.313 0 01-2.973-.507l.428-2.834c.703.224 1.44.335 2.183.349 2.006 0 3.183-.921 3.183-4.262l.026-12.416zM83.067 65.357v2.434h-7.32v-2.434h7.32zM100.158 73.63c-1.585.632-3.281.921-4.978.862-6.129 0-9.851-3.834-9.851-9.707-.283-5.353 3.827-9.923 9.18-10.206.375-.02.757-.02 1.131.006a11.112 11.112 0 014.775.862l-.783 2.801a9.476 9.476 0 00-3.788-.75c-3.932 0-6.76 2.467-6.76 7.116 0 4.235 2.499 6.971 6.734 6.971a9.806 9.806 0 003.834-.717l.506 2.762zM111.2 46.766v35.61h-8.641v-3.182h4.583V49.949h-4.583v-3.183h8.64z" />
</svg>`, RV = `<svg fill="currentColor" viewBox="0 0 128 128">
    <path
        d="M65.004 115.355c-.461-.894-1.004-2.796-1.356-3.601-.378-.711-1.46-2.692-1.984-3.332-1.164-1.332-1.437-1.438-1.809-3.23-.628-3.067-2.148-8.462-4.042-12.227-1.004-2-2.626-3.606-4.067-5.07-1.246-1.247-4.121-3.31-4.668-3.227-4.766.894-6.226 5.586-8.457 9.27-1.27 2.062-2.516 3.769-3.52 5.937-.898 1.98-.812 4.23-2.331 5.938a15.44 15.44 0 00-3.333 5.855c-.195.453-.546 4.957-1.003 6.016l7.02-.438c6.585.461 4.687 2.961 14.858 2.438l16.098-.54a24.864 24.864 0 00-1.433-3.792zM111.793 8.254H16.207C7.312 8.23.086 15.457.086 24.352v35.105c2.352-.812 5.578-5.75 6.668-6.934 1.789-2.062 2.16-4.77 3.059-6.378 2.062-3.793 2.433-6.477 7.101-6.477 2.164 0 3.063.516 4.5 2.516.996 1.332 2.79 3.957 3.602 5.668 1.004 1.98 2.523 4.582 3.254 5.125.515.351.972.722 1.433.894.707.27 1.356-.27 1.902-.629.622-.539.895-1.52 1.52-2.953.895-2.086 1.813-4.418 2.332-5.312.914-1.461 1.273-3.254 2.25-4.067 1.461-1.246 3.441-1.355 3.957-1.437 2.98-.625 4.336 1.437 5.777 2.707.973.894 2.243 2.605 3.246 4.851.708 1.793 1.606 3.52 2.067 4.5.351.98 1.266 2.606 1.789 4.582.543 1.711 1.809 3.067 2.352 3.961 0 0 .812 2.164 5.476 4.145a34.992 34.992 0 004.336 1.52c2.066.734 4.047.644 6.563.374 1.789 0 2.793-2.625 3.601-4.683.438-1.254.98-4.774 1.25-5.758.27-.996-.437-1.707.192-2.625.722-.977 1.164-1.082 1.519-2.332.914-2.793 5.957-2.875 8.832-2.875 2.414 0 2.063 2.332 6.125 1.52 2.336-.434 4.586.273 7.023.995 2.063.543 4.043 1.168 5.204 2.524.73.898 2.629 5.312.73 5.476.164.188.36.645.625.817-.46 1.707-2.25.46-3.332.27-1.355-.27-2.332 0-3.684.624-2.335.996-5.668.918-7.726 2.625-1.715 1.438-1.715 4.582-2.543 6.371 0 0-2.254 5.696-6.996 9.192-1.278.914-3.715 3.058-8.918 3.871-2.356.355-4.586.355-7.024.27-1.164-.079-2.332-.079-3.52-.079-.706 0-3.062-.109-2.96.164l-.27.645c.024.29.063.602.164.895.102.515.102.976.192 1.437 0 .98-.086 2.063 0 3.066.082 2.063.894 3.957 1.004 6.102.078 2.355 1.246 4.875 2.414 6.77.46.707 1.086.789 1.355 1.71.352.98 0 2.141.188 3.227.625 4.227 1.875 8.73 3.773 12.61v.078c2.332-.352 4.77-1.247 7.836-1.684 5.664-.832 13.5-.461 18.54-.914 12.796-1.168 19.706 5.226 31.148 2.601V24.336c-.063-8.895-7.293-16.102-16.207-16.102zM64.086 83.855c0-.187 0-.187 0 0zm-34.457 14.75c.894-1.98 1.433-4.125 2.144-6.101.73-1.899 1.813-4.61 3.684-5.582-.246-.274-3.957-.375-4.934-.461-1.082-.086-2.171-.273-3.25-.438a135.241 135.241 0 01-6.125-1.265c-1.168-.274-5.21-1.715-6.02-2.067-2.085-.894-3.421-3.52-4.96-3.246-.977.188-1.98.54-2.605 1.54-.543.812-.731 2.242-1.083 3.226-.437 1.086-1.168 2.164-1.707 3.25-1.277 1.875-3.332 3.582-4.23 5.484-.191.457-.27.895-.457 1.356v21.683c1.082.188 2.16.371 3.328.73 8.996 2.438 11.164 2.606 19.98 1.63l.813-.11c.625-1.437 1.188-6.207 1.629-7.644.352-1.164.812-2.063.996-3.14.164-1.09 0-2.173-.102-3.15-.171-2.628 1.895-3.519 2.899-5.69zm0 0" />
</svg>`, AV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M7.01 10.207h-.944l-.515 2.648h.838c.556 0 .97-.105 1.242-.314.272-.21.455-.559.55-1.049.092-.47.05-.802-.124-.995-.175-.193-.523-.29-1.047-.29zM12 5.688C5.373 5.688 0 8.514 0 12s5.373 6.313 12 6.313S24 15.486 24 12c0-3.486-5.373-6.312-12-6.312zm-3.26 7.451c-.261.25-.575.438-.917.551-.336.108-.765.164-1.285.164H5.357l-.327 1.681H3.652l1.23-6.326h2.65c.797 0 1.378.209 1.744.628.366.418.476 1.002.33 1.752a2.836 2.836 0 0 1-.305.847c-.143.255-.33.49-.561.703zm4.024.715l.543-2.799c.063-.318.039-.536-.068-.651-.107-.116-.336-.174-.687-.174H11.46l-.704 3.625H9.388l1.23-6.327h1.367l-.327 1.682h1.218c.767 0 1.295.134 1.586.401s.378.7.263 1.299l-.572 2.944h-1.389zm7.597-2.265a2.782 2.782 0 0 1-.305.847c-.143.255-.33.49-.561.703a2.44 2.44 0 0 1-.917.551c-.336.108-.765.164-1.286.164h-1.18l-.327 1.682h-1.378l1.23-6.326h2.649c.797 0 1.378.209 1.744.628.366.417.477 1.001.331 1.751zM17.766 10.207h-.943l-.516 2.648h.838c.557 0 .971-.105 1.242-.314.272-.21.455-.559.551-1.049.092-.47.049-.802-.125-.995s-.524-.29-1.047-.29z" />
</svg>`, XV = `<svg viewBox="0 0 101 121" xmlns="http://www.w3.org/2000/svg">
  <g fill="none" fill-rule="evenodd">
    <path
      d="M63.69 58.855c-1.543-1.81-3.237-3.894-5.03-5.886-10.174-11.3-20.257-22.684-30.61-33.815C23.31 14.06 21.8 9.114 27.49 4.085c5.623-4.97 11.148-4.53 16.306 1.188C58.162 21.193 72.51 37.13 87.113 52.83c5.452 5.864 4.182 9.851-1.823 14.196-23.049 16.683-45.968 33.547-68.862 50.443-5.146 3.8-10.052 4.75-14.209-.86-4.586-6.19-.343-9.872 4.414-13.336 17.013-12.392 33.993-24.83 50.9-37.366 2.355-1.746 5.736-2.764 6.157-7.05Z"
      fill="currentColor" />
    <path
      d="M70.977 118.723c-6.196 0-12.4.213-18.583-.068-4.932-.223-7.9-2.979-7.838-8.174.06-4.912 2.536-8.605 7.463-8.738 13.542-.363 27.104-.285 40.651-.02 4.305.084 7.483 2.89 7.457 7.375-.03 5.146-2.739 9.133-8.25 9.465-6.944.42-13.93.104-20.899.104v.056Z"
      fill="currentColor" />
  </g>
</svg>`, qV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M14.25.18l.9.2.73.26.59.3.45.32.34.34.25.34.16.33.1.3.04.26.02.2-.01.13V8.5l-.05.63-.13.55-.21.46-.26.38-.3.31-.33.25-.35.19-.35.14-.33.1-.3.07-.26.04-.21.02H8.77l-.69.05-.59.14-.5.22-.41.27-.33.32-.27.35-.2.36-.15.37-.1.35-.07.32-.04.27-.02.21v3.06H3.17l-.21-.03-.28-.07-.32-.12-.35-.18-.36-.26-.36-.36-.35-.46-.32-.59-.28-.73-.21-.88-.14-1.05-.05-1.23.06-1.22.16-1.04.24-.87.32-.71.36-.57.4-.44.42-.33.42-.24.4-.16.36-.1.32-.05.24-.01h.16l.06.01h8.16v-.83H6.18l-.01-2.75-.02-.37.05-.34.11-.31.17-.28.25-.26.31-.23.38-.2.44-.18.51-.15.58-.12.64-.1.71-.06.77-.04.84-.02 1.27.05zm-6.3 1.98l-.23.33-.08.41.08.41.23.34.33.22.41.09.41-.09.33-.22.23-.34.08-.41-.08-.41-.23-.33-.33-.22-.41-.09-.41.09zm13.09 3.95l.28.06.32.12.35.18.36.27.36.35.35.47.32.59.28.73.21.88.14 1.04.05 1.23-.06 1.23-.16 1.04-.24.86-.32.71-.36.57-.4.45-.42.33-.42.24-.4.16-.36.09-.32.05-.24.02-.16-.01h-8.22v.82h5.84l.01 2.76.02.36-.05.34-.11.31-.17.29-.25.25-.31.24-.38.2-.44.17-.51.15-.58.13-.64.09-.71.07-.77.04-.84.01-1.27-.04-1.07-.14-.9-.2-.73-.25-.59-.3-.45-.33-.34-.34-.25-.34-.16-.33-.1-.3-.04-.25-.02-.2.01-.13v-5.34l.05-.64.13-.54.21-.46.26-.38.3-.32.33-.24.35-.2.35-.14.33-.1.3-.06.26-.04.21-.02.13-.01h5.84l.69-.05.59-.14.5-.21.41-.28.33-.32.27-.35.2-.36.15-.36.1-.35.07-.32.04-.28.02-.21V6.07h2.09l.14.01zm-6.47 14.25l-.23.33-.08.41.08.41.23.33.33.23.41.08.41-.08.33-.23.23-.33.08-.41-.08-.41-.23-.33-.33-.23-.41-.08-.41.08z" />
</svg>`, DV = `<svg fill="currentColor" viewBox="0 0 128 128">
  <path
    d="M64 14.648c-35.346 0-64 19.19-64 42.863C0 78.275 22.046 95.589 51.316 99.53V86.699c-15.55-4.89-26.166-14.693-26.166-25.991 0-16.183 21.779-29.303 48.646-29.303 26.866 0 46.693 8.975 46.693 29.303 0 10.486-5.273 17.95-14.066 22.72 1.204.908 2.22 2.072 2.904 3.419l.388.655C121.025 79.772 128 69.189 128 57.51c0-23.672-28.654-42.863-64-42.863zm20.1 74.88c-2.612.257-5.322.41-8.114.462l.002 9.63a88.362 88.362 0 0012.474-2.492l-.501-.941c-.68-1.268-1.347-2.543-2.033-3.807a41.01 41.01 0 00-1.828-2.851z" />
  <path
    d="M97.469 81.036s3.874 1.169 6.124 2.307c.78.396 2.132 1.184 3.106 2.22a8.388 8.388 0 011.42 2.04l15.266 25.74-24.674.01-11.537-21.666s-2.363-4.06-3.817-5.237c-1.213-.982-1.73-1.331-2.929-1.331h-5.862l.004 28.219-21.834.009V41.263h43.845s19.97.36 19.97 19.359S97.47 81.035 97.47 81.035zm-9.497-24.137l-13.218-.009-.006 12.257 13.224-.004s6.124-.019 6.124-6.235c0-6.34-6.124-6.01-6.124-6.01z"
    fill-rule="evenodd" />
</svg>`, jV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Ruby</title>
    <path
        d="M20.156.083c3.033.525 3.893 2.598 3.829 4.77L24 4.822 22.635 22.71 4.89 23.926h.016C3.433 23.864.15 23.729 0 19.139l1.645-3 2.819 6.586.503 1.172 2.805-9.144-.03.007.016-.03 9.255 2.956-1.396-5.431-.99-3.9 8.82-.569-.615-.51L16.5 2.114 20.159.073l-.003.01zM0 19.089zM5.13 5.073c3.561-3.533 8.157-5.621 9.922-3.84 1.762 1.777-.105 6.105-3.673 9.636-3.563 3.532-8.103 5.734-9.864 3.957-1.766-1.777.045-6.217 3.612-9.75l.003-.003z" />
</svg>`, UV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Scala</title>
    <path
        d="M4.589 24c4.537 0 13.81-1.516 14.821-3v-5.729c-.957 1.408-10.284 2.912-14.821 2.912V24zM4.589 16.365c4.537 0 13.81-1.516 14.821-3V7.636c-.957 1.408-10.284 2.912-14.821 2.912v5.817zM4.589 8.729c4.537 0 13.81-1.516 14.821-3V0C18.453 1.408 9.126 2.912 4.589 2.912v5.817z" />
</svg>`, IV = `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 14">
  <path
    d="m2.378 9.9 5.139-4.627L2.377.645.69 2.205l3.4 3.042v.051L.69 8.341 2.378 9.9Zm14.19 3.299V11H8.591v2.199h7.977Z"
    fill-rule="nonzero" fill="currentColor" />
</svg>`, FV = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128" fill="currentColor">
	<path
		d="M117.3 87.3c.2-.6.4-1.3.5-1.9 7-28-10.1-61.2-39.2-78.6C91.4 24 97 44.9 92 63.2c-.4 1.6-1 3.2-1.6 4.7-.6-.4-1.5-.9-2.5-1.5 0 0-28.9-17.9-60.2-49.4-.9-.8 16.7 25 36.6 46.1-9.4-5.3-35.5-24.3-52-39.4 2 3.4 4.4 6.7 7.1 9.8C33.1 51 51.2 72.6 72.7 89.2c-15.2 9.3-36.6 10-57.9 0C9.5 86.7 4.6 83.7 0 80.3c9 14.4 22.9 26.9 39.9 34.2 20.2 8.7 40.3 8.1 55.2.1.1 0 .1-.1.2-.1.7-.4 1.3-.7 2-1.1 7.2-3.7 21.3-7.4 28.9 7.4 1.7 3.6 5.7-15.6-8.9-33.5z" />
</svg>`, ZV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>TypeScript</title>
    <path
        d="M1.125 0C.502 0 0 .502 0 1.125v21.75C0 23.498.502 24 1.125 24h21.75c.623 0 1.125-.502 1.125-1.125V1.125C24 .502 23.498 0 22.875 0zm17.363 9.75c.612 0 1.154.037 1.627.111a6.38 6.38 0 0 1 1.306.34v2.458a3.95 3.95 0 0 0-.643-.361 5.093 5.093 0 0 0-.717-.26 5.453 5.453 0 0 0-1.426-.2c-.3 0-.573.028-.819.086a2.1 2.1 0 0 0-.623.242c-.17.104-.3.229-.393.374a.888.888 0 0 0-.14.49c0 .196.053.373.156.529.104.156.252.304.443.444s.423.276.696.41c.273.135.582.274.926.416.47.197.892.407 1.266.628.374.222.695.473.963.753.268.279.472.598.614.957.142.359.214.776.214 1.253 0 .657-.125 1.21-.373 1.656a3.033 3.033 0 0 1-1.012 1.085 4.38 4.38 0 0 1-1.487.596c-.566.12-1.163.18-1.79.18a9.916 9.916 0 0 1-1.84-.164 5.544 5.544 0 0 1-1.512-.493v-2.63a5.033 5.033 0 0 0 3.237 1.2c.333 0 .624-.03.872-.09.249-.06.456-.144.623-.25.166-.108.29-.234.373-.38a1.023 1.023 0 0 0-.074-1.089 2.12 2.12 0 0 0-.537-.5 5.597 5.597 0 0 0-.807-.444 27.72 27.72 0 0 0-1.007-.436c-.918-.383-1.602-.852-2.053-1.405-.45-.553-.676-1.222-.676-2.005 0-.614.123-1.141.369-1.582.246-.441.58-.804 1.004-1.089a4.494 4.494 0 0 1 1.47-.629 7.536 7.536 0 0 1 1.77-.201zm-15.113.188h9.563v2.166H9.506v9.646H6.789v-9.646H3.375z" />
</svg>`, MV = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M23.55 10.91 13.09.45a1.55 1.55 0 0 0-2.18 0L8.46 2.9 11 5.48a2.06 2.06 0 0 1 1-.23 2.25 2.25 0 0 1 2.25 2.25 2.18 2.18 0 0 1-.22 1l2.19 2.2a2 2 0 1 1-1.06 1.06L13 9.52a1 1 0 0 1-.21.09v5.54a2 2 0 1 1-1.5 0V9.61A2.24 2.24 0 0 1 9.75 7.5a2.18 2.18 0 0 1 .22-1L7.4 4 .45 11a1.55 1.55 0 0 0 0 2.18l10.46 10.37a1.55 1.55 0 0 0 2.18 0l10.46-10.46a1.55 1.55 0 0 0 0-2.18Z" fill="currentColor"></path></svg>', NV = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Tailwind CSS</title>
    <path
        d="M12.001,4.8c-3.2,0-5.2,1.6-6,4.8c1.2-1.6,2.6-2.2,4.2-1.8c0.913,0.228,1.565,0.89,2.288,1.624 C13.666,10.618,15.027,12,18.001,12c3.2,0,5.2-1.6,6-4.8c-1.2,1.6-2.6,2.2-4.2,1.8c-0.913-0.228-1.565-0.89-2.288-1.624 C16.337,6.182,14.976,4.8,12.001,4.8z M6.001,12c-3.2,0-5.2,1.6-6,4.8c1.2-1.6,2.6-2.2,4.2-1.8c0.913,0.228,1.565,0.89,2.288,1.624 c1.177,1.194,2.538,2.576,5.512,2.576c3.2,0,5.2-1.6,6-4.8c-1.2,1.6-2.6,2.2-4.2,1.8c-0.913-0.228-1.565-0.89-2.288-1.624 C10.337,13.382,8.976,12,6.001,12z" />
</svg>`, WV = /* @__PURE__ */ Object.assign({ "./solid/interface-close.svg": zW, "./solid/interface-copy-clipboard.svg": HW, "./solid/interface-dots-horizontal.svg": GW, "./solid/interface-dots-vertical.svg": KW, "./solid/interface-favorite-stars-sparkles.svg": JW, "./solid/mail-send-email-paper-airplane.svg": eV }), VV = /* @__PURE__ */ Object.assign({ "./line/arrow-chevron-down.svg": tV, "./line/arrow-chevron-left.svg": rV, "./line/arrow-chevron-right.svg": nV, "./line/arrow-chevron-up.svg": iV, "./line/arrow-down.svg": oV, "./line/arrow-left.svg": sV, "./line/arrow-right.svg": aV, "./line/arrow-up.svg": lV, "./line/interface-add.svg": uV, "./line/interface-close.svg": cV, "./line/programming-script-code.svg": fV }), YV = /* @__PURE__ */ Object.assign({ "./brand/brand-software-development-github.svg": dV, "./brand/programming-framework-angular.svg": hV, "./brand/programming-framework-astro.svg": pV, "./brand/programming-framework-laravel.svg": OV, "./brand/programming-framework-nextdotjs.svg": mV, "./brand/programming-framework-react.svg": gV, "./brand/programming-framework-vuedotjs.svg": yV, "./brand/programming-language-c.svg": vV, "./brand/programming-language-clojure.svg": bV, "./brand/programming-language-csharp.svg": SV, "./brand/programming-language-css3.svg": $V, "./brand/programming-language-go.svg": wV, "./brand/programming-language-html5.svg": PV, "./brand/programming-language-http.svg": _V, "./brand/programming-language-java.svg": xV, "./brand/programming-language-javascript-js.svg": QV, "./brand/programming-language-json.svg": TV, "./brand/programming-language-kotlin.svg": kV, "./brand/programming-language-node.svg": EV, "./brand/programming-language-objc.svg": CV, "./brand/programming-language-ocaml.svg": RV, "./brand/programming-language-php.svg": AV, "./brand/programming-language-powershell.svg": XV, "./brand/programming-language-python.svg": qV, "./brand/programming-language-r.svg": DV, "./brand/programming-language-ruby.svg": jV, "./brand/programming-language-scala.svg": UV, "./brand/programming-language-shell.svg": IV, "./brand/programming-language-swift.svg": FV, "./brand/programming-language-typescript.svg": ZV, "./brand/programming-tool-git.svg": MV, "./brand/programming-tool-tailwindcss.svg": NV });
function h0(t10, e3) {
  const r3 = Object.entries(t10).map(([o3, s3]) => {
    const a3 = o3.replace("./solid/", "").replace("./line/", "").replace("./brand/", "").replace(".svg", "");
    return {
      icon: {
        // Prefix the src with the group so that the final flat icon map has unique keys
        src: `${e3}/${a3}`,
        title: a3.replaceAll("-", " "),
        group: e3,
        tags: []
      },
      rawData: s3
    };
  }), n3 = r3.map((o3) => o3.icon), i3 = Object.fromEntries(
    r3.map((o3) => [o3.icon.src, o3.rawData])
  );
  return {
    iconDefinitionList: n3,
    iconDataMap: i3
  };
}
const UQ = h0(WV, "solid"), IQ = h0(VV, "line"), FQ = h0(YV, "brand");
[
  ...UQ.iconDefinitionList,
  ...IQ.iconDefinitionList,
  ...FQ.iconDefinitionList
];
const LV = {
  ...UQ.iconDataMap,
  ...IQ.iconDataMap,
  ...FQ.iconDataMap
}, BV = (t10) => LV[t10], zV = ["alt", "src"], as = /* @__PURE__ */ defineComponent({
  __name: "Icon",
  props: {
    src: {},
    title: {}
  },
  setup(t10) {
    const e3 = t10, r3 = computed(() => BV(e3.src));
    return (n3, i3) => r3.value ? (openBlock(), createBlock(unref(jQ), {
      key: 0,
      raw: r3.value
    }, null, 8, ["raw"])) : (openBlock(), createElementBlock("img", {
      key: 1,
      alt: n3.title,
      src: n3.src
    }, null, 8, zV));
  }
}), HV = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
    <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3.429"
        d="M24 1.714v44.572M1.714 24h44.572" />
</svg>`, GV = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32.5 23.5" fill="currentColor">
    <path d="M11.2 23.5 0 12.3l2.15-2.15 9.05 9.05L30.4 0l2.15 2.15z" />
</svg>`, KV = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path d="m19.5 8.25-7.5 7.5-7.5-7.5" />
</svg>`, JV = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path d="M15.75 19.5 8.25 12l7.5-7.5" />
</svg>`, eY = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path d="m8.25 4.5 7.5 7.5-7.5 7.5" />
</svg>`, tY = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path d="m4.5 15.75 7.5-7.5 7.5 7.5" />
</svg>`, rY = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14">
    <path stroke="currentColor" d="m12.5 1.5-11 11m0-11 11 11" />
</svg>`, nY = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
    <path
        d="M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" />
</svg>`, iY = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9 9">
    <g fill="none" fill-rule="evenodd" transform="translate(.67 .67)">
        <rect transform="rotate(180 4 4)" />
        <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width=".5"
            d="M2.85 1.73h3.4v3.4m0-3.4L1.74 6.24" />
    </g>
</svg>`, oY = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 1024 1024">
    <path
        d="M512 0a512 512 0 0 0-162 998c26 4 35-11 35-25l-1-95c-128 23-161-32-172-60-6-15-31-61-52-73-18-10-44-33-1-33 40-1 69 37 78 52 46 78 120 56 149 43 5-33 18-56 33-69-114-13-234-56-234-253 0-56 20-101 53-137-5-13-23-65 5-136 0 0 43-13 141 53a487 487 0 0 1 256 0c98-66 141-53 141-53 28 71 10 123 5 136 33 36 53 81 53 137 0 197-120 240-234 253 18 16 35 47 35 95l-1 140c0 14 9 30 35 25A512 512 0 0 0 512 0z" />
</svg>`, sY = `<svg
  height="24"
  viewBox="0 0 24 24"
  width="24"
  xmlns="http://www.w3.org/2000/svg">
  <path
    d="M24 12a1 1 0 0 0 -1 -1h-3.91a0.51 0.51 0 0 1 -0.49 -0.4 6.83 6.83 0 0 0 -0.94 -2.28 0.5 0.5 0 0 1 0.06 -0.63l2.77 -2.76a1 1 0 1 0 -1.42 -1.42l-2.76 2.77a0.5 0.5 0 0 1 -0.63 0.06 6.83 6.83 0 0 0 -2.28 -0.94 0.5 0.5 0 0 1 -0.4 -0.49V1a1 1 0 0 0 -2 0v3.91a0.51 0.51 0 0 1 -0.4 0.49 6.83 6.83 0 0 0 -2.28 0.94 0.5 0.5 0 0 1 -0.63 -0.06L4.93 3.51a1 1 0 0 0 -1.42 1.42l2.77 2.76a0.5 0.5 0 0 1 0.06 0.63 6.83 6.83 0 0 0 -0.94 2.28 0.5 0.5 0 0 1 -0.49 0.4H1a1 1 0 0 0 0 2h3.91a0.51 0.51 0 0 1 0.49 0.4 6.83 6.83 0 0 0 0.94 2.28 0.5 0.5 0 0 1 -0.06 0.63l-2.77 2.76a1 1 0 1 0 1.42 1.42l2.76 -2.77a0.5 0.5 0 0 1 0.63 -0.06 6.83 6.83 0 0 0 2.28 0.94 0.5 0.5 0 0 1 0.4 0.49V23a1 1 0 0 0 2 0v-3.91a0.51 0.51 0 0 1 0.4 -0.49 6.83 6.83 0 0 0 2.28 -0.94 0.5 0.5 0 0 1 0.63 0.06l2.76 2.77a1 1 0 1 0 1.42 -1.42l-2.77 -2.76a0.5 0.5 0 0 1 -0.06 -0.63 6.83 6.83 0 0 0 0.94 -2.28 0.5 0.5 0 0 1 0.49 -0.4H23a1 1 0 0 0 1 -1Zm-8.74 2.5A5.76 5.76 0 0 1 9.5 8.74a5.66 5.66 0 0 1 0.16 -1.31 0.49 0.49 0 0 1 0.34 -0.36 5.36 5.36 0 0 1 1.8 -0.31 5.47 5.47 0 0 1 5.46 5.46 5.36 5.36 0 0 1 -0.31 1.8 0.49 0.49 0 0 1 -0.35 0.32 5.53 5.53 0 0 1 -1.34 0.16Z"
    fill="currentColor"
    stroke-width="1"></path>
</svg>`, aY = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 593 593">
    <path fill="currentColor" fill-rule="evenodd"
        d="M347 0c6 0 12 5 12 12v134l94-95c5-5 13-5 17 0l72 72c4 4 5 12 0 16v1l-95 94h134c7 0 12 5 12 12v101c0 7-5 12-12 12H447l95 94c4 5 5 13 0 17l-72 72c-4 4-12 5-16 0h-1l-94-95v134c0 7-5 12-12 12H246c-7 0-12-5-12-12v-70c0-22 9-43 24-59l130-130c14-14 14-37 0-51L259 142a84 84 0 0 1-25-59V12c0-7 5-12 12-12h101ZM138 52h1l219 219c14 14 14 37 0 51L139 542c-4 5-12 5-17 0l-71-70c-4-5-5-12 0-17l95-96H12c-7 0-12-5-12-12V246c0-7 5-12 12-12h134l-95-94c-4-5-4-12 0-17l71-71c4-5 12-5 16 0Z" />
</svg>`, lY = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 662 662">
    <path fill-rule="evenodd" fill="currentColor"
        d="M331 0a331 331 0 1 1 0 662 331 331 0 0 1 0-662Zm148.5 109 .6.9a187 187 0 1 1-297.6-.9 267 267 0 1 0 297 0Z" />
</svg>`, uY = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 620 620">
    <path fill="currentColor"
        d="M-.653 309.29c-.078 82.272 31.848 159.735 89.739 218.178l.283.283c122.379 121.247 319.824 121.184 440.16-.283 119.967-121.1 119.409-316.933-.998-437.339l-.99-.99C468.681 30.845 390.716-1.017 307.893-.67c-82.83.354-160.443 32.994-218.814 91.79C31.209 149.555-.724 227.025-.653 309.29Zm469.271-160.789.778.778c87.9 87.9 88.325 231.005.707 319.33-77.753 78.46-199.786 87.412-288.959 26.862l198.513-198.513-.007 166.361 83.68-.07v-306.22H157.11l-.008 83.6h160.584L121.994 436.323c-59.347-87.689-50.536-208.59 26.51-286.343C236.34 61.294 379.94 60.67 468.61 148.494Z" />
</svg>`, cY = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 642 642" fill="currentColor">
    <path
        d="M321 0a321 321 0 1 1 0 642 321 321 0 0 1 0-642Zm51.3 63L321 189.5 269.7 63l1 136.5-95.8-97.2L228 228l-125.7-53.1 97.2 95.8-136.5-1L189.5 321 63 372.3l136.5-1-97.2 95.8 125.7-53-53.1 125.6 95.8-97.2-1 136.5L321 452.5 372.3 579l-1-136.5 95.8 97.2-53-125.7 125.6 53.1-97.2-95.8 136.5 1L452.5 321 579 269.7l-136.5 1 97.2-95.8L414 228l53.1-125.7-95.8 97.2 1-136.5Z" />
</svg>`, fY = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 620 620" fill="currentColor">
    <path
        d="M529.2 90.8A310 310 0 1 0 90.8 529.2 310 310 0 0 0 529.2 90.8M122.4 498.2c-54.9-55-15.4-183.5 88.2-287 103.6-103.7 232.1-143.2 287-88.3 54.9 54.8 15.4 183.4-88.3 287-103.5 103.6-232 143.1-286.9 88.3m261.8-262.7A104.7 104.7 0 1 1 236 383.7a104.7 104.7 0 0 1 148.2-148.2" />
</svg>`, dY = `<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 14 14">
    <path fill="none" stroke="currentColor" d="M14 3.4H0m14 7.2H0" />
</svg>`, hY = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor">
    <path fill-rule="evenodd"
        d="M12.6 11.2h.1l3 3a1 1 0 1 1-1.4 1.5l-3-3a1 1 0 0 1-.1-.1 7 7 0 1 1 1.4-1.4zM7 12A5 5 0 1 0 7 2a5 5 0 0 0 0 10z" />
</svg>`, kS = /* @__PURE__ */ Object.assign({ "./Add.svg": HV, "./CheckMark.svg": GV, "./ChevronDown.svg": KV, "./ChevronLeft.svg": JV, "./ChevronRight.svg": eY, "./ChevronUp.svg": tY, "./Close.svg": rY, "./Ellipses.svg": nY, "./ExternalLink.svg": iY, "./GitHub.svg": oY, "./LightDarkModeToggle.svg": sY, "./Logo.svg": aY, "./LogoAPI.svg": lY, "./LogoClient.svg": uY, "./LogoMarket.svg": cY, "./LogoSwagger.svg": fY, "./Menu.svg": dY, "./Search.svg": hY }), pY = (t10) => {
  const e3 = `./${t10}.svg`;
  return kS[e3] === void 0 ? (console.warn(`Could not find icon: ${t10}`), "") : kS[e3];
}, So = /* @__PURE__ */ defineComponent({
  __name: "FlowIcon",
  props: {
    icon: {}
  },
  setup(t10) {
    const e3 = t10, r3 = computed(() => pY(e3.icon));
    return (n3, i3) => r3.value ? (openBlock(), createBlock(unref(jQ), {
      key: 0,
      class: "flow-icon",
      height: "100%",
      raw: r3.value
    }, null, 8, ["raw"])) : createCommentVNode("", true);
  }
}), cm = /* @__PURE__ */ defineComponent({
  __name: "FlowIconButton",
  props: {
    label: {},
    icon: {},
    variant: { default: "clear" }
  },
  setup(t10) {
    return (e3, r3) => (openBlock(), createBlock(YW, {
      class: "icon-button",
      icon: "",
      label: e3.label,
      variant: e3.variant
    }, {
      default: withCtx(() => [
        createVNode(unref(So), { icon: e3.icon }, null, 8, ["icon"])
      ]),
      _: 1
    }, 8, ["label", "variant"]));
  }
}), OY = {
  key: 1,
  class: "action-menu"
}, mY = /* @__PURE__ */ defineComponent({
  __name: "SidebarElement",
  props: {
    item: {},
    isActive: { type: Boolean },
    hasChildren: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["select", "toggleOpen"],
  setup(t10, { expose: e3, emit: r3 }) {
    const n3 = t10, i3 = computed(() => {
      const l3 = n3.item;
      return l3.type === "Link" ? {
        href: l3.link,
        rel: "noopener noreferrer",
        target: "_blank"
      } : {};
    });
    function o3() {
      if (n3.item.type !== "Link") {
        if (n3.item.type === "Folder") {
          r3("toggleOpen");
          return;
        }
        r3("select");
      }
    }
    function s3() {
      n3.item.type !== "Folder" && r3("toggleOpen");
    }
    const a3 = ref(null);
    return e3({ el: a3 }), (l3, u3) => {
      var c3, f3, d3;
      return openBlock(), createElementBlock("li", {
        ref_key: "el",
        ref: a3,
        class: "sidebar-group-item"
      }, [
        createElementVNode("div", {
          class: normalizeClass(["sidebar-heading", {
            "sidebar-group-item__folder": l3.hasChildren || l3.item.type === "Folder",
            active_page: l3.isActive
          }]),
          onClick: o3
        }, [
          l3.hasChildren || l3.item.type === "Folder" ? (openBlock(), createBlock(cm, {
            key: 0,
            class: "toggle-nested-icon",
            icon: l3.open ? "ChevronDown" : "ChevronRight",
            label: "Toggle group",
            variant: "text",
            width: "20px",
            onClick: s3
          }, null, 8, ["icon"])) : createCommentVNode("", true),
          createElementVNode("a", mergeProps({ class: "flex-1 sidebar-heading-link" }, i3.value), [
            (f3 = (c3 = l3.item) == null ? void 0 : c3.icon) != null && f3.src ? (openBlock(), createBlock(unref(as), {
              key: 0,
              class: "sidebar-icon",
              src: l3.item.icon.src
            }, null, 8, ["src"])) : createCommentVNode("", true),
            createElementVNode("p", null, toDisplayString(l3.item.title), 1),
            l3.item.httpVerb ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(["sidebar-heading-type", [
                l3.item.httpVerb ? `sidebar-heading-type--${l3.item.httpVerb}` : ""
              ]])
            }, toDisplayString(l3.item.httpVerb), 3)) : createCommentVNode("", true)
          ], 16),
          ((d3 = l3.item) == null ? void 0 : d3.type) === "Link" ? (openBlock(), createBlock(unref(So), {
            key: 1,
            class: "link-icon",
            icon: "ExternalLink",
            width: "16px"
          })) : createCommentVNode("", true)
        ], 2),
        l3.open ? renderSlot(l3.$slots, "default", { key: 0 }, void 0, true) : createCommentVNode("", true),
        l3.$slots["action-menu"] ? (openBlock(), createElementBlock("div", OY, [
          renderSlot(l3.$slots, "action-menu", {}, void 0, true)
        ])) : createCommentVNode("", true)
      ], 512);
    };
  }
});
const ES = /* @__PURE__ */ Re(mY, [["__scopeId", "data-v-2fd8cd87"]]), CS = /* @__PURE__ */ defineComponent({
  __name: "SidebarGroup",
  props: {
    level: {}
  },
  setup(t10) {
    return (e3, r3) => (openBlock(), createElementBlock("ul", {
      class: "sidebar-group sidebar-indent-nested",
      style: normalizeStyle({ "--sidebar-level": e3.level })
    }, [
      renderSlot(e3.$slots, "default")
    ], 4));
  }
}), gY = { class: "sidebar" }, yY = -160, fm = /* @__PURE__ */ defineComponent({
  __name: "Sidebar",
  props: {
    parsedSpec: {}
  },
  setup(t10) {
    const e3 = t10, {
      state: r3,
      toggleCollapsedSidebarItem: n3,
      setCollapsedSidebarItem: i3
    } = Zr();
    watch(
      e3.parsedSpec,
      () => {
        var _10;
        const $10 = (_10 = e3.parsedSpec.tags) == null ? void 0 : _10[0];
        $10 && i3(Tn($10), true);
      },
      { immediate: true }
    );
    const { server: o3, authentication: s3 } = Ui(), { state: a3, toggleApiClient: l3 } = hs(), { setActiveRequest: u3 } = Nr();
    function c3($10) {
      const _10 = zO({
        serverState: o3,
        authenticationState: s3,
        operation: $10
      });
      u3(_10), l3(_10, true);
    }
    const f3 = ($10) => {
      var _10, P10;
      return ((P10 = (_10 = e3.parsedSpec) == null ? void 0 : _10.tags) == null ? void 0 : P10.length) !== 1 || ($10 == null ? void 0 : $10.name) !== "default" || ($10 == null ? void 0 : $10.description) !== "";
    }, d3 = ref([]);
    watch(
      () => {
        var $10, _10;
        return (_10 = ($10 = e3 == null ? void 0 : e3.parsedSpec) == null ? void 0 : $10.info) == null ? void 0 : _10.description;
      },
      async () => {
        var _10, P10;
        const $10 = (P10 = (_10 = e3 == null ? void 0 : e3.parsedSpec) == null ? void 0 : _10.info) == null ? void 0 : P10.description;
        return $10 ? d3.value = await p10($10) : [];
      }
    );
    const p10 = async ($10) => {
      const _10 = await HO($10), P10 = Zx(_10);
      return _10.filter((q5) => q5.depth === P10);
    }, h10 = ($10) => a3.sidebarIdVisibility[$10] ?? false, m10 = computed(() => {
      var N5, B5, H10, ne, re2, fe;
      const $10 = d3.value.map((pe) => ({
        id: Fx(pe),
        title: pe.value.toUpperCase(),
        type: "Page"
      })), _10 = (B5 = (N5 = e3 == null ? void 0 : e3.parsedSpec) == null ? void 0 : N5.tags) == null ? void 0 : B5[0], P10 = _10 && f3(_10) && ((H10 = _10.operations) == null ? void 0 : H10.length) > 0 ? (ne = e3.parsedSpec.tags) == null ? void 0 : ne.map((pe) => {
        var Ee2;
        return {
          id: Tn(pe),
          title: pe.name.toUpperCase(),
          type: "Folder",
          children: (Ee2 = pe.operations) == null ? void 0 : Ee2.map((qe) => ({
            id: ss(qe, pe),
            title: qe.name,
            type: "Page",
            httpVerb: qe.httpVerb,
            select: () => {
              a3.showApiClient && c3(qe);
            }
          }))
        };
      }) : (re2 = _10 == null ? void 0 : _10.operations) == null ? void 0 : re2.map((pe) => ({
        id: ss(pe, _10),
        title: pe.name,
        type: "Page",
        httpVerb: pe.httpVerb,
        select: () => {
          a3.showApiClient && c3(pe);
        }
      })), q5 = Wx(e3.parsedSpec) ? [
        {
          id: Wo(),
          title: "MODELS",
          type: "Folder",
          children: Object.keys(((fe = e3.parsedSpec.components) == null ? void 0 : fe.schemas) ?? {}).map(
            (pe) => ({
              id: Wo(pe),
              title: pe,
              type: "Page"
            })
          )
        }
      ] : [];
      return [...$10, ...P10 ?? [], ...q5];
    }), O10 = computed(() => {
      var _10;
      return ((_10 = m10.value.reduce((P10, q5) => (P10.push(q5), q5.children && P10.push(...q5.children), P10), []).find((P10) => h10(P10.id))) == null ? void 0 : _10.id) ?? null;
    }), g = ref(null), v10 = ref({});
    watch(O10, ($10) => {
      var q5, N5, B5, H10, ne;
      const _10 = v10.value[$10];
      if (!_10 || !g.value)
        return;
      let P10 = yY;
      _10.getAttribute("data-sidebar-type") === "heading" ? P10 += _10.offsetTop + ((q5 = _10.getElementsByClassName("sidebar-heading")) == null ? void 0 : q5[0]).offsetHeight : P10 += _10.offsetTop + (((N5 = _10.parentElement) == null ? void 0 : N5.offsetTop) ?? 0) + (((H10 = (B5 = _10.parentElement) == null ? void 0 : B5.parentElement) == null ? void 0 : H10.offsetTop) ?? 0), (ne = g.value) == null || ne.scrollTo({ top: P10, behavior: "smooth" });
    });
    const S10 = ($10, _10) => {
      $10 != null && $10.el && (v10.value[_10] = $10.el);
    };
    return ($10, _10) => (openBlock(), createElementBlock("div", gY, [
      renderSlot($10.$slots, "sidebar-start"),
      createElementVNode("div", {
        ref_key: "scrollerEl",
        ref: g,
        class: "pages custom-scroll custom-scroll-self-contain-overflow"
      }, [
        createVNode(CS, { level: 0 }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(m10.value, (P10) => (openBlock(), createBlock(ES, {
              key: P10.id,
              ref_for: true,
              ref: (q5) => S10(q5, P10.id),
              "data-sidebar-type": "heading",
              isActive: O10.value === P10.id,
              item: {
                uid: "",
                title: P10.title,
                type: P10.type,
                httpVerb: P10.httpVerb
              },
              open: unref(r3).collapsedSidebarItems[P10.id] ?? false,
              onSelect: () => {
                P10.id && unref(Js)(P10.id), P10.select && P10.select();
              },
              onToggleOpen: () => unref(n3)(P10.id)
            }, {
              default: withCtx(() => {
                var q5;
                return [
                  P10.children && ((q5 = P10.children) == null ? void 0 : q5.length) > 0 ? (openBlock(), createBlock(CS, {
                    key: 0,
                    level: 0
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(P10.children, (N5) => (openBlock(), createBlock(ES, {
                        key: N5.id,
                        ref_for: true,
                        ref: (B5) => S10(B5, N5.id),
                        isActive: O10.value === N5.id,
                        item: {
                          uid: "",
                          title: N5.title,
                          type: N5.type,
                          httpVerb: N5.httpVerb
                        },
                        onSelect: () => {
                          N5.id && unref(Js)(N5.id), N5.select && N5.select();
                        }
                      }, null, 8, ["isActive", "item", "onSelect"]))), 128))
                    ]),
                    _: 2
                  }, 1024)) : createCommentVNode("", true)
                ];
              }),
              _: 2
            }, 1032, ["isActive", "item", "open", "onSelect", "onToggleOpen"]))), 128))
          ]),
          _: 1
        })
      ], 512),
      renderSlot($10.$slots, "sidebar-end")
    ]));
  }
});
const ls = reactive([]);
function QY(t10, e3) {
  const r3 = Ax();
  ls.push({ id: r3, ...t10, options: e3 });
  let n3;
  return e3 != null && e3.timeout && (n3 = setTimeout(() => {
    dm(r3);
  }, e3.timeout)), { id: r3, dismiss: () => {
    n3 && clearTimeout(n3), dm(r3);
  }, active: () => ls.some((s3) => s3.id === r3) };
}
function TY(t10, e3) {
  return QY(t10, e3);
}
function ZQ() {
  return {
    toasts: readonly(ls),
    addToast: TY,
    removeToast: dm,
    clearToasts: kY
  };
}
function dm(t10) {
  const e3 = ls.findIndex((r3) => r3.id === t10);
  e3 < 0 || ls.splice(e3, 1);
}
function kY() {
  ls.splice(0, ls.length);
}
ref(false);
function MQ(t10) {
  return {
    parameterMap: computed(() => {
      const { parameters: r3 } = t10.operation.information, n3 = {
        path: [],
        query: [],
        header: []
      };
      return t10.operation.pathParameters && t10.operation.pathParameters.forEach((i3) => {
        i3.in === "path" ? n3.path.push(i3) : i3.in === "query" ? n3.query.push(i3) : i3.in === "header" && n3.header.push(i3);
      }), r3 && r3.forEach((i3) => {
        i3.in === "path" ? n3.path.push(i3) : i3.in === "query" ? n3.query.push(i3) : i3.in === "header" && n3.header.push(i3);
      }), n3;
    })
  };
}
typeof window < "u" && (window.process = window.process || {
  platform: "browser",
  browser: true
});
var gs = {}, yu = {}, NQ = {}, WQ = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return false;
  if (typeof Symbol.iterator == "symbol")
    return true;
  var e3 = {}, r3 = Symbol("test"), n3 = Object(r3);
  if (typeof r3 == "string" || Object.prototype.toString.call(r3) !== "[object Symbol]" || Object.prototype.toString.call(n3) !== "[object Symbol]")
    return false;
  var i3 = 42;
  e3[r3] = i3;
  for (r3 in e3)
    return false;
  if (typeof Object.keys == "function" && Object.keys(e3).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e3).length !== 0)
    return false;
  var o3 = Object.getOwnPropertySymbols(e3);
  if (o3.length !== 1 || o3[0] !== r3 || !Object.prototype.propertyIsEnumerable.call(e3, r3))
    return false;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var s3 = Object.getOwnPropertyDescriptor(e3, r3);
    if (s3.value !== i3 || s3.enumerable !== true)
      return false;
  }
  return true;
}, YY = WQ, p0 = function() {
  return YY() && !!Symbol.toStringTag;
}, XS = typeof Symbol < "u" && Symbol, LY = WQ, BY = function() {
  return typeof XS != "function" || typeof Symbol != "function" || typeof XS("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : LY();
}, qS = {
  foo: {}
}, zY = Object, HY = function() {
  return { __proto__: qS }.foo === qS.foo && !({ __proto__: null } instanceof zY);
}, GY = "Function.prototype.bind called on incompatible ", zh = Array.prototype.slice, KY = Object.prototype.toString, JY = "[object Function]", eL = function(e3) {
  var r3 = this;
  if (typeof r3 != "function" || KY.call(r3) !== JY)
    throw new TypeError(GY + r3);
  for (var n3 = zh.call(arguments, 1), i3, o3 = function() {
    if (this instanceof i3) {
      var c3 = r3.apply(
        this,
        n3.concat(zh.call(arguments))
      );
      return Object(c3) === c3 ? c3 : this;
    } else
      return r3.apply(
        e3,
        n3.concat(zh.call(arguments))
      );
  }, s3 = Math.max(0, r3.length - n3.length), a3 = [], l3 = 0; l3 < s3; l3++)
    a3.push("$" + l3);
  if (i3 = Function("binder", "return function (" + a3.join(",") + "){ return binder.apply(this,arguments); }")(o3), r3.prototype) {
    var u3 = function() {
    };
    u3.prototype = r3.prototype, i3.prototype = new u3(), u3.prototype = null;
  }
  return i3;
}, tL = eL, O0 = Function.prototype.bind || tL, rL = O0, nL = rL.call(Function.call, Object.prototype.hasOwnProperty), nt, ga = SyntaxError, VQ = Function, ea = TypeError, Hh = function(t10) {
  try {
    return VQ('"use strict"; return (' + t10 + ").constructor;")();
  } catch {
  }
}, Jo = Object.getOwnPropertyDescriptor;
if (Jo)
  try {
    Jo({}, "");
  } catch {
    Jo = null;
  }
var Gh = function() {
  throw new ea();
}, iL = Jo ? function() {
  try {
    return arguments.callee, Gh;
  } catch {
    try {
      return Jo(arguments, "callee").get;
    } catch {
      return Gh;
    }
  }
}() : Gh, Qs = BY(), oL = HY(), er = Object.getPrototypeOf || (oL ? function(t10) {
  return t10.__proto__;
} : null), As = {}, sL = typeof Uint8Array > "u" || !er ? nt : er(Uint8Array), es = {
  "%AggregateError%": typeof AggregateError > "u" ? nt : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? nt : ArrayBuffer,
  "%ArrayIteratorPrototype%": Qs && er ? er([][Symbol.iterator]()) : nt,
  "%AsyncFromSyncIteratorPrototype%": nt,
  "%AsyncFunction%": As,
  "%AsyncGenerator%": As,
  "%AsyncGeneratorFunction%": As,
  "%AsyncIteratorPrototype%": As,
  "%Atomics%": typeof Atomics > "u" ? nt : Atomics,
  "%BigInt%": typeof BigInt > "u" ? nt : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? nt : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? nt : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? nt : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? nt : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? nt : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? nt : FinalizationRegistry,
  "%Function%": VQ,
  "%GeneratorFunction%": As,
  "%Int8Array%": typeof Int8Array > "u" ? nt : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? nt : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? nt : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Qs && er ? er(er([][Symbol.iterator]())) : nt,
  "%JSON%": typeof JSON == "object" ? JSON : nt,
  "%Map%": typeof Map > "u" ? nt : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Qs || !er ? nt : er((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? nt : Promise,
  "%Proxy%": typeof Proxy > "u" ? nt : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? nt : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? nt : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Qs || !er ? nt : er((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? nt : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Qs && er ? er(""[Symbol.iterator]()) : nt,
  "%Symbol%": Qs ? Symbol : nt,
  "%SyntaxError%": ga,
  "%ThrowTypeError%": iL,
  "%TypedArray%": sL,
  "%TypeError%": ea,
  "%Uint8Array%": typeof Uint8Array > "u" ? nt : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? nt : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? nt : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? nt : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? nt : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? nt : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? nt : WeakSet
};
if (er)
  try {
    null.error;
  } catch (t10) {
    var aL = er(er(t10));
    es["%Error.prototype%"] = aL;
  }
var lL = function t3(e3) {
  var r3;
  if (e3 === "%AsyncFunction%")
    r3 = Hh("async function () {}");
  else if (e3 === "%GeneratorFunction%")
    r3 = Hh("function* () {}");
  else if (e3 === "%AsyncGeneratorFunction%")
    r3 = Hh("async function* () {}");
  else if (e3 === "%AsyncGenerator%") {
    var n3 = t3("%AsyncGeneratorFunction%");
    n3 && (r3 = n3.prototype);
  } else if (e3 === "%AsyncIteratorPrototype%") {
    var i3 = t3("%AsyncGenerator%");
    i3 && er && (r3 = er(i3.prototype));
  }
  return es[e3] = r3, r3;
}, DS = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, vu = O0, wf = nL, uL = vu.call(Function.call, Array.prototype.concat), cL = vu.call(Function.apply, Array.prototype.splice), jS = vu.call(Function.call, String.prototype.replace), Pf = vu.call(Function.call, String.prototype.slice), fL = vu.call(Function.call, RegExp.prototype.exec), dL = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, hL = /\\(\\)?/g, pL = function(e3) {
  var r3 = Pf(e3, 0, 1), n3 = Pf(e3, -1);
  if (r3 === "%" && n3 !== "%")
    throw new ga("invalid intrinsic syntax, expected closing `%`");
  if (n3 === "%" && r3 !== "%")
    throw new ga("invalid intrinsic syntax, expected opening `%`");
  var i3 = [];
  return jS(e3, dL, function(o3, s3, a3, l3) {
    i3[i3.length] = a3 ? jS(l3, hL, "$1") : s3 || o3;
  }), i3;
}, OL = function(e3, r3) {
  var n3 = e3, i3;
  if (wf(DS, n3) && (i3 = DS[n3], n3 = "%" + i3[0] + "%"), wf(es, n3)) {
    var o3 = es[n3];
    if (o3 === As && (o3 = lL(n3)), typeof o3 > "u" && !r3)
      throw new ea("intrinsic " + e3 + " exists, but is not available. Please file an issue!");
    return {
      alias: i3,
      name: n3,
      value: o3
    };
  }
  throw new ga("intrinsic " + e3 + " does not exist!");
}, m0 = function(e3, r3) {
  if (typeof e3 != "string" || e3.length === 0)
    throw new ea("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r3 != "boolean")
    throw new ea('"allowMissing" argument must be a boolean');
  if (fL(/^%?[^%]*%?$/, e3) === null)
    throw new ga("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var n3 = pL(e3), i3 = n3.length > 0 ? n3[0] : "", o3 = OL("%" + i3 + "%", r3), s3 = o3.name, a3 = o3.value, l3 = false, u3 = o3.alias;
  u3 && (i3 = u3[0], cL(n3, uL([0, 1], u3)));
  for (var c3 = 1, f3 = true; c3 < n3.length; c3 += 1) {
    var d3 = n3[c3], p10 = Pf(d3, 0, 1), h10 = Pf(d3, -1);
    if ((p10 === '"' || p10 === "'" || p10 === "`" || h10 === '"' || h10 === "'" || h10 === "`") && p10 !== h10)
      throw new ga("property names with quotes must have matching quotes");
    if ((d3 === "constructor" || !f3) && (l3 = true), i3 += "." + d3, s3 = "%" + i3 + "%", wf(es, s3))
      a3 = es[s3];
    else if (a3 != null) {
      if (!(d3 in a3)) {
        if (!r3)
          throw new ea("base intrinsic for " + e3 + " exists, but the property is not available.");
        return;
      }
      if (Jo && c3 + 1 >= n3.length) {
        var m10 = Jo(a3, d3);
        f3 = !!m10, f3 && "get" in m10 && !("originalValue" in m10.get) ? a3 = m10.get : a3 = a3[d3];
      } else
        f3 = wf(a3, d3), a3 = a3[d3];
      f3 && !l3 && (es[s3] = a3);
    }
  }
  return a3;
}, YQ = { exports: {} };
(function(t10) {
  var e3 = O0, r3 = m0, n3 = r3("%Function.prototype.apply%"), i3 = r3("%Function.prototype.call%"), o3 = r3("%Reflect.apply%", true) || e3.call(i3, n3), s3 = r3("%Object.getOwnPropertyDescriptor%", true), a3 = r3("%Object.defineProperty%", true), l3 = r3("%Math.max%");
  if (a3)
    try {
      a3({}, "a", { value: 1 });
    } catch {
      a3 = null;
    }
  t10.exports = function(f3) {
    var d3 = o3(e3, i3, arguments);
    if (s3 && a3) {
      var p10 = s3(d3, "length");
      p10.configurable && a3(
        d3,
        "length",
        { value: 1 + l3(0, f3.length - (arguments.length - 1)) }
      );
    }
    return d3;
  };
  var u3 = function() {
    return o3(e3, n3, arguments);
  };
  a3 ? a3(t10.exports, "apply", { value: u3 }) : t10.exports.apply = u3;
})(YQ);
var LQ = YQ.exports, BQ = m0, zQ = LQ, mL = zQ(BQ("String.prototype.indexOf")), HQ = function(e3, r3) {
  var n3 = BQ(e3, !!r3);
  return typeof n3 == "function" && mL(e3, ".prototype.") > -1 ? zQ(n3) : n3;
}, gL = p0(), yL = HQ, hm = yL("Object.prototype.toString"), vd = function(e3) {
  return gL && e3 && typeof e3 == "object" && Symbol.toStringTag in e3 ? false : hm(e3) === "[object Arguments]";
}, GQ = function(e3) {
  return vd(e3) ? true : e3 !== null && typeof e3 == "object" && typeof e3.length == "number" && e3.length >= 0 && hm(e3) !== "[object Array]" && hm(e3.callee) === "[object Function]";
}, vL = function() {
  return vd(arguments);
}();
vd.isLegacyArguments = GQ;
var bL = vL ? vd : GQ, SL = Object.prototype.toString, $L = Function.prototype.toString, wL = /^\s*(?:function)?\*/, KQ = p0(), Kh = Object.getPrototypeOf, PL = function() {
  if (!KQ)
    return false;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, Jh, _L = function(e3) {
  if (typeof e3 != "function")
    return false;
  if (wL.test($L.call(e3)))
    return true;
  if (!KQ) {
    var r3 = SL.call(e3);
    return r3 === "[object GeneratorFunction]";
  }
  if (!Kh)
    return false;
  if (typeof Jh > "u") {
    var n3 = PL();
    Jh = n3 ? Kh(n3) : false;
  }
  return Kh(e3) === Jh;
}, JQ = Function.prototype.toString, Zs = typeof Reflect == "object" && Reflect !== null && Reflect.apply, pm, Ec;
if (typeof Zs == "function" && typeof Object.defineProperty == "function")
  try {
    pm = Object.defineProperty({}, "length", {
      get: function() {
        throw Ec;
      }
    }), Ec = {}, Zs(function() {
      throw 42;
    }, null, pm);
  } catch (t10) {
    t10 !== Ec && (Zs = null);
  }
else
  Zs = null;
var xL = /^\s*class\b/, Om = function(e3) {
  try {
    var r3 = JQ.call(e3);
    return xL.test(r3);
  } catch {
    return false;
  }
}, ep = function(e3) {
  try {
    return Om(e3) ? false : (JQ.call(e3), true);
  } catch {
    return false;
  }
}, Cc = Object.prototype.toString, QL = "[object Object]", TL = "[object Function]", kL = "[object GeneratorFunction]", EL = "[object HTMLAllCollection]", CL = "[object HTML document.all class]", RL = "[object HTMLCollection]", AL = typeof Symbol == "function" && !!Symbol.toStringTag, XL = !(0 in [,]), mm = function() {
  return false;
};
if (typeof document == "object") {
  var qL = document.all;
  Cc.call(qL) === Cc.call(document.all) && (mm = function(e3) {
    if ((XL || !e3) && (typeof e3 > "u" || typeof e3 == "object"))
      try {
        var r3 = Cc.call(e3);
        return (r3 === EL || r3 === CL || r3 === RL || r3 === QL) && e3("") == null;
      } catch {
      }
    return false;
  });
}
var DL = Zs ? function(e3) {
  if (mm(e3))
    return true;
  if (!e3 || typeof e3 != "function" && typeof e3 != "object")
    return false;
  try {
    Zs(e3, null, pm);
  } catch (r3) {
    if (r3 !== Ec)
      return false;
  }
  return !Om(e3) && ep(e3);
} : function(e3) {
  if (mm(e3))
    return true;
  if (!e3 || typeof e3 != "function" && typeof e3 != "object")
    return false;
  if (AL)
    return ep(e3);
  if (Om(e3))
    return false;
  var r3 = Cc.call(e3);
  return r3 !== TL && r3 !== kL && !/^\[object HTML/.test(r3) ? false : ep(e3);
}, jL = DL, UL = Object.prototype.toString, eT = Object.prototype.hasOwnProperty, IL = function(e3, r3, n3) {
  for (var i3 = 0, o3 = e3.length; i3 < o3; i3++)
    eT.call(e3, i3) && (n3 == null ? r3(e3[i3], i3, e3) : r3.call(n3, e3[i3], i3, e3));
}, FL = function(e3, r3, n3) {
  for (var i3 = 0, o3 = e3.length; i3 < o3; i3++)
    n3 == null ? r3(e3.charAt(i3), i3, e3) : r3.call(n3, e3.charAt(i3), i3, e3);
}, ZL = function(e3, r3, n3) {
  for (var i3 in e3)
    eT.call(e3, i3) && (n3 == null ? r3(e3[i3], i3, e3) : r3.call(n3, e3[i3], i3, e3));
}, ML = function(e3, r3, n3) {
  if (!jL(r3))
    throw new TypeError("iterator must be a function");
  var i3;
  arguments.length >= 3 && (i3 = n3), UL.call(e3) === "[object Array]" ? IL(e3, r3, i3) : typeof e3 == "string" ? FL(e3, r3, i3) : ZL(e3, r3, i3);
}, NL = ML, tp = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], WL = typeof globalThis > "u" ? yt : globalThis, VL = function() {
  for (var e3 = [], r3 = 0; r3 < tp.length; r3++)
    typeof WL[tp[r3]] == "function" && (e3[e3.length] = tp[r3]);
  return e3;
}, YL = m0, Rc = YL("%Object.getOwnPropertyDescriptor%", true);
if (Rc)
  try {
    Rc([], "length");
  } catch {
    Rc = null;
  }
var LL = Rc, _f = NL, BL = VL, US = LQ, g0 = HQ, Ac = LL, zL = g0("Object.prototype.toString"), tT = p0(), IS = typeof globalThis > "u" ? yt : globalThis, gm = BL(), y0 = g0("String.prototype.slice"), rp = Object.getPrototypeOf, HL = g0("Array.prototype.indexOf", true) || function(e3, r3) {
  for (var n3 = 0; n3 < e3.length; n3 += 1)
    if (e3[n3] === r3)
      return n3;
  return -1;
}, xf = { __proto__: null };
tT && Ac && rp ? _f(gm, function(t10) {
  var e3 = new IS[t10]();
  if (Symbol.toStringTag in e3) {
    var r3 = rp(e3), n3 = Ac(r3, Symbol.toStringTag);
    if (!n3) {
      var i3 = rp(r3);
      n3 = Ac(i3, Symbol.toStringTag);
    }
    xf["$" + t10] = US(n3.get);
  }
}) : _f(gm, function(t10) {
  var e3 = new IS[t10]();
  xf["$" + t10] = US(e3.slice);
});
var GL = function(e3) {
  var r3 = false;
  return _f(xf, function(n3, i3) {
    if (!r3)
      try {
        "$" + n3(e3) === i3 && (r3 = y0(i3, 1));
      } catch {
      }
  }), r3;
}, KL = function(e3) {
  var r3 = false;
  return _f(xf, function(n3, i3) {
    if (!r3)
      try {
        n3(e3), r3 = y0(i3, 1);
      } catch {
      }
  }), r3;
}, rT = function(e3) {
  if (!e3 || typeof e3 != "object")
    return false;
  if (!tT) {
    var r3 = y0(zL(e3), 8, -1);
    return HL(gm, r3) > -1 ? r3 : r3 !== "Object" ? false : KL(e3);
  }
  return Ac ? GL(e3) : null;
}, JL = rT, eB = function(e3) {
  return !!JL(e3);
};
(function(t10) {
  var e3 = bL, r3 = _L, n3 = rT, i3 = eB;
  function o3(le) {
    return le.call.bind(le);
  }
  var s3 = typeof BigInt < "u", a3 = typeof Symbol < "u", l3 = o3(Object.prototype.toString), u3 = o3(Number.prototype.valueOf), c3 = o3(String.prototype.valueOf), f3 = o3(Boolean.prototype.valueOf);
  if (s3)
    var d3 = o3(BigInt.prototype.valueOf);
  if (a3)
    var p10 = o3(Symbol.prototype.valueOf);
  function h10(le, qr) {
    if (typeof le != "object")
      return false;
    try {
      return qr(le), true;
    } catch {
      return false;
    }
  }
  t10.isArgumentsObject = e3, t10.isGeneratorFunction = r3, t10.isTypedArray = i3;
  function m10(le) {
    return typeof Promise < "u" && le instanceof Promise || le !== null && typeof le == "object" && typeof le.then == "function" && typeof le.catch == "function";
  }
  t10.isPromise = m10;
  function O10(le) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(le) : i3(le) || X10(le);
  }
  t10.isArrayBufferView = O10;
  function g(le) {
    return n3(le) === "Uint8Array";
  }
  t10.isUint8Array = g;
  function v10(le) {
    return n3(le) === "Uint8ClampedArray";
  }
  t10.isUint8ClampedArray = v10;
  function S10(le) {
    return n3(le) === "Uint16Array";
  }
  t10.isUint16Array = S10;
  function $10(le) {
    return n3(le) === "Uint32Array";
  }
  t10.isUint32Array = $10;
  function _10(le) {
    return n3(le) === "Int8Array";
  }
  t10.isInt8Array = _10;
  function P10(le) {
    return n3(le) === "Int16Array";
  }
  t10.isInt16Array = P10;
  function q5(le) {
    return n3(le) === "Int32Array";
  }
  t10.isInt32Array = q5;
  function N5(le) {
    return n3(le) === "Float32Array";
  }
  t10.isFloat32Array = N5;
  function B5(le) {
    return n3(le) === "Float64Array";
  }
  t10.isFloat64Array = B5;
  function H10(le) {
    return n3(le) === "BigInt64Array";
  }
  t10.isBigInt64Array = H10;
  function ne(le) {
    return n3(le) === "BigUint64Array";
  }
  t10.isBigUint64Array = ne;
  function re2(le) {
    return l3(le) === "[object Map]";
  }
  re2.working = typeof Map < "u" && re2(/* @__PURE__ */ new Map());
  function fe(le) {
    return typeof Map > "u" ? false : re2.working ? re2(le) : le instanceof Map;
  }
  t10.isMap = fe;
  function pe(le) {
    return l3(le) === "[object Set]";
  }
  pe.working = typeof Set < "u" && pe(/* @__PURE__ */ new Set());
  function Ee2(le) {
    return typeof Set > "u" ? false : pe.working ? pe(le) : le instanceof Set;
  }
  t10.isSet = Ee2;
  function qe(le) {
    return l3(le) === "[object WeakMap]";
  }
  qe.working = typeof WeakMap < "u" && qe(/* @__PURE__ */ new WeakMap());
  function _e(le) {
    return typeof WeakMap > "u" ? false : qe.working ? qe(le) : le instanceof WeakMap;
  }
  t10.isWeakMap = _e;
  function Ie(le) {
    return l3(le) === "[object WeakSet]";
  }
  Ie.working = typeof WeakSet < "u" && Ie(/* @__PURE__ */ new WeakSet());
  function je2(le) {
    return Ie(le);
  }
  t10.isWeakSet = je2;
  function G(le) {
    return l3(le) === "[object ArrayBuffer]";
  }
  G.working = typeof ArrayBuffer < "u" && G(new ArrayBuffer());
  function Z(le) {
    return typeof ArrayBuffer > "u" ? false : G.working ? G(le) : le instanceof ArrayBuffer;
  }
  t10.isArrayBuffer = Z;
  function C10(le) {
    return l3(le) === "[object DataView]";
  }
  C10.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && C10(new DataView(new ArrayBuffer(1), 0, 1));
  function X10(le) {
    return typeof DataView > "u" ? false : C10.working ? C10(le) : le instanceof DataView;
  }
  t10.isDataView = X10;
  var w10 = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function U10(le) {
    return l3(le) === "[object SharedArrayBuffer]";
  }
  function T10(le) {
    return typeof w10 > "u" ? false : (typeof U10.working > "u" && (U10.working = U10(new w10())), U10.working ? U10(le) : le instanceof w10);
  }
  t10.isSharedArrayBuffer = T10;
  function F5(le) {
    return l3(le) === "[object AsyncFunction]";
  }
  t10.isAsyncFunction = F5;
  function V3(le) {
    return l3(le) === "[object Map Iterator]";
  }
  t10.isMapIterator = V3;
  function ie2(le) {
    return l3(le) === "[object Set Iterator]";
  }
  t10.isSetIterator = ie2;
  function ce2(le) {
    return l3(le) === "[object Generator]";
  }
  t10.isGeneratorObject = ce2;
  function E(le) {
    return l3(le) === "[object WebAssembly.Module]";
  }
  t10.isWebAssemblyCompiledModule = E;
  function D5(le) {
    return h10(le, u3);
  }
  t10.isNumberObject = D5;
  function se(le) {
    return h10(le, c3);
  }
  t10.isStringObject = se;
  function ye(le) {
    return h10(le, f3);
  }
  t10.isBooleanObject = ye;
  function Ye(le) {
    return s3 && h10(le, d3);
  }
  t10.isBigIntObject = Ye;
  function xe2(le) {
    return a3 && h10(le, p10);
  }
  t10.isSymbolObject = xe2;
  function Ge(le) {
    return D5(le) || se(le) || ye(le) || Ye(le) || xe2(le);
  }
  t10.isBoxedPrimitive = Ge;
  function or(le) {
    return typeof Uint8Array < "u" && (Z(le) || T10(le));
  }
  t10.isAnyArrayBuffer = or, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(le) {
    Object.defineProperty(t10, le, {
      enumerable: false,
      value: function() {
        throw new Error(le + " is not supported in userland");
      }
    });
  });
})(NQ);
var tB = function(e3) {
  return e3 && typeof e3 == "object" && typeof e3.copy == "function" && typeof e3.fill == "function" && typeof e3.readUInt8 == "function";
}, ym = { exports: {} };
typeof Object.create == "function" ? ym.exports = function(e3, r3) {
  r3 && (e3.super_ = r3, e3.prototype = Object.create(r3.prototype, {
    constructor: {
      value: e3,
      enumerable: false,
      writable: true,
      configurable: true
    }
  }));
} : ym.exports = function(e3, r3) {
  if (r3) {
    e3.super_ = r3;
    var n3 = function() {
    };
    n3.prototype = r3.prototype, e3.prototype = new n3(), e3.prototype.constructor = e3;
  }
};
var $o = ym.exports;
(function(t10) {
  var e3 = Object.getOwnPropertyDescriptors || function(X10) {
    for (var w10 = Object.keys(X10), U10 = {}, T10 = 0; T10 < w10.length; T10++)
      U10[w10[T10]] = Object.getOwnPropertyDescriptor(X10, w10[T10]);
    return U10;
  }, r3 = /%[sdj%]/g;
  t10.format = function(C10) {
    if (!_10(C10)) {
      for (var X10 = [], w10 = 0; w10 < arguments.length; w10++)
        X10.push(s3(arguments[w10]));
      return X10.join(" ");
    }
    for (var w10 = 1, U10 = arguments, T10 = U10.length, F5 = String(C10).replace(r3, function(ie2) {
      if (ie2 === "%%")
        return "%";
      if (w10 >= T10)
        return ie2;
      switch (ie2) {
        case "%s":
          return String(U10[w10++]);
        case "%d":
          return Number(U10[w10++]);
        case "%j":
          try {
            return JSON.stringify(U10[w10++]);
          } catch {
            return "[Circular]";
          }
        default:
          return ie2;
      }
    }), V3 = U10[w10]; w10 < T10; V3 = U10[++w10])
      v10(V3) || !B5(V3) ? F5 += " " + V3 : F5 += " " + s3(V3);
    return F5;
  }, t10.deprecate = function(C10, X10) {
    if (typeof $e.process < "u" && $e.process.noDeprecation === true)
      return C10;
    if (typeof $e.process > "u")
      return function() {
        return t10.deprecate(C10, X10).apply(this, arguments);
      };
    var w10 = false;
    function U10() {
      if (!w10) {
        if ($e.process.throwDeprecation)
          throw new Error(X10);
        $e.process.traceDeprecation ? console.trace(X10) : console.error(X10), w10 = true;
      }
      return C10.apply(this, arguments);
    }
    return U10;
  };
  var n3 = {}, i3 = /^$/;
  if ($e.process.env.NODE_DEBUG) {
    var o3 = $e.process.env.NODE_DEBUG;
    o3 = o3.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i3 = new RegExp("^" + o3 + "$", "i");
  }
  t10.debuglog = function(C10) {
    if (C10 = C10.toUpperCase(), !n3[C10])
      if (i3.test(C10)) {
        var X10 = $e.process.pid;
        n3[C10] = function() {
          var w10 = t10.format.apply(t10, arguments);
          console.error("%s %d: %s", C10, X10, w10);
        };
      } else
        n3[C10] = function() {
        };
    return n3[C10];
  };
  function s3(C10, X10) {
    var w10 = {
      seen: [],
      stylize: l3
    };
    return arguments.length >= 3 && (w10.depth = arguments[2]), arguments.length >= 4 && (w10.colors = arguments[3]), g(X10) ? w10.showHidden = X10 : X10 && t10._extend(w10, X10), q5(w10.showHidden) && (w10.showHidden = false), q5(w10.depth) && (w10.depth = 2), q5(w10.colors) && (w10.colors = false), q5(w10.customInspect) && (w10.customInspect = true), w10.colors && (w10.stylize = a3), c3(w10, C10, w10.depth);
  }
  t10.inspect = s3, s3.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, s3.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function a3(C10, X10) {
    var w10 = s3.styles[X10];
    return w10 ? "\x1B[" + s3.colors[w10][0] + "m" + C10 + "\x1B[" + s3.colors[w10][1] + "m" : C10;
  }
  function l3(C10, X10) {
    return C10;
  }
  function u3(C10) {
    var X10 = {};
    return C10.forEach(function(w10, U10) {
      X10[w10] = true;
    }), X10;
  }
  function c3(C10, X10, w10) {
    if (C10.customInspect && X10 && re2(X10.inspect) && // Filter out the util module, it's inspect function is special
    X10.inspect !== t10.inspect && // Also filter out any prototype objects using the circular check.
    !(X10.constructor && X10.constructor.prototype === X10)) {
      var U10 = X10.inspect(w10, C10);
      return _10(U10) || (U10 = c3(C10, U10, w10)), U10;
    }
    var T10 = f3(C10, X10);
    if (T10)
      return T10;
    var F5 = Object.keys(X10), V3 = u3(F5);
    if (C10.showHidden && (F5 = Object.getOwnPropertyNames(X10)), ne(X10) && (F5.indexOf("message") >= 0 || F5.indexOf("description") >= 0))
      return d3(X10);
    if (F5.length === 0) {
      if (re2(X10)) {
        var ie2 = X10.name ? ": " + X10.name : "";
        return C10.stylize("[Function" + ie2 + "]", "special");
      }
      if (N5(X10))
        return C10.stylize(RegExp.prototype.toString.call(X10), "regexp");
      if (H10(X10))
        return C10.stylize(Date.prototype.toString.call(X10), "date");
      if (ne(X10))
        return d3(X10);
    }
    var ce2 = "", E = false, D5 = ["{", "}"];
    if (O10(X10) && (E = true, D5 = ["[", "]"]), re2(X10)) {
      var se = X10.name ? ": " + X10.name : "";
      ce2 = " [Function" + se + "]";
    }
    if (N5(X10) && (ce2 = " " + RegExp.prototype.toString.call(X10)), H10(X10) && (ce2 = " " + Date.prototype.toUTCString.call(X10)), ne(X10) && (ce2 = " " + d3(X10)), F5.length === 0 && (!E || X10.length == 0))
      return D5[0] + ce2 + D5[1];
    if (w10 < 0)
      return N5(X10) ? C10.stylize(RegExp.prototype.toString.call(X10), "regexp") : C10.stylize("[Object]", "special");
    C10.seen.push(X10);
    var ye;
    return E ? ye = p10(C10, X10, w10, V3, F5) : ye = F5.map(function(Ye) {
      return h10(C10, X10, w10, V3, Ye, E);
    }), C10.seen.pop(), m10(ye, ce2, D5);
  }
  function f3(C10, X10) {
    if (q5(X10))
      return C10.stylize("undefined", "undefined");
    if (_10(X10)) {
      var w10 = "'" + JSON.stringify(X10).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return C10.stylize(w10, "string");
    }
    if ($10(X10))
      return C10.stylize("" + X10, "number");
    if (g(X10))
      return C10.stylize("" + X10, "boolean");
    if (v10(X10))
      return C10.stylize("null", "null");
  }
  function d3(C10) {
    return "[" + Error.prototype.toString.call(C10) + "]";
  }
  function p10(C10, X10, w10, U10, T10) {
    for (var F5 = [], V3 = 0, ie2 = X10.length; V3 < ie2; ++V3)
      Ie(X10, String(V3)) ? F5.push(h10(
        C10,
        X10,
        w10,
        U10,
        String(V3),
        true
      )) : F5.push("");
    return T10.forEach(function(ce2) {
      ce2.match(/^\d+$/) || F5.push(h10(
        C10,
        X10,
        w10,
        U10,
        ce2,
        true
      ));
    }), F5;
  }
  function h10(C10, X10, w10, U10, T10, F5) {
    var V3, ie2, ce2;
    if (ce2 = Object.getOwnPropertyDescriptor(X10, T10) || { value: X10[T10] }, ce2.get ? ce2.set ? ie2 = C10.stylize("[Getter/Setter]", "special") : ie2 = C10.stylize("[Getter]", "special") : ce2.set && (ie2 = C10.stylize("[Setter]", "special")), Ie(U10, T10) || (V3 = "[" + T10 + "]"), ie2 || (C10.seen.indexOf(ce2.value) < 0 ? (v10(w10) ? ie2 = c3(C10, ce2.value, null) : ie2 = c3(C10, ce2.value, w10 - 1), ie2.indexOf(`
`) > -1 && (F5 ? ie2 = ie2.split(`
`).map(function(E) {
      return "  " + E;
    }).join(`
`).slice(2) : ie2 = `
` + ie2.split(`
`).map(function(E) {
      return "   " + E;
    }).join(`
`))) : ie2 = C10.stylize("[Circular]", "special")), q5(V3)) {
      if (F5 && T10.match(/^\d+$/))
        return ie2;
      V3 = JSON.stringify("" + T10), V3.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (V3 = V3.slice(1, -1), V3 = C10.stylize(V3, "name")) : (V3 = V3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), V3 = C10.stylize(V3, "string"));
    }
    return V3 + ": " + ie2;
  }
  function m10(C10, X10, w10) {
    var U10 = C10.reduce(function(T10, F5) {
      return F5.indexOf(`
`) >= 0, T10 + F5.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return U10 > 60 ? w10[0] + (X10 === "" ? "" : X10 + `
 `) + " " + C10.join(`,
  `) + " " + w10[1] : w10[0] + X10 + " " + C10.join(", ") + " " + w10[1];
  }
  t10.types = NQ;
  function O10(C10) {
    return Array.isArray(C10);
  }
  t10.isArray = O10;
  function g(C10) {
    return typeof C10 == "boolean";
  }
  t10.isBoolean = g;
  function v10(C10) {
    return C10 === null;
  }
  t10.isNull = v10;
  function S10(C10) {
    return C10 == null;
  }
  t10.isNullOrUndefined = S10;
  function $10(C10) {
    return typeof C10 == "number";
  }
  t10.isNumber = $10;
  function _10(C10) {
    return typeof C10 == "string";
  }
  t10.isString = _10;
  function P10(C10) {
    return typeof C10 == "symbol";
  }
  t10.isSymbol = P10;
  function q5(C10) {
    return C10 === void 0;
  }
  t10.isUndefined = q5;
  function N5(C10) {
    return B5(C10) && pe(C10) === "[object RegExp]";
  }
  t10.isRegExp = N5, t10.types.isRegExp = N5;
  function B5(C10) {
    return typeof C10 == "object" && C10 !== null;
  }
  t10.isObject = B5;
  function H10(C10) {
    return B5(C10) && pe(C10) === "[object Date]";
  }
  t10.isDate = H10, t10.types.isDate = H10;
  function ne(C10) {
    return B5(C10) && (pe(C10) === "[object Error]" || C10 instanceof Error);
  }
  t10.isError = ne, t10.types.isNativeError = ne;
  function re2(C10) {
    return typeof C10 == "function";
  }
  t10.isFunction = re2;
  function fe(C10) {
    return C10 === null || typeof C10 == "boolean" || typeof C10 == "number" || typeof C10 == "string" || typeof C10 == "symbol" || // ES6 symbol
    typeof C10 > "u";
  }
  t10.isPrimitive = fe, t10.isBuffer = tB;
  function pe(C10) {
    return Object.prototype.toString.call(C10);
  }
  function Ee2(C10) {
    return C10 < 10 ? "0" + C10.toString(10) : C10.toString(10);
  }
  var qe = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function _e() {
    var C10 = /* @__PURE__ */ new Date(), X10 = [
      Ee2(C10.getHours()),
      Ee2(C10.getMinutes()),
      Ee2(C10.getSeconds())
    ].join(":");
    return [C10.getDate(), qe[C10.getMonth()], X10].join(" ");
  }
  t10.log = function() {
    console.log("%s - %s", _e(), t10.format.apply(t10, arguments));
  }, t10.inherits = $o, t10._extend = function(C10, X10) {
    if (!X10 || !B5(X10))
      return C10;
    for (var w10 = Object.keys(X10), U10 = w10.length; U10--; )
      C10[w10[U10]] = X10[w10[U10]];
    return C10;
  };
  function Ie(C10, X10) {
    return Object.prototype.hasOwnProperty.call(C10, X10);
  }
  var je2 = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  t10.promisify = function(X10) {
    if (typeof X10 != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (je2 && X10[je2]) {
      var w10 = X10[je2];
      if (typeof w10 != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(w10, je2, {
        value: w10,
        enumerable: false,
        writable: false,
        configurable: true
      }), w10;
    }
    function w10() {
      for (var U10, T10, F5 = new Promise(function(ce2, E) {
        U10 = ce2, T10 = E;
      }), V3 = [], ie2 = 0; ie2 < arguments.length; ie2++)
        V3.push(arguments[ie2]);
      V3.push(function(ce2, E) {
        ce2 ? T10(ce2) : U10(E);
      });
      try {
        X10.apply(this, V3);
      } catch (ce2) {
        T10(ce2);
      }
      return F5;
    }
    return Object.setPrototypeOf(w10, Object.getPrototypeOf(X10)), je2 && Object.defineProperty(w10, je2, {
      value: w10,
      enumerable: false,
      writable: false,
      configurable: true
    }), Object.defineProperties(
      w10,
      e3(X10)
    );
  }, t10.promisify.custom = je2;
  function G(C10, X10) {
    if (!C10) {
      var w10 = new Error("Promise was rejected with a falsy value");
      w10.reason = C10, C10 = w10;
    }
    return X10(C10);
  }
  function Z(C10) {
    if (typeof C10 != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function X10() {
      for (var w10 = [], U10 = 0; U10 < arguments.length; U10++)
        w10.push(arguments[U10]);
      var T10 = w10.pop();
      if (typeof T10 != "function")
        throw new TypeError("The last argument must be of type Function");
      var F5 = this, V3 = function() {
        return T10.apply(F5, arguments);
      };
      C10.apply(this, w10).then(
        function(ie2) {
          $e.process.nextTick(V3.bind(null, null, ie2));
        },
        function(ie2) {
          $e.process.nextTick(G.bind(null, ie2, V3));
        }
      );
    }
    return Object.setPrototypeOf(X10, Object.getPrototypeOf(C10)), Object.defineProperties(
      X10,
      e3(C10)
    ), X10;
  }
  t10.callbackify = Z;
})(yu);
var vm = { exports: {} }, Qf = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
Qf.exports;
(function(t10, e3) {
  (function(r3) {
    var n3 = e3 && !e3.nodeType && e3, i3 = t10 && !t10.nodeType && t10, o3 = typeof yt == "object" && yt;
    (o3.global === o3 || o3.window === o3 || o3.self === o3) && (r3 = o3);
    var s3, a3 = 2147483647, l3 = 36, u3 = 1, c3 = 26, f3 = 38, d3 = 700, p10 = 72, h10 = 128, m10 = "-", O10 = /^xn--/, g = /[^\x20-\x7E]/, v10 = /[\x2E\u3002\uFF0E\uFF61]/g, S10 = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, $10 = l3 - u3, _10 = Math.floor, P10 = String.fromCharCode, q5;
    function N5(G) {
      throw new RangeError(S10[G]);
    }
    function B5(G, Z) {
      for (var C10 = G.length, X10 = []; C10--; )
        X10[C10] = Z(G[C10]);
      return X10;
    }
    function H10(G, Z) {
      var C10 = G.split("@"), X10 = "";
      C10.length > 1 && (X10 = C10[0] + "@", G = C10[1]), G = G.replace(v10, ".");
      var w10 = G.split("."), U10 = B5(w10, Z).join(".");
      return X10 + U10;
    }
    function ne(G) {
      for (var Z = [], C10 = 0, X10 = G.length, w10, U10; C10 < X10; )
        w10 = G.charCodeAt(C10++), w10 >= 55296 && w10 <= 56319 && C10 < X10 ? (U10 = G.charCodeAt(C10++), (U10 & 64512) == 56320 ? Z.push(((w10 & 1023) << 10) + (U10 & 1023) + 65536) : (Z.push(w10), C10--)) : Z.push(w10);
      return Z;
    }
    function re2(G) {
      return B5(G, function(Z) {
        var C10 = "";
        return Z > 65535 && (Z -= 65536, C10 += P10(Z >>> 10 & 1023 | 55296), Z = 56320 | Z & 1023), C10 += P10(Z), C10;
      }).join("");
    }
    function fe(G) {
      return G - 48 < 10 ? G - 22 : G - 65 < 26 ? G - 65 : G - 97 < 26 ? G - 97 : l3;
    }
    function pe(G, Z) {
      return G + 22 + 75 * (G < 26) - ((Z != 0) << 5);
    }
    function Ee2(G, Z, C10) {
      var X10 = 0;
      for (G = C10 ? _10(G / d3) : G >> 1, G += _10(G / Z); G > $10 * c3 >> 1; X10 += l3)
        G = _10(G / $10);
      return _10(X10 + ($10 + 1) * G / (G + f3));
    }
    function qe(G) {
      var Z = [], C10 = G.length, X10, w10 = 0, U10 = h10, T10 = p10, F5, V3, ie2, ce2, E, D5, se, ye, Ye;
      for (F5 = G.lastIndexOf(m10), F5 < 0 && (F5 = 0), V3 = 0; V3 < F5; ++V3)
        G.charCodeAt(V3) >= 128 && N5("not-basic"), Z.push(G.charCodeAt(V3));
      for (ie2 = F5 > 0 ? F5 + 1 : 0; ie2 < C10; ) {
        for (ce2 = w10, E = 1, D5 = l3; ie2 >= C10 && N5("invalid-input"), se = fe(G.charCodeAt(ie2++)), (se >= l3 || se > _10((a3 - w10) / E)) && N5("overflow"), w10 += se * E, ye = D5 <= T10 ? u3 : D5 >= T10 + c3 ? c3 : D5 - T10, !(se < ye); D5 += l3)
          Ye = l3 - ye, E > _10(a3 / Ye) && N5("overflow"), E *= Ye;
        X10 = Z.length + 1, T10 = Ee2(w10 - ce2, X10, ce2 == 0), _10(w10 / X10) > a3 - U10 && N5("overflow"), U10 += _10(w10 / X10), w10 %= X10, Z.splice(w10++, 0, U10);
      }
      return re2(Z);
    }
    function _e(G) {
      var Z, C10, X10, w10, U10, T10, F5, V3, ie2, ce2, E, D5 = [], se, ye, Ye, xe2;
      for (G = ne(G), se = G.length, Z = h10, C10 = 0, U10 = p10, T10 = 0; T10 < se; ++T10)
        E = G[T10], E < 128 && D5.push(P10(E));
      for (X10 = w10 = D5.length, w10 && D5.push(m10); X10 < se; ) {
        for (F5 = a3, T10 = 0; T10 < se; ++T10)
          E = G[T10], E >= Z && E < F5 && (F5 = E);
        for (ye = X10 + 1, F5 - Z > _10((a3 - C10) / ye) && N5("overflow"), C10 += (F5 - Z) * ye, Z = F5, T10 = 0; T10 < se; ++T10)
          if (E = G[T10], E < Z && ++C10 > a3 && N5("overflow"), E == Z) {
            for (V3 = C10, ie2 = l3; ce2 = ie2 <= U10 ? u3 : ie2 >= U10 + c3 ? c3 : ie2 - U10, !(V3 < ce2); ie2 += l3)
              xe2 = V3 - ce2, Ye = l3 - ce2, D5.push(
                P10(pe(ce2 + xe2 % Ye, 0))
              ), V3 = _10(xe2 / Ye);
            D5.push(P10(pe(V3, 0))), U10 = Ee2(C10, ye, X10 == w10), C10 = 0, ++X10;
          }
        ++C10, ++Z;
      }
      return D5.join("");
    }
    function Ie(G) {
      return H10(G, function(Z) {
        return O10.test(Z) ? qe(Z.slice(4).toLowerCase()) : Z;
      });
    }
    function je2(G) {
      return H10(G, function(Z) {
        return g.test(Z) ? "xn--" + _e(Z) : Z;
      });
    }
    if (s3 = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "1.4.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: ne,
        encode: re2
      },
      decode: qe,
      encode: _e,
      toASCII: je2,
      toUnicode: Ie
    }, n3 && i3)
      if (t10.exports == n3)
        i3.exports = s3;
      else
        for (q5 in s3)
          s3.hasOwnProperty(q5) && (n3[q5] = s3[q5]);
    else
      r3.punycode = s3;
  })(yt);
})(Qf, Qf.exports);
var rB = Qf.exports;
const nB = /* @__PURE__ */ lg(rB);
function iB(t10, e3) {
  return Object.prototype.hasOwnProperty.call(t10, e3);
}
var oB = function(t10, e3, r3, n3) {
  e3 = e3 || "&", r3 = r3 || "=";
  var i3 = {};
  if (typeof t10 != "string" || t10.length === 0)
    return i3;
  var o3 = /\+/g;
  t10 = t10.split(e3);
  var s3 = 1e3;
  n3 && typeof n3.maxKeys == "number" && (s3 = n3.maxKeys);
  var a3 = t10.length;
  s3 > 0 && a3 > s3 && (a3 = s3);
  for (var l3 = 0; l3 < a3; ++l3) {
    var u3 = t10[l3].replace(o3, "%20"), c3 = u3.indexOf(r3), f3, d3, p10, h10;
    c3 >= 0 ? (f3 = u3.substr(0, c3), d3 = u3.substr(c3 + 1)) : (f3 = u3, d3 = ""), p10 = decodeURIComponent(f3), h10 = decodeURIComponent(d3), iB(i3, p10) ? sB(i3[p10]) ? i3[p10].push(h10) : i3[p10] = [i3[p10], h10] : i3[p10] = h10;
  }
  return i3;
}, sB = Array.isArray || function(t10) {
  return Object.prototype.toString.call(t10) === "[object Array]";
}, Ja = function(t10) {
  switch (typeof t10) {
    case "string":
      return t10;
    case "boolean":
      return t10 ? "true" : "false";
    case "number":
      return isFinite(t10) ? t10 : "";
    default:
      return "";
  }
}, aB = function(t10, e3, r3, n3) {
  return e3 = e3 || "&", r3 = r3 || "=", t10 === null && (t10 = void 0), typeof t10 == "object" ? FS(uB(t10), function(i3) {
    var o3 = encodeURIComponent(Ja(i3)) + r3;
    return lB(t10[i3]) ? FS(t10[i3], function(s3) {
      return o3 + encodeURIComponent(Ja(s3));
    }).join(e3) : o3 + encodeURIComponent(Ja(t10[i3]));
  }).join(e3) : n3 ? encodeURIComponent(Ja(n3)) + r3 + encodeURIComponent(Ja(t10)) : "";
}, lB = Array.isArray || function(t10) {
  return Object.prototype.toString.call(t10) === "[object Array]";
};
function FS(t10, e3) {
  if (t10.map)
    return t10.map(e3);
  for (var r3 = [], n3 = 0; n3 < t10.length; n3++)
    r3.push(e3(t10[n3], n3));
  return r3;
}
var uB = Object.keys || function(t10) {
  var e3 = [];
  for (var r3 in t10)
    Object.prototype.hasOwnProperty.call(t10, r3) && e3.push(r3);
  return e3;
}, nT, iT, cB = iT = oB, fB = nT = aB;
function dB(t10) {
  return encodeURIComponent(t10);
}
function hB(t10) {
  return decodeURIComponent(t10);
}
var pB = {
  decode: cB,
  encode: fB,
  parse: iT,
  stringify: nT,
  escape: dB,
  unescape: hB
}, OB = {
  isString: function(t10) {
    return typeof t10 == "string";
  },
  isObject: function(t10) {
    return typeof t10 == "object" && t10 !== null;
  },
  isNull: function(t10) {
    return t10 === null;
  },
  isNullOrUndefined: function(t10) {
    return t10 == null;
  }
}, mB = nB, Yn = OB, gB = bu, yB = EB, oT = CB, vB = kB, bB = hn;
function hn() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var SB = /^([a-z0-9.+-]+:)/i, $B = /:[0-9]*$/, wB = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, PB = ["<", ">", '"', "`", " ", "\r", `
`, "	"], _B = ["{", "}", "|", "\\", "^", "`"].concat(PB), bm = ["'"].concat(_B), ZS = ["%", "/", "?", ";", "#"].concat(bm), MS = ["/", "?", "#"], xB = 255, NS = /^[+a-z0-9A-Z_-]{0,63}$/, QB = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, TB = {
  javascript: true,
  "javascript:": true
}, Sm = {
  javascript: true,
  "javascript:": true
}, ta = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
}, $m = pB;
function bu(t10, e3, r3) {
  if (t10 && Yn.isObject(t10) && t10 instanceof hn)
    return t10;
  var n3 = new hn();
  return n3.parse(t10, e3, r3), n3;
}
hn.prototype.parse = function(t10, e3, r3) {
  if (!Yn.isString(t10))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof t10);
  var n3 = t10.indexOf("?"), i3 = n3 !== -1 && n3 < t10.indexOf("#") ? "?" : "#", o3 = t10.split(i3), s3 = /\\/g;
  o3[0] = o3[0].replace(s3, "/"), t10 = o3.join(i3);
  var a3 = t10;
  if (a3 = a3.trim(), !r3 && t10.split("#").length === 1) {
    var l3 = wB.exec(a3);
    if (l3)
      return this.path = a3, this.href = a3, this.pathname = l3[1], l3[2] ? (this.search = l3[2], e3 ? this.query = $m.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : e3 && (this.search = "", this.query = {}), this;
  }
  var u3 = SB.exec(a3);
  if (u3) {
    u3 = u3[0];
    var c3 = u3.toLowerCase();
    this.protocol = c3, a3 = a3.substr(u3.length);
  }
  if (r3 || u3 || a3.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var f3 = a3.substr(0, 2) === "//";
    f3 && !(u3 && Sm[u3]) && (a3 = a3.substr(2), this.slashes = true);
  }
  if (!Sm[u3] && (f3 || u3 && !ta[u3])) {
    for (var d3 = -1, p10 = 0; p10 < MS.length; p10++) {
      var h10 = a3.indexOf(MS[p10]);
      h10 !== -1 && (d3 === -1 || h10 < d3) && (d3 = h10);
    }
    var m10, O10;
    d3 === -1 ? O10 = a3.lastIndexOf("@") : O10 = a3.lastIndexOf("@", d3), O10 !== -1 && (m10 = a3.slice(0, O10), a3 = a3.slice(O10 + 1), this.auth = decodeURIComponent(m10)), d3 = -1;
    for (var p10 = 0; p10 < ZS.length; p10++) {
      var h10 = a3.indexOf(ZS[p10]);
      h10 !== -1 && (d3 === -1 || h10 < d3) && (d3 = h10);
    }
    d3 === -1 && (d3 = a3.length), this.host = a3.slice(0, d3), a3 = a3.slice(d3), this.parseHost(), this.hostname = this.hostname || "";
    var g = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!g)
      for (var v10 = this.hostname.split(/\./), p10 = 0, S10 = v10.length; p10 < S10; p10++) {
        var $10 = v10[p10];
        if ($10 && !$10.match(NS)) {
          for (var _10 = "", P10 = 0, q5 = $10.length; P10 < q5; P10++)
            $10.charCodeAt(P10) > 127 ? _10 += "x" : _10 += $10[P10];
          if (!_10.match(NS)) {
            var N5 = v10.slice(0, p10), B5 = v10.slice(p10 + 1), H10 = $10.match(QB);
            H10 && (N5.push(H10[1]), B5.unshift(H10[2])), B5.length && (a3 = "/" + B5.join(".") + a3), this.hostname = N5.join(".");
            break;
          }
        }
      }
    this.hostname.length > xB ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), g || (this.hostname = mB.toASCII(this.hostname));
    var ne = this.port ? ":" + this.port : "", re2 = this.hostname || "";
    this.host = re2 + ne, this.href += this.host, g && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), a3[0] !== "/" && (a3 = "/" + a3));
  }
  if (!TB[c3])
    for (var p10 = 0, S10 = bm.length; p10 < S10; p10++) {
      var fe = bm[p10];
      if (a3.indexOf(fe) !== -1) {
        var pe = encodeURIComponent(fe);
        pe === fe && (pe = escape(fe)), a3 = a3.split(fe).join(pe);
      }
    }
  var Ee2 = a3.indexOf("#");
  Ee2 !== -1 && (this.hash = a3.substr(Ee2), a3 = a3.slice(0, Ee2));
  var qe = a3.indexOf("?");
  if (qe !== -1 ? (this.search = a3.substr(qe), this.query = a3.substr(qe + 1), e3 && (this.query = $m.parse(this.query)), a3 = a3.slice(0, qe)) : e3 && (this.search = "", this.query = {}), a3 && (this.pathname = a3), ta[c3] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var ne = this.pathname || "", _e = this.search || "";
    this.path = ne + _e;
  }
  return this.href = this.format(), this;
};
function kB(t10) {
  return Yn.isString(t10) && (t10 = bu(t10)), t10 instanceof hn ? t10.format() : hn.prototype.format.call(t10);
}
hn.prototype.format = function() {
  var t10 = this.auth || "";
  t10 && (t10 = encodeURIComponent(t10), t10 = t10.replace(/%3A/i, ":"), t10 += "@");
  var e3 = this.protocol || "", r3 = this.pathname || "", n3 = this.hash || "", i3 = false, o3 = "";
  this.host ? i3 = t10 + this.host : this.hostname && (i3 = t10 + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i3 += ":" + this.port)), this.query && Yn.isObject(this.query) && Object.keys(this.query).length && (o3 = $m.stringify(this.query));
  var s3 = this.search || o3 && "?" + o3 || "";
  return e3 && e3.substr(-1) !== ":" && (e3 += ":"), this.slashes || (!e3 || ta[e3]) && i3 !== false ? (i3 = "//" + (i3 || ""), r3 && r3.charAt(0) !== "/" && (r3 = "/" + r3)) : i3 || (i3 = ""), n3 && n3.charAt(0) !== "#" && (n3 = "#" + n3), s3 && s3.charAt(0) !== "?" && (s3 = "?" + s3), r3 = r3.replace(/[?#]/g, function(a3) {
    return encodeURIComponent(a3);
  }), s3 = s3.replace("#", "%23"), e3 + i3 + r3 + s3 + n3;
};
function EB(t10, e3) {
  return bu(t10, false, true).resolve(e3);
}
hn.prototype.resolve = function(t10) {
  return this.resolveObject(bu(t10, false, true)).format();
};
function CB(t10, e3) {
  return t10 ? bu(t10, false, true).resolveObject(e3) : e3;
}
hn.prototype.resolveObject = function(t10) {
  if (Yn.isString(t10)) {
    var e3 = new hn();
    e3.parse(t10, false, true), t10 = e3;
  }
  for (var r3 = new hn(), n3 = Object.keys(this), i3 = 0; i3 < n3.length; i3++) {
    var o3 = n3[i3];
    r3[o3] = this[o3];
  }
  if (r3.hash = t10.hash, t10.href === "")
    return r3.href = r3.format(), r3;
  if (t10.slashes && !t10.protocol) {
    for (var s3 = Object.keys(t10), a3 = 0; a3 < s3.length; a3++) {
      var l3 = s3[a3];
      l3 !== "protocol" && (r3[l3] = t10[l3]);
    }
    return ta[r3.protocol] && r3.hostname && !r3.pathname && (r3.path = r3.pathname = "/"), r3.href = r3.format(), r3;
  }
  if (t10.protocol && t10.protocol !== r3.protocol) {
    if (!ta[t10.protocol]) {
      for (var u3 = Object.keys(t10), c3 = 0; c3 < u3.length; c3++) {
        var f3 = u3[c3];
        r3[f3] = t10[f3];
      }
      return r3.href = r3.format(), r3;
    }
    if (r3.protocol = t10.protocol, !t10.host && !Sm[t10.protocol]) {
      for (var S10 = (t10.pathname || "").split("/"); S10.length && !(t10.host = S10.shift()); )
        ;
      t10.host || (t10.host = ""), t10.hostname || (t10.hostname = ""), S10[0] !== "" && S10.unshift(""), S10.length < 2 && S10.unshift(""), r3.pathname = S10.join("/");
    } else
      r3.pathname = t10.pathname;
    if (r3.search = t10.search, r3.query = t10.query, r3.host = t10.host || "", r3.auth = t10.auth, r3.hostname = t10.hostname || t10.host, r3.port = t10.port, r3.pathname || r3.search) {
      var d3 = r3.pathname || "", p10 = r3.search || "";
      r3.path = d3 + p10;
    }
    return r3.slashes = r3.slashes || t10.slashes, r3.href = r3.format(), r3;
  }
  var h10 = r3.pathname && r3.pathname.charAt(0) === "/", m10 = t10.host || t10.pathname && t10.pathname.charAt(0) === "/", O10 = m10 || h10 || r3.host && t10.pathname, g = O10, v10 = r3.pathname && r3.pathname.split("/") || [], S10 = t10.pathname && t10.pathname.split("/") || [], $10 = r3.protocol && !ta[r3.protocol];
  if ($10 && (r3.hostname = "", r3.port = null, r3.host && (v10[0] === "" ? v10[0] = r3.host : v10.unshift(r3.host)), r3.host = "", t10.protocol && (t10.hostname = null, t10.port = null, t10.host && (S10[0] === "" ? S10[0] = t10.host : S10.unshift(t10.host)), t10.host = null), O10 = O10 && (S10[0] === "" || v10[0] === "")), m10)
    r3.host = t10.host || t10.host === "" ? t10.host : r3.host, r3.hostname = t10.hostname || t10.hostname === "" ? t10.hostname : r3.hostname, r3.search = t10.search, r3.query = t10.query, v10 = S10;
  else if (S10.length)
    v10 || (v10 = []), v10.pop(), v10 = v10.concat(S10), r3.search = t10.search, r3.query = t10.query;
  else if (!Yn.isNullOrUndefined(t10.search)) {
    if ($10) {
      r3.hostname = r3.host = v10.shift();
      var _10 = r3.host && r3.host.indexOf("@") > 0 ? r3.host.split("@") : false;
      _10 && (r3.auth = _10.shift(), r3.host = r3.hostname = _10.shift());
    }
    return r3.search = t10.search, r3.query = t10.query, (!Yn.isNull(r3.pathname) || !Yn.isNull(r3.search)) && (r3.path = (r3.pathname ? r3.pathname : "") + (r3.search ? r3.search : "")), r3.href = r3.format(), r3;
  }
  if (!v10.length)
    return r3.pathname = null, r3.search ? r3.path = "/" + r3.search : r3.path = null, r3.href = r3.format(), r3;
  for (var P10 = v10.slice(-1)[0], q5 = (r3.host || t10.host || v10.length > 1) && (P10 === "." || P10 === "..") || P10 === "", N5 = 0, B5 = v10.length; B5 >= 0; B5--)
    P10 = v10[B5], P10 === "." ? v10.splice(B5, 1) : P10 === ".." ? (v10.splice(B5, 1), N5++) : N5 && (v10.splice(B5, 1), N5--);
  if (!O10 && !g)
    for (; N5--; N5)
      v10.unshift("..");
  O10 && v10[0] !== "" && (!v10[0] || v10[0].charAt(0) !== "/") && v10.unshift(""), q5 && v10.join("/").substr(-1) !== "/" && v10.push("");
  var H10 = v10[0] === "" || v10[0] && v10[0].charAt(0) === "/";
  if ($10) {
    r3.hostname = r3.host = H10 ? "" : v10.length ? v10.shift() : "";
    var _10 = r3.host && r3.host.indexOf("@") > 0 ? r3.host.split("@") : false;
    _10 && (r3.auth = _10.shift(), r3.host = r3.hostname = _10.shift());
  }
  return O10 = O10 || r3.host && v10.length, O10 && !H10 && v10.unshift(""), v10.length ? r3.pathname = v10.join("/") : (r3.pathname = null, r3.path = null), (!Yn.isNull(r3.pathname) || !Yn.isNull(r3.search)) && (r3.path = (r3.pathname ? r3.pathname : "") + (r3.search ? r3.search : "")), r3.auth = t10.auth || r3.auth, r3.slashes = r3.slashes || t10.slashes, r3.href = r3.format(), r3;
};
hn.prototype.parseHost = function() {
  var t10 = this.host, e3 = $B.exec(t10);
  e3 && (e3 = e3[0], e3 !== ":" && (this.port = e3.substr(1)), t10 = t10.substr(0, t10.length - e3.length)), t10 && (this.hostname = t10);
};
function RB(t10, e3) {
  for (var r3 = 0, n3 = t10.length - 1; n3 >= 0; n3--) {
    var i3 = t10[n3];
    i3 === "." ? t10.splice(n3, 1) : i3 === ".." ? (t10.splice(n3, 1), r3++) : r3 && (t10.splice(n3, 1), r3--);
  }
  if (e3)
    for (; r3--; r3)
      t10.unshift("..");
  return t10;
}
function AB() {
  for (var t10 = "", e3 = false, r3 = arguments.length - 1; r3 >= -1 && !e3; r3--) {
    var n3 = r3 >= 0 ? arguments[r3] : "/";
    if (typeof n3 != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!n3)
      continue;
    t10 = n3 + "/" + t10, e3 = n3.charAt(0) === "/";
  }
  return t10 = RB(XB(t10.split("/"), function(i3) {
    return !!i3;
  }), !e3).join("/"), (e3 ? "/" : "") + t10 || ".";
}
function XB(t10, e3) {
  if (t10.filter)
    return t10.filter(e3);
  for (var r3 = [], n3 = 0; n3 < t10.length; n3++)
    e3(t10[n3], n3, t10) && r3.push(t10[n3]);
  return r3;
}
var sT = function(t10) {
  function e3() {
    var n3 = this || self;
    return delete t10.prototype.__magic__, n3;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return e3();
  t10.defineProperty(t10.prototype, "__magic__", {
    configurable: true,
    get: e3
  });
  var r3 = __magic__;
  return r3;
}(Object), qB = (
  /** @type {formatImport}*/
  vB
), aT = (
  /** @type {parseImport}*/
  gB
), lT = (
  /** @type {resolveImport}*/
  yB
), uT = (
  /** @type {UrlImport}*/
  bB
), mo = sT.URL, cT = sT.URLSearchParams, DB = /%/g, jB = /\\/g, UB = /\n/g, IB = /\r/g, FB = /\t/g, ZB = 47;
function MB(t10) {
  var e3 = (
    /** @type {URL|null} */
    t10 ?? null
  );
  return !!(e3 !== null && (e3 != null && e3.href) && (e3 != null && e3.origin));
}
function NB(t10) {
  if (t10.hostname !== "")
    throw new TypeError('File URL host must be "localhost" or empty on browser');
  for (var e3 = t10.pathname, r3 = 0; r3 < e3.length; r3++)
    if (e3[r3] === "%") {
      var n3 = e3.codePointAt(r3 + 2) | 32;
      if (e3[r3 + 1] === "2" && n3 === 102)
        throw new TypeError("File URL path must not include encoded / characters");
    }
  return decodeURIComponent(e3);
}
function WB(t10) {
  return t10.includes("%") && (t10 = t10.replace(DB, "%25")), t10.includes("\\") && (t10 = t10.replace(jB, "%5C")), t10.includes(`
`) && (t10 = t10.replace(UB, "%0A")), t10.includes("\r") && (t10 = t10.replace(IB, "%0D")), t10.includes("	") && (t10 = t10.replace(FB, "%09")), t10;
}
var fT = (
  /**
   * @type {domainToASCII}
   */
  function(e3) {
    if (typeof e3 > "u")
      throw new TypeError('The "domain" argument must be specified');
    return new mo("http://" + e3).hostname;
  }
), dT = (
  /**
   * @type {domainToUnicode}
   */
  function(e3) {
    if (typeof e3 > "u")
      throw new TypeError('The "domain" argument must be specified');
    return new mo("http://" + e3).hostname;
  }
), hT = (
  /**
   * @type {(url: string) => URL}
   */
  function(e3) {
    var r3 = new mo("file://"), n3 = AB(e3), i3 = e3.charCodeAt(e3.length - 1);
    return i3 === ZB && n3[n3.length - 1] !== "/" && (n3 += "/"), r3.pathname = WB(n3), r3;
  }
), pT = (
  /**
   * @type {fileURLToPath & ((path: string | URL) => string)}
   */
  function(e3) {
    if (!MB(e3) && typeof e3 != "string")
      throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof e3 + " (" + e3 + ")");
    var r3 = new mo(e3);
    if (r3.protocol !== "file:")
      throw new TypeError("The URL must be of scheme file");
    return NB(r3);
  }
), OT = (
  /**
   * @type {(
   *   ((urlObject: URL, options?: URLFormatOptions) => string) &
   *   ((urlObject: UrlObject | string, options?: never) => string)
   * )}
   */
  function(e3, r3) {
    var n3, i3, o3;
    if (r3 === void 0 && (r3 = {}), !(e3 instanceof mo))
      return qB(e3);
    if (typeof r3 != "object" || r3 === null)
      throw new TypeError('The "options" argument must be of type object.');
    var s3 = (n3 = r3.auth) != null ? n3 : true, a3 = (i3 = r3.fragment) != null ? i3 : true, l3 = (o3 = r3.search) != null ? o3 : true, u3 = new mo(e3.toString());
    return s3 || (u3.username = "", u3.password = ""), a3 || (u3.hash = ""), l3 || (u3.search = ""), u3.toString();
  }
), VB = {
  format: OT,
  parse: aT,
  resolve: lT,
  resolveObject: oT,
  Url: uT,
  URL: mo,
  URLSearchParams: cT,
  domainToASCII: fT,
  domainToUnicode: dT,
  pathToFileURL: hT,
  fileURLToPath: pT
};
const YB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  URL: mo,
  URLSearchParams: cT,
  Url: uT,
  default: VB,
  domainToASCII: fT,
  domainToUnicode: dT,
  fileURLToPath: pT,
  format: OT,
  parse: aT,
  pathToFileURL: hT,
  resolve: lT,
  resolveObject: oT
}, Symbol.toStringTag, { value: "Module" })), Tf = /* @__PURE__ */ ug(YB);
(function(t10, e3) {
  let r3 = /^win/.test($e.process.platform), n3 = /\//g, i3 = /^(\w{2,}):\/\//i, o3 = t10.exports, s3 = /~1/g, a3 = /~0/g, l3 = [
    /\?/g,
    "%3F",
    /\#/g,
    "%23"
  ], u3 = [
    /\%23/g,
    "#",
    /\%24/g,
    "$",
    /\%26/g,
    "&",
    /\%2C/g,
    ",",
    /\%40/g,
    "@"
  ];
  e3.parse = Tf.parse, e3.resolve = Tf.resolve, e3.cwd = function() {
    if ($e.process.browser)
      return location.href;
    let f3 = $e.process.cwd(), d3 = f3.slice(-1);
    return d3 === "/" || d3 === "\\" ? f3 : f3 + "/";
  }, e3.getProtocol = function(f3) {
    let d3 = i3.exec(f3);
    if (d3)
      return d3[1].toLowerCase();
  }, e3.getExtension = function(f3) {
    let d3 = f3.lastIndexOf(".");
    return d3 >= 0 ? f3.substr(d3).toLowerCase() : "";
  }, e3.getHash = function(f3) {
    let d3 = f3.indexOf("#");
    return d3 >= 0 ? f3.substr(d3) : "#";
  }, e3.stripHash = function(f3) {
    let d3 = f3.indexOf("#");
    return d3 >= 0 && (f3 = f3.substr(0, d3)), f3;
  }, e3.isHttp = function(f3) {
    let d3 = o3.getProtocol(f3);
    return d3 === "http" || d3 === "https" ? true : d3 === void 0 ? $e.process.browser : false;
  }, e3.isFileSystemPath = function(f3) {
    if ($e.process.browser)
      return false;
    let d3 = o3.getProtocol(f3);
    return d3 === void 0 || d3 === "file";
  }, e3.fromFileSystemPath = function(f3) {
    r3 && (f3 = f3.replace(/\\/g, "/")), f3 = encodeURI(f3);
    for (let d3 = 0; d3 < l3.length; d3 += 2)
      f3 = f3.replace(l3[d3], l3[d3 + 1]);
    return f3;
  }, e3.toFileSystemPath = function(f3, d3) {
    f3 = decodeURI(f3);
    for (let h10 = 0; h10 < u3.length; h10 += 2)
      f3 = f3.replace(u3[h10], u3[h10 + 1]);
    let p10 = f3.substr(0, 7).toLowerCase() === "file://";
    return p10 && (f3 = f3[7] === "/" ? f3.substr(8) : f3.substr(7), r3 && f3[1] === "/" && (f3 = f3[0] + ":" + f3.substr(1)), d3 ? f3 = "file:///" + f3 : (p10 = false, f3 = r3 ? f3 : "/" + f3)), r3 && !p10 && (f3 = f3.replace(n3, "\\"), f3.substr(1, 2) === ":\\" && (f3 = f3[0].toUpperCase() + f3.substr(1))), f3;
  }, e3.safePointerToPath = function(f3) {
    return f3.length <= 1 || f3[0] !== "#" || f3[1] !== "/" ? [] : f3.slice(2).split("/").map((d3) => decodeURIComponent(d3).replace(s3, "/").replace(a3, "~"));
  };
})(vm, vm.exports);
var mn = vm.exports;
const mT = yu, LB = mn;
gs.format = mT.format;
gs.inherits = mT.inherits;
gs.swaggerParamRegExp = /\{([^/}]+)}/g;
const BB = ["get", "post", "put", "delete", "patch", "options", "head", "trace"];
function np(t10, e3) {
  if (t10.url && t10.url.startsWith("/")) {
    const r3 = LB.parse(e3), n3 = r3.protocol + "//" + r3.hostname + t10.url;
    return t10.url = n3, t10;
  }
}
function zB(t10, e3) {
  t10.openapi && e3 && (e3.startsWith("http:") || e3.startsWith("https:")) && (t10.servers && t10.servers.map((r3) => np(r3, e3)), ["paths", "webhooks"].forEach((r3) => {
    Object.keys(t10[r3] || []).forEach((n3) => {
      const i3 = t10[r3][n3];
      Object.keys(i3).forEach((o3) => {
        o3 === "servers" ? i3[o3].map((s3) => np(s3, e3)) : BB.includes(o3) && i3[o3].servers && i3[o3].servers.map((s3) => np(s3, e3));
      });
    });
  }));
}
gs.fixOasRelativeServers = zB;
const HB = false, GB = /\r?\n/, KB = /\bono[ @]/;
function JB(t10) {
  return !!(t10 && t10.configurable && typeof t10.get == "function");
}
function ez(t10) {
  return !!// If there is no stack property, then it's writable, since assigning it will create it
  (!t10 || t10.writable || typeof t10.set == "function");
}
function gT(t10, e3) {
  let r3 = yT(t10.stack), n3 = e3 ? e3.stack : void 0;
  return r3 && n3 ? r3 + `

` + n3 : r3 || n3;
}
function tz(t10, e3, r3) {
  r3 ? Object.defineProperty(e3, "stack", {
    get: () => {
      let n3 = t10.get.apply(e3);
      return gT({ stack: n3 }, r3);
    },
    enumerable: false,
    configurable: true
  }) : rz(e3, t10);
}
function yT(t10) {
  if (t10) {
    let e3 = t10.split(GB), r3;
    for (let n3 = 0; n3 < e3.length; n3++) {
      let i3 = e3[n3];
      if (KB.test(i3))
        r3 === void 0 && (r3 = n3);
      else if (r3 !== void 0) {
        e3.splice(r3, n3 - r3);
        break;
      }
    }
    if (e3.length > 0)
      return e3.join(`
`);
  }
  return t10;
}
function rz(t10, e3) {
  Object.defineProperty(t10, "stack", {
    get: () => yT(e3.get.apply(t10)),
    enumerable: false,
    configurable: true
  });
}
const nz = ["function", "symbol", "undefined"], iz = ["constructor", "prototype", "__proto__"], oz = Object.getPrototypeOf({});
function vT() {
  let t10 = {}, e3 = this;
  for (let r3 of bT(e3))
    if (typeof r3 == "string") {
      let n3 = e3[r3], i3 = typeof n3;
      nz.includes(i3) || (t10[r3] = n3);
    }
  return t10;
}
function bT(t10, e3 = []) {
  let r3 = [];
  for (; t10 && t10 !== oz; )
    r3 = r3.concat(Object.getOwnPropertyNames(t10), Object.getOwnPropertySymbols(t10)), t10 = Object.getPrototypeOf(t10);
  let n3 = new Set(r3);
  for (let i3 of e3.concat(iz))
    n3.delete(i3);
  return n3;
}
const sz = ["name", "message", "stack"];
function Xc(t10, e3, r3) {
  let n3 = t10;
  return az(n3, e3), e3 && typeof e3 == "object" && lz(n3, e3), n3.toJSON = vT, r3 && typeof r3 == "object" && Object.assign(n3, r3), n3;
}
function az(t10, e3) {
  let r3 = Object.getOwnPropertyDescriptor(t10, "stack");
  JB(r3) ? tz(r3, t10, e3) : ez(r3) && (t10.stack = gT(t10, e3));
}
function lz(t10, e3) {
  let r3 = bT(e3, sz), n3 = t10, i3 = e3;
  for (let o3 of r3)
    if (n3[o3] === void 0)
      try {
        n3[o3] = i3[o3];
      } catch {
      }
}
function uz(t10) {
  return t10 = t10 || {}, {
    concatMessages: t10.concatMessages === void 0 ? true : !!t10.concatMessages,
    format: t10.format === void 0 ? HB : typeof t10.format == "function" ? t10.format : false
  };
}
function cz(t10, e3) {
  let r3, n3, i3, o3 = "";
  return typeof t10[0] == "string" ? i3 = t10 : typeof t10[1] == "string" ? (t10[0] instanceof Error ? r3 = t10[0] : n3 = t10[0], i3 = t10.slice(1)) : (r3 = t10[0], n3 = t10[1], i3 = t10.slice(2)), i3.length > 0 && (e3.format ? o3 = e3.format.apply(void 0, i3) : o3 = i3.join(" ")), e3.concatMessages && r3 && r3.message && (o3 += (o3 ? ` 
` : "") + r3.message), { originalError: r3, props: n3, message: o3 };
}
const wo = v0;
function v0(t10, e3) {
  e3 = uz(e3);
  function r3(...n3) {
    let { originalError: i3, props: o3, message: s3 } = cz(n3, e3), a3 = new t10(s3);
    return Xc(a3, i3, o3);
  }
  return r3[Symbol.species] = t10, r3;
}
v0.toJSON = function(e3) {
  return vT.call(e3);
};
v0.extend = function(e3, r3, n3) {
  return n3 || r3 instanceof Error ? Xc(e3, r3, n3) : r3 ? Xc(e3, void 0, r3) : Xc(e3);
};
const WS = ci;
ci.error = new wo(Error);
ci.eval = new wo(EvalError);
ci.range = new wo(RangeError);
ci.reference = new wo(ReferenceError);
ci.syntax = new wo(SyntaxError);
ci.type = new wo(TypeError);
ci.uri = new wo(URIError);
const fz = ci;
function ci(...t10) {
  let e3 = t10[0];
  if (typeof e3 == "object" && typeof e3.name == "string") {
    for (let r3 of Object.values(fz))
      if (typeof r3 == "function" && r3.name === "ono") {
        let n3 = r3[Symbol.species];
        if (n3 && n3 !== Error && (e3 instanceof n3 || e3.name === n3.name))
          return r3.apply(void 0, t10);
      }
  }
  return ci.error.apply(void 0, t10);
}
typeof module == "object" && typeof module.exports == "object" && (module.exports.default = module.exports.default || {}, module.exports = Object.assign(module.exports.default, module.exports));
const dz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Ono: wo,
  default: WS,
  ono: WS
}, Symbol.toStringTag, { value: "Module" })), fi = /* @__PURE__ */ ug(dz);
var wm = { exports: {} }, ra = {}, kn = {}, ya = {}, Su = {}, Le = {}, Jl = {};
(function(t10) {
  Object.defineProperty(t10, "__esModule", { value: true }), t10.regexpCode = t10.getEsmExportName = t10.getProperty = t10.safeStringify = t10.stringify = t10.strConcat = t10.addCodeArg = t10.str = t10._ = t10.nil = t10._Code = t10.Name = t10.IDENTIFIER = t10._CodeOrName = void 0;
  class e3 {
  }
  t10._CodeOrName = e3, t10.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r3 extends e3 {
    constructor(v10) {
      if (super(), !t10.IDENTIFIER.test(v10))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = v10;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  t10.Name = r3;
  class n3 extends e3 {
    constructor(v10) {
      super(), this._items = typeof v10 == "string" ? [v10] : v10;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const v10 = this._items[0];
      return v10 === "" || v10 === '""';
    }
    get str() {
      var v10;
      return (v10 = this._str) !== null && v10 !== void 0 ? v10 : this._str = this._items.reduce((S10, $10) => `${S10}${$10}`, "");
    }
    get names() {
      var v10;
      return (v10 = this._names) !== null && v10 !== void 0 ? v10 : this._names = this._items.reduce((S10, $10) => ($10 instanceof r3 && (S10[$10.str] = (S10[$10.str] || 0) + 1), S10), {});
    }
  }
  t10._Code = n3, t10.nil = new n3("");
  function i3(g, ...v10) {
    const S10 = [g[0]];
    let $10 = 0;
    for (; $10 < v10.length; )
      a3(S10, v10[$10]), S10.push(g[++$10]);
    return new n3(S10);
  }
  t10._ = i3;
  const o3 = new n3("+");
  function s3(g, ...v10) {
    const S10 = [p10(g[0])];
    let $10 = 0;
    for (; $10 < v10.length; )
      S10.push(o3), a3(S10, v10[$10]), S10.push(o3, p10(g[++$10]));
    return l3(S10), new n3(S10);
  }
  t10.str = s3;
  function a3(g, v10) {
    v10 instanceof n3 ? g.push(...v10._items) : v10 instanceof r3 ? g.push(v10) : g.push(f3(v10));
  }
  t10.addCodeArg = a3;
  function l3(g) {
    let v10 = 1;
    for (; v10 < g.length - 1; ) {
      if (g[v10] === o3) {
        const S10 = u3(g[v10 - 1], g[v10 + 1]);
        if (S10 !== void 0) {
          g.splice(v10 - 1, 3, S10);
          continue;
        }
        g[v10++] = "+";
      }
      v10++;
    }
  }
  function u3(g, v10) {
    if (v10 === '""')
      return g;
    if (g === '""')
      return v10;
    if (typeof g == "string")
      return v10 instanceof r3 || g[g.length - 1] !== '"' ? void 0 : typeof v10 != "string" ? `${g.slice(0, -1)}${v10}"` : v10[0] === '"' ? g.slice(0, -1) + v10.slice(1) : void 0;
    if (typeof v10 == "string" && v10[0] === '"' && !(g instanceof r3))
      return `"${g}${v10.slice(1)}`;
  }
  function c3(g, v10) {
    return v10.emptyStr() ? g : g.emptyStr() ? v10 : s3`${g}${v10}`;
  }
  t10.strConcat = c3;
  function f3(g) {
    return typeof g == "number" || typeof g == "boolean" || g === null ? g : p10(Array.isArray(g) ? g.join(",") : g);
  }
  function d3(g) {
    return new n3(p10(g));
  }
  t10.stringify = d3;
  function p10(g) {
    return JSON.stringify(g).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  t10.safeStringify = p10;
  function h10(g) {
    return typeof g == "string" && t10.IDENTIFIER.test(g) ? new n3(`.${g}`) : i3`[${g}]`;
  }
  t10.getProperty = h10;
  function m10(g) {
    if (typeof g == "string" && t10.IDENTIFIER.test(g))
      return new n3(`${g}`);
    throw new Error(`CodeGen: invalid export name: ${g}, use explicit $id name mapping`);
  }
  t10.getEsmExportName = m10;
  function O10(g) {
    return new n3(g.toString());
  }
  t10.regexpCode = O10;
})(Jl);
var Pm = {};
(function(t10) {
  Object.defineProperty(t10, "__esModule", { value: true }), t10.ValueScope = t10.ValueScopeName = t10.Scope = t10.varKinds = t10.UsedValueState = void 0;
  const e3 = Jl;
  class r3 extends Error {
    constructor(u3) {
      super(`CodeGen: "code" for ${u3} not defined`), this.value = u3.value;
    }
  }
  var n3;
  (function(l3) {
    l3[l3.Started = 0] = "Started", l3[l3.Completed = 1] = "Completed";
  })(n3 = t10.UsedValueState || (t10.UsedValueState = {})), t10.varKinds = {
    const: new e3.Name("const"),
    let: new e3.Name("let"),
    var: new e3.Name("var")
  };
  class i3 {
    constructor({ prefixes: u3, parent: c3 } = {}) {
      this._names = {}, this._prefixes = u3, this._parent = c3;
    }
    toName(u3) {
      return u3 instanceof e3.Name ? u3 : this.name(u3);
    }
    name(u3) {
      return new e3.Name(this._newName(u3));
    }
    _newName(u3) {
      const c3 = this._names[u3] || this._nameGroup(u3);
      return `${u3}${c3.index++}`;
    }
    _nameGroup(u3) {
      var c3, f3;
      if (!((f3 = (c3 = this._parent) === null || c3 === void 0 ? void 0 : c3._prefixes) === null || f3 === void 0) && f3.has(u3) || this._prefixes && !this._prefixes.has(u3))
        throw new Error(`CodeGen: prefix "${u3}" is not allowed in this scope`);
      return this._names[u3] = { prefix: u3, index: 0 };
    }
  }
  t10.Scope = i3;
  class o3 extends e3.Name {
    constructor(u3, c3) {
      super(c3), this.prefix = u3;
    }
    setValue(u3, { property: c3, itemIndex: f3 }) {
      this.value = u3, this.scopePath = (0, e3._)`.${new e3.Name(c3)}[${f3}]`;
    }
  }
  t10.ValueScopeName = o3;
  const s3 = (0, e3._)`\n`;
  class a3 extends i3 {
    constructor(u3) {
      super(u3), this._values = {}, this._scope = u3.scope, this.opts = { ...u3, _n: u3.lines ? s3 : e3.nil };
    }
    get() {
      return this._scope;
    }
    name(u3) {
      return new o3(u3, this._newName(u3));
    }
    value(u3, c3) {
      var f3;
      if (c3.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const d3 = this.toName(u3), { prefix: p10 } = d3, h10 = (f3 = c3.key) !== null && f3 !== void 0 ? f3 : c3.ref;
      let m10 = this._values[p10];
      if (m10) {
        const v10 = m10.get(h10);
        if (v10)
          return v10;
      } else
        m10 = this._values[p10] = /* @__PURE__ */ new Map();
      m10.set(h10, d3);
      const O10 = this._scope[p10] || (this._scope[p10] = []), g = O10.length;
      return O10[g] = c3.ref, d3.setValue(c3, { property: p10, itemIndex: g }), d3;
    }
    getValue(u3, c3) {
      const f3 = this._values[u3];
      if (f3)
        return f3.get(c3);
    }
    scopeRefs(u3, c3 = this._values) {
      return this._reduceValues(c3, (f3) => {
        if (f3.scopePath === void 0)
          throw new Error(`CodeGen: name "${f3}" has no value`);
        return (0, e3._)`${u3}${f3.scopePath}`;
      });
    }
    scopeCode(u3 = this._values, c3, f3) {
      return this._reduceValues(u3, (d3) => {
        if (d3.value === void 0)
          throw new Error(`CodeGen: name "${d3}" has no value`);
        return d3.value.code;
      }, c3, f3);
    }
    _reduceValues(u3, c3, f3 = {}, d3) {
      let p10 = e3.nil;
      for (const h10 in u3) {
        const m10 = u3[h10];
        if (!m10)
          continue;
        const O10 = f3[h10] = f3[h10] || /* @__PURE__ */ new Map();
        m10.forEach((g) => {
          if (O10.has(g))
            return;
          O10.set(g, n3.Started);
          let v10 = c3(g);
          if (v10) {
            const S10 = this.opts.es5 ? t10.varKinds.var : t10.varKinds.const;
            p10 = (0, e3._)`${p10}${S10} ${g} = ${v10};${this.opts._n}`;
          } else if (v10 = d3 == null ? void 0 : d3(g))
            p10 = (0, e3._)`${p10}${v10}${this.opts._n}`;
          else
            throw new r3(g);
          O10.set(g, n3.Completed);
        });
      }
      return p10;
    }
  }
  t10.ValueScope = a3;
})(Pm);
(function(t10) {
  Object.defineProperty(t10, "__esModule", { value: true }), t10.or = t10.and = t10.not = t10.CodeGen = t10.operators = t10.varKinds = t10.ValueScopeName = t10.ValueScope = t10.Scope = t10.Name = t10.regexpCode = t10.stringify = t10.getProperty = t10.nil = t10.strConcat = t10.str = t10._ = void 0;
  const e3 = Jl, r3 = Pm;
  var n3 = Jl;
  Object.defineProperty(t10, "_", { enumerable: true, get: function() {
    return n3._;
  } }), Object.defineProperty(t10, "str", { enumerable: true, get: function() {
    return n3.str;
  } }), Object.defineProperty(t10, "strConcat", { enumerable: true, get: function() {
    return n3.strConcat;
  } }), Object.defineProperty(t10, "nil", { enumerable: true, get: function() {
    return n3.nil;
  } }), Object.defineProperty(t10, "getProperty", { enumerable: true, get: function() {
    return n3.getProperty;
  } }), Object.defineProperty(t10, "stringify", { enumerable: true, get: function() {
    return n3.stringify;
  } }), Object.defineProperty(t10, "regexpCode", { enumerable: true, get: function() {
    return n3.regexpCode;
  } }), Object.defineProperty(t10, "Name", { enumerable: true, get: function() {
    return n3.Name;
  } });
  var i3 = Pm;
  Object.defineProperty(t10, "Scope", { enumerable: true, get: function() {
    return i3.Scope;
  } }), Object.defineProperty(t10, "ValueScope", { enumerable: true, get: function() {
    return i3.ValueScope;
  } }), Object.defineProperty(t10, "ValueScopeName", { enumerable: true, get: function() {
    return i3.ValueScopeName;
  } }), Object.defineProperty(t10, "varKinds", { enumerable: true, get: function() {
    return i3.varKinds;
  } }), t10.operators = {
    GT: new e3._Code(">"),
    GTE: new e3._Code(">="),
    LT: new e3._Code("<"),
    LTE: new e3._Code("<="),
    EQ: new e3._Code("==="),
    NEQ: new e3._Code("!=="),
    NOT: new e3._Code("!"),
    OR: new e3._Code("||"),
    AND: new e3._Code("&&"),
    ADD: new e3._Code("+")
  };
  class o3 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(w10, U10) {
      return this;
    }
  }
  class s3 extends o3 {
    constructor(w10, U10, T10) {
      super(), this.varKind = w10, this.name = U10, this.rhs = T10;
    }
    render({ es5: w10, _n: U10 }) {
      const T10 = w10 ? r3.varKinds.var : this.varKind, F5 = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${T10} ${this.name}${F5};` + U10;
    }
    optimizeNames(w10, U10) {
      if (w10[this.name.str])
        return this.rhs && (this.rhs = pe(this.rhs, w10, U10)), this;
    }
    get names() {
      return this.rhs instanceof e3._CodeOrName ? this.rhs.names : {};
    }
  }
  class a3 extends o3 {
    constructor(w10, U10, T10) {
      super(), this.lhs = w10, this.rhs = U10, this.sideEffects = T10;
    }
    render({ _n: w10 }) {
      return `${this.lhs} = ${this.rhs};` + w10;
    }
    optimizeNames(w10, U10) {
      if (!(this.lhs instanceof e3.Name && !w10[this.lhs.str] && !this.sideEffects))
        return this.rhs = pe(this.rhs, w10, U10), this;
    }
    get names() {
      const w10 = this.lhs instanceof e3.Name ? {} : { ...this.lhs.names };
      return fe(w10, this.rhs);
    }
  }
  class l3 extends a3 {
    constructor(w10, U10, T10, F5) {
      super(w10, T10, F5), this.op = U10;
    }
    render({ _n: w10 }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + w10;
    }
  }
  class u3 extends o3 {
    constructor(w10) {
      super(), this.label = w10, this.names = {};
    }
    render({ _n: w10 }) {
      return `${this.label}:` + w10;
    }
  }
  class c3 extends o3 {
    constructor(w10) {
      super(), this.label = w10, this.names = {};
    }
    render({ _n: w10 }) {
      return `break${this.label ? ` ${this.label}` : ""};` + w10;
    }
  }
  class f3 extends o3 {
    constructor(w10) {
      super(), this.error = w10;
    }
    render({ _n: w10 }) {
      return `throw ${this.error};` + w10;
    }
    get names() {
      return this.error.names;
    }
  }
  class d3 extends o3 {
    constructor(w10) {
      super(), this.code = w10;
    }
    render({ _n: w10 }) {
      return `${this.code};` + w10;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(w10, U10) {
      return this.code = pe(this.code, w10, U10), this;
    }
    get names() {
      return this.code instanceof e3._CodeOrName ? this.code.names : {};
    }
  }
  class p10 extends o3 {
    constructor(w10 = []) {
      super(), this.nodes = w10;
    }
    render(w10) {
      return this.nodes.reduce((U10, T10) => U10 + T10.render(w10), "");
    }
    optimizeNodes() {
      const { nodes: w10 } = this;
      let U10 = w10.length;
      for (; U10--; ) {
        const T10 = w10[U10].optimizeNodes();
        Array.isArray(T10) ? w10.splice(U10, 1, ...T10) : T10 ? w10[U10] = T10 : w10.splice(U10, 1);
      }
      return w10.length > 0 ? this : void 0;
    }
    optimizeNames(w10, U10) {
      const { nodes: T10 } = this;
      let F5 = T10.length;
      for (; F5--; ) {
        const V3 = T10[F5];
        V3.optimizeNames(w10, U10) || (Ee2(w10, V3.names), T10.splice(F5, 1));
      }
      return T10.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((w10, U10) => re2(w10, U10.names), {});
    }
  }
  class h10 extends p10 {
    render(w10) {
      return "{" + w10._n + super.render(w10) + "}" + w10._n;
    }
  }
  class m10 extends p10 {
  }
  class O10 extends h10 {
  }
  O10.kind = "else";
  class g extends h10 {
    constructor(w10, U10) {
      super(U10), this.condition = w10;
    }
    render(w10) {
      let U10 = `if(${this.condition})` + super.render(w10);
      return this.else && (U10 += "else " + this.else.render(w10)), U10;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const w10 = this.condition;
      if (w10 === true)
        return this.nodes;
      let U10 = this.else;
      if (U10) {
        const T10 = U10.optimizeNodes();
        U10 = this.else = Array.isArray(T10) ? new O10(T10) : T10;
      }
      if (U10)
        return w10 === false ? U10 instanceof g ? U10 : U10.nodes : this.nodes.length ? this : new g(qe(w10), U10 instanceof g ? [U10] : U10.nodes);
      if (!(w10 === false || !this.nodes.length))
        return this;
    }
    optimizeNames(w10, U10) {
      var T10;
      if (this.else = (T10 = this.else) === null || T10 === void 0 ? void 0 : T10.optimizeNames(w10, U10), !!(super.optimizeNames(w10, U10) || this.else))
        return this.condition = pe(this.condition, w10, U10), this;
    }
    get names() {
      const w10 = super.names;
      return fe(w10, this.condition), this.else && re2(w10, this.else.names), w10;
    }
  }
  g.kind = "if";
  class v10 extends h10 {
  }
  v10.kind = "for";
  class S10 extends v10 {
    constructor(w10) {
      super(), this.iteration = w10;
    }
    render(w10) {
      return `for(${this.iteration})` + super.render(w10);
    }
    optimizeNames(w10, U10) {
      if (super.optimizeNames(w10, U10))
        return this.iteration = pe(this.iteration, w10, U10), this;
    }
    get names() {
      return re2(super.names, this.iteration.names);
    }
  }
  class $10 extends v10 {
    constructor(w10, U10, T10, F5) {
      super(), this.varKind = w10, this.name = U10, this.from = T10, this.to = F5;
    }
    render(w10) {
      const U10 = w10.es5 ? r3.varKinds.var : this.varKind, { name: T10, from: F5, to: V3 } = this;
      return `for(${U10} ${T10}=${F5}; ${T10}<${V3}; ${T10}++)` + super.render(w10);
    }
    get names() {
      const w10 = fe(super.names, this.from);
      return fe(w10, this.to);
    }
  }
  class _10 extends v10 {
    constructor(w10, U10, T10, F5) {
      super(), this.loop = w10, this.varKind = U10, this.name = T10, this.iterable = F5;
    }
    render(w10) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(w10);
    }
    optimizeNames(w10, U10) {
      if (super.optimizeNames(w10, U10))
        return this.iterable = pe(this.iterable, w10, U10), this;
    }
    get names() {
      return re2(super.names, this.iterable.names);
    }
  }
  class P10 extends h10 {
    constructor(w10, U10, T10) {
      super(), this.name = w10, this.args = U10, this.async = T10;
    }
    render(w10) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(w10);
    }
  }
  P10.kind = "func";
  class q5 extends p10 {
    render(w10) {
      return "return " + super.render(w10);
    }
  }
  q5.kind = "return";
  class N5 extends h10 {
    render(w10) {
      let U10 = "try" + super.render(w10);
      return this.catch && (U10 += this.catch.render(w10)), this.finally && (U10 += this.finally.render(w10)), U10;
    }
    optimizeNodes() {
      var w10, U10;
      return super.optimizeNodes(), (w10 = this.catch) === null || w10 === void 0 || w10.optimizeNodes(), (U10 = this.finally) === null || U10 === void 0 || U10.optimizeNodes(), this;
    }
    optimizeNames(w10, U10) {
      var T10, F5;
      return super.optimizeNames(w10, U10), (T10 = this.catch) === null || T10 === void 0 || T10.optimizeNames(w10, U10), (F5 = this.finally) === null || F5 === void 0 || F5.optimizeNames(w10, U10), this;
    }
    get names() {
      const w10 = super.names;
      return this.catch && re2(w10, this.catch.names), this.finally && re2(w10, this.finally.names), w10;
    }
  }
  class B5 extends h10 {
    constructor(w10) {
      super(), this.error = w10;
    }
    render(w10) {
      return `catch(${this.error})` + super.render(w10);
    }
  }
  B5.kind = "catch";
  class H10 extends h10 {
    render(w10) {
      return "finally" + super.render(w10);
    }
  }
  H10.kind = "finally";
  class ne {
    constructor(w10, U10 = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...U10, _n: U10.lines ? `
` : "" }, this._extScope = w10, this._scope = new r3.Scope({ parent: w10 }), this._nodes = [new m10()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(w10) {
      return this._scope.name(w10);
    }
    // reserves unique name in the external scope
    scopeName(w10) {
      return this._extScope.name(w10);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(w10, U10) {
      const T10 = this._extScope.value(w10, U10);
      return (this._values[T10.prefix] || (this._values[T10.prefix] = /* @__PURE__ */ new Set())).add(T10), T10;
    }
    getScopeValue(w10, U10) {
      return this._extScope.getValue(w10, U10);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(w10) {
      return this._extScope.scopeRefs(w10, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(w10, U10, T10, F5) {
      const V3 = this._scope.toName(U10);
      return T10 !== void 0 && F5 && (this._constants[V3.str] = T10), this._leafNode(new s3(w10, V3, T10)), V3;
    }
    // `const` declaration (`var` in es5 mode)
    const(w10, U10, T10) {
      return this._def(r3.varKinds.const, w10, U10, T10);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(w10, U10, T10) {
      return this._def(r3.varKinds.let, w10, U10, T10);
    }
    // `var` declaration with optional assignment
    var(w10, U10, T10) {
      return this._def(r3.varKinds.var, w10, U10, T10);
    }
    // assignment code
    assign(w10, U10, T10) {
      return this._leafNode(new a3(w10, U10, T10));
    }
    // `+=` code
    add(w10, U10) {
      return this._leafNode(new l3(w10, t10.operators.ADD, U10));
    }
    // appends passed SafeExpr to code or executes Block
    code(w10) {
      return typeof w10 == "function" ? w10() : w10 !== e3.nil && this._leafNode(new d3(w10)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...w10) {
      const U10 = ["{"];
      for (const [T10, F5] of w10)
        U10.length > 1 && U10.push(","), U10.push(T10), (T10 !== F5 || this.opts.es5) && (U10.push(":"), (0, e3.addCodeArg)(U10, F5));
      return U10.push("}"), new e3._Code(U10);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(w10, U10, T10) {
      if (this._blockNode(new g(w10)), U10 && T10)
        this.code(U10).else().code(T10).endIf();
      else if (U10)
        this.code(U10).endIf();
      else if (T10)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(w10) {
      return this._elseNode(new g(w10));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new O10());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(g, O10);
    }
    _for(w10, U10) {
      return this._blockNode(w10), U10 && this.code(U10).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(w10, U10) {
      return this._for(new S10(w10), U10);
    }
    // `for` statement for a range of values
    forRange(w10, U10, T10, F5, V3 = this.opts.es5 ? r3.varKinds.var : r3.varKinds.let) {
      const ie2 = this._scope.toName(w10);
      return this._for(new $10(V3, ie2, U10, T10), () => F5(ie2));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(w10, U10, T10, F5 = r3.varKinds.const) {
      const V3 = this._scope.toName(w10);
      if (this.opts.es5) {
        const ie2 = U10 instanceof e3.Name ? U10 : this.var("_arr", U10);
        return this.forRange("_i", 0, (0, e3._)`${ie2}.length`, (ce2) => {
          this.var(V3, (0, e3._)`${ie2}[${ce2}]`), T10(V3);
        });
      }
      return this._for(new _10("of", F5, V3, U10), () => T10(V3));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(w10, U10, T10, F5 = this.opts.es5 ? r3.varKinds.var : r3.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(w10, (0, e3._)`Object.keys(${U10})`, T10);
      const V3 = this._scope.toName(w10);
      return this._for(new _10("in", F5, V3, U10), () => T10(V3));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(v10);
    }
    // `label` statement
    label(w10) {
      return this._leafNode(new u3(w10));
    }
    // `break` statement
    break(w10) {
      return this._leafNode(new c3(w10));
    }
    // `return` statement
    return(w10) {
      const U10 = new q5();
      if (this._blockNode(U10), this.code(w10), U10.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(q5);
    }
    // `try` statement
    try(w10, U10, T10) {
      if (!U10 && !T10)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const F5 = new N5();
      if (this._blockNode(F5), this.code(w10), U10) {
        const V3 = this.name("e");
        this._currNode = F5.catch = new B5(V3), U10(V3);
      }
      return T10 && (this._currNode = F5.finally = new H10(), this.code(T10)), this._endBlockNode(B5, H10);
    }
    // `throw` statement
    throw(w10) {
      return this._leafNode(new f3(w10));
    }
    // start self-balancing block
    block(w10, U10) {
      return this._blockStarts.push(this._nodes.length), w10 && this.code(w10).endBlock(U10), this;
    }
    // end the current self-balancing block
    endBlock(w10) {
      const U10 = this._blockStarts.pop();
      if (U10 === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const T10 = this._nodes.length - U10;
      if (T10 < 0 || w10 !== void 0 && T10 !== w10)
        throw new Error(`CodeGen: wrong number of nodes: ${T10} vs ${w10} expected`);
      return this._nodes.length = U10, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(w10, U10 = e3.nil, T10, F5) {
      return this._blockNode(new P10(w10, U10, T10)), F5 && this.code(F5).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(P10);
    }
    optimize(w10 = 1) {
      for (; w10-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(w10) {
      return this._currNode.nodes.push(w10), this;
    }
    _blockNode(w10) {
      this._currNode.nodes.push(w10), this._nodes.push(w10);
    }
    _endBlockNode(w10, U10) {
      const T10 = this._currNode;
      if (T10 instanceof w10 || U10 && T10 instanceof U10)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${U10 ? `${w10.kind}/${U10.kind}` : w10.kind}"`);
    }
    _elseNode(w10) {
      const U10 = this._currNode;
      if (!(U10 instanceof g))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = U10.else = w10, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const w10 = this._nodes;
      return w10[w10.length - 1];
    }
    set _currNode(w10) {
      const U10 = this._nodes;
      U10[U10.length - 1] = w10;
    }
  }
  t10.CodeGen = ne;
  function re2(X10, w10) {
    for (const U10 in w10)
      X10[U10] = (X10[U10] || 0) + (w10[U10] || 0);
    return X10;
  }
  function fe(X10, w10) {
    return w10 instanceof e3._CodeOrName ? re2(X10, w10.names) : X10;
  }
  function pe(X10, w10, U10) {
    if (X10 instanceof e3.Name)
      return T10(X10);
    if (!F5(X10))
      return X10;
    return new e3._Code(X10._items.reduce((V3, ie2) => (ie2 instanceof e3.Name && (ie2 = T10(ie2)), ie2 instanceof e3._Code ? V3.push(...ie2._items) : V3.push(ie2), V3), []));
    function T10(V3) {
      const ie2 = U10[V3.str];
      return ie2 === void 0 || w10[V3.str] !== 1 ? V3 : (delete w10[V3.str], ie2);
    }
    function F5(V3) {
      return V3 instanceof e3._Code && V3._items.some((ie2) => ie2 instanceof e3.Name && w10[ie2.str] === 1 && U10[ie2.str] !== void 0);
    }
  }
  function Ee2(X10, w10) {
    for (const U10 in w10)
      X10[U10] = (X10[U10] || 0) - (w10[U10] || 0);
  }
  function qe(X10) {
    return typeof X10 == "boolean" || typeof X10 == "number" || X10 === null ? !X10 : (0, e3._)`!${C10(X10)}`;
  }
  t10.not = qe;
  const _e = Z(t10.operators.AND);
  function Ie(...X10) {
    return X10.reduce(_e);
  }
  t10.and = Ie;
  const je2 = Z(t10.operators.OR);
  function G(...X10) {
    return X10.reduce(je2);
  }
  t10.or = G;
  function Z(X10) {
    return (w10, U10) => w10 === e3.nil ? U10 : U10 === e3.nil ? w10 : (0, e3._)`${C10(w10)} ${X10} ${C10(U10)}`;
  }
  function C10(X10) {
    return X10 instanceof e3.Name ? X10 : (0, e3._)`(${X10})`;
  }
})(Le);
var tt = {};
(function(t10) {
  Object.defineProperty(t10, "__esModule", { value: true }), t10.checkStrictMode = t10.getErrorPath = t10.Type = t10.useFunc = t10.setEvaluated = t10.evaluatedPropsToName = t10.mergeEvaluated = t10.eachItem = t10.unescapeJsonPointer = t10.escapeJsonPointer = t10.escapeFragment = t10.unescapeFragment = t10.schemaRefOrVal = t10.schemaHasRulesButRef = t10.schemaHasRules = t10.checkUnknownRules = t10.alwaysValidSchema = t10.toHash = void 0;
  const e3 = Le, r3 = Jl;
  function n3(P10) {
    const q5 = {};
    for (const N5 of P10)
      q5[N5] = true;
    return q5;
  }
  t10.toHash = n3;
  function i3(P10, q5) {
    return typeof q5 == "boolean" ? q5 : Object.keys(q5).length === 0 ? true : (o3(P10, q5), !s3(q5, P10.self.RULES.all));
  }
  t10.alwaysValidSchema = i3;
  function o3(P10, q5 = P10.schema) {
    const { opts: N5, self: B5 } = P10;
    if (!N5.strictSchema || typeof q5 == "boolean")
      return;
    const H10 = B5.RULES.keywords;
    for (const ne in q5)
      H10[ne] || _10(P10, `unknown keyword: "${ne}"`);
  }
  t10.checkUnknownRules = o3;
  function s3(P10, q5) {
    if (typeof P10 == "boolean")
      return !P10;
    for (const N5 in P10)
      if (q5[N5])
        return true;
    return false;
  }
  t10.schemaHasRules = s3;
  function a3(P10, q5) {
    if (typeof P10 == "boolean")
      return !P10;
    for (const N5 in P10)
      if (N5 !== "$ref" && q5.all[N5])
        return true;
    return false;
  }
  t10.schemaHasRulesButRef = a3;
  function l3({ topSchemaRef: P10, schemaPath: q5 }, N5, B5, H10) {
    if (!H10) {
      if (typeof N5 == "number" || typeof N5 == "boolean")
        return N5;
      if (typeof N5 == "string")
        return (0, e3._)`${N5}`;
    }
    return (0, e3._)`${P10}${q5}${(0, e3.getProperty)(B5)}`;
  }
  t10.schemaRefOrVal = l3;
  function u3(P10) {
    return d3(decodeURIComponent(P10));
  }
  t10.unescapeFragment = u3;
  function c3(P10) {
    return encodeURIComponent(f3(P10));
  }
  t10.escapeFragment = c3;
  function f3(P10) {
    return typeof P10 == "number" ? `${P10}` : P10.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  t10.escapeJsonPointer = f3;
  function d3(P10) {
    return P10.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  t10.unescapeJsonPointer = d3;
  function p10(P10, q5) {
    if (Array.isArray(P10))
      for (const N5 of P10)
        q5(N5);
    else
      q5(P10);
  }
  t10.eachItem = p10;
  function h10({ mergeNames: P10, mergeToName: q5, mergeValues: N5, resultToName: B5 }) {
    return (H10, ne, re2, fe) => {
      const pe = re2 === void 0 ? ne : re2 instanceof e3.Name ? (ne instanceof e3.Name ? P10(H10, ne, re2) : q5(H10, ne, re2), re2) : ne instanceof e3.Name ? (q5(H10, re2, ne), ne) : N5(ne, re2);
      return fe === e3.Name && !(pe instanceof e3.Name) ? B5(H10, pe) : pe;
    };
  }
  t10.mergeEvaluated = {
    props: h10({
      mergeNames: (P10, q5, N5) => P10.if((0, e3._)`${N5} !== true && ${q5} !== undefined`, () => {
        P10.if((0, e3._)`${q5} === true`, () => P10.assign(N5, true), () => P10.assign(N5, (0, e3._)`${N5} || {}`).code((0, e3._)`Object.assign(${N5}, ${q5})`));
      }),
      mergeToName: (P10, q5, N5) => P10.if((0, e3._)`${N5} !== true`, () => {
        q5 === true ? P10.assign(N5, true) : (P10.assign(N5, (0, e3._)`${N5} || {}`), O10(P10, N5, q5));
      }),
      mergeValues: (P10, q5) => P10 === true ? true : { ...P10, ...q5 },
      resultToName: m10
    }),
    items: h10({
      mergeNames: (P10, q5, N5) => P10.if((0, e3._)`${N5} !== true && ${q5} !== undefined`, () => P10.assign(N5, (0, e3._)`${q5} === true ? true : ${N5} > ${q5} ? ${N5} : ${q5}`)),
      mergeToName: (P10, q5, N5) => P10.if((0, e3._)`${N5} !== true`, () => P10.assign(N5, q5 === true ? true : (0, e3._)`${N5} > ${q5} ? ${N5} : ${q5}`)),
      mergeValues: (P10, q5) => P10 === true ? true : Math.max(P10, q5),
      resultToName: (P10, q5) => P10.var("items", q5)
    })
  };
  function m10(P10, q5) {
    if (q5 === true)
      return P10.var("props", true);
    const N5 = P10.var("props", (0, e3._)`{}`);
    return q5 !== void 0 && O10(P10, N5, q5), N5;
  }
  t10.evaluatedPropsToName = m10;
  function O10(P10, q5, N5) {
    Object.keys(N5).forEach((B5) => P10.assign((0, e3._)`${q5}${(0, e3.getProperty)(B5)}`, true));
  }
  t10.setEvaluated = O10;
  const g = {};
  function v10(P10, q5) {
    return P10.scopeValue("func", {
      ref: q5,
      code: g[q5.code] || (g[q5.code] = new r3._Code(q5.code))
    });
  }
  t10.useFunc = v10;
  var S10;
  (function(P10) {
    P10[P10.Num = 0] = "Num", P10[P10.Str = 1] = "Str";
  })(S10 = t10.Type || (t10.Type = {}));
  function $10(P10, q5, N5) {
    if (P10 instanceof e3.Name) {
      const B5 = q5 === S10.Num;
      return N5 ? B5 ? (0, e3._)`"[" + ${P10} + "]"` : (0, e3._)`"['" + ${P10} + "']"` : B5 ? (0, e3._)`"/" + ${P10}` : (0, e3._)`"/" + ${P10}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return N5 ? (0, e3.getProperty)(P10).toString() : "/" + f3(P10);
  }
  t10.getErrorPath = $10;
  function _10(P10, q5, N5 = P10.opts.strictSchema) {
    if (N5) {
      if (q5 = `strict mode: ${q5}`, N5 === true)
        throw new Error(q5);
      P10.self.logger.warn(q5);
    }
  }
  t10.checkStrictMode = _10;
})(tt);
var nn = {};
Object.defineProperty(nn, "__esModule", { value: true });
const hr = Le, hz = {
  // validation function arguments
  data: new hr.Name("data"),
  // args passed from referencing schema
  valCxt: new hr.Name("valCxt"),
  instancePath: new hr.Name("instancePath"),
  parentData: new hr.Name("parentData"),
  parentDataProperty: new hr.Name("parentDataProperty"),
  rootData: new hr.Name("rootData"),
  dynamicAnchors: new hr.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new hr.Name("vErrors"),
  errors: new hr.Name("errors"),
  this: new hr.Name("this"),
  // "globals"
  self: new hr.Name("self"),
  scope: new hr.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new hr.Name("json"),
  jsonPos: new hr.Name("jsonPos"),
  jsonLen: new hr.Name("jsonLen"),
  jsonPart: new hr.Name("jsonPart")
};
nn.default = hz;
(function(t10) {
  Object.defineProperty(t10, "__esModule", { value: true }), t10.extendErrors = t10.resetErrorsCount = t10.reportExtraError = t10.reportError = t10.keyword$DataError = t10.keywordError = void 0;
  const e3 = Le, r3 = tt, n3 = nn;
  t10.keywordError = {
    message: ({ keyword: O10 }) => (0, e3.str)`must pass "${O10}" keyword validation`
  }, t10.keyword$DataError = {
    message: ({ keyword: O10, schemaType: g }) => g ? (0, e3.str)`"${O10}" keyword must be ${g} ($data)` : (0, e3.str)`"${O10}" keyword is invalid ($data)`
  };
  function i3(O10, g = t10.keywordError, v10, S10) {
    const { it: $10 } = O10, { gen: _10, compositeRule: P10, allErrors: q5 } = $10, N5 = f3(O10, g, v10);
    S10 ?? (P10 || q5) ? l3(_10, N5) : u3($10, (0, e3._)`[${N5}]`);
  }
  t10.reportError = i3;
  function o3(O10, g = t10.keywordError, v10) {
    const { it: S10 } = O10, { gen: $10, compositeRule: _10, allErrors: P10 } = S10, q5 = f3(O10, g, v10);
    l3($10, q5), _10 || P10 || u3(S10, n3.default.vErrors);
  }
  t10.reportExtraError = o3;
  function s3(O10, g) {
    O10.assign(n3.default.errors, g), O10.if((0, e3._)`${n3.default.vErrors} !== null`, () => O10.if(g, () => O10.assign((0, e3._)`${n3.default.vErrors}.length`, g), () => O10.assign(n3.default.vErrors, null)));
  }
  t10.resetErrorsCount = s3;
  function a3({ gen: O10, keyword: g, schemaValue: v10, data: S10, errsCount: $10, it: _10 }) {
    if ($10 === void 0)
      throw new Error("ajv implementation error");
    const P10 = O10.name("err");
    O10.forRange("i", $10, n3.default.errors, (q5) => {
      O10.const(P10, (0, e3._)`${n3.default.vErrors}[${q5}]`), O10.if((0, e3._)`${P10}.instancePath === undefined`, () => O10.assign((0, e3._)`${P10}.instancePath`, (0, e3.strConcat)(n3.default.instancePath, _10.errorPath))), O10.assign((0, e3._)`${P10}.schemaPath`, (0, e3.str)`${_10.errSchemaPath}/${g}`), _10.opts.verbose && (O10.assign((0, e3._)`${P10}.schema`, v10), O10.assign((0, e3._)`${P10}.data`, S10));
    });
  }
  t10.extendErrors = a3;
  function l3(O10, g) {
    const v10 = O10.const("err", g);
    O10.if((0, e3._)`${n3.default.vErrors} === null`, () => O10.assign(n3.default.vErrors, (0, e3._)`[${v10}]`), (0, e3._)`${n3.default.vErrors}.push(${v10})`), O10.code((0, e3._)`${n3.default.errors}++`);
  }
  function u3(O10, g) {
    const { gen: v10, validateName: S10, schemaEnv: $10 } = O10;
    $10.$async ? v10.throw((0, e3._)`new ${O10.ValidationError}(${g})`) : (v10.assign((0, e3._)`${S10}.errors`, g), v10.return(false));
  }
  const c3 = {
    keyword: new e3.Name("keyword"),
    schemaPath: new e3.Name("schemaPath"),
    params: new e3.Name("params"),
    propertyName: new e3.Name("propertyName"),
    message: new e3.Name("message"),
    schema: new e3.Name("schema"),
    parentSchema: new e3.Name("parentSchema")
  };
  function f3(O10, g, v10) {
    const { createErrors: S10 } = O10.it;
    return S10 === false ? (0, e3._)`{}` : d3(O10, g, v10);
  }
  function d3(O10, g, v10 = {}) {
    const { gen: S10, it: $10 } = O10, _10 = [
      p10($10, v10),
      h10(O10, v10)
    ];
    return m10(O10, g, _10), S10.object(..._10);
  }
  function p10({ errorPath: O10 }, { instancePath: g }) {
    const v10 = g ? (0, e3.str)`${O10}${(0, r3.getErrorPath)(g, r3.Type.Str)}` : O10;
    return [n3.default.instancePath, (0, e3.strConcat)(n3.default.instancePath, v10)];
  }
  function h10({ keyword: O10, it: { errSchemaPath: g } }, { schemaPath: v10, parentSchema: S10 }) {
    let $10 = S10 ? g : (0, e3.str)`${g}/${O10}`;
    return v10 && ($10 = (0, e3.str)`${$10}${(0, r3.getErrorPath)(v10, r3.Type.Str)}`), [c3.schemaPath, $10];
  }
  function m10(O10, { params: g, message: v10 }, S10) {
    const { keyword: $10, data: _10, schemaValue: P10, it: q5 } = O10, { opts: N5, propertyName: B5, topSchemaRef: H10, schemaPath: ne } = q5;
    S10.push([c3.keyword, $10], [c3.params, typeof g == "function" ? g(O10) : g || (0, e3._)`{}`]), N5.messages && S10.push([c3.message, typeof v10 == "function" ? v10(O10) : v10]), N5.verbose && S10.push([c3.schema, P10], [c3.parentSchema, (0, e3._)`${H10}${ne}`], [n3.default.data, _10]), B5 && S10.push([c3.propertyName, B5]);
  }
})(Su);
Object.defineProperty(ya, "__esModule", { value: true });
ya.boolOrEmptySchema = ya.topBoolOrEmptySchema = void 0;
const pz = Su, Oz = Le, mz = nn, gz = {
  message: "boolean schema is false"
};
function yz(t10) {
  const { gen: e3, schema: r3, validateName: n3 } = t10;
  r3 === false ? ST(t10, false) : typeof r3 == "object" && r3.$async === true ? e3.return(mz.default.data) : (e3.assign((0, Oz._)`${n3}.errors`, null), e3.return(true));
}
ya.topBoolOrEmptySchema = yz;
function vz(t10, e3) {
  const { gen: r3, schema: n3 } = t10;
  n3 === false ? (r3.var(e3, false), ST(t10)) : r3.var(e3, true);
}
ya.boolOrEmptySchema = vz;
function ST(t10, e3) {
  const { gen: r3, data: n3 } = t10, i3 = {
    gen: r3,
    keyword: "false schema",
    data: n3,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it: t10
  };
  (0, pz.reportError)(i3, gz, void 0, e3);
}
var $u = {}, us = {};
Object.defineProperty(us, "__esModule", { value: true });
us.getRules = us.isJSONType = void 0;
const bz = ["string", "number", "integer", "boolean", "null", "object", "array"], Sz = new Set(bz);
function $z(t10) {
  return typeof t10 == "string" && Sz.has(t10);
}
us.isJSONType = $z;
function wz() {
  const t10 = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...t10, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, t10.number, t10.string, t10.array, t10.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
us.getRules = wz;
var Ti = {};
Object.defineProperty(Ti, "__esModule", { value: true });
Ti.shouldUseRule = Ti.shouldUseGroup = Ti.schemaHasRulesForType = void 0;
function Pz({ schema: t10, self: e3 }, r3) {
  const n3 = e3.RULES.types[r3];
  return n3 && n3 !== true && $T(t10, n3);
}
Ti.schemaHasRulesForType = Pz;
function $T(t10, e3) {
  return e3.rules.some((r3) => wT(t10, r3));
}
Ti.shouldUseGroup = $T;
function wT(t10, e3) {
  var r3;
  return t10[e3.keyword] !== void 0 || ((r3 = e3.definition.implements) === null || r3 === void 0 ? void 0 : r3.some((n3) => t10[n3] !== void 0));
}
Ti.shouldUseRule = wT;
(function(t10) {
  Object.defineProperty(t10, "__esModule", { value: true }), t10.reportTypeError = t10.checkDataTypes = t10.checkDataType = t10.coerceAndCheckDataType = t10.getJSONTypes = t10.getSchemaTypes = t10.DataType = void 0;
  const e3 = us, r3 = Ti, n3 = Su, i3 = Le, o3 = tt;
  var s3;
  (function(S10) {
    S10[S10.Correct = 0] = "Correct", S10[S10.Wrong = 1] = "Wrong";
  })(s3 = t10.DataType || (t10.DataType = {}));
  function a3(S10) {
    const $10 = l3(S10.type);
    if ($10.includes("null")) {
      if (S10.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!$10.length && S10.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      S10.nullable === true && $10.push("null");
    }
    return $10;
  }
  t10.getSchemaTypes = a3;
  function l3(S10) {
    const $10 = Array.isArray(S10) ? S10 : S10 ? [S10] : [];
    if ($10.every(e3.isJSONType))
      return $10;
    throw new Error("type must be JSONType or JSONType[]: " + $10.join(","));
  }
  t10.getJSONTypes = l3;
  function u3(S10, $10) {
    const { gen: _10, data: P10, opts: q5 } = S10, N5 = f3($10, q5.coerceTypes), B5 = $10.length > 0 && !(N5.length === 0 && $10.length === 1 && (0, r3.schemaHasRulesForType)(S10, $10[0]));
    if (B5) {
      const H10 = m10($10, P10, q5.strictNumbers, s3.Wrong);
      _10.if(H10, () => {
        N5.length ? d3(S10, $10, N5) : g(S10);
      });
    }
    return B5;
  }
  t10.coerceAndCheckDataType = u3;
  const c3 = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function f3(S10, $10) {
    return $10 ? S10.filter((_10) => c3.has(_10) || $10 === "array" && _10 === "array") : [];
  }
  function d3(S10, $10, _10) {
    const { gen: P10, data: q5, opts: N5 } = S10, B5 = P10.let("dataType", (0, i3._)`typeof ${q5}`), H10 = P10.let("coerced", (0, i3._)`undefined`);
    N5.coerceTypes === "array" && P10.if((0, i3._)`${B5} == 'object' && Array.isArray(${q5}) && ${q5}.length == 1`, () => P10.assign(q5, (0, i3._)`${q5}[0]`).assign(B5, (0, i3._)`typeof ${q5}`).if(m10($10, q5, N5.strictNumbers), () => P10.assign(H10, q5))), P10.if((0, i3._)`${H10} !== undefined`);
    for (const re2 of _10)
      (c3.has(re2) || re2 === "array" && N5.coerceTypes === "array") && ne(re2);
    P10.else(), g(S10), P10.endIf(), P10.if((0, i3._)`${H10} !== undefined`, () => {
      P10.assign(q5, H10), p10(S10, H10);
    });
    function ne(re2) {
      switch (re2) {
        case "string":
          P10.elseIf((0, i3._)`${B5} == "number" || ${B5} == "boolean"`).assign(H10, (0, i3._)`"" + ${q5}`).elseIf((0, i3._)`${q5} === null`).assign(H10, (0, i3._)`""`);
          return;
        case "number":
          P10.elseIf((0, i3._)`${B5} == "boolean" || ${q5} === null
              || (${B5} == "string" && ${q5} && ${q5} == +${q5})`).assign(H10, (0, i3._)`+${q5}`);
          return;
        case "integer":
          P10.elseIf((0, i3._)`${B5} === "boolean" || ${q5} === null
              || (${B5} === "string" && ${q5} && ${q5} == +${q5} && !(${q5} % 1))`).assign(H10, (0, i3._)`+${q5}`);
          return;
        case "boolean":
          P10.elseIf((0, i3._)`${q5} === "false" || ${q5} === 0 || ${q5} === null`).assign(H10, false).elseIf((0, i3._)`${q5} === "true" || ${q5} === 1`).assign(H10, true);
          return;
        case "null":
          P10.elseIf((0, i3._)`${q5} === "" || ${q5} === 0 || ${q5} === false`), P10.assign(H10, null);
          return;
        case "array":
          P10.elseIf((0, i3._)`${B5} === "string" || ${B5} === "number"
              || ${B5} === "boolean" || ${q5} === null`).assign(H10, (0, i3._)`[${q5}]`);
      }
    }
  }
  function p10({ gen: S10, parentData: $10, parentDataProperty: _10 }, P10) {
    S10.if((0, i3._)`${$10} !== undefined`, () => S10.assign((0, i3._)`${$10}[${_10}]`, P10));
  }
  function h10(S10, $10, _10, P10 = s3.Correct) {
    const q5 = P10 === s3.Correct ? i3.operators.EQ : i3.operators.NEQ;
    let N5;
    switch (S10) {
      case "null":
        return (0, i3._)`${$10} ${q5} null`;
      case "array":
        N5 = (0, i3._)`Array.isArray(${$10})`;
        break;
      case "object":
        N5 = (0, i3._)`${$10} && typeof ${$10} == "object" && !Array.isArray(${$10})`;
        break;
      case "integer":
        N5 = B5((0, i3._)`!(${$10} % 1) && !isNaN(${$10})`);
        break;
      case "number":
        N5 = B5();
        break;
      default:
        return (0, i3._)`typeof ${$10} ${q5} ${S10}`;
    }
    return P10 === s3.Correct ? N5 : (0, i3.not)(N5);
    function B5(H10 = i3.nil) {
      return (0, i3.and)((0, i3._)`typeof ${$10} == "number"`, H10, _10 ? (0, i3._)`isFinite(${$10})` : i3.nil);
    }
  }
  t10.checkDataType = h10;
  function m10(S10, $10, _10, P10) {
    if (S10.length === 1)
      return h10(S10[0], $10, _10, P10);
    let q5;
    const N5 = (0, o3.toHash)(S10);
    if (N5.array && N5.object) {
      const B5 = (0, i3._)`typeof ${$10} != "object"`;
      q5 = N5.null ? B5 : (0, i3._)`!${$10} || ${B5}`, delete N5.null, delete N5.array, delete N5.object;
    } else
      q5 = i3.nil;
    N5.number && delete N5.integer;
    for (const B5 in N5)
      q5 = (0, i3.and)(q5, h10(B5, $10, _10, P10));
    return q5;
  }
  t10.checkDataTypes = m10;
  const O10 = {
    message: ({ schema: S10 }) => `must be ${S10}`,
    params: ({ schema: S10, schemaValue: $10 }) => typeof S10 == "string" ? (0, i3._)`{type: ${S10}}` : (0, i3._)`{type: ${$10}}`
  };
  function g(S10) {
    const $10 = v10(S10);
    (0, n3.reportError)($10, O10);
  }
  t10.reportTypeError = g;
  function v10(S10) {
    const { gen: $10, data: _10, schema: P10 } = S10, q5 = (0, o3.schemaRefOrVal)(S10, P10, "type");
    return {
      gen: $10,
      keyword: "type",
      data: _10,
      schema: P10.type,
      schemaCode: q5,
      schemaValue: q5,
      parentSchema: P10,
      params: {},
      it: S10
    };
  }
})($u);
var bd = {};
Object.defineProperty(bd, "__esModule", { value: true });
bd.assignDefaults = void 0;
const Ts = Le, _z = tt;
function xz(t10, e3) {
  const { properties: r3, items: n3 } = t10.schema;
  if (e3 === "object" && r3)
    for (const i3 in r3)
      VS(t10, i3, r3[i3].default);
  else
    e3 === "array" && Array.isArray(n3) && n3.forEach((i3, o3) => VS(t10, o3, i3.default));
}
bd.assignDefaults = xz;
function VS(t10, e3, r3) {
  const { gen: n3, compositeRule: i3, data: o3, opts: s3 } = t10;
  if (r3 === void 0)
    return;
  const a3 = (0, Ts._)`${o3}${(0, Ts.getProperty)(e3)}`;
  if (i3) {
    (0, _z.checkStrictMode)(t10, `default is ignored for: ${a3}`);
    return;
  }
  let l3 = (0, Ts._)`${a3} === undefined`;
  s3.useDefaults === "empty" && (l3 = (0, Ts._)`${l3} || ${a3} === null || ${a3} === ""`), n3.if(l3, (0, Ts._)`${a3} = ${(0, Ts.stringify)(r3)}`);
}
var ti = {}, Ke = {};
Object.defineProperty(Ke, "__esModule", { value: true });
Ke.validateUnion = Ke.validateArray = Ke.usePattern = Ke.callValidateCode = Ke.schemaProperties = Ke.allSchemaProperties = Ke.noPropertyInData = Ke.propertyInData = Ke.isOwnProperty = Ke.hasPropFunc = Ke.reportMissingProp = Ke.checkMissingProp = Ke.checkReportMissingProp = void 0;
const _t = Le, b0 = tt, Li = nn, Qz = tt;
function Tz(t10, e3) {
  const { gen: r3, data: n3, it: i3 } = t10;
  r3.if($0(r3, n3, e3, i3.opts.ownProperties), () => {
    t10.setParams({ missingProperty: (0, _t._)`${e3}` }, true), t10.error();
  });
}
Ke.checkReportMissingProp = Tz;
function kz({ gen: t10, data: e3, it: { opts: r3 } }, n3, i3) {
  return (0, _t.or)(...n3.map((o3) => (0, _t.and)($0(t10, e3, o3, r3.ownProperties), (0, _t._)`${i3} = ${o3}`)));
}
Ke.checkMissingProp = kz;
function Ez(t10, e3) {
  t10.setParams({ missingProperty: e3 }, true), t10.error();
}
Ke.reportMissingProp = Ez;
function PT(t10) {
  return t10.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, _t._)`Object.prototype.hasOwnProperty`
  });
}
Ke.hasPropFunc = PT;
function S0(t10, e3, r3) {
  return (0, _t._)`${PT(t10)}.call(${e3}, ${r3})`;
}
Ke.isOwnProperty = S0;
function Cz(t10, e3, r3, n3) {
  const i3 = (0, _t._)`${e3}${(0, _t.getProperty)(r3)} !== undefined`;
  return n3 ? (0, _t._)`${i3} && ${S0(t10, e3, r3)}` : i3;
}
Ke.propertyInData = Cz;
function $0(t10, e3, r3, n3) {
  const i3 = (0, _t._)`${e3}${(0, _t.getProperty)(r3)} === undefined`;
  return n3 ? (0, _t.or)(i3, (0, _t.not)(S0(t10, e3, r3))) : i3;
}
Ke.noPropertyInData = $0;
function _T(t10) {
  return t10 ? Object.keys(t10).filter((e3) => e3 !== "__proto__") : [];
}
Ke.allSchemaProperties = _T;
function Rz(t10, e3) {
  return _T(e3).filter((r3) => !(0, b0.alwaysValidSchema)(t10, e3[r3]));
}
Ke.schemaProperties = Rz;
function Az({ schemaCode: t10, data: e3, it: { gen: r3, topSchemaRef: n3, schemaPath: i3, errorPath: o3 }, it: s3 }, a3, l3, u3) {
  const c3 = u3 ? (0, _t._)`${t10}, ${e3}, ${n3}${i3}` : e3, f3 = [
    [Li.default.instancePath, (0, _t.strConcat)(Li.default.instancePath, o3)],
    [Li.default.parentData, s3.parentData],
    [Li.default.parentDataProperty, s3.parentDataProperty],
    [Li.default.rootData, Li.default.rootData]
  ];
  s3.opts.dynamicRef && f3.push([Li.default.dynamicAnchors, Li.default.dynamicAnchors]);
  const d3 = (0, _t._)`${c3}, ${r3.object(...f3)}`;
  return l3 !== _t.nil ? (0, _t._)`${a3}.call(${l3}, ${d3})` : (0, _t._)`${a3}(${d3})`;
}
Ke.callValidateCode = Az;
const Xz = (0, _t._)`new RegExp`;
function qz({ gen: t10, it: { opts: e3 } }, r3) {
  const n3 = e3.unicodeRegExp ? "u" : "", { regExp: i3 } = e3.code, o3 = i3(r3, n3);
  return t10.scopeValue("pattern", {
    key: o3.toString(),
    ref: o3,
    code: (0, _t._)`${i3.code === "new RegExp" ? Xz : (0, Qz.useFunc)(t10, i3)}(${r3}, ${n3})`
  });
}
Ke.usePattern = qz;
function Dz(t10) {
  const { gen: e3, data: r3, keyword: n3, it: i3 } = t10, o3 = e3.name("valid");
  if (i3.allErrors) {
    const a3 = e3.let("valid", true);
    return s3(() => e3.assign(a3, false)), a3;
  }
  return e3.var(o3, true), s3(() => e3.break()), o3;
  function s3(a3) {
    const l3 = e3.const("len", (0, _t._)`${r3}.length`);
    e3.forRange("i", 0, l3, (u3) => {
      t10.subschema({
        keyword: n3,
        dataProp: u3,
        dataPropType: b0.Type.Num
      }, o3), e3.if((0, _t.not)(o3), a3);
    });
  }
}
Ke.validateArray = Dz;
function jz(t10) {
  const { gen: e3, schema: r3, keyword: n3, it: i3 } = t10;
  if (!Array.isArray(r3))
    throw new Error("ajv implementation error");
  if (r3.some((l3) => (0, b0.alwaysValidSchema)(i3, l3)) && !i3.opts.unevaluated)
    return;
  const s3 = e3.let("valid", false), a3 = e3.name("_valid");
  e3.block(() => r3.forEach((l3, u3) => {
    const c3 = t10.subschema({
      keyword: n3,
      schemaProp: u3,
      compositeRule: true
    }, a3);
    e3.assign(s3, (0, _t._)`${s3} || ${a3}`), t10.mergeValidEvaluated(c3, a3) || e3.if((0, _t.not)(s3));
  })), t10.result(s3, () => t10.reset(), () => t10.error(true));
}
Ke.validateUnion = jz;
Object.defineProperty(ti, "__esModule", { value: true });
ti.validateKeywordUsage = ti.validSchemaType = ti.funcKeywordCode = ti.macroKeywordCode = void 0;
const Qr = Le, Xo = nn, Uz = Ke, Iz = Su;
function Fz(t10, e3) {
  const { gen: r3, keyword: n3, schema: i3, parentSchema: o3, it: s3 } = t10, a3 = e3.macro.call(s3.self, i3, o3, s3), l3 = xT(r3, n3, a3);
  s3.opts.validateSchema !== false && s3.self.validateSchema(a3, true);
  const u3 = r3.name("valid");
  t10.subschema({
    schema: a3,
    schemaPath: Qr.nil,
    errSchemaPath: `${s3.errSchemaPath}/${n3}`,
    topSchemaRef: l3,
    compositeRule: true
  }, u3), t10.pass(u3, () => t10.error(true));
}
ti.macroKeywordCode = Fz;
function Zz(t10, e3) {
  var r3;
  const { gen: n3, keyword: i3, schema: o3, parentSchema: s3, $data: a3, it: l3 } = t10;
  Nz(l3, e3);
  const u3 = !a3 && e3.compile ? e3.compile.call(l3.self, o3, s3, l3) : e3.validate, c3 = xT(n3, i3, u3), f3 = n3.let("valid");
  t10.block$data(f3, d3), t10.ok((r3 = e3.valid) !== null && r3 !== void 0 ? r3 : f3);
  function d3() {
    if (e3.errors === false)
      m10(), e3.modifying && YS(t10), O10(() => t10.error());
    else {
      const g = e3.async ? p10() : h10();
      e3.modifying && YS(t10), O10(() => Mz(t10, g));
    }
  }
  function p10() {
    const g = n3.let("ruleErrs", null);
    return n3.try(() => m10((0, Qr._)`await `), (v10) => n3.assign(f3, false).if((0, Qr._)`${v10} instanceof ${l3.ValidationError}`, () => n3.assign(g, (0, Qr._)`${v10}.errors`), () => n3.throw(v10))), g;
  }
  function h10() {
    const g = (0, Qr._)`${c3}.errors`;
    return n3.assign(g, null), m10(Qr.nil), g;
  }
  function m10(g = e3.async ? (0, Qr._)`await ` : Qr.nil) {
    const v10 = l3.opts.passContext ? Xo.default.this : Xo.default.self, S10 = !("compile" in e3 && !a3 || e3.schema === false);
    n3.assign(f3, (0, Qr._)`${g}${(0, Uz.callValidateCode)(t10, c3, v10, S10)}`, e3.modifying);
  }
  function O10(g) {
    var v10;
    n3.if((0, Qr.not)((v10 = e3.valid) !== null && v10 !== void 0 ? v10 : f3), g);
  }
}
ti.funcKeywordCode = Zz;
function YS(t10) {
  const { gen: e3, data: r3, it: n3 } = t10;
  e3.if(n3.parentData, () => e3.assign(r3, (0, Qr._)`${n3.parentData}[${n3.parentDataProperty}]`));
}
function Mz(t10, e3) {
  const { gen: r3 } = t10;
  r3.if((0, Qr._)`Array.isArray(${e3})`, () => {
    r3.assign(Xo.default.vErrors, (0, Qr._)`${Xo.default.vErrors} === null ? ${e3} : ${Xo.default.vErrors}.concat(${e3})`).assign(Xo.default.errors, (0, Qr._)`${Xo.default.vErrors}.length`), (0, Iz.extendErrors)(t10);
  }, () => t10.error());
}
function Nz({ schemaEnv: t10 }, e3) {
  if (e3.async && !t10.$async)
    throw new Error("async keyword in sync schema");
}
function xT(t10, e3, r3) {
  if (r3 === void 0)
    throw new Error(`keyword "${e3}" failed to compile`);
  return t10.scopeValue("keyword", typeof r3 == "function" ? { ref: r3 } : { ref: r3, code: (0, Qr.stringify)(r3) });
}
function Wz(t10, e3, r3 = false) {
  return !e3.length || e3.some((n3) => n3 === "array" ? Array.isArray(t10) : n3 === "object" ? t10 && typeof t10 == "object" && !Array.isArray(t10) : typeof t10 == n3 || r3 && typeof t10 > "u");
}
ti.validSchemaType = Wz;
function Vz({ schema: t10, opts: e3, self: r3, errSchemaPath: n3 }, i3, o3) {
  if (Array.isArray(i3.keyword) ? !i3.keyword.includes(o3) : i3.keyword !== o3)
    throw new Error("ajv implementation error");
  const s3 = i3.dependencies;
  if (s3 != null && s3.some((a3) => !Object.prototype.hasOwnProperty.call(t10, a3)))
    throw new Error(`parent schema must have dependencies of ${o3}: ${s3.join(",")}`);
  if (i3.validateSchema && !i3.validateSchema(t10[o3])) {
    const l3 = `keyword "${o3}" value is invalid at path "${n3}": ` + r3.errorsText(i3.validateSchema.errors);
    if (e3.validateSchema === "log")
      r3.logger.error(l3);
    else
      throw new Error(l3);
  }
}
ti.validateKeywordUsage = Vz;
var so = {};
Object.defineProperty(so, "__esModule", { value: true });
so.extendSubschemaMode = so.extendSubschemaData = so.getSubschema = void 0;
const Gn = Le, QT = tt;
function Yz(t10, { keyword: e3, schemaProp: r3, schema: n3, schemaPath: i3, errSchemaPath: o3, topSchemaRef: s3 }) {
  if (e3 !== void 0 && n3 !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (e3 !== void 0) {
    const a3 = t10.schema[e3];
    return r3 === void 0 ? {
      schema: a3,
      schemaPath: (0, Gn._)`${t10.schemaPath}${(0, Gn.getProperty)(e3)}`,
      errSchemaPath: `${t10.errSchemaPath}/${e3}`
    } : {
      schema: a3[r3],
      schemaPath: (0, Gn._)`${t10.schemaPath}${(0, Gn.getProperty)(e3)}${(0, Gn.getProperty)(r3)}`,
      errSchemaPath: `${t10.errSchemaPath}/${e3}/${(0, QT.escapeFragment)(r3)}`
    };
  }
  if (n3 !== void 0) {
    if (i3 === void 0 || o3 === void 0 || s3 === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: n3,
      schemaPath: i3,
      topSchemaRef: s3,
      errSchemaPath: o3
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
so.getSubschema = Yz;
function Lz(t10, e3, { dataProp: r3, dataPropType: n3, data: i3, dataTypes: o3, propertyName: s3 }) {
  if (i3 !== void 0 && r3 !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: a3 } = e3;
  if (r3 !== void 0) {
    const { errorPath: u3, dataPathArr: c3, opts: f3 } = e3, d3 = a3.let("data", (0, Gn._)`${e3.data}${(0, Gn.getProperty)(r3)}`, true);
    l3(d3), t10.errorPath = (0, Gn.str)`${u3}${(0, QT.getErrorPath)(r3, n3, f3.jsPropertySyntax)}`, t10.parentDataProperty = (0, Gn._)`${r3}`, t10.dataPathArr = [...c3, t10.parentDataProperty];
  }
  if (i3 !== void 0) {
    const u3 = i3 instanceof Gn.Name ? i3 : a3.let("data", i3, true);
    l3(u3), s3 !== void 0 && (t10.propertyName = s3);
  }
  o3 && (t10.dataTypes = o3);
  function l3(u3) {
    t10.data = u3, t10.dataLevel = e3.dataLevel + 1, t10.dataTypes = [], e3.definedProperties = /* @__PURE__ */ new Set(), t10.parentData = e3.data, t10.dataNames = [...e3.dataNames, u3];
  }
}
so.extendSubschemaData = Lz;
function Bz(t10, { jtdDiscriminator: e3, jtdMetadata: r3, compositeRule: n3, createErrors: i3, allErrors: o3 }) {
  n3 !== void 0 && (t10.compositeRule = n3), i3 !== void 0 && (t10.createErrors = i3), o3 !== void 0 && (t10.allErrors = o3), t10.jtdDiscriminator = e3, t10.jtdMetadata = r3;
}
so.extendSubschemaMode = Bz;
var fr = {}, TT = function t5(e3, r3) {
  if (e3 === r3)
    return true;
  if (e3 && r3 && typeof e3 == "object" && typeof r3 == "object") {
    if (e3.constructor !== r3.constructor)
      return false;
    var n3, i3, o3;
    if (Array.isArray(e3)) {
      if (n3 = e3.length, n3 != r3.length)
        return false;
      for (i3 = n3; i3-- !== 0; )
        if (!t5(e3[i3], r3[i3]))
          return false;
      return true;
    }
    if (e3.constructor === RegExp)
      return e3.source === r3.source && e3.flags === r3.flags;
    if (e3.valueOf !== Object.prototype.valueOf)
      return e3.valueOf() === r3.valueOf();
    if (e3.toString !== Object.prototype.toString)
      return e3.toString() === r3.toString();
    if (o3 = Object.keys(e3), n3 = o3.length, n3 !== Object.keys(r3).length)
      return false;
    for (i3 = n3; i3-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r3, o3[i3]))
        return false;
    for (i3 = n3; i3-- !== 0; ) {
      var s3 = o3[i3];
      if (!t5(e3[s3], r3[s3]))
        return false;
    }
    return true;
  }
  return e3 !== e3 && r3 !== r3;
}, kT = { exports: {} }, no = kT.exports = function(t10, e3, r3) {
  typeof e3 == "function" && (r3 = e3, e3 = {}), r3 = e3.cb || r3;
  var n3 = typeof r3 == "function" ? r3 : r3.pre || function() {
  }, i3 = r3.post || function() {
  };
  qc(e3, n3, i3, t10, "", t10);
};
no.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
no.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
no.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
no.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function qc(t10, e3, r3, n3, i3, o3, s3, a3, l3, u3) {
  if (n3 && typeof n3 == "object" && !Array.isArray(n3)) {
    e3(n3, i3, o3, s3, a3, l3, u3);
    for (var c3 in n3) {
      var f3 = n3[c3];
      if (Array.isArray(f3)) {
        if (c3 in no.arrayKeywords)
          for (var d3 = 0; d3 < f3.length; d3++)
            qc(t10, e3, r3, f3[d3], i3 + "/" + c3 + "/" + d3, o3, i3, c3, n3, d3);
      } else if (c3 in no.propsKeywords) {
        if (f3 && typeof f3 == "object")
          for (var p10 in f3)
            qc(t10, e3, r3, f3[p10], i3 + "/" + c3 + "/" + zz(p10), o3, i3, c3, n3, p10);
      } else
        (c3 in no.keywords || t10.allKeys && !(c3 in no.skipKeywords)) && qc(t10, e3, r3, f3, i3 + "/" + c3, o3, i3, c3, n3);
    }
    r3(n3, i3, o3, s3, a3, l3, u3);
  }
}
function zz(t10) {
  return t10.replace(/~/g, "~0").replace(/\//g, "~1");
}
var Hz = kT.exports;
Object.defineProperty(fr, "__esModule", { value: true });
fr.getSchemaRefs = fr.resolveUrl = fr.normalizeId = fr._getFullPath = fr.getFullPath = fr.inlineRef = void 0;
const Gz = tt, Kz = TT, Jz = Hz, eH = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function tH(t10, e3 = true) {
  return typeof t10 == "boolean" ? true : e3 === true ? !_m(t10) : e3 ? ET(t10) <= e3 : false;
}
fr.inlineRef = tH;
const rH = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function _m(t10) {
  for (const e3 in t10) {
    if (rH.has(e3))
      return true;
    const r3 = t10[e3];
    if (Array.isArray(r3) && r3.some(_m) || typeof r3 == "object" && _m(r3))
      return true;
  }
  return false;
}
function ET(t10) {
  let e3 = 0;
  for (const r3 in t10) {
    if (r3 === "$ref")
      return 1 / 0;
    if (e3++, !eH.has(r3) && (typeof t10[r3] == "object" && (0, Gz.eachItem)(t10[r3], (n3) => e3 += ET(n3)), e3 === 1 / 0))
      return 1 / 0;
  }
  return e3;
}
function CT(t10, e3 = "", r3) {
  r3 !== false && (e3 = na(e3));
  const n3 = t10.parse(e3);
  return RT(t10, n3);
}
fr.getFullPath = CT;
function RT(t10, e3) {
  return t10.serialize(e3).split("#")[0] + "#";
}
fr._getFullPath = RT;
const nH = /#\/?$/;
function na(t10) {
  return t10 ? t10.replace(nH, "") : "";
}
fr.normalizeId = na;
function iH(t10, e3, r3) {
  return r3 = na(r3), t10.resolve(e3, r3);
}
fr.resolveUrl = iH;
const oH = /^[a-z_][-a-z0-9._]*$/i;
function sH(t10, e3) {
  if (typeof t10 == "boolean")
    return {};
  const { schemaId: r3, uriResolver: n3 } = this.opts, i3 = na(t10[r3] || e3), o3 = { "": i3 }, s3 = CT(n3, i3, false), a3 = {}, l3 = /* @__PURE__ */ new Set();
  return Jz(t10, { allKeys: true }, (f3, d3, p10, h10) => {
    if (h10 === void 0)
      return;
    const m10 = s3 + d3;
    let O10 = o3[h10];
    typeof f3[r3] == "string" && (O10 = g.call(this, f3[r3])), v10.call(this, f3.$anchor), v10.call(this, f3.$dynamicAnchor), o3[d3] = O10;
    function g(S10) {
      const $10 = this.opts.uriResolver.resolve;
      if (S10 = na(O10 ? $10(O10, S10) : S10), l3.has(S10))
        throw c3(S10);
      l3.add(S10);
      let _10 = this.refs[S10];
      return typeof _10 == "string" && (_10 = this.refs[_10]), typeof _10 == "object" ? u3(f3, _10.schema, S10) : S10 !== na(m10) && (S10[0] === "#" ? (u3(f3, a3[S10], S10), a3[S10] = f3) : this.refs[S10] = m10), S10;
    }
    function v10(S10) {
      if (typeof S10 == "string") {
        if (!oH.test(S10))
          throw new Error(`invalid anchor "${S10}"`);
        g.call(this, `#${S10}`);
      }
    }
  }), a3;
  function u3(f3, d3, p10) {
    if (d3 !== void 0 && !Kz(f3, d3))
      throw c3(p10);
  }
  function c3(f3) {
    return new Error(`reference "${f3}" resolves to more than one schema`);
  }
}
fr.getSchemaRefs = sH;
Object.defineProperty(kn, "__esModule", { value: true });
kn.getData = kn.KeywordCxt = kn.validateFunctionCode = void 0;
const AT = ya, LS = $u, w0 = Ti, kf = $u, aH = bd, bl = ti, ip = so, Ce = Le, Ne = nn, lH = fr, ki = tt, el = Su;
function uH(t10) {
  if (DT(t10) && (jT(t10), qT(t10))) {
    dH(t10);
    return;
  }
  XT(t10, () => (0, AT.topBoolOrEmptySchema)(t10));
}
kn.validateFunctionCode = uH;
function XT({ gen: t10, validateName: e3, schema: r3, schemaEnv: n3, opts: i3 }, o3) {
  i3.code.es5 ? t10.func(e3, (0, Ce._)`${Ne.default.data}, ${Ne.default.valCxt}`, n3.$async, () => {
    t10.code((0, Ce._)`"use strict"; ${BS(r3, i3)}`), fH(t10, i3), t10.code(o3);
  }) : t10.func(e3, (0, Ce._)`${Ne.default.data}, ${cH(i3)}`, n3.$async, () => t10.code(BS(r3, i3)).code(o3));
}
function cH(t10) {
  return (0, Ce._)`{${Ne.default.instancePath}="", ${Ne.default.parentData}, ${Ne.default.parentDataProperty}, ${Ne.default.rootData}=${Ne.default.data}${t10.dynamicRef ? (0, Ce._)`, ${Ne.default.dynamicAnchors}={}` : Ce.nil}}={}`;
}
function fH(t10, e3) {
  t10.if(Ne.default.valCxt, () => {
    t10.var(Ne.default.instancePath, (0, Ce._)`${Ne.default.valCxt}.${Ne.default.instancePath}`), t10.var(Ne.default.parentData, (0, Ce._)`${Ne.default.valCxt}.${Ne.default.parentData}`), t10.var(Ne.default.parentDataProperty, (0, Ce._)`${Ne.default.valCxt}.${Ne.default.parentDataProperty}`), t10.var(Ne.default.rootData, (0, Ce._)`${Ne.default.valCxt}.${Ne.default.rootData}`), e3.dynamicRef && t10.var(Ne.default.dynamicAnchors, (0, Ce._)`${Ne.default.valCxt}.${Ne.default.dynamicAnchors}`);
  }, () => {
    t10.var(Ne.default.instancePath, (0, Ce._)`""`), t10.var(Ne.default.parentData, (0, Ce._)`undefined`), t10.var(Ne.default.parentDataProperty, (0, Ce._)`undefined`), t10.var(Ne.default.rootData, Ne.default.data), e3.dynamicRef && t10.var(Ne.default.dynamicAnchors, (0, Ce._)`{}`);
  });
}
function dH(t10) {
  const { schema: e3, opts: r3, gen: n3 } = t10;
  XT(t10, () => {
    r3.$comment && e3.$comment && IT(t10), gH(t10), n3.let(Ne.default.vErrors, null), n3.let(Ne.default.errors, 0), r3.unevaluated && hH(t10), UT(t10), bH(t10);
  });
}
function hH(t10) {
  const { gen: e3, validateName: r3 } = t10;
  t10.evaluated = e3.const("evaluated", (0, Ce._)`${r3}.evaluated`), e3.if((0, Ce._)`${t10.evaluated}.dynamicProps`, () => e3.assign((0, Ce._)`${t10.evaluated}.props`, (0, Ce._)`undefined`)), e3.if((0, Ce._)`${t10.evaluated}.dynamicItems`, () => e3.assign((0, Ce._)`${t10.evaluated}.items`, (0, Ce._)`undefined`));
}
function BS(t10, e3) {
  const r3 = typeof t10 == "object" && t10[e3.schemaId];
  return r3 && (e3.code.source || e3.code.process) ? (0, Ce._)`/*# sourceURL=${r3} */` : Ce.nil;
}
function pH(t10, e3) {
  if (DT(t10) && (jT(t10), qT(t10))) {
    OH(t10, e3);
    return;
  }
  (0, AT.boolOrEmptySchema)(t10, e3);
}
function qT({ schema: t10, self: e3 }) {
  if (typeof t10 == "boolean")
    return !t10;
  for (const r3 in t10)
    if (e3.RULES.all[r3])
      return true;
  return false;
}
function DT(t10) {
  return typeof t10.schema != "boolean";
}
function OH(t10, e3) {
  const { schema: r3, gen: n3, opts: i3 } = t10;
  i3.$comment && r3.$comment && IT(t10), yH(t10), vH(t10);
  const o3 = n3.const("_errs", Ne.default.errors);
  UT(t10, o3), n3.var(e3, (0, Ce._)`${o3} === ${Ne.default.errors}`);
}
function jT(t10) {
  (0, ki.checkUnknownRules)(t10), mH(t10);
}
function UT(t10, e3) {
  if (t10.opts.jtd)
    return zS(t10, [], false, e3);
  const r3 = (0, LS.getSchemaTypes)(t10.schema), n3 = (0, LS.coerceAndCheckDataType)(t10, r3);
  zS(t10, r3, !n3, e3);
}
function mH(t10) {
  const { schema: e3, errSchemaPath: r3, opts: n3, self: i3 } = t10;
  e3.$ref && n3.ignoreKeywordsWithRef && (0, ki.schemaHasRulesButRef)(e3, i3.RULES) && i3.logger.warn(`$ref: keywords ignored in schema at path "${r3}"`);
}
function gH(t10) {
  const { schema: e3, opts: r3 } = t10;
  e3.default !== void 0 && r3.useDefaults && r3.strictSchema && (0, ki.checkStrictMode)(t10, "default is ignored in the schema root");
}
function yH(t10) {
  const e3 = t10.schema[t10.opts.schemaId];
  e3 && (t10.baseId = (0, lH.resolveUrl)(t10.opts.uriResolver, t10.baseId, e3));
}
function vH(t10) {
  if (t10.schema.$async && !t10.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function IT({ gen: t10, schemaEnv: e3, schema: r3, errSchemaPath: n3, opts: i3 }) {
  const o3 = r3.$comment;
  if (i3.$comment === true)
    t10.code((0, Ce._)`${Ne.default.self}.logger.log(${o3})`);
  else if (typeof i3.$comment == "function") {
    const s3 = (0, Ce.str)`${n3}/$comment`, a3 = t10.scopeValue("root", { ref: e3.root });
    t10.code((0, Ce._)`${Ne.default.self}.opts.$comment(${o3}, ${s3}, ${a3}.schema)`);
  }
}
function bH(t10) {
  const { gen: e3, schemaEnv: r3, validateName: n3, ValidationError: i3, opts: o3 } = t10;
  r3.$async ? e3.if((0, Ce._)`${Ne.default.errors} === 0`, () => e3.return(Ne.default.data), () => e3.throw((0, Ce._)`new ${i3}(${Ne.default.vErrors})`)) : (e3.assign((0, Ce._)`${n3}.errors`, Ne.default.vErrors), o3.unevaluated && SH(t10), e3.return((0, Ce._)`${Ne.default.errors} === 0`));
}
function SH({ gen: t10, evaluated: e3, props: r3, items: n3 }) {
  r3 instanceof Ce.Name && t10.assign((0, Ce._)`${e3}.props`, r3), n3 instanceof Ce.Name && t10.assign((0, Ce._)`${e3}.items`, n3);
}
function zS(t10, e3, r3, n3) {
  const { gen: i3, schema: o3, data: s3, allErrors: a3, opts: l3, self: u3 } = t10, { RULES: c3 } = u3;
  if (o3.$ref && (l3.ignoreKeywordsWithRef || !(0, ki.schemaHasRulesButRef)(o3, c3))) {
    i3.block(() => MT(t10, "$ref", c3.all.$ref.definition));
    return;
  }
  l3.jtd || $H(t10, e3), i3.block(() => {
    for (const d3 of c3.rules)
      f3(d3);
    f3(c3.post);
  });
  function f3(d3) {
    (0, w0.shouldUseGroup)(o3, d3) && (d3.type ? (i3.if((0, kf.checkDataType)(d3.type, s3, l3.strictNumbers)), HS(t10, d3), e3.length === 1 && e3[0] === d3.type && r3 && (i3.else(), (0, kf.reportTypeError)(t10)), i3.endIf()) : HS(t10, d3), a3 || i3.if((0, Ce._)`${Ne.default.errors} === ${n3 || 0}`));
  }
}
function HS(t10, e3) {
  const { gen: r3, schema: n3, opts: { useDefaults: i3 } } = t10;
  i3 && (0, aH.assignDefaults)(t10, e3.type), r3.block(() => {
    for (const o3 of e3.rules)
      (0, w0.shouldUseRule)(n3, o3) && MT(t10, o3.keyword, o3.definition, e3.type);
  });
}
function $H(t10, e3) {
  t10.schemaEnv.meta || !t10.opts.strictTypes || (wH(t10, e3), t10.opts.allowUnionTypes || PH(t10, e3), _H(t10, t10.dataTypes));
}
function wH(t10, e3) {
  if (e3.length) {
    if (!t10.dataTypes.length) {
      t10.dataTypes = e3;
      return;
    }
    e3.forEach((r3) => {
      FT(t10.dataTypes, r3) || P0(t10, `type "${r3}" not allowed by context "${t10.dataTypes.join(",")}"`);
    }), QH(t10, e3);
  }
}
function PH(t10, e3) {
  e3.length > 1 && !(e3.length === 2 && e3.includes("null")) && P0(t10, "use allowUnionTypes to allow union type keyword");
}
function _H(t10, e3) {
  const r3 = t10.self.RULES.all;
  for (const n3 in r3) {
    const i3 = r3[n3];
    if (typeof i3 == "object" && (0, w0.shouldUseRule)(t10.schema, i3)) {
      const { type: o3 } = i3.definition;
      o3.length && !o3.some((s3) => xH(e3, s3)) && P0(t10, `missing type "${o3.join(",")}" for keyword "${n3}"`);
    }
  }
}
function xH(t10, e3) {
  return t10.includes(e3) || e3 === "number" && t10.includes("integer");
}
function FT(t10, e3) {
  return t10.includes(e3) || e3 === "integer" && t10.includes("number");
}
function QH(t10, e3) {
  const r3 = [];
  for (const n3 of t10.dataTypes)
    FT(e3, n3) ? r3.push(n3) : e3.includes("integer") && n3 === "number" && r3.push("integer");
  t10.dataTypes = r3;
}
function P0(t10, e3) {
  const r3 = t10.schemaEnv.baseId + t10.errSchemaPath;
  e3 += ` at "${r3}" (strictTypes)`, (0, ki.checkStrictMode)(t10, e3, t10.opts.strictTypes);
}
class ZT {
  constructor(e3, r3, n3) {
    if ((0, bl.validateKeywordUsage)(e3, r3, n3), this.gen = e3.gen, this.allErrors = e3.allErrors, this.keyword = n3, this.data = e3.data, this.schema = e3.schema[n3], this.$data = r3.$data && e3.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, ki.schemaRefOrVal)(e3, this.schema, n3, this.$data), this.schemaType = r3.schemaType, this.parentSchema = e3.schema, this.params = {}, this.it = e3, this.def = r3, this.$data)
      this.schemaCode = e3.gen.const("vSchema", NT(this.$data, e3));
    else if (this.schemaCode = this.schemaValue, !(0, bl.validSchemaType)(this.schema, r3.schemaType, r3.allowUndefined))
      throw new Error(`${n3} value must be ${JSON.stringify(r3.schemaType)}`);
    ("code" in r3 ? r3.trackErrors : r3.errors !== false) && (this.errsCount = e3.gen.const("_errs", Ne.default.errors));
  }
  result(e3, r3, n3) {
    this.failResult((0, Ce.not)(e3), r3, n3);
  }
  failResult(e3, r3, n3) {
    this.gen.if(e3), n3 ? n3() : this.error(), r3 ? (this.gen.else(), r3(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(e3, r3) {
    this.failResult((0, Ce.not)(e3), void 0, r3);
  }
  fail(e3) {
    if (e3 === void 0) {
      this.error(), this.allErrors || this.gen.if(false);
      return;
    }
    this.gen.if(e3), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(e3) {
    if (!this.$data)
      return this.fail(e3);
    const { schemaCode: r3 } = this;
    this.fail((0, Ce._)`${r3} !== undefined && (${(0, Ce.or)(this.invalid$data(), e3)})`);
  }
  error(e3, r3, n3) {
    if (r3) {
      this.setParams(r3), this._error(e3, n3), this.setParams({});
      return;
    }
    this._error(e3, n3);
  }
  _error(e3, r3) {
    (e3 ? el.reportExtraError : el.reportError)(this, this.def.error, r3);
  }
  $dataError() {
    (0, el.reportError)(this, this.def.$dataError || el.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, el.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(e3) {
    this.allErrors || this.gen.if(e3);
  }
  setParams(e3, r3) {
    r3 ? Object.assign(this.params, e3) : this.params = e3;
  }
  block$data(e3, r3, n3 = Ce.nil) {
    this.gen.block(() => {
      this.check$data(e3, n3), r3();
    });
  }
  check$data(e3 = Ce.nil, r3 = Ce.nil) {
    if (!this.$data)
      return;
    const { gen: n3, schemaCode: i3, schemaType: o3, def: s3 } = this;
    n3.if((0, Ce.or)((0, Ce._)`${i3} === undefined`, r3)), e3 !== Ce.nil && n3.assign(e3, true), (o3.length || s3.validateSchema) && (n3.elseIf(this.invalid$data()), this.$dataError(), e3 !== Ce.nil && n3.assign(e3, false)), n3.else();
  }
  invalid$data() {
    const { gen: e3, schemaCode: r3, schemaType: n3, def: i3, it: o3 } = this;
    return (0, Ce.or)(s3(), a3());
    function s3() {
      if (n3.length) {
        if (!(r3 instanceof Ce.Name))
          throw new Error("ajv implementation error");
        const l3 = Array.isArray(n3) ? n3 : [n3];
        return (0, Ce._)`${(0, kf.checkDataTypes)(l3, r3, o3.opts.strictNumbers, kf.DataType.Wrong)}`;
      }
      return Ce.nil;
    }
    function a3() {
      if (i3.validateSchema) {
        const l3 = e3.scopeValue("validate$data", { ref: i3.validateSchema });
        return (0, Ce._)`!${l3}(${r3})`;
      }
      return Ce.nil;
    }
  }
  subschema(e3, r3) {
    const n3 = (0, ip.getSubschema)(this.it, e3);
    (0, ip.extendSubschemaData)(n3, this.it, e3), (0, ip.extendSubschemaMode)(n3, e3);
    const i3 = { ...this.it, ...n3, items: void 0, props: void 0 };
    return pH(i3, r3), i3;
  }
  mergeEvaluated(e3, r3) {
    const { it: n3, gen: i3 } = this;
    n3.opts.unevaluated && (n3.props !== true && e3.props !== void 0 && (n3.props = ki.mergeEvaluated.props(i3, e3.props, n3.props, r3)), n3.items !== true && e3.items !== void 0 && (n3.items = ki.mergeEvaluated.items(i3, e3.items, n3.items, r3)));
  }
  mergeValidEvaluated(e3, r3) {
    const { it: n3, gen: i3 } = this;
    if (n3.opts.unevaluated && (n3.props !== true || n3.items !== true))
      return i3.if(r3, () => this.mergeEvaluated(e3, Ce.Name)), true;
  }
}
kn.KeywordCxt = ZT;
function MT(t10, e3, r3, n3) {
  const i3 = new ZT(t10, r3, e3);
  "code" in r3 ? r3.code(i3, n3) : i3.$data && r3.validate ? (0, bl.funcKeywordCode)(i3, r3) : "macro" in r3 ? (0, bl.macroKeywordCode)(i3, r3) : (r3.compile || r3.validate) && (0, bl.funcKeywordCode)(i3, r3);
}
const TH = /^\/(?:[^~]|~0|~1)*$/, kH = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function NT(t10, { dataLevel: e3, dataNames: r3, dataPathArr: n3 }) {
  let i3, o3;
  if (t10 === "")
    return Ne.default.rootData;
  if (t10[0] === "/") {
    if (!TH.test(t10))
      throw new Error(`Invalid JSON-pointer: ${t10}`);
    i3 = t10, o3 = Ne.default.rootData;
  } else {
    const u3 = kH.exec(t10);
    if (!u3)
      throw new Error(`Invalid JSON-pointer: ${t10}`);
    const c3 = +u3[1];
    if (i3 = u3[2], i3 === "#") {
      if (c3 >= e3)
        throw new Error(l3("property/index", c3));
      return n3[e3 - c3];
    }
    if (c3 > e3)
      throw new Error(l3("data", c3));
    if (o3 = r3[e3 - c3], !i3)
      return o3;
  }
  let s3 = o3;
  const a3 = i3.split("/");
  for (const u3 of a3)
    u3 && (o3 = (0, Ce._)`${o3}${(0, Ce.getProperty)((0, ki.unescapeJsonPointer)(u3))}`, s3 = (0, Ce._)`${s3} && ${o3}`);
  return s3;
  function l3(u3, c3) {
    return `Cannot access ${u3} ${c3} levels up, current level is ${e3}`;
  }
}
kn.getData = NT;
var wu = {};
Object.defineProperty(wu, "__esModule", { value: true });
class EH extends Error {
  constructor(e3) {
    super("validation failed"), this.errors = e3, this.ajv = this.validation = true;
  }
}
wu.default = EH;
var Pu = {};
Object.defineProperty(Pu, "__esModule", { value: true });
const op = fr;
class CH extends Error {
  constructor(e3, r3, n3, i3) {
    super(i3 || `can't resolve reference ${n3} from id ${r3}`), this.missingRef = (0, op.resolveUrl)(e3, r3, n3), this.missingSchema = (0, op.normalizeId)((0, op.getFullPath)(e3, this.missingRef));
  }
}
Pu.default = CH;
var Cr = {};
Object.defineProperty(Cr, "__esModule", { value: true });
Cr.resolveSchema = Cr.getCompilingSchema = Cr.resolveRef = Cr.compileSchema = Cr.SchemaEnv = void 0;
const vn = Le, RH = wu, Eo = nn, _n = fr, GS = tt, AH = kn;
class Sd {
  constructor(e3) {
    var r3;
    this.refs = {}, this.dynamicAnchors = {};
    let n3;
    typeof e3.schema == "object" && (n3 = e3.schema), this.schema = e3.schema, this.schemaId = e3.schemaId, this.root = e3.root || this, this.baseId = (r3 = e3.baseId) !== null && r3 !== void 0 ? r3 : (0, _n.normalizeId)(n3 == null ? void 0 : n3[e3.schemaId || "$id"]), this.schemaPath = e3.schemaPath, this.localRefs = e3.localRefs, this.meta = e3.meta, this.$async = n3 == null ? void 0 : n3.$async, this.refs = {};
  }
}
Cr.SchemaEnv = Sd;
function _0(t10) {
  const e3 = WT.call(this, t10);
  if (e3)
    return e3;
  const r3 = (0, _n.getFullPath)(this.opts.uriResolver, t10.root.baseId), { es5: n3, lines: i3 } = this.opts.code, { ownProperties: o3 } = this.opts, s3 = new vn.CodeGen(this.scope, { es5: n3, lines: i3, ownProperties: o3 });
  let a3;
  t10.$async && (a3 = s3.scopeValue("Error", {
    ref: RH.default,
    code: (0, vn._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const l3 = s3.scopeName("validate");
  t10.validateName = l3;
  const u3 = {
    gen: s3,
    allErrors: this.opts.allErrors,
    data: Eo.default.data,
    parentData: Eo.default.parentData,
    parentDataProperty: Eo.default.parentDataProperty,
    dataNames: [Eo.default.data],
    dataPathArr: [vn.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: s3.scopeValue("schema", this.opts.code.source === true ? { ref: t10.schema, code: (0, vn.stringify)(t10.schema) } : { ref: t10.schema }),
    validateName: l3,
    ValidationError: a3,
    schema: t10.schema,
    schemaEnv: t10,
    rootId: r3,
    baseId: t10.baseId || r3,
    schemaPath: vn.nil,
    errSchemaPath: t10.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, vn._)`""`,
    opts: this.opts,
    self: this
  };
  let c3;
  try {
    this._compilations.add(t10), (0, AH.validateFunctionCode)(u3), s3.optimize(this.opts.code.optimize);
    const f3 = s3.toString();
    c3 = `${s3.scopeRefs(Eo.default.scope)}return ${f3}`, this.opts.code.process && (c3 = this.opts.code.process(c3, t10));
    const p10 = new Function(`${Eo.default.self}`, `${Eo.default.scope}`, c3)(this, this.scope.get());
    if (this.scope.value(l3, { ref: p10 }), p10.errors = null, p10.schema = t10.schema, p10.schemaEnv = t10, t10.$async && (p10.$async = true), this.opts.code.source === true && (p10.source = { validateName: l3, validateCode: f3, scopeValues: s3._values }), this.opts.unevaluated) {
      const { props: h10, items: m10 } = u3;
      p10.evaluated = {
        props: h10 instanceof vn.Name ? void 0 : h10,
        items: m10 instanceof vn.Name ? void 0 : m10,
        dynamicProps: h10 instanceof vn.Name,
        dynamicItems: m10 instanceof vn.Name
      }, p10.source && (p10.source.evaluated = (0, vn.stringify)(p10.evaluated));
    }
    return t10.validate = p10, t10;
  } catch (f3) {
    throw delete t10.validate, delete t10.validateName, c3 && this.logger.error("Error compiling schema, function code:", c3), f3;
  } finally {
    this._compilations.delete(t10);
  }
}
Cr.compileSchema = _0;
function XH(t10, e3, r3) {
  var n3;
  r3 = (0, _n.resolveUrl)(this.opts.uriResolver, e3, r3);
  const i3 = t10.refs[r3];
  if (i3)
    return i3;
  let o3 = jH.call(this, t10, r3);
  if (o3 === void 0) {
    const s3 = (n3 = t10.localRefs) === null || n3 === void 0 ? void 0 : n3[r3], { schemaId: a3 } = this.opts;
    s3 && (o3 = new Sd({ schema: s3, schemaId: a3, root: t10, baseId: e3 }));
  }
  if (o3 !== void 0)
    return t10.refs[r3] = qH.call(this, o3);
}
Cr.resolveRef = XH;
function qH(t10) {
  return (0, _n.inlineRef)(t10.schema, this.opts.inlineRefs) ? t10.schema : t10.validate ? t10 : _0.call(this, t10);
}
function WT(t10) {
  for (const e3 of this._compilations)
    if (DH(e3, t10))
      return e3;
}
Cr.getCompilingSchema = WT;
function DH(t10, e3) {
  return t10.schema === e3.schema && t10.root === e3.root && t10.baseId === e3.baseId;
}
function jH(t10, e3) {
  let r3;
  for (; typeof (r3 = this.refs[e3]) == "string"; )
    e3 = r3;
  return r3 || this.schemas[e3] || $d.call(this, t10, e3);
}
function $d(t10, e3) {
  const r3 = this.opts.uriResolver.parse(e3), n3 = (0, _n._getFullPath)(this.opts.uriResolver, r3);
  let i3 = (0, _n.getFullPath)(this.opts.uriResolver, t10.baseId, void 0);
  if (Object.keys(t10.schema).length > 0 && n3 === i3)
    return sp.call(this, r3, t10);
  const o3 = (0, _n.normalizeId)(n3), s3 = this.refs[o3] || this.schemas[o3];
  if (typeof s3 == "string") {
    const a3 = $d.call(this, t10, s3);
    return typeof (a3 == null ? void 0 : a3.schema) != "object" ? void 0 : sp.call(this, r3, a3);
  }
  if (typeof (s3 == null ? void 0 : s3.schema) == "object") {
    if (s3.validate || _0.call(this, s3), o3 === (0, _n.normalizeId)(e3)) {
      const { schema: a3 } = s3, { schemaId: l3 } = this.opts, u3 = a3[l3];
      return u3 && (i3 = (0, _n.resolveUrl)(this.opts.uriResolver, i3, u3)), new Sd({ schema: a3, schemaId: l3, root: t10, baseId: i3 });
    }
    return sp.call(this, r3, s3);
  }
}
Cr.resolveSchema = $d;
const UH = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function sp(t10, { baseId: e3, schema: r3, root: n3 }) {
  var i3;
  if (((i3 = t10.fragment) === null || i3 === void 0 ? void 0 : i3[0]) !== "/")
    return;
  for (const a3 of t10.fragment.slice(1).split("/")) {
    if (typeof r3 == "boolean")
      return;
    const l3 = r3[(0, GS.unescapeFragment)(a3)];
    if (l3 === void 0)
      return;
    r3 = l3;
    const u3 = typeof r3 == "object" && r3[this.opts.schemaId];
    !UH.has(a3) && u3 && (e3 = (0, _n.resolveUrl)(this.opts.uriResolver, e3, u3));
  }
  let o3;
  if (typeof r3 != "boolean" && r3.$ref && !(0, GS.schemaHasRulesButRef)(r3, this.RULES)) {
    const a3 = (0, _n.resolveUrl)(this.opts.uriResolver, e3, r3.$ref);
    o3 = $d.call(this, n3, a3);
  }
  const { schemaId: s3 } = this.opts;
  if (o3 = o3 || new Sd({ schema: r3, schemaId: s3, root: n3, baseId: e3 }), o3.schema !== o3.root.schema)
    return o3;
}
const IH = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", FH = "Meta-schema for $data reference (JSON AnySchema extension proposal)", ZH = "object", MH = [
  "$data"
], NH = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, WH = false, VH = {
  $id: IH,
  description: FH,
  type: ZH,
  required: MH,
  properties: NH,
  additionalProperties: WH
};
var x0 = {}, xm = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(t10, e3) {
  (function(r3, n3) {
    n3(e3);
  })(yt, function(r3) {
    function n3() {
      for (var W10 = arguments.length, I10 = Array(W10), Y = 0; Y < W10; Y++)
        I10[Y] = arguments[Y];
      if (I10.length > 1) {
        I10[0] = I10[0].slice(0, -1);
        for (var ee = I10.length - 1, J5 = 1; J5 < ee; ++J5)
          I10[J5] = I10[J5].slice(1, -1);
        return I10[ee] = I10[ee].slice(1), I10.join("");
      } else
        return I10[0];
    }
    function i3(W10) {
      return "(?:" + W10 + ")";
    }
    function o3(W10) {
      return W10 === void 0 ? "undefined" : W10 === null ? "null" : Object.prototype.toString.call(W10).split(" ").pop().split("]").shift().toLowerCase();
    }
    function s3(W10) {
      return W10.toUpperCase();
    }
    function a3(W10) {
      return W10 != null ? W10 instanceof Array ? W10 : typeof W10.length != "number" || W10.split || W10.setInterval || W10.call ? [W10] : Array.prototype.slice.call(W10) : [];
    }
    function l3(W10, I10) {
      var Y = W10;
      if (I10)
        for (var ee in I10)
          Y[ee] = I10[ee];
      return Y;
    }
    function u3(W10) {
      var I10 = "[A-Za-z]", Y = "[0-9]", ee = n3(Y, "[A-Fa-f]"), J5 = i3(i3("%[EFef]" + ee + "%" + ee + ee + "%" + ee + ee) + "|" + i3("%[89A-Fa-f]" + ee + "%" + ee + ee) + "|" + i3("%" + ee + ee)), Ae = "[\\:\\/\\?\\#\\[\\]\\@]", De = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", it = n3(Ae, De), wt = W10 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", Ut = W10 ? "[\\uE000-\\uF8FF]" : "[]", rt2 = n3(I10, Y, "[\\-\\.\\_\\~]", wt);
      i3(I10 + n3(I10, Y, "[\\+\\-\\.]") + "*"), i3(i3(J5 + "|" + n3(rt2, De, "[\\:]")) + "*");
      var St = i3(i3("25[0-5]") + "|" + i3("2[0-4]" + Y) + "|" + i3("1" + Y + Y) + "|" + i3("0?[1-9]" + Y) + "|0?0?" + Y), It = i3(St + "\\." + St + "\\." + St + "\\." + St), Ve2 = i3(ee + "{1,4}"), Et = i3(i3(Ve2 + "\\:" + Ve2) + "|" + It), Wt = i3(i3(Ve2 + "\\:") + "{6}" + Et), Ct = i3("\\:\\:" + i3(Ve2 + "\\:") + "{5}" + Et), Wi = i3(i3(Ve2) + "?\\:\\:" + i3(Ve2 + "\\:") + "{4}" + Et), qn = i3(i3(i3(Ve2 + "\\:") + "{0,1}" + Ve2) + "?\\:\\:" + i3(Ve2 + "\\:") + "{3}" + Et), Dn = i3(i3(i3(Ve2 + "\\:") + "{0,2}" + Ve2) + "?\\:\\:" + i3(Ve2 + "\\:") + "{2}" + Et), Ss = i3(i3(i3(Ve2 + "\\:") + "{0,3}" + Ve2) + "?\\:\\:" + Ve2 + "\\:" + Et), Qo2 = i3(i3(i3(Ve2 + "\\:") + "{0,4}" + Ve2) + "?\\:\\:" + Et), sn = i3(i3(i3(Ve2 + "\\:") + "{0,5}" + Ve2) + "?\\:\\:" + Ve2), jn = i3(i3(i3(Ve2 + "\\:") + "{0,6}" + Ve2) + "?\\:\\:"), To2 = i3([Wt, Ct, Wi, qn, Dn, Ss, Qo2, sn, jn].join("|")), Oi = i3(i3(rt2 + "|" + J5) + "+");
      i3("[vV]" + ee + "+\\." + n3(rt2, De, "[\\:]") + "+"), i3(i3(J5 + "|" + n3(rt2, De)) + "*");
      var Ia = i3(J5 + "|" + n3(rt2, De, "[\\:\\@]"));
      return i3(i3(J5 + "|" + n3(rt2, De, "[\\@]")) + "+"), i3(i3(Ia + "|" + n3("[\\/\\?]", Ut)) + "*"), {
        NOT_SCHEME: new RegExp(n3("[^]", I10, Y, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(n3("[^\\%\\:]", rt2, De), "g"),
        NOT_HOST: new RegExp(n3("[^\\%\\[\\]\\:]", rt2, De), "g"),
        NOT_PATH: new RegExp(n3("[^\\%\\/\\:\\@]", rt2, De), "g"),
        NOT_PATH_NOSCHEME: new RegExp(n3("[^\\%\\/\\@]", rt2, De), "g"),
        NOT_QUERY: new RegExp(n3("[^\\%]", rt2, De, "[\\:\\@\\/\\?]", Ut), "g"),
        NOT_FRAGMENT: new RegExp(n3("[^\\%]", rt2, De, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(n3("[^]", rt2, De), "g"),
        UNRESERVED: new RegExp(rt2, "g"),
        OTHER_CHARS: new RegExp(n3("[^\\%]", rt2, it), "g"),
        PCT_ENCODED: new RegExp(J5, "g"),
        IPV4ADDRESS: new RegExp("^(" + It + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + To2 + ")" + i3(i3("\\%25|\\%(?!" + ee + "{2})") + "(" + Oi + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var c3 = u3(false), f3 = u3(true), d3 = function() {
      function W10(I10, Y) {
        var ee = [], J5 = true, Ae = false, De = void 0;
        try {
          for (var it = I10[Symbol.iterator](), wt; !(J5 = (wt = it.next()).done) && (ee.push(wt.value), !(Y && ee.length === Y)); J5 = true)
            ;
        } catch (Ut) {
          Ae = true, De = Ut;
        } finally {
          try {
            !J5 && it.return && it.return();
          } finally {
            if (Ae)
              throw De;
          }
        }
        return ee;
      }
      return function(I10, Y) {
        if (Array.isArray(I10))
          return I10;
        if (Symbol.iterator in Object(I10))
          return W10(I10, Y);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), p10 = function(W10) {
      if (Array.isArray(W10)) {
        for (var I10 = 0, Y = Array(W10.length); I10 < W10.length; I10++)
          Y[I10] = W10[I10];
        return Y;
      } else
        return Array.from(W10);
    }, h10 = 2147483647, m10 = 36, O10 = 1, g = 26, v10 = 38, S10 = 700, $10 = 72, _10 = 128, P10 = "-", q5 = /^xn--/, N5 = /[^\0-\x7E]/, B5 = /[\x2E\u3002\uFF0E\uFF61]/g, H10 = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, ne = m10 - O10, re2 = Math.floor, fe = String.fromCharCode;
    function pe(W10) {
      throw new RangeError(H10[W10]);
    }
    function Ee2(W10, I10) {
      for (var Y = [], ee = W10.length; ee--; )
        Y[ee] = I10(W10[ee]);
      return Y;
    }
    function qe(W10, I10) {
      var Y = W10.split("@"), ee = "";
      Y.length > 1 && (ee = Y[0] + "@", W10 = Y[1]), W10 = W10.replace(B5, ".");
      var J5 = W10.split("."), Ae = Ee2(J5, I10).join(".");
      return ee + Ae;
    }
    function _e(W10) {
      for (var I10 = [], Y = 0, ee = W10.length; Y < ee; ) {
        var J5 = W10.charCodeAt(Y++);
        if (J5 >= 55296 && J5 <= 56319 && Y < ee) {
          var Ae = W10.charCodeAt(Y++);
          (Ae & 64512) == 56320 ? I10.push(((J5 & 1023) << 10) + (Ae & 1023) + 65536) : (I10.push(J5), Y--);
        } else
          I10.push(J5);
      }
      return I10;
    }
    var Ie = function(I10) {
      return String.fromCodePoint.apply(String, p10(I10));
    }, je2 = function(I10) {
      return I10 - 48 < 10 ? I10 - 22 : I10 - 65 < 26 ? I10 - 65 : I10 - 97 < 26 ? I10 - 97 : m10;
    }, G = function(I10, Y) {
      return I10 + 22 + 75 * (I10 < 26) - ((Y != 0) << 5);
    }, Z = function(I10, Y, ee) {
      var J5 = 0;
      for (
        I10 = ee ? re2(I10 / S10) : I10 >> 1, I10 += re2(I10 / Y);
        /* no initialization */
        I10 > ne * g >> 1;
        J5 += m10
      )
        I10 = re2(I10 / ne);
      return re2(J5 + (ne + 1) * I10 / (I10 + v10));
    }, C10 = function(I10) {
      var Y = [], ee = I10.length, J5 = 0, Ae = _10, De = $10, it = I10.lastIndexOf(P10);
      it < 0 && (it = 0);
      for (var wt = 0; wt < it; ++wt)
        I10.charCodeAt(wt) >= 128 && pe("not-basic"), Y.push(I10.charCodeAt(wt));
      for (var Ut = it > 0 ? it + 1 : 0; Ut < ee; ) {
        for (
          var rt2 = J5, St = 1, It = m10;
          ;
          /* no condition */
          It += m10
        ) {
          Ut >= ee && pe("invalid-input");
          var Ve2 = je2(I10.charCodeAt(Ut++));
          (Ve2 >= m10 || Ve2 > re2((h10 - J5) / St)) && pe("overflow"), J5 += Ve2 * St;
          var Et = It <= De ? O10 : It >= De + g ? g : It - De;
          if (Ve2 < Et)
            break;
          var Wt = m10 - Et;
          St > re2(h10 / Wt) && pe("overflow"), St *= Wt;
        }
        var Ct = Y.length + 1;
        De = Z(J5 - rt2, Ct, rt2 == 0), re2(J5 / Ct) > h10 - Ae && pe("overflow"), Ae += re2(J5 / Ct), J5 %= Ct, Y.splice(J5++, 0, Ae);
      }
      return String.fromCodePoint.apply(String, Y);
    }, X10 = function(I10) {
      var Y = [];
      I10 = _e(I10);
      var ee = I10.length, J5 = _10, Ae = 0, De = $10, it = true, wt = false, Ut = void 0;
      try {
        for (var rt2 = I10[Symbol.iterator](), St; !(it = (St = rt2.next()).done); it = true) {
          var It = St.value;
          It < 128 && Y.push(fe(It));
        }
      } catch (Fa) {
        wt = true, Ut = Fa;
      } finally {
        try {
          !it && rt2.return && rt2.return();
        } finally {
          if (wt)
            throw Ut;
        }
      }
      var Ve2 = Y.length, Et = Ve2;
      for (Ve2 && Y.push(P10); Et < ee; ) {
        var Wt = h10, Ct = true, Wi = false, qn = void 0;
        try {
          for (var Dn = I10[Symbol.iterator](), Ss; !(Ct = (Ss = Dn.next()).done); Ct = true) {
            var Qo2 = Ss.value;
            Qo2 >= J5 && Qo2 < Wt && (Wt = Qo2);
          }
        } catch (Fa) {
          Wi = true, qn = Fa;
        } finally {
          try {
            !Ct && Dn.return && Dn.return();
          } finally {
            if (Wi)
              throw qn;
          }
        }
        var sn = Et + 1;
        Wt - J5 > re2((h10 - Ae) / sn) && pe("overflow"), Ae += (Wt - J5) * sn, J5 = Wt;
        var jn = true, To2 = false, Oi = void 0;
        try {
          for (var Ia = I10[Symbol.iterator](), q1; !(jn = (q1 = Ia.next()).done); jn = true) {
            var D1 = q1.value;
            if (D1 < J5 && ++Ae > h10 && pe("overflow"), D1 == J5) {
              for (
                var Au = Ae, Xu = m10;
                ;
                /* no condition */
                Xu += m10
              ) {
                var qu = Xu <= De ? O10 : Xu >= De + g ? g : Xu - De;
                if (Au < qu)
                  break;
                var j1 = Au - qu, U1 = m10 - qu;
                Y.push(fe(G(qu + j1 % U1, 0))), Au = re2(j1 / U1);
              }
              Y.push(fe(G(Au, 0))), De = Z(Ae, sn, Et == Ve2), Ae = 0, ++Et;
            }
          }
        } catch (Fa) {
          To2 = true, Oi = Fa;
        } finally {
          try {
            !jn && Ia.return && Ia.return();
          } finally {
            if (To2)
              throw Oi;
          }
        }
        ++Ae, ++J5;
      }
      return Y.join("");
    }, w10 = function(I10) {
      return qe(I10, function(Y) {
        return q5.test(Y) ? C10(Y.slice(4).toLowerCase()) : Y;
      });
    }, U10 = function(I10) {
      return qe(I10, function(Y) {
        return N5.test(Y) ? "xn--" + X10(Y) : Y;
      });
    }, T10 = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: _e,
        encode: Ie
      },
      decode: C10,
      encode: X10,
      toASCII: U10,
      toUnicode: w10
    }, F5 = {};
    function V3(W10) {
      var I10 = W10.charCodeAt(0), Y = void 0;
      return I10 < 16 ? Y = "%0" + I10.toString(16).toUpperCase() : I10 < 128 ? Y = "%" + I10.toString(16).toUpperCase() : I10 < 2048 ? Y = "%" + (I10 >> 6 | 192).toString(16).toUpperCase() + "%" + (I10 & 63 | 128).toString(16).toUpperCase() : Y = "%" + (I10 >> 12 | 224).toString(16).toUpperCase() + "%" + (I10 >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (I10 & 63 | 128).toString(16).toUpperCase(), Y;
    }
    function ie2(W10) {
      for (var I10 = "", Y = 0, ee = W10.length; Y < ee; ) {
        var J5 = parseInt(W10.substr(Y + 1, 2), 16);
        if (J5 < 128)
          I10 += String.fromCharCode(J5), Y += 3;
        else if (J5 >= 194 && J5 < 224) {
          if (ee - Y >= 6) {
            var Ae = parseInt(W10.substr(Y + 4, 2), 16);
            I10 += String.fromCharCode((J5 & 31) << 6 | Ae & 63);
          } else
            I10 += W10.substr(Y, 6);
          Y += 6;
        } else if (J5 >= 224) {
          if (ee - Y >= 9) {
            var De = parseInt(W10.substr(Y + 4, 2), 16), it = parseInt(W10.substr(Y + 7, 2), 16);
            I10 += String.fromCharCode((J5 & 15) << 12 | (De & 63) << 6 | it & 63);
          } else
            I10 += W10.substr(Y, 9);
          Y += 9;
        } else
          I10 += W10.substr(Y, 3), Y += 3;
      }
      return I10;
    }
    function ce2(W10, I10) {
      function Y(ee) {
        var J5 = ie2(ee);
        return J5.match(I10.UNRESERVED) ? J5 : ee;
      }
      return W10.scheme && (W10.scheme = String(W10.scheme).replace(I10.PCT_ENCODED, Y).toLowerCase().replace(I10.NOT_SCHEME, "")), W10.userinfo !== void 0 && (W10.userinfo = String(W10.userinfo).replace(I10.PCT_ENCODED, Y).replace(I10.NOT_USERINFO, V3).replace(I10.PCT_ENCODED, s3)), W10.host !== void 0 && (W10.host = String(W10.host).replace(I10.PCT_ENCODED, Y).toLowerCase().replace(I10.NOT_HOST, V3).replace(I10.PCT_ENCODED, s3)), W10.path !== void 0 && (W10.path = String(W10.path).replace(I10.PCT_ENCODED, Y).replace(W10.scheme ? I10.NOT_PATH : I10.NOT_PATH_NOSCHEME, V3).replace(I10.PCT_ENCODED, s3)), W10.query !== void 0 && (W10.query = String(W10.query).replace(I10.PCT_ENCODED, Y).replace(I10.NOT_QUERY, V3).replace(I10.PCT_ENCODED, s3)), W10.fragment !== void 0 && (W10.fragment = String(W10.fragment).replace(I10.PCT_ENCODED, Y).replace(I10.NOT_FRAGMENT, V3).replace(I10.PCT_ENCODED, s3)), W10;
    }
    function E(W10) {
      return W10.replace(/^0*(.*)/, "$1") || "0";
    }
    function D5(W10, I10) {
      var Y = W10.match(I10.IPV4ADDRESS) || [], ee = d3(Y, 2), J5 = ee[1];
      return J5 ? J5.split(".").map(E).join(".") : W10;
    }
    function se(W10, I10) {
      var Y = W10.match(I10.IPV6ADDRESS) || [], ee = d3(Y, 3), J5 = ee[1], Ae = ee[2];
      if (J5) {
        for (var De = J5.toLowerCase().split("::").reverse(), it = d3(De, 2), wt = it[0], Ut = it[1], rt2 = Ut ? Ut.split(":").map(E) : [], St = wt.split(":").map(E), It = I10.IPV4ADDRESS.test(St[St.length - 1]), Ve2 = It ? 7 : 8, Et = St.length - Ve2, Wt = Array(Ve2), Ct = 0; Ct < Ve2; ++Ct)
          Wt[Ct] = rt2[Ct] || St[Et + Ct] || "";
        It && (Wt[Ve2 - 1] = D5(Wt[Ve2 - 1], I10));
        var Wi = Wt.reduce(function(sn, jn, To2) {
          if (!jn || jn === "0") {
            var Oi = sn[sn.length - 1];
            Oi && Oi.index + Oi.length === To2 ? Oi.length++ : sn.push({ index: To2, length: 1 });
          }
          return sn;
        }, []), qn = Wi.sort(function(sn, jn) {
          return jn.length - sn.length;
        })[0], Dn = void 0;
        if (qn && qn.length > 1) {
          var Ss = Wt.slice(0, qn.index), Qo2 = Wt.slice(qn.index + qn.length);
          Dn = Ss.join(":") + "::" + Qo2.join(":");
        } else
          Dn = Wt.join(":");
        return Ae && (Dn += "%" + Ae), Dn;
      } else
        return W10;
    }
    var ye = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, Ye = "".match(/(){0}/)[1] === void 0;
    function xe2(W10) {
      var I10 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Y = {}, ee = I10.iri !== false ? f3 : c3;
      I10.reference === "suffix" && (W10 = (I10.scheme ? I10.scheme + ":" : "") + "//" + W10);
      var J5 = W10.match(ye);
      if (J5) {
        Ye ? (Y.scheme = J5[1], Y.userinfo = J5[3], Y.host = J5[4], Y.port = parseInt(J5[5], 10), Y.path = J5[6] || "", Y.query = J5[7], Y.fragment = J5[8], isNaN(Y.port) && (Y.port = J5[5])) : (Y.scheme = J5[1] || void 0, Y.userinfo = W10.indexOf("@") !== -1 ? J5[3] : void 0, Y.host = W10.indexOf("//") !== -1 ? J5[4] : void 0, Y.port = parseInt(J5[5], 10), Y.path = J5[6] || "", Y.query = W10.indexOf("?") !== -1 ? J5[7] : void 0, Y.fragment = W10.indexOf("#") !== -1 ? J5[8] : void 0, isNaN(Y.port) && (Y.port = W10.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? J5[4] : void 0)), Y.host && (Y.host = se(D5(Y.host, ee), ee)), Y.scheme === void 0 && Y.userinfo === void 0 && Y.host === void 0 && Y.port === void 0 && !Y.path && Y.query === void 0 ? Y.reference = "same-document" : Y.scheme === void 0 ? Y.reference = "relative" : Y.fragment === void 0 ? Y.reference = "absolute" : Y.reference = "uri", I10.reference && I10.reference !== "suffix" && I10.reference !== Y.reference && (Y.error = Y.error || "URI is not a " + I10.reference + " reference.");
        var Ae = F5[(I10.scheme || Y.scheme || "").toLowerCase()];
        if (!I10.unicodeSupport && (!Ae || !Ae.unicodeSupport)) {
          if (Y.host && (I10.domainHost || Ae && Ae.domainHost))
            try {
              Y.host = T10.toASCII(Y.host.replace(ee.PCT_ENCODED, ie2).toLowerCase());
            } catch (De) {
              Y.error = Y.error || "Host's domain name can not be converted to ASCII via punycode: " + De;
            }
          ce2(Y, c3);
        } else
          ce2(Y, ee);
        Ae && Ae.parse && Ae.parse(Y, I10);
      } else
        Y.error = Y.error || "URI can not be parsed.";
      return Y;
    }
    function Ge(W10, I10) {
      var Y = I10.iri !== false ? f3 : c3, ee = [];
      return W10.userinfo !== void 0 && (ee.push(W10.userinfo), ee.push("@")), W10.host !== void 0 && ee.push(se(D5(String(W10.host), Y), Y).replace(Y.IPV6ADDRESS, function(J5, Ae, De) {
        return "[" + Ae + (De ? "%25" + De : "") + "]";
      })), (typeof W10.port == "number" || typeof W10.port == "string") && (ee.push(":"), ee.push(String(W10.port))), ee.length ? ee.join("") : void 0;
    }
    var or = /^\.\.?\//, le = /^\/\.(\/|$)/, qr = /^\/\.\.(\/|$)/, Vr2 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function Tt(W10) {
      for (var I10 = []; W10.length; )
        if (W10.match(or))
          W10 = W10.replace(or, "");
        else if (W10.match(le))
          W10 = W10.replace(le, "/");
        else if (W10.match(qr))
          W10 = W10.replace(qr, "/"), I10.pop();
        else if (W10 === "." || W10 === "..")
          W10 = "";
        else {
          var Y = W10.match(Vr2);
          if (Y) {
            var ee = Y[0];
            W10 = W10.slice(ee.length), I10.push(ee);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return I10.join("");
    }
    function Xt2(W10) {
      var I10 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Y = I10.iri ? f3 : c3, ee = [], J5 = F5[(I10.scheme || W10.scheme || "").toLowerCase()];
      if (J5 && J5.serialize && J5.serialize(W10, I10), W10.host && !Y.IPV6ADDRESS.test(W10.host)) {
        if (I10.domainHost || J5 && J5.domainHost)
          try {
            W10.host = I10.iri ? T10.toUnicode(W10.host) : T10.toASCII(W10.host.replace(Y.PCT_ENCODED, ie2).toLowerCase());
          } catch (it) {
            W10.error = W10.error || "Host's domain name can not be converted to " + (I10.iri ? "Unicode" : "ASCII") + " via punycode: " + it;
          }
      }
      ce2(W10, Y), I10.reference !== "suffix" && W10.scheme && (ee.push(W10.scheme), ee.push(":"));
      var Ae = Ge(W10, I10);
      if (Ae !== void 0 && (I10.reference !== "suffix" && ee.push("//"), ee.push(Ae), W10.path && W10.path.charAt(0) !== "/" && ee.push("/")), W10.path !== void 0) {
        var De = W10.path;
        !I10.absolutePath && (!J5 || !J5.absolutePath) && (De = Tt(De)), Ae === void 0 && (De = De.replace(/^\/\//, "/%2F")), ee.push(De);
      }
      return W10.query !== void 0 && (ee.push("?"), ee.push(W10.query)), W10.fragment !== void 0 && (ee.push("#"), ee.push(W10.fragment)), ee.join("");
    }
    function on(W10, I10) {
      var Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ee = arguments[3], J5 = {};
      return ee || (W10 = xe2(Xt2(W10, Y), Y), I10 = xe2(Xt2(I10, Y), Y)), Y = Y || {}, !Y.tolerant && I10.scheme ? (J5.scheme = I10.scheme, J5.userinfo = I10.userinfo, J5.host = I10.host, J5.port = I10.port, J5.path = Tt(I10.path || ""), J5.query = I10.query) : (I10.userinfo !== void 0 || I10.host !== void 0 || I10.port !== void 0 ? (J5.userinfo = I10.userinfo, J5.host = I10.host, J5.port = I10.port, J5.path = Tt(I10.path || ""), J5.query = I10.query) : (I10.path ? (I10.path.charAt(0) === "/" ? J5.path = Tt(I10.path) : ((W10.userinfo !== void 0 || W10.host !== void 0 || W10.port !== void 0) && !W10.path ? J5.path = "/" + I10.path : W10.path ? J5.path = W10.path.slice(0, W10.path.lastIndexOf("/") + 1) + I10.path : J5.path = I10.path, J5.path = Tt(J5.path)), J5.query = I10.query) : (J5.path = W10.path, I10.query !== void 0 ? J5.query = I10.query : J5.query = W10.query), J5.userinfo = W10.userinfo, J5.host = W10.host, J5.port = W10.port), J5.scheme = W10.scheme), J5.fragment = I10.fragment, J5;
    }
    function Jt2(W10, I10, Y) {
      var ee = l3({ scheme: "null" }, Y);
      return Xt2(on(xe2(W10, ee), xe2(I10, ee), ee, true), ee);
    }
    function xr2(W10, I10) {
      return typeof W10 == "string" ? W10 = Xt2(xe2(W10, I10), I10) : o3(W10) === "object" && (W10 = xe2(Xt2(W10, I10), I10)), W10;
    }
    function x10(W10, I10, Y) {
      return typeof W10 == "string" ? W10 = Xt2(xe2(W10, Y), Y) : o3(W10) === "object" && (W10 = Xt2(W10, Y)), typeof I10 == "string" ? I10 = Xt2(xe2(I10, Y), Y) : o3(I10) === "object" && (I10 = Xt2(I10, Y)), W10 === I10;
    }
    function y10(W10, I10) {
      return W10 && W10.toString().replace(!I10 || !I10.iri ? c3.ESCAPE : f3.ESCAPE, V3);
    }
    function b10(W10, I10) {
      return W10 && W10.toString().replace(!I10 || !I10.iri ? c3.PCT_ENCODED : f3.PCT_ENCODED, ie2);
    }
    var j10 = {
      scheme: "http",
      domainHost: true,
      parse: function(I10, Y) {
        return I10.host || (I10.error = I10.error || "HTTP URIs must have a host."), I10;
      },
      serialize: function(I10, Y) {
        var ee = String(I10.scheme).toLowerCase() === "https";
        return (I10.port === (ee ? 443 : 80) || I10.port === "") && (I10.port = void 0), I10.path || (I10.path = "/"), I10;
      }
    }, L5 = {
      scheme: "https",
      domainHost: j10.domainHost,
      parse: j10.parse,
      serialize: j10.serialize
    };
    function K(W10) {
      return typeof W10.secure == "boolean" ? W10.secure : String(W10.scheme).toLowerCase() === "wss";
    }
    var ae = {
      scheme: "ws",
      domainHost: true,
      parse: function(I10, Y) {
        var ee = I10;
        return ee.secure = K(ee), ee.resourceName = (ee.path || "/") + (ee.query ? "?" + ee.query : ""), ee.path = void 0, ee.query = void 0, ee;
      },
      serialize: function(I10, Y) {
        if ((I10.port === (K(I10) ? 443 : 80) || I10.port === "") && (I10.port = void 0), typeof I10.secure == "boolean" && (I10.scheme = I10.secure ? "wss" : "ws", I10.secure = void 0), I10.resourceName) {
          var ee = I10.resourceName.split("?"), J5 = d3(ee, 2), Ae = J5[0], De = J5[1];
          I10.path = Ae && Ae !== "/" ? Ae : void 0, I10.query = De, I10.resourceName = void 0;
        }
        return I10.fragment = void 0, I10;
      }
    }, ze2 = {
      scheme: "wss",
      domainHost: ae.domainHost,
      parse: ae.parse,
      serialize: ae.serialize
    }, kt = {}, mt = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", at = "[0-9A-Fa-f]", dt2 = i3(i3("%[EFef]" + at + "%" + at + at + "%" + at + at) + "|" + i3("%[89A-Fa-f]" + at + "%" + at + at) + "|" + i3("%" + at + at)), Z5 = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", M5 = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", N52 = n3(M5, '[\\"\\\\]'), W5 = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", V5 = new RegExp(mt, "g"), bs = new RegExp(dt2, "g"), Y5 = new RegExp(n3("[^]", Z5, "[\\.]", '[\\"]', N52), "g"), C1 = new RegExp(n3("[^]", mt, W5), "g"), L52 = C1;
    function eh(W10) {
      var I10 = ie2(W10);
      return I10.match(V5) ? I10 : W10;
    }
    var R1 = {
      scheme: "mailto",
      parse: function(I10, Y) {
        var ee = I10, J5 = ee.to = ee.path ? ee.path.split(",") : [];
        if (ee.path = void 0, ee.query) {
          for (var Ae = false, De = {}, it = ee.query.split("&"), wt = 0, Ut = it.length; wt < Ut; ++wt) {
            var rt2 = it[wt].split("=");
            switch (rt2[0]) {
              case "to":
                for (var St = rt2[1].split(","), It = 0, Ve2 = St.length; It < Ve2; ++It)
                  J5.push(St[It]);
                break;
              case "subject":
                ee.subject = b10(rt2[1], Y);
                break;
              case "body":
                ee.body = b10(rt2[1], Y);
                break;
              default:
                Ae = true, De[b10(rt2[0], Y)] = b10(rt2[1], Y);
                break;
            }
          }
          Ae && (ee.headers = De);
        }
        ee.query = void 0;
        for (var Et = 0, Wt = J5.length; Et < Wt; ++Et) {
          var Ct = J5[Et].split("@");
          if (Ct[0] = b10(Ct[0]), Y.unicodeSupport)
            Ct[1] = b10(Ct[1], Y).toLowerCase();
          else
            try {
              Ct[1] = T10.toASCII(b10(Ct[1], Y).toLowerCase());
            } catch (Wi) {
              ee.error = ee.error || "Email address's domain name can not be converted to ASCII via punycode: " + Wi;
            }
          J5[Et] = Ct.join("@");
        }
        return ee;
      },
      serialize: function(I10, Y) {
        var ee = I10, J5 = a3(I10.to);
        if (J5) {
          for (var Ae = 0, De = J5.length; Ae < De; ++Ae) {
            var it = String(J5[Ae]), wt = it.lastIndexOf("@"), Ut = it.slice(0, wt).replace(bs, eh).replace(bs, s3).replace(Y5, V3), rt2 = it.slice(wt + 1);
            try {
              rt2 = Y.iri ? T10.toUnicode(rt2) : T10.toASCII(b10(rt2, Y).toLowerCase());
            } catch (Et) {
              ee.error = ee.error || "Email address's domain name can not be converted to " + (Y.iri ? "Unicode" : "ASCII") + " via punycode: " + Et;
            }
            J5[Ae] = Ut + "@" + rt2;
          }
          ee.path = J5.join(",");
        }
        var St = I10.headers = I10.headers || {};
        I10.subject && (St.subject = I10.subject), I10.body && (St.body = I10.body);
        var It = [];
        for (var Ve2 in St)
          St[Ve2] !== kt[Ve2] && It.push(Ve2.replace(bs, eh).replace(bs, s3).replace(C1, V3) + "=" + St[Ve2].replace(bs, eh).replace(bs, s3).replace(L52, V3));
        return It.length && (ee.query = It.join("&")), ee;
      }
    }, B52 = /^([^\:]+)\:(.*)/, A1 = {
      scheme: "urn",
      parse: function(I10, Y) {
        var ee = I10.path && I10.path.match(B52), J5 = I10;
        if (ee) {
          var Ae = Y.scheme || J5.scheme || "urn", De = ee[1].toLowerCase(), it = ee[2], wt = Ae + ":" + (Y.nid || De), Ut = F5[wt];
          J5.nid = De, J5.nss = it, J5.path = void 0, Ut && (J5 = Ut.parse(J5, Y));
        } else
          J5.error = J5.error || "URN can not be parsed.";
        return J5;
      },
      serialize: function(I10, Y) {
        var ee = Y.scheme || I10.scheme || "urn", J5 = I10.nid, Ae = ee + ":" + (Y.nid || J5), De = F5[Ae];
        De && (I10 = De.serialize(I10, Y));
        var it = I10, wt = I10.nss;
        return it.path = (J5 || Y.nid) + ":" + wt, it;
      }
    }, z5 = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, X1 = {
      scheme: "urn:uuid",
      parse: function(I10, Y) {
        var ee = I10;
        return ee.uuid = ee.nss, ee.nss = void 0, !Y.tolerant && (!ee.uuid || !ee.uuid.match(z5)) && (ee.error = ee.error || "UUID is not valid."), ee;
      },
      serialize: function(I10, Y) {
        var ee = I10;
        return ee.nss = (I10.uuid || "").toLowerCase(), ee;
      }
    };
    F5[j10.scheme] = j10, F5[L5.scheme] = L5, F5[ae.scheme] = ae, F5[ze2.scheme] = ze2, F5[R1.scheme] = R1, F5[A1.scheme] = A1, F5[X1.scheme] = X1, r3.SCHEMES = F5, r3.pctEncChar = V3, r3.pctDecChars = ie2, r3.parse = xe2, r3.removeDotSegments = Tt, r3.serialize = Xt2, r3.resolveComponents = on, r3.resolve = Jt2, r3.normalize = xr2, r3.equal = x10, r3.escapeComponent = y10, r3.unescapeComponent = b10, Object.defineProperty(r3, "__esModule", { value: true });
  });
})(xm, xm.exports);
var YH = xm.exports;
Object.defineProperty(x0, "__esModule", { value: true });
const VT = YH;
VT.code = 'require("ajv/dist/runtime/uri").default';
x0.default = VT;
(function(t10) {
  Object.defineProperty(t10, "__esModule", { value: true }), t10.CodeGen = t10.Name = t10.nil = t10.stringify = t10.str = t10._ = t10.KeywordCxt = void 0;
  var e3 = kn;
  Object.defineProperty(t10, "KeywordCxt", { enumerable: true, get: function() {
    return e3.KeywordCxt;
  } });
  var r3 = Le;
  Object.defineProperty(t10, "_", { enumerable: true, get: function() {
    return r3._;
  } }), Object.defineProperty(t10, "str", { enumerable: true, get: function() {
    return r3.str;
  } }), Object.defineProperty(t10, "stringify", { enumerable: true, get: function() {
    return r3.stringify;
  } }), Object.defineProperty(t10, "nil", { enumerable: true, get: function() {
    return r3.nil;
  } }), Object.defineProperty(t10, "Name", { enumerable: true, get: function() {
    return r3.Name;
  } }), Object.defineProperty(t10, "CodeGen", { enumerable: true, get: function() {
    return r3.CodeGen;
  } });
  const n3 = wu, i3 = Pu, o3 = us, s3 = Cr, a3 = Le, l3 = fr, u3 = $u, c3 = tt, f3 = VH, d3 = x0, p10 = (G, Z) => new RegExp(G, Z);
  p10.code = "new RegExp";
  const h10 = ["removeAdditional", "useDefaults", "coerceTypes"], m10 = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), O10 = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, g = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, v10 = 200;
  function S10(G) {
    var Z, C10, X10, w10, U10, T10, F5, V3, ie2, ce2, E, D5, se, ye, Ye, xe2, Ge, or, le, qr, Vr2, Tt, Xt2, on, Jt2;
    const xr2 = G.strict, x10 = (Z = G.code) === null || Z === void 0 ? void 0 : Z.optimize, y10 = x10 === true || x10 === void 0 ? 1 : x10 || 0, b10 = (X10 = (C10 = G.code) === null || C10 === void 0 ? void 0 : C10.regExp) !== null && X10 !== void 0 ? X10 : p10, j10 = (w10 = G.uriResolver) !== null && w10 !== void 0 ? w10 : d3.default;
    return {
      strictSchema: (T10 = (U10 = G.strictSchema) !== null && U10 !== void 0 ? U10 : xr2) !== null && T10 !== void 0 ? T10 : true,
      strictNumbers: (V3 = (F5 = G.strictNumbers) !== null && F5 !== void 0 ? F5 : xr2) !== null && V3 !== void 0 ? V3 : true,
      strictTypes: (ce2 = (ie2 = G.strictTypes) !== null && ie2 !== void 0 ? ie2 : xr2) !== null && ce2 !== void 0 ? ce2 : "log",
      strictTuples: (D5 = (E = G.strictTuples) !== null && E !== void 0 ? E : xr2) !== null && D5 !== void 0 ? D5 : "log",
      strictRequired: (ye = (se = G.strictRequired) !== null && se !== void 0 ? se : xr2) !== null && ye !== void 0 ? ye : false,
      code: G.code ? { ...G.code, optimize: y10, regExp: b10 } : { optimize: y10, regExp: b10 },
      loopRequired: (Ye = G.loopRequired) !== null && Ye !== void 0 ? Ye : v10,
      loopEnum: (xe2 = G.loopEnum) !== null && xe2 !== void 0 ? xe2 : v10,
      meta: (Ge = G.meta) !== null && Ge !== void 0 ? Ge : true,
      messages: (or = G.messages) !== null && or !== void 0 ? or : true,
      inlineRefs: (le = G.inlineRefs) !== null && le !== void 0 ? le : true,
      schemaId: (qr = G.schemaId) !== null && qr !== void 0 ? qr : "$id",
      addUsedSchema: (Vr2 = G.addUsedSchema) !== null && Vr2 !== void 0 ? Vr2 : true,
      validateSchema: (Tt = G.validateSchema) !== null && Tt !== void 0 ? Tt : true,
      validateFormats: (Xt2 = G.validateFormats) !== null && Xt2 !== void 0 ? Xt2 : true,
      unicodeRegExp: (on = G.unicodeRegExp) !== null && on !== void 0 ? on : true,
      int32range: (Jt2 = G.int32range) !== null && Jt2 !== void 0 ? Jt2 : true,
      uriResolver: j10
    };
  }
  class $10 {
    constructor(Z = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), Z = this.opts = { ...Z, ...S10(Z) };
      const { es5: C10, lines: X10 } = this.opts.code;
      this.scope = new a3.ValueScope({ scope: {}, prefixes: m10, es5: C10, lines: X10 }), this.logger = re2(Z.logger);
      const w10 = Z.validateFormats;
      Z.validateFormats = false, this.RULES = (0, o3.getRules)(), _10.call(this, O10, Z, "NOT SUPPORTED"), _10.call(this, g, Z, "DEPRECATED", "warn"), this._metaOpts = H10.call(this), Z.formats && N5.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), Z.keywords && B5.call(this, Z.keywords), typeof Z.meta == "object" && this.addMetaSchema(Z.meta), q5.call(this), Z.validateFormats = w10;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: Z, meta: C10, schemaId: X10 } = this.opts;
      let w10 = f3;
      X10 === "id" && (w10 = { ...f3 }, w10.id = w10.$id, delete w10.$id), C10 && Z && this.addMetaSchema(w10, w10[X10], false);
    }
    defaultMeta() {
      const { meta: Z, schemaId: C10 } = this.opts;
      return this.opts.defaultMeta = typeof Z == "object" ? Z[C10] || Z : void 0;
    }
    validate(Z, C10) {
      let X10;
      if (typeof Z == "string") {
        if (X10 = this.getSchema(Z), !X10)
          throw new Error(`no schema with key or ref "${Z}"`);
      } else
        X10 = this.compile(Z);
      const w10 = X10(C10);
      return "$async" in X10 || (this.errors = X10.errors), w10;
    }
    compile(Z, C10) {
      const X10 = this._addSchema(Z, C10);
      return X10.validate || this._compileSchemaEnv(X10);
    }
    compileAsync(Z, C10) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: X10 } = this.opts;
      return w10.call(this, Z, C10);
      async function w10(ce2, E) {
        await U10.call(this, ce2.$schema);
        const D5 = this._addSchema(ce2, E);
        return D5.validate || T10.call(this, D5);
      }
      async function U10(ce2) {
        ce2 && !this.getSchema(ce2) && await w10.call(this, { $ref: ce2 }, true);
      }
      async function T10(ce2) {
        try {
          return this._compileSchemaEnv(ce2);
        } catch (E) {
          if (!(E instanceof i3.default))
            throw E;
          return F5.call(this, E), await V3.call(this, E.missingSchema), T10.call(this, ce2);
        }
      }
      function F5({ missingSchema: ce2, missingRef: E }) {
        if (this.refs[ce2])
          throw new Error(`AnySchema ${ce2} is loaded but ${E} cannot be resolved`);
      }
      async function V3(ce2) {
        const E = await ie2.call(this, ce2);
        this.refs[ce2] || await U10.call(this, E.$schema), this.refs[ce2] || this.addSchema(E, ce2, C10);
      }
      async function ie2(ce2) {
        const E = this._loading[ce2];
        if (E)
          return E;
        try {
          return await (this._loading[ce2] = X10(ce2));
        } finally {
          delete this._loading[ce2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(Z, C10, X10, w10 = this.opts.validateSchema) {
      if (Array.isArray(Z)) {
        for (const T10 of Z)
          this.addSchema(T10, void 0, X10, w10);
        return this;
      }
      let U10;
      if (typeof Z == "object") {
        const { schemaId: T10 } = this.opts;
        if (U10 = Z[T10], U10 !== void 0 && typeof U10 != "string")
          throw new Error(`schema ${T10} must be string`);
      }
      return C10 = (0, l3.normalizeId)(C10 || U10), this._checkUnique(C10), this.schemas[C10] = this._addSchema(Z, X10, C10, w10, true), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(Z, C10, X10 = this.opts.validateSchema) {
      return this.addSchema(Z, C10, true, X10), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(Z, C10) {
      if (typeof Z == "boolean")
        return true;
      let X10;
      if (X10 = Z.$schema, X10 !== void 0 && typeof X10 != "string")
        throw new Error("$schema must be a string");
      if (X10 = X10 || this.opts.defaultMeta || this.defaultMeta(), !X10)
        return this.logger.warn("meta-schema not available"), this.errors = null, true;
      const w10 = this.validate(X10, Z);
      if (!w10 && C10) {
        const U10 = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(U10);
        else
          throw new Error(U10);
      }
      return w10;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(Z) {
      let C10;
      for (; typeof (C10 = P10.call(this, Z)) == "string"; )
        Z = C10;
      if (C10 === void 0) {
        const { schemaId: X10 } = this.opts, w10 = new s3.SchemaEnv({ schema: {}, schemaId: X10 });
        if (C10 = s3.resolveSchema.call(this, w10, Z), !C10)
          return;
        this.refs[Z] = C10;
      }
      return C10.validate || this._compileSchemaEnv(C10);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(Z) {
      if (Z instanceof RegExp)
        return this._removeAllSchemas(this.schemas, Z), this._removeAllSchemas(this.refs, Z), this;
      switch (typeof Z) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const C10 = P10.call(this, Z);
          return typeof C10 == "object" && this._cache.delete(C10.schema), delete this.schemas[Z], delete this.refs[Z], this;
        }
        case "object": {
          const C10 = Z;
          this._cache.delete(C10);
          let X10 = Z[this.opts.schemaId];
          return X10 && (X10 = (0, l3.normalizeId)(X10), delete this.schemas[X10], delete this.refs[X10]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(Z) {
      for (const C10 of Z)
        this.addKeyword(C10);
      return this;
    }
    addKeyword(Z, C10) {
      let X10;
      if (typeof Z == "string")
        X10 = Z, typeof C10 == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), C10.keyword = X10);
      else if (typeof Z == "object" && C10 === void 0) {
        if (C10 = Z, X10 = C10.keyword, Array.isArray(X10) && !X10.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (pe.call(this, X10, C10), !C10)
        return (0, c3.eachItem)(X10, (U10) => Ee2.call(this, U10)), this;
      _e.call(this, C10);
      const w10 = {
        ...C10,
        type: (0, u3.getJSONTypes)(C10.type),
        schemaType: (0, u3.getJSONTypes)(C10.schemaType)
      };
      return (0, c3.eachItem)(X10, w10.type.length === 0 ? (U10) => Ee2.call(this, U10, w10) : (U10) => w10.type.forEach((T10) => Ee2.call(this, U10, w10, T10))), this;
    }
    getKeyword(Z) {
      const C10 = this.RULES.all[Z];
      return typeof C10 == "object" ? C10.definition : !!C10;
    }
    // Remove keyword
    removeKeyword(Z) {
      const { RULES: C10 } = this;
      delete C10.keywords[Z], delete C10.all[Z];
      for (const X10 of C10.rules) {
        const w10 = X10.rules.findIndex((U10) => U10.keyword === Z);
        w10 >= 0 && X10.rules.splice(w10, 1);
      }
      return this;
    }
    // Add format
    addFormat(Z, C10) {
      return typeof C10 == "string" && (C10 = new RegExp(C10)), this.formats[Z] = C10, this;
    }
    errorsText(Z = this.errors, { separator: C10 = ", ", dataVar: X10 = "data" } = {}) {
      return !Z || Z.length === 0 ? "No errors" : Z.map((w10) => `${X10}${w10.instancePath} ${w10.message}`).reduce((w10, U10) => w10 + C10 + U10);
    }
    $dataMetaSchema(Z, C10) {
      const X10 = this.RULES.all;
      Z = JSON.parse(JSON.stringify(Z));
      for (const w10 of C10) {
        const U10 = w10.split("/").slice(1);
        let T10 = Z;
        for (const F5 of U10)
          T10 = T10[F5];
        for (const F5 in X10) {
          const V3 = X10[F5];
          if (typeof V3 != "object")
            continue;
          const { $data: ie2 } = V3.definition, ce2 = T10[F5];
          ie2 && ce2 && (T10[F5] = je2(ce2));
        }
      }
      return Z;
    }
    _removeAllSchemas(Z, C10) {
      for (const X10 in Z) {
        const w10 = Z[X10];
        (!C10 || C10.test(X10)) && (typeof w10 == "string" ? delete Z[X10] : w10 && !w10.meta && (this._cache.delete(w10.schema), delete Z[X10]));
      }
    }
    _addSchema(Z, C10, X10, w10 = this.opts.validateSchema, U10 = this.opts.addUsedSchema) {
      let T10;
      const { schemaId: F5 } = this.opts;
      if (typeof Z == "object")
        T10 = Z[F5];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof Z != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let V3 = this._cache.get(Z);
      if (V3 !== void 0)
        return V3;
      X10 = (0, l3.normalizeId)(T10 || X10);
      const ie2 = l3.getSchemaRefs.call(this, Z, X10);
      return V3 = new s3.SchemaEnv({ schema: Z, schemaId: F5, meta: C10, baseId: X10, localRefs: ie2 }), this._cache.set(V3.schema, V3), U10 && !X10.startsWith("#") && (X10 && this._checkUnique(X10), this.refs[X10] = V3), w10 && this.validateSchema(Z, true), V3;
    }
    _checkUnique(Z) {
      if (this.schemas[Z] || this.refs[Z])
        throw new Error(`schema with key or id "${Z}" already exists`);
    }
    _compileSchemaEnv(Z) {
      if (Z.meta ? this._compileMetaSchema(Z) : s3.compileSchema.call(this, Z), !Z.validate)
        throw new Error("ajv implementation error");
      return Z.validate;
    }
    _compileMetaSchema(Z) {
      const C10 = this.opts;
      this.opts = this._metaOpts;
      try {
        s3.compileSchema.call(this, Z);
      } finally {
        this.opts = C10;
      }
    }
  }
  t10.default = $10, $10.ValidationError = n3.default, $10.MissingRefError = i3.default;
  function _10(G, Z, C10, X10 = "error") {
    for (const w10 in G) {
      const U10 = w10;
      U10 in Z && this.logger[X10](`${C10}: option ${w10}. ${G[U10]}`);
    }
  }
  function P10(G) {
    return G = (0, l3.normalizeId)(G), this.schemas[G] || this.refs[G];
  }
  function q5() {
    const G = this.opts.schemas;
    if (G)
      if (Array.isArray(G))
        this.addSchema(G);
      else
        for (const Z in G)
          this.addSchema(G[Z], Z);
  }
  function N5() {
    for (const G in this.opts.formats) {
      const Z = this.opts.formats[G];
      Z && this.addFormat(G, Z);
    }
  }
  function B5(G) {
    if (Array.isArray(G)) {
      this.addVocabulary(G);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const Z in G) {
      const C10 = G[Z];
      C10.keyword || (C10.keyword = Z), this.addKeyword(C10);
    }
  }
  function H10() {
    const G = { ...this.opts };
    for (const Z of h10)
      delete G[Z];
    return G;
  }
  const ne = { log() {
  }, warn() {
  }, error() {
  } };
  function re2(G) {
    if (G === false)
      return ne;
    if (G === void 0)
      return console;
    if (G.log && G.warn && G.error)
      return G;
    throw new Error("logger must implement log, warn and error methods");
  }
  const fe = /^[a-z_$][a-z0-9_$:-]*$/i;
  function pe(G, Z) {
    const { RULES: C10 } = this;
    if ((0, c3.eachItem)(G, (X10) => {
      if (C10.keywords[X10])
        throw new Error(`Keyword ${X10} is already defined`);
      if (!fe.test(X10))
        throw new Error(`Keyword ${X10} has invalid name`);
    }), !!Z && Z.$data && !("code" in Z || "validate" in Z))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function Ee2(G, Z, C10) {
    var X10;
    const w10 = Z == null ? void 0 : Z.post;
    if (C10 && w10)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: U10 } = this;
    let T10 = w10 ? U10.post : U10.rules.find(({ type: V3 }) => V3 === C10);
    if (T10 || (T10 = { type: C10, rules: [] }, U10.rules.push(T10)), U10.keywords[G] = true, !Z)
      return;
    const F5 = {
      keyword: G,
      definition: {
        ...Z,
        type: (0, u3.getJSONTypes)(Z.type),
        schemaType: (0, u3.getJSONTypes)(Z.schemaType)
      }
    };
    Z.before ? qe.call(this, T10, F5, Z.before) : T10.rules.push(F5), U10.all[G] = F5, (X10 = Z.implements) === null || X10 === void 0 || X10.forEach((V3) => this.addKeyword(V3));
  }
  function qe(G, Z, C10) {
    const X10 = G.rules.findIndex((w10) => w10.keyword === C10);
    X10 >= 0 ? G.rules.splice(X10, 0, Z) : (G.rules.push(Z), this.logger.warn(`rule ${C10} is not defined`));
  }
  function _e(G) {
    let { metaSchema: Z } = G;
    Z !== void 0 && (G.$data && this.opts.$data && (Z = je2(Z)), G.validateSchema = this.compile(Z, true));
  }
  const Ie = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function je2(G) {
    return { anyOf: [G, Ie] };
  }
})(ra);
var Q0 = {}, T0 = {}, li = {};
Object.defineProperty(li, "__esModule", { value: true });
li.callRef = li.getValidate = void 0;
const LH = Pu, KS = Ke, Dr = Le, ks = nn, JS = Cr, nc = tt, BH = {
  keyword: "$ref",
  schemaType: "string",
  code(t10) {
    const { gen: e3, schema: r3, it: n3 } = t10, { baseId: i3, schemaEnv: o3, validateName: s3, opts: a3, self: l3 } = n3, { root: u3 } = o3;
    if ((r3 === "#" || r3 === "#/") && i3 === u3.baseId)
      return f3();
    const c3 = JS.resolveRef.call(l3, u3, i3, r3);
    if (c3 === void 0)
      throw new LH.default(n3.opts.uriResolver, i3, r3);
    if (c3 instanceof JS.SchemaEnv)
      return d3(c3);
    return p10(c3);
    function f3() {
      if (o3 === u3)
        return Dc(t10, s3, o3, o3.$async);
      const h10 = e3.scopeValue("root", { ref: u3 });
      return Dc(t10, (0, Dr._)`${h10}.validate`, u3, u3.$async);
    }
    function d3(h10) {
      const m10 = YT(t10, h10);
      Dc(t10, m10, h10, h10.$async);
    }
    function p10(h10) {
      const m10 = e3.scopeValue("schema", a3.code.source === true ? { ref: h10, code: (0, Dr.stringify)(h10) } : { ref: h10 }), O10 = e3.name("valid"), g = t10.subschema({
        schema: h10,
        dataTypes: [],
        schemaPath: Dr.nil,
        topSchemaRef: m10,
        errSchemaPath: r3
      }, O10);
      t10.mergeEvaluated(g), t10.ok(O10);
    }
  }
};
function YT(t10, e3) {
  const { gen: r3 } = t10;
  return e3.validate ? r3.scopeValue("validate", { ref: e3.validate }) : (0, Dr._)`${r3.scopeValue("wrapper", { ref: e3 })}.validate`;
}
li.getValidate = YT;
function Dc(t10, e3, r3, n3) {
  const { gen: i3, it: o3 } = t10, { allErrors: s3, schemaEnv: a3, opts: l3 } = o3, u3 = l3.passContext ? ks.default.this : Dr.nil;
  n3 ? c3() : f3();
  function c3() {
    if (!a3.$async)
      throw new Error("async schema referenced by sync schema");
    const h10 = i3.let("valid");
    i3.try(() => {
      i3.code((0, Dr._)`await ${(0, KS.callValidateCode)(t10, e3, u3)}`), p10(e3), s3 || i3.assign(h10, true);
    }, (m10) => {
      i3.if((0, Dr._)`!(${m10} instanceof ${o3.ValidationError})`, () => i3.throw(m10)), d3(m10), s3 || i3.assign(h10, false);
    }), t10.ok(h10);
  }
  function f3() {
    t10.result((0, KS.callValidateCode)(t10, e3, u3), () => p10(e3), () => d3(e3));
  }
  function d3(h10) {
    const m10 = (0, Dr._)`${h10}.errors`;
    i3.assign(ks.default.vErrors, (0, Dr._)`${ks.default.vErrors} === null ? ${m10} : ${ks.default.vErrors}.concat(${m10})`), i3.assign(ks.default.errors, (0, Dr._)`${ks.default.vErrors}.length`);
  }
  function p10(h10) {
    var m10;
    if (!o3.opts.unevaluated)
      return;
    const O10 = (m10 = r3 == null ? void 0 : r3.validate) === null || m10 === void 0 ? void 0 : m10.evaluated;
    if (o3.props !== true)
      if (O10 && !O10.dynamicProps)
        O10.props !== void 0 && (o3.props = nc.mergeEvaluated.props(i3, O10.props, o3.props));
      else {
        const g = i3.var("props", (0, Dr._)`${h10}.evaluated.props`);
        o3.props = nc.mergeEvaluated.props(i3, g, o3.props, Dr.Name);
      }
    if (o3.items !== true)
      if (O10 && !O10.dynamicItems)
        O10.items !== void 0 && (o3.items = nc.mergeEvaluated.items(i3, O10.items, o3.items));
      else {
        const g = i3.var("items", (0, Dr._)`${h10}.evaluated.items`);
        o3.items = nc.mergeEvaluated.items(i3, g, o3.items, Dr.Name);
      }
  }
}
li.callRef = Dc;
li.default = BH;
Object.defineProperty(T0, "__esModule", { value: true });
const zH = li, HH = [
  "$schema",
  "id",
  "$defs",
  { keyword: "$comment" },
  "definitions",
  zH.default
];
T0.default = HH;
var k0 = {}, E0 = {};
Object.defineProperty(E0, "__esModule", { value: true });
const Qm = ra, GH = Le, Bi = GH.operators, Tm = {
  maximum: {
    exclusive: "exclusiveMaximum",
    ops: [
      { okStr: "<=", ok: Bi.LTE, fail: Bi.GT },
      { okStr: "<", ok: Bi.LT, fail: Bi.GTE }
    ]
  },
  minimum: {
    exclusive: "exclusiveMinimum",
    ops: [
      { okStr: ">=", ok: Bi.GTE, fail: Bi.LT },
      { okStr: ">", ok: Bi.GT, fail: Bi.LTE }
    ]
  }
}, KH = {
  message: (t10) => Qm.str`must be ${km(t10).okStr} ${t10.schemaCode}`,
  params: (t10) => Qm._`{comparison: ${km(t10).okStr}, limit: ${t10.schemaCode}}`
}, JH = {
  keyword: Object.keys(Tm),
  type: "number",
  schemaType: "number",
  $data: true,
  error: KH,
  code(t10) {
    const { data: e3, schemaCode: r3 } = t10;
    t10.fail$data(Qm._`${e3} ${km(t10).fail} ${r3} || isNaN(${e3})`);
  }
};
function km(t10) {
  var e3;
  const r3 = t10.keyword, n3 = !((e3 = t10.parentSchema) === null || e3 === void 0) && e3[Tm[r3].exclusive] ? 1 : 0;
  return Tm[r3].ops[n3];
}
E0.default = JH;
var C0 = {};
Object.defineProperty(C0, "__esModule", { value: true });
const e$ = {
  exclusiveMaximum: "maximum",
  exclusiveMinimum: "minimum"
}, eG = {
  keyword: Object.keys(e$),
  type: "number",
  schemaType: "boolean",
  code({ keyword: t10, parentSchema: e3 }) {
    const r3 = e$[t10];
    if (e3[r3] === void 0)
      throw new Error(`${t10} can only be used with ${r3}`);
  }
};
C0.default = eG;
var wd = {};
Object.defineProperty(wd, "__esModule", { value: true });
const Sl = Le, tG = {
  message: ({ schemaCode: t10 }) => (0, Sl.str)`must be multiple of ${t10}`,
  params: ({ schemaCode: t10 }) => (0, Sl._)`{multipleOf: ${t10}}`
}, rG = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: tG,
  code(t10) {
    const { gen: e3, data: r3, schemaCode: n3, it: i3 } = t10, o3 = i3.opts.multipleOfPrecision, s3 = e3.let("res"), a3 = o3 ? (0, Sl._)`Math.abs(Math.round(${s3}) - ${s3}) > 1e-${o3}` : (0, Sl._)`${s3} !== parseInt(${s3})`;
    t10.fail$data((0, Sl._)`(${n3} === 0 || (${s3} = ${r3}/${n3}, ${a3}))`);
  }
};
wd.default = rG;
var Pd = {}, R0 = {};
Object.defineProperty(R0, "__esModule", { value: true });
function LT(t10) {
  const e3 = t10.length;
  let r3 = 0, n3 = 0, i3;
  for (; n3 < e3; )
    r3++, i3 = t10.charCodeAt(n3++), i3 >= 55296 && i3 <= 56319 && n3 < e3 && (i3 = t10.charCodeAt(n3), (i3 & 64512) === 56320 && n3++);
  return r3;
}
R0.default = LT;
LT.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(Pd, "__esModule", { value: true });
const qo = Le, nG = tt, iG = R0, oG = {
  message({ keyword: t10, schemaCode: e3 }) {
    const r3 = t10 === "maxLength" ? "more" : "fewer";
    return (0, qo.str)`must NOT have ${r3} than ${e3} characters`;
  },
  params: ({ schemaCode: t10 }) => (0, qo._)`{limit: ${t10}}`
}, sG = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: oG,
  code(t10) {
    const { keyword: e3, data: r3, schemaCode: n3, it: i3 } = t10, o3 = e3 === "maxLength" ? qo.operators.GT : qo.operators.LT, s3 = i3.opts.unicode === false ? (0, qo._)`${r3}.length` : (0, qo._)`${(0, nG.useFunc)(t10.gen, iG.default)}(${r3})`;
    t10.fail$data((0, qo._)`${s3} ${o3} ${n3}`);
  }
};
Pd.default = sG;
var _d = {};
Object.defineProperty(_d, "__esModule", { value: true });
const aG = Ke, Ef = Le, lG = {
  message: ({ schemaCode: t10 }) => (0, Ef.str)`must match pattern "${t10}"`,
  params: ({ schemaCode: t10 }) => (0, Ef._)`{pattern: ${t10}}`
}, uG = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: lG,
  code(t10) {
    const { data: e3, $data: r3, schema: n3, schemaCode: i3, it: o3 } = t10, s3 = o3.opts.unicodeRegExp ? "u" : "", a3 = r3 ? (0, Ef._)`(new RegExp(${i3}, ${s3}))` : (0, aG.usePattern)(t10, n3);
    t10.fail$data((0, Ef._)`!${a3}.test(${e3})`);
  }
};
_d.default = uG;
var xd = {};
Object.defineProperty(xd, "__esModule", { value: true });
const $l = Le, cG = {
  message({ keyword: t10, schemaCode: e3 }) {
    const r3 = t10 === "maxProperties" ? "more" : "fewer";
    return (0, $l.str)`must NOT have ${r3} than ${e3} properties`;
  },
  params: ({ schemaCode: t10 }) => (0, $l._)`{limit: ${t10}}`
}, fG = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: cG,
  code(t10) {
    const { keyword: e3, data: r3, schemaCode: n3 } = t10, i3 = e3 === "maxProperties" ? $l.operators.GT : $l.operators.LT;
    t10.fail$data((0, $l._)`Object.keys(${r3}).length ${i3} ${n3}`);
  }
};
xd.default = fG;
var Qd = {};
Object.defineProperty(Qd, "__esModule", { value: true });
const tl = Ke, wl = Le, dG = tt, hG = {
  message: ({ params: { missingProperty: t10 } }) => (0, wl.str)`must have required property '${t10}'`,
  params: ({ params: { missingProperty: t10 } }) => (0, wl._)`{missingProperty: ${t10}}`
}, pG = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: hG,
  code(t10) {
    const { gen: e3, schema: r3, schemaCode: n3, data: i3, $data: o3, it: s3 } = t10, { opts: a3 } = s3;
    if (!o3 && r3.length === 0)
      return;
    const l3 = r3.length >= a3.loopRequired;
    if (s3.allErrors ? u3() : c3(), a3.strictRequired) {
      const p10 = t10.parentSchema.properties, { definedProperties: h10 } = t10.it;
      for (const m10 of r3)
        if ((p10 == null ? void 0 : p10[m10]) === void 0 && !h10.has(m10)) {
          const O10 = s3.schemaEnv.baseId + s3.errSchemaPath, g = `required property "${m10}" is not defined at "${O10}" (strictRequired)`;
          (0, dG.checkStrictMode)(s3, g, s3.opts.strictRequired);
        }
    }
    function u3() {
      if (l3 || o3)
        t10.block$data(wl.nil, f3);
      else
        for (const p10 of r3)
          (0, tl.checkReportMissingProp)(t10, p10);
    }
    function c3() {
      const p10 = e3.let("missing");
      if (l3 || o3) {
        const h10 = e3.let("valid", true);
        t10.block$data(h10, () => d3(p10, h10)), t10.ok(h10);
      } else
        e3.if((0, tl.checkMissingProp)(t10, r3, p10)), (0, tl.reportMissingProp)(t10, p10), e3.else();
    }
    function f3() {
      e3.forOf("prop", n3, (p10) => {
        t10.setParams({ missingProperty: p10 }), e3.if((0, tl.noPropertyInData)(e3, i3, p10, a3.ownProperties), () => t10.error());
      });
    }
    function d3(p10, h10) {
      t10.setParams({ missingProperty: p10 }), e3.forOf(p10, n3, () => {
        e3.assign(h10, (0, tl.propertyInData)(e3, i3, p10, a3.ownProperties)), e3.if((0, wl.not)(h10), () => {
          t10.error(), e3.break();
        });
      }, wl.nil);
    }
  }
};
Qd.default = pG;
var Td = {};
Object.defineProperty(Td, "__esModule", { value: true });
const Pl = Le, OG = {
  message({ keyword: t10, schemaCode: e3 }) {
    const r3 = t10 === "maxItems" ? "more" : "fewer";
    return (0, Pl.str)`must NOT have ${r3} than ${e3} items`;
  },
  params: ({ schemaCode: t10 }) => (0, Pl._)`{limit: ${t10}}`
}, mG = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: OG,
  code(t10) {
    const { keyword: e3, data: r3, schemaCode: n3 } = t10, i3 = e3 === "maxItems" ? Pl.operators.GT : Pl.operators.LT;
    t10.fail$data((0, Pl._)`${r3}.length ${i3} ${n3}`);
  }
};
Td.default = mG;
var kd = {}, _u = {};
Object.defineProperty(_u, "__esModule", { value: true });
const BT = TT;
BT.code = 'require("ajv/dist/runtime/equal").default';
_u.default = BT;
Object.defineProperty(kd, "__esModule", { value: true });
const ap = $u, sr = Le, gG = tt, yG = _u, vG = {
  message: ({ params: { i: t10, j: e3 } }) => (0, sr.str)`must NOT have duplicate items (items ## ${e3} and ${t10} are identical)`,
  params: ({ params: { i: t10, j: e3 } }) => (0, sr._)`{i: ${t10}, j: ${e3}}`
}, bG = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: vG,
  code(t10) {
    const { gen: e3, data: r3, $data: n3, schema: i3, parentSchema: o3, schemaCode: s3, it: a3 } = t10;
    if (!n3 && !i3)
      return;
    const l3 = e3.let("valid"), u3 = o3.items ? (0, ap.getSchemaTypes)(o3.items) : [];
    t10.block$data(l3, c3, (0, sr._)`${s3} === false`), t10.ok(l3);
    function c3() {
      const h10 = e3.let("i", (0, sr._)`${r3}.length`), m10 = e3.let("j");
      t10.setParams({ i: h10, j: m10 }), e3.assign(l3, true), e3.if((0, sr._)`${h10} > 1`, () => (f3() ? d3 : p10)(h10, m10));
    }
    function f3() {
      return u3.length > 0 && !u3.some((h10) => h10 === "object" || h10 === "array");
    }
    function d3(h10, m10) {
      const O10 = e3.name("item"), g = (0, ap.checkDataTypes)(u3, O10, a3.opts.strictNumbers, ap.DataType.Wrong), v10 = e3.const("indices", (0, sr._)`{}`);
      e3.for((0, sr._)`;${h10}--;`, () => {
        e3.let(O10, (0, sr._)`${r3}[${h10}]`), e3.if(g, (0, sr._)`continue`), u3.length > 1 && e3.if((0, sr._)`typeof ${O10} == "string"`, (0, sr._)`${O10} += "_"`), e3.if((0, sr._)`typeof ${v10}[${O10}] == "number"`, () => {
          e3.assign(m10, (0, sr._)`${v10}[${O10}]`), t10.error(), e3.assign(l3, false).break();
        }).code((0, sr._)`${v10}[${O10}] = ${h10}`);
      });
    }
    function p10(h10, m10) {
      const O10 = (0, gG.useFunc)(e3, yG.default), g = e3.name("outer");
      e3.label(g).for((0, sr._)`;${h10}--;`, () => e3.for((0, sr._)`${m10} = ${h10}; ${m10}--;`, () => e3.if((0, sr._)`${O10}(${r3}[${h10}], ${r3}[${m10}])`, () => {
        t10.error(), e3.assign(l3, false).break(g);
      })));
    }
  }
};
kd.default = bG;
var Ed = {};
Object.defineProperty(Ed, "__esModule", { value: true });
const Em = Le, SG = tt, $G = _u, wG = {
  message: "must be equal to constant",
  params: ({ schemaCode: t10 }) => (0, Em._)`{allowedValue: ${t10}}`
}, PG = {
  keyword: "const",
  $data: true,
  error: wG,
  code(t10) {
    const { gen: e3, data: r3, $data: n3, schemaCode: i3, schema: o3 } = t10;
    n3 || o3 && typeof o3 == "object" ? t10.fail$data((0, Em._)`!${(0, SG.useFunc)(e3, $G.default)}(${r3}, ${i3})`) : t10.fail((0, Em._)`${o3} !== ${r3}`);
  }
};
Ed.default = PG;
var Cd = {};
Object.defineProperty(Cd, "__esModule", { value: true });
const hl = Le, _G = tt, xG = _u, QG = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: t10 }) => (0, hl._)`{allowedValues: ${t10}}`
}, TG = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: QG,
  code(t10) {
    const { gen: e3, data: r3, $data: n3, schema: i3, schemaCode: o3, it: s3 } = t10;
    if (!n3 && i3.length === 0)
      throw new Error("enum must have non-empty array");
    const a3 = i3.length >= s3.opts.loopEnum;
    let l3;
    const u3 = () => l3 ?? (l3 = (0, _G.useFunc)(e3, xG.default));
    let c3;
    if (a3 || n3)
      c3 = e3.let("valid"), t10.block$data(c3, f3);
    else {
      if (!Array.isArray(i3))
        throw new Error("ajv implementation error");
      const p10 = e3.const("vSchema", o3);
      c3 = (0, hl.or)(...i3.map((h10, m10) => d3(p10, m10)));
    }
    t10.pass(c3);
    function f3() {
      e3.assign(c3, false), e3.forOf("v", o3, (p10) => e3.if((0, hl._)`${u3()}(${r3}, ${p10})`, () => e3.assign(c3, true).break()));
    }
    function d3(p10, h10) {
      const m10 = i3[h10];
      return typeof m10 == "object" && m10 !== null ? (0, hl._)`${u3()}(${r3}, ${p10}[${h10}])` : (0, hl._)`${r3} === ${m10}`;
    }
  }
};
Cd.default = TG;
Object.defineProperty(k0, "__esModule", { value: true });
const kG = E0, EG = C0, CG = wd, RG = Pd, AG = _d, XG = xd, qG = Qd, DG = Td, jG = kd, UG = Ed, IG = Cd, FG = [
  // number
  kG.default,
  EG.default,
  CG.default,
  // string
  RG.default,
  AG.default,
  // object
  XG.default,
  qG.default,
  // array
  DG.default,
  jG.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  UG.default,
  IG.default
];
k0.default = FG;
var Rd = {}, Ca = {};
Object.defineProperty(Ca, "__esModule", { value: true });
Ca.validateAdditionalItems = void 0;
const Do = Le, Cm = tt, ZG = {
  message: ({ params: { len: t10 } }) => (0, Do.str)`must NOT have more than ${t10} items`,
  params: ({ params: { len: t10 } }) => (0, Do._)`{limit: ${t10}}`
}, MG = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: ZG,
  code(t10) {
    const { parentSchema: e3, it: r3 } = t10, { items: n3 } = e3;
    if (!Array.isArray(n3)) {
      (0, Cm.checkStrictMode)(r3, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    zT(t10, n3);
  }
};
function zT(t10, e3) {
  const { gen: r3, schema: n3, data: i3, keyword: o3, it: s3 } = t10;
  s3.items = true;
  const a3 = r3.const("len", (0, Do._)`${i3}.length`);
  if (n3 === false)
    t10.setParams({ len: e3.length }), t10.pass((0, Do._)`${a3} <= ${e3.length}`);
  else if (typeof n3 == "object" && !(0, Cm.alwaysValidSchema)(s3, n3)) {
    const u3 = r3.var("valid", (0, Do._)`${a3} <= ${e3.length}`);
    r3.if((0, Do.not)(u3), () => l3(u3)), t10.ok(u3);
  }
  function l3(u3) {
    r3.forRange("i", e3.length, a3, (c3) => {
      t10.subschema({ keyword: o3, dataProp: c3, dataPropType: Cm.Type.Num }, u3), s3.allErrors || r3.if((0, Do.not)(u3), () => r3.break());
    });
  }
}
Ca.validateAdditionalItems = zT;
Ca.default = MG;
var A0 = {}, Ra = {};
Object.defineProperty(Ra, "__esModule", { value: true });
Ra.validateTuple = void 0;
const t$ = Le, jc = tt, NG = Ke, WG = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(t10) {
    const { schema: e3, it: r3 } = t10;
    if (Array.isArray(e3))
      return HT(t10, "additionalItems", e3);
    r3.items = true, !(0, jc.alwaysValidSchema)(r3, e3) && t10.ok((0, NG.validateArray)(t10));
  }
};
function HT(t10, e3, r3 = t10.schema) {
  const { gen: n3, parentSchema: i3, data: o3, keyword: s3, it: a3 } = t10;
  c3(i3), a3.opts.unevaluated && r3.length && a3.items !== true && (a3.items = jc.mergeEvaluated.items(n3, r3.length, a3.items));
  const l3 = n3.name("valid"), u3 = n3.const("len", (0, t$._)`${o3}.length`);
  r3.forEach((f3, d3) => {
    (0, jc.alwaysValidSchema)(a3, f3) || (n3.if((0, t$._)`${u3} > ${d3}`, () => t10.subschema({
      keyword: s3,
      schemaProp: d3,
      dataProp: d3
    }, l3)), t10.ok(l3));
  });
  function c3(f3) {
    const { opts: d3, errSchemaPath: p10 } = a3, h10 = r3.length, m10 = h10 === f3.minItems && (h10 === f3.maxItems || f3[e3] === false);
    if (d3.strictTuples && !m10) {
      const O10 = `"${s3}" is ${h10}-tuple, but minItems or maxItems/${e3} are not specified or different at path "${p10}"`;
      (0, jc.checkStrictMode)(a3, O10, d3.strictTuples);
    }
  }
}
Ra.validateTuple = HT;
Ra.default = WG;
Object.defineProperty(A0, "__esModule", { value: true });
const VG = Ra, YG = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (t10) => (0, VG.validateTuple)(t10, "items")
};
A0.default = YG;
var X0 = {};
Object.defineProperty(X0, "__esModule", { value: true });
const r$ = Le, LG = tt, BG = Ke, zG = Ca, HG = {
  message: ({ params: { len: t10 } }) => (0, r$.str)`must NOT have more than ${t10} items`,
  params: ({ params: { len: t10 } }) => (0, r$._)`{limit: ${t10}}`
}, GG = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: HG,
  code(t10) {
    const { schema: e3, parentSchema: r3, it: n3 } = t10, { prefixItems: i3 } = r3;
    n3.items = true, !(0, LG.alwaysValidSchema)(n3, e3) && (i3 ? (0, zG.validateAdditionalItems)(t10, i3) : t10.ok((0, BG.validateArray)(t10)));
  }
};
X0.default = GG;
var q0 = {};
Object.defineProperty(q0, "__esModule", { value: true });
const ln = Le, ic = tt, KG = {
  message: ({ params: { min: t10, max: e3 } }) => e3 === void 0 ? (0, ln.str)`must contain at least ${t10} valid item(s)` : (0, ln.str)`must contain at least ${t10} and no more than ${e3} valid item(s)`,
  params: ({ params: { min: t10, max: e3 } }) => e3 === void 0 ? (0, ln._)`{minContains: ${t10}}` : (0, ln._)`{minContains: ${t10}, maxContains: ${e3}}`
}, JG = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: KG,
  code(t10) {
    const { gen: e3, schema: r3, parentSchema: n3, data: i3, it: o3 } = t10;
    let s3, a3;
    const { minContains: l3, maxContains: u3 } = n3;
    o3.opts.next ? (s3 = l3 === void 0 ? 1 : l3, a3 = u3) : s3 = 1;
    const c3 = e3.const("len", (0, ln._)`${i3}.length`);
    if (t10.setParams({ min: s3, max: a3 }), a3 === void 0 && s3 === 0) {
      (0, ic.checkStrictMode)(o3, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (a3 !== void 0 && s3 > a3) {
      (0, ic.checkStrictMode)(o3, '"minContains" > "maxContains" is always invalid'), t10.fail();
      return;
    }
    if ((0, ic.alwaysValidSchema)(o3, r3)) {
      let m10 = (0, ln._)`${c3} >= ${s3}`;
      a3 !== void 0 && (m10 = (0, ln._)`${m10} && ${c3} <= ${a3}`), t10.pass(m10);
      return;
    }
    o3.items = true;
    const f3 = e3.name("valid");
    a3 === void 0 && s3 === 1 ? p10(f3, () => e3.if(f3, () => e3.break())) : s3 === 0 ? (e3.let(f3, true), a3 !== void 0 && e3.if((0, ln._)`${i3}.length > 0`, d3)) : (e3.let(f3, false), d3()), t10.result(f3, () => t10.reset());
    function d3() {
      const m10 = e3.name("_valid"), O10 = e3.let("count", 0);
      p10(m10, () => e3.if(m10, () => h10(O10)));
    }
    function p10(m10, O10) {
      e3.forRange("i", 0, c3, (g) => {
        t10.subschema({
          keyword: "contains",
          dataProp: g,
          dataPropType: ic.Type.Num,
          compositeRule: true
        }, m10), O10();
      });
    }
    function h10(m10) {
      e3.code((0, ln._)`${m10}++`), a3 === void 0 ? e3.if((0, ln._)`${m10} >= ${s3}`, () => e3.assign(f3, true).break()) : (e3.if((0, ln._)`${m10} > ${a3}`, () => e3.assign(f3, false).break()), s3 === 1 ? e3.assign(f3, true) : e3.if((0, ln._)`${m10} >= ${s3}`, () => e3.assign(f3, true)));
    }
  }
};
q0.default = JG;
var Ad = {};
(function(t10) {
  Object.defineProperty(t10, "__esModule", { value: true }), t10.validateSchemaDeps = t10.validatePropertyDeps = t10.error = void 0;
  const e3 = Le, r3 = tt, n3 = Ke;
  t10.error = {
    message: ({ params: { property: l3, depsCount: u3, deps: c3 } }) => {
      const f3 = u3 === 1 ? "property" : "properties";
      return (0, e3.str)`must have ${f3} ${c3} when property ${l3} is present`;
    },
    params: ({ params: { property: l3, depsCount: u3, deps: c3, missingProperty: f3 } }) => (0, e3._)`{property: ${l3},
    missingProperty: ${f3},
    depsCount: ${u3},
    deps: ${c3}}`
    // TODO change to reference
  };
  const i3 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: t10.error,
    code(l3) {
      const [u3, c3] = o3(l3);
      s3(l3, u3), a3(l3, c3);
    }
  };
  function o3({ schema: l3 }) {
    const u3 = {}, c3 = {};
    for (const f3 in l3) {
      if (f3 === "__proto__")
        continue;
      const d3 = Array.isArray(l3[f3]) ? u3 : c3;
      d3[f3] = l3[f3];
    }
    return [u3, c3];
  }
  function s3(l3, u3 = l3.schema) {
    const { gen: c3, data: f3, it: d3 } = l3;
    if (Object.keys(u3).length === 0)
      return;
    const p10 = c3.let("missing");
    for (const h10 in u3) {
      const m10 = u3[h10];
      if (m10.length === 0)
        continue;
      const O10 = (0, n3.propertyInData)(c3, f3, h10, d3.opts.ownProperties);
      l3.setParams({
        property: h10,
        depsCount: m10.length,
        deps: m10.join(", ")
      }), d3.allErrors ? c3.if(O10, () => {
        for (const g of m10)
          (0, n3.checkReportMissingProp)(l3, g);
      }) : (c3.if((0, e3._)`${O10} && (${(0, n3.checkMissingProp)(l3, m10, p10)})`), (0, n3.reportMissingProp)(l3, p10), c3.else());
    }
  }
  t10.validatePropertyDeps = s3;
  function a3(l3, u3 = l3.schema) {
    const { gen: c3, data: f3, keyword: d3, it: p10 } = l3, h10 = c3.name("valid");
    for (const m10 in u3)
      (0, r3.alwaysValidSchema)(p10, u3[m10]) || (c3.if(
        (0, n3.propertyInData)(c3, f3, m10, p10.opts.ownProperties),
        () => {
          const O10 = l3.subschema({ keyword: d3, schemaProp: m10 }, h10);
          l3.mergeValidEvaluated(O10, h10);
        },
        () => c3.var(h10, true)
        // TODO var
      ), l3.ok(h10));
  }
  t10.validateSchemaDeps = a3, t10.default = i3;
})(Ad);
var D0 = {};
Object.defineProperty(D0, "__esModule", { value: true });
const GT = Le, eK = tt, tK = {
  message: "property name must be valid",
  params: ({ params: t10 }) => (0, GT._)`{propertyName: ${t10.propertyName}}`
}, rK = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: tK,
  code(t10) {
    const { gen: e3, schema: r3, data: n3, it: i3 } = t10;
    if ((0, eK.alwaysValidSchema)(i3, r3))
      return;
    const o3 = e3.name("valid");
    e3.forIn("key", n3, (s3) => {
      t10.setParams({ propertyName: s3 }), t10.subschema({
        keyword: "propertyNames",
        data: s3,
        dataTypes: ["string"],
        propertyName: s3,
        compositeRule: true
      }, o3), e3.if((0, GT.not)(o3), () => {
        t10.error(true), i3.allErrors || e3.break();
      });
    }), t10.ok(o3);
  }
};
D0.default = rK;
var Xd = {};
Object.defineProperty(Xd, "__esModule", { value: true });
const oc = Ke, bn = Le, nK = nn, sc = tt, iK = {
  message: "must NOT have additional properties",
  params: ({ params: t10 }) => (0, bn._)`{additionalProperty: ${t10.additionalProperty}}`
}, oK = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: iK,
  code(t10) {
    const { gen: e3, schema: r3, parentSchema: n3, data: i3, errsCount: o3, it: s3 } = t10;
    if (!o3)
      throw new Error("ajv implementation error");
    const { allErrors: a3, opts: l3 } = s3;
    if (s3.props = true, l3.removeAdditional !== "all" && (0, sc.alwaysValidSchema)(s3, r3))
      return;
    const u3 = (0, oc.allSchemaProperties)(n3.properties), c3 = (0, oc.allSchemaProperties)(n3.patternProperties);
    f3(), t10.ok((0, bn._)`${o3} === ${nK.default.errors}`);
    function f3() {
      e3.forIn("key", i3, (O10) => {
        !u3.length && !c3.length ? h10(O10) : e3.if(d3(O10), () => h10(O10));
      });
    }
    function d3(O10) {
      let g;
      if (u3.length > 8) {
        const v10 = (0, sc.schemaRefOrVal)(s3, n3.properties, "properties");
        g = (0, oc.isOwnProperty)(e3, v10, O10);
      } else
        u3.length ? g = (0, bn.or)(...u3.map((v10) => (0, bn._)`${O10} === ${v10}`)) : g = bn.nil;
      return c3.length && (g = (0, bn.or)(g, ...c3.map((v10) => (0, bn._)`${(0, oc.usePattern)(t10, v10)}.test(${O10})`))), (0, bn.not)(g);
    }
    function p10(O10) {
      e3.code((0, bn._)`delete ${i3}[${O10}]`);
    }
    function h10(O10) {
      if (l3.removeAdditional === "all" || l3.removeAdditional && r3 === false) {
        p10(O10);
        return;
      }
      if (r3 === false) {
        t10.setParams({ additionalProperty: O10 }), t10.error(), a3 || e3.break();
        return;
      }
      if (typeof r3 == "object" && !(0, sc.alwaysValidSchema)(s3, r3)) {
        const g = e3.name("valid");
        l3.removeAdditional === "failing" ? (m10(O10, g, false), e3.if((0, bn.not)(g), () => {
          t10.reset(), p10(O10);
        })) : (m10(O10, g), a3 || e3.if((0, bn.not)(g), () => e3.break()));
      }
    }
    function m10(O10, g, v10) {
      const S10 = {
        keyword: "additionalProperties",
        dataProp: O10,
        dataPropType: sc.Type.Str
      };
      v10 === false && Object.assign(S10, {
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }), t10.subschema(S10, g);
    }
  }
};
Xd.default = oK;
var j0 = {};
Object.defineProperty(j0, "__esModule", { value: true });
const sK = kn, n$ = Ke, lp = tt, i$ = Xd, aK = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(t10) {
    const { gen: e3, schema: r3, parentSchema: n3, data: i3, it: o3 } = t10;
    o3.opts.removeAdditional === "all" && n3.additionalProperties === void 0 && i$.default.code(new sK.KeywordCxt(o3, i$.default, "additionalProperties"));
    const s3 = (0, n$.allSchemaProperties)(r3);
    for (const f3 of s3)
      o3.definedProperties.add(f3);
    o3.opts.unevaluated && s3.length && o3.props !== true && (o3.props = lp.mergeEvaluated.props(e3, (0, lp.toHash)(s3), o3.props));
    const a3 = s3.filter((f3) => !(0, lp.alwaysValidSchema)(o3, r3[f3]));
    if (a3.length === 0)
      return;
    const l3 = e3.name("valid");
    for (const f3 of a3)
      u3(f3) ? c3(f3) : (e3.if((0, n$.propertyInData)(e3, i3, f3, o3.opts.ownProperties)), c3(f3), o3.allErrors || e3.else().var(l3, true), e3.endIf()), t10.it.definedProperties.add(f3), t10.ok(l3);
    function u3(f3) {
      return o3.opts.useDefaults && !o3.compositeRule && r3[f3].default !== void 0;
    }
    function c3(f3) {
      t10.subschema({
        keyword: "properties",
        schemaProp: f3,
        dataProp: f3
      }, l3);
    }
  }
};
j0.default = aK;
var U0 = {};
Object.defineProperty(U0, "__esModule", { value: true });
const o$ = Ke, ac = Le, s$ = tt, a$ = tt, lK = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(t10) {
    const { gen: e3, schema: r3, data: n3, parentSchema: i3, it: o3 } = t10, { opts: s3 } = o3, a3 = (0, o$.allSchemaProperties)(r3), l3 = a3.filter((m10) => (0, s$.alwaysValidSchema)(o3, r3[m10]));
    if (a3.length === 0 || l3.length === a3.length && (!o3.opts.unevaluated || o3.props === true))
      return;
    const u3 = s3.strictSchema && !s3.allowMatchingProperties && i3.properties, c3 = e3.name("valid");
    o3.props !== true && !(o3.props instanceof ac.Name) && (o3.props = (0, a$.evaluatedPropsToName)(e3, o3.props));
    const { props: f3 } = o3;
    d3();
    function d3() {
      for (const m10 of a3)
        u3 && p10(m10), o3.allErrors ? h10(m10) : (e3.var(c3, true), h10(m10), e3.if(c3));
    }
    function p10(m10) {
      for (const O10 in u3)
        new RegExp(m10).test(O10) && (0, s$.checkStrictMode)(o3, `property ${O10} matches pattern ${m10} (use allowMatchingProperties)`);
    }
    function h10(m10) {
      e3.forIn("key", n3, (O10) => {
        e3.if((0, ac._)`${(0, o$.usePattern)(t10, m10)}.test(${O10})`, () => {
          const g = l3.includes(m10);
          g || t10.subschema({
            keyword: "patternProperties",
            schemaProp: m10,
            dataProp: O10,
            dataPropType: a$.Type.Str
          }, c3), o3.opts.unevaluated && f3 !== true ? e3.assign((0, ac._)`${f3}[${O10}]`, true) : !g && !o3.allErrors && e3.if((0, ac.not)(c3), () => e3.break());
        });
      });
    }
  }
};
U0.default = lK;
var I0 = {};
Object.defineProperty(I0, "__esModule", { value: true });
const uK = tt, cK = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(t10) {
    const { gen: e3, schema: r3, it: n3 } = t10;
    if ((0, uK.alwaysValidSchema)(n3, r3)) {
      t10.fail();
      return;
    }
    const i3 = e3.name("valid");
    t10.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, i3), t10.failResult(i3, () => t10.reset(), () => t10.error());
  },
  error: { message: "must NOT be valid" }
};
I0.default = cK;
var F0 = {};
Object.defineProperty(F0, "__esModule", { value: true });
const fK = Ke, dK = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: fK.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
F0.default = dK;
var Z0 = {};
Object.defineProperty(Z0, "__esModule", { value: true });
const Uc = Le, hK = tt, pK = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: t10 }) => (0, Uc._)`{passingSchemas: ${t10.passing}}`
}, OK = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: pK,
  code(t10) {
    const { gen: e3, schema: r3, parentSchema: n3, it: i3 } = t10;
    if (!Array.isArray(r3))
      throw new Error("ajv implementation error");
    if (i3.opts.discriminator && n3.discriminator)
      return;
    const o3 = r3, s3 = e3.let("valid", false), a3 = e3.let("passing", null), l3 = e3.name("_valid");
    t10.setParams({ passing: a3 }), e3.block(u3), t10.result(s3, () => t10.reset(), () => t10.error(true));
    function u3() {
      o3.forEach((c3, f3) => {
        let d3;
        (0, hK.alwaysValidSchema)(i3, c3) ? e3.var(l3, true) : d3 = t10.subschema({
          keyword: "oneOf",
          schemaProp: f3,
          compositeRule: true
        }, l3), f3 > 0 && e3.if((0, Uc._)`${l3} && ${s3}`).assign(s3, false).assign(a3, (0, Uc._)`[${a3}, ${f3}]`).else(), e3.if(l3, () => {
          e3.assign(s3, true), e3.assign(a3, f3), d3 && t10.mergeEvaluated(d3, Uc.Name);
        });
      });
    }
  }
};
Z0.default = OK;
var M0 = {};
Object.defineProperty(M0, "__esModule", { value: true });
const mK = tt, gK = {
  keyword: "allOf",
  schemaType: "array",
  code(t10) {
    const { gen: e3, schema: r3, it: n3 } = t10;
    if (!Array.isArray(r3))
      throw new Error("ajv implementation error");
    const i3 = e3.name("valid");
    r3.forEach((o3, s3) => {
      if ((0, mK.alwaysValidSchema)(n3, o3))
        return;
      const a3 = t10.subschema({ keyword: "allOf", schemaProp: s3 }, i3);
      t10.ok(i3), t10.mergeEvaluated(a3);
    });
  }
};
M0.default = gK;
var N0 = {};
Object.defineProperty(N0, "__esModule", { value: true });
const Cf = Le, KT = tt, yK = {
  message: ({ params: t10 }) => (0, Cf.str)`must match "${t10.ifClause}" schema`,
  params: ({ params: t10 }) => (0, Cf._)`{failingKeyword: ${t10.ifClause}}`
}, vK = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: yK,
  code(t10) {
    const { gen: e3, parentSchema: r3, it: n3 } = t10;
    r3.then === void 0 && r3.else === void 0 && (0, KT.checkStrictMode)(n3, '"if" without "then" and "else" is ignored');
    const i3 = l$(n3, "then"), o3 = l$(n3, "else");
    if (!i3 && !o3)
      return;
    const s3 = e3.let("valid", true), a3 = e3.name("_valid");
    if (l3(), t10.reset(), i3 && o3) {
      const c3 = e3.let("ifClause");
      t10.setParams({ ifClause: c3 }), e3.if(a3, u3("then", c3), u3("else", c3));
    } else
      i3 ? e3.if(a3, u3("then")) : e3.if((0, Cf.not)(a3), u3("else"));
    t10.pass(s3, () => t10.error(true));
    function l3() {
      const c3 = t10.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, a3);
      t10.mergeEvaluated(c3);
    }
    function u3(c3, f3) {
      return () => {
        const d3 = t10.subschema({ keyword: c3 }, a3);
        e3.assign(s3, a3), t10.mergeValidEvaluated(d3, s3), f3 ? e3.assign(f3, (0, Cf._)`${c3}`) : t10.setParams({ ifClause: c3 });
      };
    }
  }
};
function l$(t10, e3) {
  const r3 = t10.schema[e3];
  return r3 !== void 0 && !(0, KT.alwaysValidSchema)(t10, r3);
}
N0.default = vK;
var W0 = {};
Object.defineProperty(W0, "__esModule", { value: true });
const bK = tt, SK = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: t10, parentSchema: e3, it: r3 }) {
    e3.if === void 0 && (0, bK.checkStrictMode)(r3, `"${t10}" without "if" is ignored`);
  }
};
W0.default = SK;
Object.defineProperty(Rd, "__esModule", { value: true });
const $K = Ca, wK = A0, PK = Ra, _K = X0, xK = q0, QK = Ad, TK = D0, kK = Xd, EK = j0, CK = U0, RK = I0, AK = F0, XK = Z0, qK = M0, DK = N0, jK = W0;
function UK(t10 = false) {
  const e3 = [
    // any
    RK.default,
    AK.default,
    XK.default,
    qK.default,
    DK.default,
    jK.default,
    // object
    TK.default,
    kK.default,
    QK.default,
    EK.default,
    CK.default
  ];
  return t10 ? e3.push(wK.default, _K.default) : e3.push($K.default, PK.default), e3.push(xK.default), e3;
}
Rd.default = UK;
var qd = {}, V0 = {};
Object.defineProperty(V0, "__esModule", { value: true });
const Ft = Le, IK = {
  message: ({ schemaCode: t10 }) => (0, Ft.str)`must match format "${t10}"`,
  params: ({ schemaCode: t10 }) => (0, Ft._)`{format: ${t10}}`
}, FK = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: IK,
  code(t10, e3) {
    const { gen: r3, data: n3, $data: i3, schema: o3, schemaCode: s3, it: a3 } = t10, { opts: l3, errSchemaPath: u3, schemaEnv: c3, self: f3 } = a3;
    if (!l3.validateFormats)
      return;
    i3 ? d3() : p10();
    function d3() {
      const h10 = r3.scopeValue("formats", {
        ref: f3.formats,
        code: l3.code.formats
      }), m10 = r3.const("fDef", (0, Ft._)`${h10}[${s3}]`), O10 = r3.let("fType"), g = r3.let("format");
      r3.if((0, Ft._)`typeof ${m10} == "object" && !(${m10} instanceof RegExp)`, () => r3.assign(O10, (0, Ft._)`${m10}.type || "string"`).assign(g, (0, Ft._)`${m10}.validate`), () => r3.assign(O10, (0, Ft._)`"string"`).assign(g, m10)), t10.fail$data((0, Ft.or)(v10(), S10()));
      function v10() {
        return l3.strictSchema === false ? Ft.nil : (0, Ft._)`${s3} && !${g}`;
      }
      function S10() {
        const $10 = c3.$async ? (0, Ft._)`(${m10}.async ? await ${g}(${n3}) : ${g}(${n3}))` : (0, Ft._)`${g}(${n3})`, _10 = (0, Ft._)`(typeof ${g} == "function" ? ${$10} : ${g}.test(${n3}))`;
        return (0, Ft._)`${g} && ${g} !== true && ${O10} === ${e3} && !${_10}`;
      }
    }
    function p10() {
      const h10 = f3.formats[o3];
      if (!h10) {
        v10();
        return;
      }
      if (h10 === true)
        return;
      const [m10, O10, g] = S10(h10);
      m10 === e3 && t10.pass($10());
      function v10() {
        if (l3.strictSchema === false) {
          f3.logger.warn(_10());
          return;
        }
        throw new Error(_10());
        function _10() {
          return `unknown format "${o3}" ignored in schema at path "${u3}"`;
        }
      }
      function S10(_10) {
        const P10 = _10 instanceof RegExp ? (0, Ft.regexpCode)(_10) : l3.code.formats ? (0, Ft._)`${l3.code.formats}${(0, Ft.getProperty)(o3)}` : void 0, q5 = r3.scopeValue("formats", { key: o3, ref: _10, code: P10 });
        return typeof _10 == "object" && !(_10 instanceof RegExp) ? [_10.type || "string", _10.validate, (0, Ft._)`${q5}.validate`] : ["string", _10, q5];
      }
      function $10() {
        if (typeof h10 == "object" && !(h10 instanceof RegExp) && h10.async) {
          if (!c3.$async)
            throw new Error("async format in sync schema");
          return (0, Ft._)`await ${g}(${n3})`;
        }
        return typeof O10 == "function" ? (0, Ft._)`${g}(${n3})` : (0, Ft._)`${g}.test(${n3})`;
      }
    }
  }
};
V0.default = FK;
Object.defineProperty(qd, "__esModule", { value: true });
const ZK = V0, MK = [ZK.default];
qd.default = MK;
Object.defineProperty(Q0, "__esModule", { value: true });
const NK = T0, WK = k0, VK = Rd, YK = qd, LK = ["title", "description", "default"], BK = [
  NK.default,
  WK.default,
  VK.default(),
  YK.default,
  LK
];
Q0.default = BK;
var Dd = {}, JT = {};
(function(t10) {
  Object.defineProperty(t10, "__esModule", { value: true }), t10.DiscrError = void 0, function(e3) {
    e3.Tag = "tag", e3.Mapping = "mapping";
  }(t10.DiscrError || (t10.DiscrError = {}));
})(JT);
Object.defineProperty(Dd, "__esModule", { value: true });
const Xs = Le, Rm = JT, u$ = Cr, zK = tt, HK = {
  message: ({ params: { discrError: t10, tagName: e3 } }) => t10 === Rm.DiscrError.Tag ? `tag "${e3}" must be string` : `value of tag "${e3}" must be in oneOf`,
  params: ({ params: { discrError: t10, tag: e3, tagName: r3 } }) => (0, Xs._)`{error: ${t10}, tag: ${r3}, tagValue: ${e3}}`
}, GK = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: HK,
  code(t10) {
    const { gen: e3, data: r3, schema: n3, parentSchema: i3, it: o3 } = t10, { oneOf: s3 } = i3;
    if (!o3.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const a3 = n3.propertyName;
    if (typeof a3 != "string")
      throw new Error("discriminator: requires propertyName");
    if (n3.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!s3)
      throw new Error("discriminator: requires oneOf keyword");
    const l3 = e3.let("valid", false), u3 = e3.const("tag", (0, Xs._)`${r3}${(0, Xs.getProperty)(a3)}`);
    e3.if((0, Xs._)`typeof ${u3} == "string"`, () => c3(), () => t10.error(false, { discrError: Rm.DiscrError.Tag, tag: u3, tagName: a3 })), t10.ok(l3);
    function c3() {
      const p10 = d3();
      e3.if(false);
      for (const h10 in p10)
        e3.elseIf((0, Xs._)`${u3} === ${h10}`), e3.assign(l3, f3(p10[h10]));
      e3.else(), t10.error(false, { discrError: Rm.DiscrError.Mapping, tag: u3, tagName: a3 }), e3.endIf();
    }
    function f3(p10) {
      const h10 = e3.name("valid"), m10 = t10.subschema({ keyword: "oneOf", schemaProp: p10 }, h10);
      return t10.mergeEvaluated(m10, Xs.Name), h10;
    }
    function d3() {
      var p10;
      const h10 = {}, m10 = g(i3);
      let O10 = true;
      for (let $10 = 0; $10 < s3.length; $10++) {
        let _10 = s3[$10];
        _10 != null && _10.$ref && !(0, zK.schemaHasRulesButRef)(_10, o3.self.RULES) && (_10 = u$.resolveRef.call(o3.self, o3.schemaEnv.root, o3.baseId, _10 == null ? void 0 : _10.$ref), _10 instanceof u$.SchemaEnv && (_10 = _10.schema));
        const P10 = (p10 = _10 == null ? void 0 : _10.properties) === null || p10 === void 0 ? void 0 : p10[a3];
        if (typeof P10 != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${a3}"`);
        O10 = O10 && (m10 || g(_10)), v10(P10, $10);
      }
      if (!O10)
        throw new Error(`discriminator: "${a3}" must be required`);
      return h10;
      function g({ required: $10 }) {
        return Array.isArray($10) && $10.includes(a3);
      }
      function v10($10, _10) {
        if ($10.const)
          S10($10.const, _10);
        else if ($10.enum)
          for (const P10 of $10.enum)
            S10(P10, _10);
        else
          throw new Error(`discriminator: "properties/${a3}" must have "const" or "enum"`);
      }
      function S10($10, _10) {
        if (typeof $10 != "string" || $10 in h10)
          throw new Error(`discriminator: "${a3}" values must be unique strings`);
        h10[$10] = _10;
      }
    }
  }
};
Dd.default = GK;
const KK = "http://json-schema.org/draft-04/schema#", JK = "http://json-schema.org/draft-04/schema#", eJ = "Core schema meta-schema", tJ = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  positiveInteger: {
    type: "integer",
    minimum: 0
  },
  positiveIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/positiveInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    minItems: 1,
    uniqueItems: true
  }
}, rJ = "object", nJ = {
  id: {
    type: "string",
    format: "uri"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: {},
  multipleOf: {
    type: "number",
    minimum: 0,
    exclusiveMinimum: true
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "boolean",
    default: false
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "boolean",
    default: false
  },
  maxLength: {
    $ref: "#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: {}
  },
  maxItems: {
    $ref: "#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: false
  },
  maxProperties: {
    $ref: "#/definitions/positiveInteger"
  },
  minProperties: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  enum: {
    type: "array",
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, iJ = {
  exclusiveMaximum: [
    "maximum"
  ],
  exclusiveMinimum: [
    "minimum"
  ]
}, oJ = {
  id: KK,
  $schema: JK,
  description: eJ,
  definitions: tJ,
  type: rJ,
  properties: nJ,
  dependencies: iJ,
  default: {}
};
(function(t10, e3) {
  Object.defineProperty(e3, "__esModule", { value: true }), e3.CodeGen = e3.Name = e3.nil = e3.stringify = e3.str = e3._ = e3.KeywordCxt = void 0;
  const r3 = ra, n3 = Q0, i3 = Dd, o3 = oJ, s3 = ["/properties"], a3 = "http://json-schema.org/draft-04/schema";
  class l3 extends r3.default {
    constructor(d3 = {}) {
      super({
        ...d3,
        schemaId: "id"
      });
    }
    _addVocabularies() {
      super._addVocabularies(), n3.default.forEach((d3) => this.addVocabulary(d3)), this.opts.discriminator && this.addKeyword(i3.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const d3 = this.opts.$data ? this.$dataMetaSchema(o3, s3) : o3;
      this.addMetaSchema(d3, a3, false), this.refs["http://json-schema.org/schema"] = a3;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a3) ? a3 : void 0);
    }
  }
  t10.exports = e3 = l3, Object.defineProperty(e3, "__esModule", { value: true }), e3.default = l3;
  var u3 = ra;
  Object.defineProperty(e3, "KeywordCxt", { enumerable: true, get: function() {
    return u3.KeywordCxt;
  } });
  var c3 = ra;
  Object.defineProperty(e3, "_", { enumerable: true, get: function() {
    return c3._;
  } }), Object.defineProperty(e3, "str", { enumerable: true, get: function() {
    return c3.str;
  } }), Object.defineProperty(e3, "stringify", { enumerable: true, get: function() {
    return c3.stringify;
  } }), Object.defineProperty(e3, "nil", { enumerable: true, get: function() {
    return c3.nil;
  } }), Object.defineProperty(e3, "Name", { enumerable: true, get: function() {
    return c3.Name;
  } }), Object.defineProperty(e3, "CodeGen", { enumerable: true, get: function() {
    return c3.CodeGen;
  } });
})(wm, wm.exports);
var sJ = wm.exports, Am = { exports: {} }, Y0 = {}, L0 = {}, B0 = {};
Object.defineProperty(B0, "__esModule", { value: true });
const aJ = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
B0.default = aJ;
Object.defineProperty(L0, "__esModule", { value: true });
const lJ = B0, uJ = li, cJ = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  lJ.default,
  uJ.default
];
L0.default = cJ;
var z0 = {}, H0 = {};
Object.defineProperty(H0, "__esModule", { value: true });
const Rf = Le, zi = Rf.operators, Af = {
  maximum: { okStr: "<=", ok: zi.LTE, fail: zi.GT },
  minimum: { okStr: ">=", ok: zi.GTE, fail: zi.LT },
  exclusiveMaximum: { okStr: "<", ok: zi.LT, fail: zi.GTE },
  exclusiveMinimum: { okStr: ">", ok: zi.GT, fail: zi.LTE }
}, fJ = {
  message: ({ keyword: t10, schemaCode: e3 }) => (0, Rf.str)`must be ${Af[t10].okStr} ${e3}`,
  params: ({ keyword: t10, schemaCode: e3 }) => (0, Rf._)`{comparison: ${Af[t10].okStr}, limit: ${e3}}`
}, dJ = {
  keyword: Object.keys(Af),
  type: "number",
  schemaType: "number",
  $data: true,
  error: fJ,
  code(t10) {
    const { keyword: e3, data: r3, schemaCode: n3 } = t10;
    t10.fail$data((0, Rf._)`${r3} ${Af[e3].fail} ${n3} || isNaN(${r3})`);
  }
};
H0.default = dJ;
Object.defineProperty(z0, "__esModule", { value: true });
const hJ = H0, pJ = wd, OJ = Pd, mJ = _d, gJ = xd, yJ = Qd, vJ = Td, bJ = kd, SJ = Ed, $J = Cd, wJ = [
  // number
  hJ.default,
  pJ.default,
  // string
  OJ.default,
  mJ.default,
  // object
  gJ.default,
  yJ.default,
  // array
  vJ.default,
  bJ.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  SJ.default,
  $J.default
];
z0.default = wJ;
var G0 = {}, Aa = {};
Object.defineProperty(Aa, "__esModule", { value: true });
Aa.dynamicAnchor = void 0;
const up = Le, PJ = nn, c$ = Cr, _J = li, xJ = {
  keyword: "$dynamicAnchor",
  schemaType: "string",
  code: (t10) => ek(t10, t10.schema)
};
function ek(t10, e3) {
  const { gen: r3, it: n3 } = t10;
  n3.schemaEnv.root.dynamicAnchors[e3] = true;
  const i3 = (0, up._)`${PJ.default.dynamicAnchors}${(0, up.getProperty)(e3)}`, o3 = n3.errSchemaPath === "#" ? n3.validateName : QJ(t10);
  r3.if((0, up._)`!${i3}`, () => r3.assign(i3, o3));
}
Aa.dynamicAnchor = ek;
function QJ(t10) {
  const { schemaEnv: e3, schema: r3, self: n3 } = t10.it, { root: i3, baseId: o3, localRefs: s3, meta: a3 } = e3.root, { schemaId: l3 } = n3.opts, u3 = new c$.SchemaEnv({ schema: r3, schemaId: l3, root: i3, baseId: o3, localRefs: s3, meta: a3 });
  return c$.compileSchema.call(n3, u3), (0, _J.getValidate)(t10, u3);
}
Aa.default = xJ;
var Xa = {};
Object.defineProperty(Xa, "__esModule", { value: true });
Xa.dynamicRef = void 0;
const f$ = Le, TJ = nn, d$ = li, kJ = {
  keyword: "$dynamicRef",
  schemaType: "string",
  code: (t10) => tk(t10, t10.schema)
};
function tk(t10, e3) {
  const { gen: r3, keyword: n3, it: i3 } = t10;
  if (e3[0] !== "#")
    throw new Error(`"${n3}" only supports hash fragment reference`);
  const o3 = e3.slice(1);
  if (i3.allErrors)
    s3();
  else {
    const l3 = r3.let("valid", false);
    s3(l3), t10.ok(l3);
  }
  function s3(l3) {
    if (i3.schemaEnv.root.dynamicAnchors[o3]) {
      const u3 = r3.let("_v", (0, f$._)`${TJ.default.dynamicAnchors}${(0, f$.getProperty)(o3)}`);
      r3.if(u3, a3(u3, l3), a3(i3.validateName, l3));
    } else
      a3(i3.validateName, l3)();
  }
  function a3(l3, u3) {
    return u3 ? () => r3.block(() => {
      (0, d$.callRef)(t10, l3), r3.let(u3, true);
    }) : () => (0, d$.callRef)(t10, l3);
  }
}
Xa.dynamicRef = tk;
Xa.default = kJ;
var K0 = {};
Object.defineProperty(K0, "__esModule", { value: true });
const EJ = Aa, CJ = tt, RJ = {
  keyword: "$recursiveAnchor",
  schemaType: "boolean",
  code(t10) {
    t10.schema ? (0, EJ.dynamicAnchor)(t10, "") : (0, CJ.checkStrictMode)(t10.it, "$recursiveAnchor: false is ignored");
  }
};
K0.default = RJ;
var J0 = {};
Object.defineProperty(J0, "__esModule", { value: true });
const AJ = Xa, XJ = {
  keyword: "$recursiveRef",
  schemaType: "string",
  code: (t10) => (0, AJ.dynamicRef)(t10, t10.schema)
};
J0.default = XJ;
Object.defineProperty(G0, "__esModule", { value: true });
const qJ = Aa, DJ = Xa, jJ = K0, UJ = J0, IJ = [qJ.default, DJ.default, jJ.default, UJ.default];
G0.default = IJ;
var e1 = {}, t1 = {};
Object.defineProperty(t1, "__esModule", { value: true });
const h$ = Ad, FJ = {
  keyword: "dependentRequired",
  type: "object",
  schemaType: "object",
  error: h$.error,
  code: (t10) => (0, h$.validatePropertyDeps)(t10)
};
t1.default = FJ;
var r1 = {};
Object.defineProperty(r1, "__esModule", { value: true });
const ZJ = Ad, MJ = {
  keyword: "dependentSchemas",
  type: "object",
  schemaType: "object",
  code: (t10) => (0, ZJ.validateSchemaDeps)(t10)
};
r1.default = MJ;
var n1 = {};
Object.defineProperty(n1, "__esModule", { value: true });
const NJ = tt, WJ = {
  keyword: ["maxContains", "minContains"],
  type: "array",
  schemaType: "number",
  code({ keyword: t10, parentSchema: e3, it: r3 }) {
    e3.contains === void 0 && (0, NJ.checkStrictMode)(r3, `"${t10}" without "contains" is ignored`);
  }
};
n1.default = WJ;
Object.defineProperty(e1, "__esModule", { value: true });
const VJ = t1, YJ = r1, LJ = n1, BJ = [VJ.default, YJ.default, LJ.default];
e1.default = BJ;
var i1 = {}, o1 = {};
Object.defineProperty(o1, "__esModule", { value: true });
const Hi = Le, p$ = tt, zJ = nn, HJ = {
  message: "must NOT have unevaluated properties",
  params: ({ params: t10 }) => (0, Hi._)`{unevaluatedProperty: ${t10.unevaluatedProperty}}`
}, GJ = {
  keyword: "unevaluatedProperties",
  type: "object",
  schemaType: ["boolean", "object"],
  trackErrors: true,
  error: HJ,
  code(t10) {
    const { gen: e3, schema: r3, data: n3, errsCount: i3, it: o3 } = t10;
    if (!i3)
      throw new Error("ajv implementation error");
    const { allErrors: s3, props: a3 } = o3;
    a3 instanceof Hi.Name ? e3.if((0, Hi._)`${a3} !== true`, () => e3.forIn("key", n3, (f3) => e3.if(u3(a3, f3), () => l3(f3)))) : a3 !== true && e3.forIn("key", n3, (f3) => a3 === void 0 ? l3(f3) : e3.if(c3(a3, f3), () => l3(f3))), o3.props = true, t10.ok((0, Hi._)`${i3} === ${zJ.default.errors}`);
    function l3(f3) {
      if (r3 === false) {
        t10.setParams({ unevaluatedProperty: f3 }), t10.error(), s3 || e3.break();
        return;
      }
      if (!(0, p$.alwaysValidSchema)(o3, r3)) {
        const d3 = e3.name("valid");
        t10.subschema({
          keyword: "unevaluatedProperties",
          dataProp: f3,
          dataPropType: p$.Type.Str
        }, d3), s3 || e3.if((0, Hi.not)(d3), () => e3.break());
      }
    }
    function u3(f3, d3) {
      return (0, Hi._)`!${f3} || !${f3}[${d3}]`;
    }
    function c3(f3, d3) {
      const p10 = [];
      for (const h10 in f3)
        f3[h10] === true && p10.push((0, Hi._)`${d3} !== ${h10}`);
      return (0, Hi.and)(...p10);
    }
  }
};
o1.default = GJ;
var s1 = {};
Object.defineProperty(s1, "__esModule", { value: true });
const jo = Le, O$ = tt, KJ = {
  message: ({ params: { len: t10 } }) => (0, jo.str)`must NOT have more than ${t10} items`,
  params: ({ params: { len: t10 } }) => (0, jo._)`{limit: ${t10}}`
}, JJ = {
  keyword: "unevaluatedItems",
  type: "array",
  schemaType: ["boolean", "object"],
  error: KJ,
  code(t10) {
    const { gen: e3, schema: r3, data: n3, it: i3 } = t10, o3 = i3.items || 0;
    if (o3 === true)
      return;
    const s3 = e3.const("len", (0, jo._)`${n3}.length`);
    if (r3 === false)
      t10.setParams({ len: o3 }), t10.fail((0, jo._)`${s3} > ${o3}`);
    else if (typeof r3 == "object" && !(0, O$.alwaysValidSchema)(i3, r3)) {
      const l3 = e3.var("valid", (0, jo._)`${s3} <= ${o3}`);
      e3.if((0, jo.not)(l3), () => a3(l3, o3)), t10.ok(l3);
    }
    i3.items = true;
    function a3(l3, u3) {
      e3.forRange("i", u3, s3, (c3) => {
        t10.subschema({ keyword: "unevaluatedItems", dataProp: c3, dataPropType: O$.Type.Num }, l3), i3.allErrors || e3.if((0, jo.not)(l3), () => e3.break());
      });
    }
  }
};
s1.default = JJ;
Object.defineProperty(i1, "__esModule", { value: true });
const eee = o1, tee = s1, ree = [eee.default, tee.default];
i1.default = ree;
var va = {};
Object.defineProperty(va, "__esModule", { value: true });
va.contentVocabulary = va.metadataVocabulary = void 0;
va.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
va.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(Y0, "__esModule", { value: true });
const nee = L0, iee = z0, oee = Rd, see = G0, aee = e1, lee = i1, uee = qd, m$ = va, cee = [
  see.default,
  nee.default,
  iee.default,
  (0, oee.default)(true),
  uee.default,
  m$.metadataVocabulary,
  m$.contentVocabulary,
  aee.default,
  lee.default
];
Y0.default = cee;
var a1 = {};
const fee = "https://json-schema.org/draft/2020-12/schema", dee = "https://json-schema.org/draft/2020-12/schema", hee = {
  "https://json-schema.org/draft/2020-12/vocab/core": true,
  "https://json-schema.org/draft/2020-12/vocab/applicator": true,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,
  "https://json-schema.org/draft/2020-12/vocab/validation": true,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": true,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,
  "https://json-schema.org/draft/2020-12/vocab/content": true
}, pee = "meta", Oee = "Core and Validation specifications meta-schema", mee = [
  {
    $ref: "meta/core"
  },
  {
    $ref: "meta/applicator"
  },
  {
    $ref: "meta/unevaluated"
  },
  {
    $ref: "meta/validation"
  },
  {
    $ref: "meta/meta-data"
  },
  {
    $ref: "meta/format-annotation"
  },
  {
    $ref: "meta/content"
  }
], gee = [
  "object",
  "boolean"
], yee = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", vee = {
  definitions: {
    $comment: '"definitions" has been replaced by "$defs".',
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    deprecated: true,
    default: {}
  },
  dependencies: {
    $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $dynamicRef: "#meta"
        },
        {
          $ref: "meta/validation#/$defs/stringArray"
        }
      ]
    },
    deprecated: true,
    default: {}
  },
  $recursiveAnchor: {
    $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
    $ref: "meta/core#/$defs/anchorString",
    deprecated: true
  },
  $recursiveRef: {
    $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
    $ref: "meta/core#/$defs/uriReferenceString",
    deprecated: true
  }
}, bee = {
  $schema: fee,
  $id: dee,
  $vocabulary: hee,
  $dynamicAnchor: pee,
  title: Oee,
  allOf: mee,
  type: gee,
  $comment: yee,
  properties: vee
}, See = "https://json-schema.org/draft/2020-12/schema", $ee = "https://json-schema.org/draft/2020-12/meta/applicator", wee = {
  "https://json-schema.org/draft/2020-12/vocab/applicator": true
}, Pee = "meta", _ee = "Applicator vocabulary meta-schema", xee = [
  "object",
  "boolean"
], Qee = {
  prefixItems: {
    $ref: "#/$defs/schemaArray"
  },
  items: {
    $dynamicRef: "#meta"
  },
  contains: {
    $dynamicRef: "#meta"
  },
  additionalProperties: {
    $dynamicRef: "#meta"
  },
  properties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependentSchemas: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  propertyNames: {
    $dynamicRef: "#meta"
  },
  if: {
    $dynamicRef: "#meta"
  },
  then: {
    $dynamicRef: "#meta"
  },
  else: {
    $dynamicRef: "#meta"
  },
  allOf: {
    $ref: "#/$defs/schemaArray"
  },
  anyOf: {
    $ref: "#/$defs/schemaArray"
  },
  oneOf: {
    $ref: "#/$defs/schemaArray"
  },
  not: {
    $dynamicRef: "#meta"
  }
}, Tee = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $dynamicRef: "#meta"
    }
  }
}, kee = {
  $schema: See,
  $id: $ee,
  $vocabulary: wee,
  $dynamicAnchor: Pee,
  title: _ee,
  type: xee,
  properties: Qee,
  $defs: Tee
}, Eee = "https://json-schema.org/draft/2020-12/schema", Cee = "https://json-schema.org/draft/2020-12/meta/unevaluated", Ree = {
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": true
}, Aee = "meta", Xee = "Unevaluated applicator vocabulary meta-schema", qee = [
  "object",
  "boolean"
], Dee = {
  unevaluatedItems: {
    $dynamicRef: "#meta"
  },
  unevaluatedProperties: {
    $dynamicRef: "#meta"
  }
}, jee = {
  $schema: Eee,
  $id: Cee,
  $vocabulary: Ree,
  $dynamicAnchor: Aee,
  title: Xee,
  type: qee,
  properties: Dee
}, Uee = "https://json-schema.org/draft/2020-12/schema", Iee = "https://json-schema.org/draft/2020-12/meta/content", Fee = {
  "https://json-schema.org/draft/2020-12/vocab/content": true
}, Zee = "meta", Mee = "Content vocabulary meta-schema", Nee = [
  "object",
  "boolean"
], Wee = {
  contentEncoding: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentSchema: {
    $dynamicRef: "#meta"
  }
}, Vee = {
  $schema: Uee,
  $id: Iee,
  $vocabulary: Fee,
  $dynamicAnchor: Zee,
  title: Mee,
  type: Nee,
  properties: Wee
}, Yee = "https://json-schema.org/draft/2020-12/schema", Lee = "https://json-schema.org/draft/2020-12/meta/core", Bee = {
  "https://json-schema.org/draft/2020-12/vocab/core": true
}, zee = "meta", Hee = "Core vocabulary meta-schema", Gee = [
  "object",
  "boolean"
], Kee = {
  $id: {
    $ref: "#/$defs/uriReferenceString",
    $comment: "Non-empty fragments not allowed.",
    pattern: "^[^#]*#?$"
  },
  $schema: {
    $ref: "#/$defs/uriString"
  },
  $ref: {
    $ref: "#/$defs/uriReferenceString"
  },
  $anchor: {
    $ref: "#/$defs/anchorString"
  },
  $dynamicRef: {
    $ref: "#/$defs/uriReferenceString"
  },
  $dynamicAnchor: {
    $ref: "#/$defs/anchorString"
  },
  $vocabulary: {
    type: "object",
    propertyNames: {
      $ref: "#/$defs/uriString"
    },
    additionalProperties: {
      type: "boolean"
    }
  },
  $comment: {
    type: "string"
  },
  $defs: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    }
  }
}, Jee = {
  anchorString: {
    type: "string",
    pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
  },
  uriString: {
    type: "string",
    format: "uri"
  },
  uriReferenceString: {
    type: "string",
    format: "uri-reference"
  }
}, ete = {
  $schema: Yee,
  $id: Lee,
  $vocabulary: Bee,
  $dynamicAnchor: zee,
  title: Hee,
  type: Gee,
  properties: Kee,
  $defs: Jee
}, tte = "https://json-schema.org/draft/2020-12/schema", rte = "https://json-schema.org/draft/2020-12/meta/format-annotation", nte = {
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": true
}, ite = "meta", ote = "Format vocabulary meta-schema for annotation results", ste = [
  "object",
  "boolean"
], ate = {
  format: {
    type: "string"
  }
}, lte = {
  $schema: tte,
  $id: rte,
  $vocabulary: nte,
  $dynamicAnchor: ite,
  title: ote,
  type: ste,
  properties: ate
}, ute = "https://json-schema.org/draft/2020-12/schema", cte = "https://json-schema.org/draft/2020-12/meta/meta-data", fte = {
  "https://json-schema.org/draft/2020-12/vocab/meta-data": true
}, dte = "meta", hte = "Meta-data vocabulary meta-schema", pte = [
  "object",
  "boolean"
], Ote = {
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: true,
  deprecated: {
    type: "boolean",
    default: false
  },
  readOnly: {
    type: "boolean",
    default: false
  },
  writeOnly: {
    type: "boolean",
    default: false
  },
  examples: {
    type: "array",
    items: true
  }
}, mte = {
  $schema: ute,
  $id: cte,
  $vocabulary: fte,
  $dynamicAnchor: dte,
  title: hte,
  type: pte,
  properties: Ote
}, gte = "https://json-schema.org/draft/2020-12/schema", yte = "https://json-schema.org/draft/2020-12/meta/validation", vte = {
  "https://json-schema.org/draft/2020-12/vocab/validation": true
}, bte = "meta", Ste = "Validation vocabulary meta-schema", $te = [
  "object",
  "boolean"
], wte = {
  type: {
    anyOf: [
      {
        $ref: "#/$defs/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/$defs/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  const: true,
  enum: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  maxItems: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: false
  },
  maxContains: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minContains: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 1
  },
  maxProperties: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/$defs/stringArray"
  },
  dependentRequired: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/stringArray"
    }
  }
}, Pte = {
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 0
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    default: []
  }
}, _te = {
  $schema: gte,
  $id: yte,
  $vocabulary: vte,
  $dynamicAnchor: bte,
  title: Ste,
  type: $te,
  properties: wte,
  $defs: Pte
};
Object.defineProperty(a1, "__esModule", { value: true });
const xte = bee, Qte = kee, Tte = jee, kte = Vee, Ete = ete, Cte = lte, Rte = mte, Ate = _te, Xte = ["/properties"];
function qte(t10) {
  return [
    xte,
    Qte,
    Tte,
    kte,
    Ete,
    e3(this, Cte),
    Rte,
    e3(this, Ate)
  ].forEach((r3) => this.addMetaSchema(r3, void 0, false)), this;
  function e3(r3, n3) {
    return t10 ? r3.$dataMetaSchema(n3, Xte) : n3;
  }
}
a1.default = qte;
(function(t10, e3) {
  Object.defineProperty(e3, "__esModule", { value: true }), e3.MissingRefError = e3.ValidationError = e3.CodeGen = e3.Name = e3.nil = e3.stringify = e3.str = e3._ = e3.KeywordCxt = void 0;
  const r3 = ra, n3 = Y0, i3 = Dd, o3 = a1, s3 = "https://json-schema.org/draft/2020-12/schema";
  class a3 extends r3.default {
    constructor(p10 = {}) {
      super({
        ...p10,
        dynamicRef: true,
        next: true,
        unevaluated: true
      });
    }
    _addVocabularies() {
      super._addVocabularies(), n3.default.forEach((p10) => this.addVocabulary(p10)), this.opts.discriminator && this.addKeyword(i3.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      const { $data: p10, meta: h10 } = this.opts;
      h10 && (o3.default.call(this, p10), this.refs["http://json-schema.org/schema"] = s3);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(s3) ? s3 : void 0);
    }
  }
  t10.exports = e3 = a3, Object.defineProperty(e3, "__esModule", { value: true }), e3.default = a3;
  var l3 = kn;
  Object.defineProperty(e3, "KeywordCxt", { enumerable: true, get: function() {
    return l3.KeywordCxt;
  } });
  var u3 = Le;
  Object.defineProperty(e3, "_", { enumerable: true, get: function() {
    return u3._;
  } }), Object.defineProperty(e3, "str", { enumerable: true, get: function() {
    return u3.str;
  } }), Object.defineProperty(e3, "stringify", { enumerable: true, get: function() {
    return u3.stringify;
  } }), Object.defineProperty(e3, "nil", { enumerable: true, get: function() {
    return u3.nil;
  } }), Object.defineProperty(e3, "Name", { enumerable: true, get: function() {
    return u3.Name;
  } }), Object.defineProperty(e3, "CodeGen", { enumerable: true, get: function() {
    return u3.CodeGen;
  } });
  var c3 = wu;
  Object.defineProperty(e3, "ValidationError", { enumerable: true, get: function() {
    return c3.default;
  } });
  var f3 = Pu;
  Object.defineProperty(e3, "MissingRefError", { enumerable: true, get: function() {
    return f3.default;
  } });
})(Am, Am.exports);
var Dte = Am.exports, Xm = { exports: {} };
const jte = "https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/schemas/v1.2/apiDeclaration.json#", Ute = "http://json-schema.org/draft-04/schema#", Ite = "object", Fte = [
  "swaggerVersion",
  "basePath",
  "apis"
], Zte = {
  swaggerVersion: {
    enum: [
      "1.2"
    ]
  },
  apiVersion: {
    type: "string"
  },
  basePath: {
    type: "string",
    format: "uri",
    pattern: "^https?://"
  },
  resourcePath: {
    type: "string",
    format: "uri",
    pattern: "^/"
  },
  apis: {
    type: "array",
    items: {
      $ref: "#/definitions/apiObject"
    }
  },
  models: {
    type: "object",
    additionalProperties: {
      $ref: "modelsObject.json#"
    }
  },
  produces: {
    $ref: "#/definitions/mimeTypeArray"
  },
  consumes: {
    $ref: "#/definitions/mimeTypeArray"
  },
  authorizations: {
    $ref: "authorizationObject.json#"
  }
}, Mte = false, Nte = {
  apiObject: {
    type: "object",
    required: [
      "path",
      "operations"
    ],
    properties: {
      path: {
        type: "string",
        format: "uri-template",
        pattern: "^/"
      },
      description: {
        type: "string"
      },
      operations: {
        type: "array",
        items: {
          $ref: "operationObject.json#"
        }
      }
    },
    additionalProperties: false
  },
  mimeTypeArray: {
    type: "array",
    items: {
      type: "string",
      format: "mime-type"
    },
    uniqueItems: true
  }
}, Wte = {
  id: jte,
  $schema: Ute,
  type: Ite,
  required: Fte,
  properties: Zte,
  additionalProperties: Mte,
  definitions: Nte
}, Vte = "A JSON Schema for Swagger 2.0 API.", Yte = "http://swagger.io/v2/schema.json#", Lte = "http://json-schema.org/draft-04/schema#", Bte = "object", zte = [
  "swagger",
  "info",
  "paths"
], Hte = false, Gte = {
  "^x-": {
    $ref: "#/definitions/vendorExtension"
  }
}, Kte = {
  swagger: {
    type: "string",
    enum: [
      "2.0"
    ],
    description: "The Swagger version of this document."
  },
  info: {
    $ref: "#/definitions/info"
  },
  host: {
    type: "string",
    pattern: "^[^{}/ :\\\\]+(?::\\d+)?$",
    description: "The host (name or ip) of the API. Example: 'swagger.io'"
  },
  basePath: {
    type: "string",
    pattern: "^/",
    description: "The base path to the API. Example: '/api'."
  },
  schemes: {
    $ref: "#/definitions/schemesList"
  },
  consumes: {
    description: "A list of MIME types accepted by the API.",
    allOf: [
      {
        $ref: "#/definitions/mediaTypeList"
      }
    ]
  },
  produces: {
    description: "A list of MIME types the API can produce.",
    allOf: [
      {
        $ref: "#/definitions/mediaTypeList"
      }
    ]
  },
  paths: {
    $ref: "#/definitions/paths"
  },
  definitions: {
    $ref: "#/definitions/definitions"
  },
  parameters: {
    $ref: "#/definitions/parameterDefinitions"
  },
  responses: {
    $ref: "#/definitions/responseDefinitions"
  },
  security: {
    $ref: "#/definitions/security"
  },
  securityDefinitions: {
    $ref: "#/definitions/securityDefinitions"
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/definitions/tag"
    },
    uniqueItems: true
  },
  externalDocs: {
    $ref: "#/definitions/externalDocs"
  }
}, Jte = {
  info: {
    type: "object",
    description: "General information about the API.",
    required: [
      "version",
      "title"
    ],
    additionalProperties: false,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      title: {
        type: "string",
        description: "A unique and precise title of the API."
      },
      version: {
        type: "string",
        description: "A semantic version number of the API."
      },
      description: {
        type: "string",
        description: "A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed."
      },
      termsOfService: {
        type: "string",
        description: "The terms of service for the API."
      },
      contact: {
        $ref: "#/definitions/contact"
      },
      license: {
        $ref: "#/definitions/license"
      }
    }
  },
  contact: {
    type: "object",
    description: "Contact information for the owners of the API.",
    additionalProperties: false,
    properties: {
      name: {
        type: "string",
        description: "The identifying name of the contact person/organization."
      },
      url: {
        type: "string",
        description: "The URL pointing to the contact information.",
        format: "uri"
      },
      email: {
        type: "string",
        description: "The email address of the contact person/organization.",
        format: "email"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  license: {
    type: "object",
    required: [
      "name"
    ],
    additionalProperties: false,
    properties: {
      name: {
        type: "string",
        description: "The name of the license type. It's encouraged to use an OSI compatible license."
      },
      url: {
        type: "string",
        description: "The URL pointing to the license.",
        format: "uri"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  paths: {
    type: "object",
    description: "Relative paths to the individual endpoints. They must be relative to the 'basePath'.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      },
      "^/": {
        $ref: "#/definitions/pathItem"
      }
    },
    additionalProperties: false
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/schema"
    },
    description: "One or more JSON objects describing the schemas being consumed and produced by the API."
  },
  parameterDefinitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/parameter"
    },
    description: "One or more JSON representations for parameters"
  },
  responseDefinitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/response"
    },
    description: "One or more JSON representations for responses"
  },
  externalDocs: {
    type: "object",
    additionalProperties: false,
    description: "information about external documentation",
    required: [
      "url"
    ],
    properties: {
      description: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  examples: {
    type: "object",
    additionalProperties: true
  },
  mimeType: {
    type: "string",
    description: "The MIME type of the HTTP message."
  },
  operation: {
    type: "object",
    required: [
      "responses"
    ],
    additionalProperties: false,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: true
      },
      summary: {
        type: "string",
        description: "A brief summary of the operation."
      },
      description: {
        type: "string",
        description: "A longer description of the operation, GitHub Flavored Markdown is allowed."
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      operationId: {
        type: "string",
        description: "A unique identifier of the operation."
      },
      produces: {
        description: "A list of MIME types the API can produce.",
        allOf: [
          {
            $ref: "#/definitions/mediaTypeList"
          }
        ]
      },
      consumes: {
        description: "A list of MIME types the API can consume.",
        allOf: [
          {
            $ref: "#/definitions/mediaTypeList"
          }
        ]
      },
      parameters: {
        $ref: "#/definitions/parametersList"
      },
      responses: {
        $ref: "#/definitions/responses"
      },
      schemes: {
        $ref: "#/definitions/schemesList"
      },
      deprecated: {
        type: "boolean",
        default: false
      },
      security: {
        $ref: "#/definitions/security"
      }
    }
  },
  pathItem: {
    type: "object",
    additionalProperties: false,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      $ref: {
        type: "string"
      },
      get: {
        $ref: "#/definitions/operation"
      },
      put: {
        $ref: "#/definitions/operation"
      },
      post: {
        $ref: "#/definitions/operation"
      },
      delete: {
        $ref: "#/definitions/operation"
      },
      options: {
        $ref: "#/definitions/operation"
      },
      head: {
        $ref: "#/definitions/operation"
      },
      patch: {
        $ref: "#/definitions/operation"
      },
      parameters: {
        $ref: "#/definitions/parametersList"
      }
    }
  },
  responses: {
    type: "object",
    description: "Response objects names can either be any valid HTTP status code or 'default'.",
    minProperties: 1,
    additionalProperties: false,
    patternProperties: {
      "^([0-9]{3})$|^(default)$": {
        $ref: "#/definitions/responseValue"
      },
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    not: {
      type: "object",
      additionalProperties: false,
      patternProperties: {
        "^x-": {
          $ref: "#/definitions/vendorExtension"
        }
      }
    }
  },
  responseValue: {
    oneOf: [
      {
        $ref: "#/definitions/response"
      },
      {
        $ref: "#/definitions/jsonReference"
      }
    ]
  },
  response: {
    type: "object",
    required: [
      "description"
    ],
    properties: {
      description: {
        type: "string"
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            $ref: "#/definitions/fileSchema"
          }
        ]
      },
      headers: {
        $ref: "#/definitions/headers"
      },
      examples: {
        $ref: "#/definitions/examples"
      }
    },
    additionalProperties: false,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  headers: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/header"
    }
  },
  header: {
    type: "object",
    additionalProperties: false,
    required: [
      "type"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "integer",
          "boolean",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  vendorExtension: {
    description: "Any property starting with x- is valid.",
    additionalProperties: true,
    additionalItems: true
  },
  bodyParameter: {
    type: "object",
    required: [
      "name",
      "in",
      "schema"
    ],
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "body"
        ]
      },
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: false
      },
      schema: {
        $ref: "#/definitions/schema"
      }
    },
    additionalProperties: false
  },
  headerParameterSubSchema: {
    additionalProperties: false,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: false
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "header"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  queryParameterSubSchema: {
    additionalProperties: false,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: false
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "query"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      allowEmptyValue: {
        type: "boolean",
        default: false,
        description: "allows sending a parameter by name only or with an empty value."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormatWithMulti"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  formDataParameterSubSchema: {
    additionalProperties: false,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: false
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "formData"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      allowEmptyValue: {
        type: "boolean",
        default: false,
        description: "allows sending a parameter by name only or with an empty value."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array",
          "file"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormatWithMulti"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  pathParameterSubSchema: {
    additionalProperties: false,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    required: [
      "required"
    ],
    properties: {
      required: {
        type: "boolean",
        enum: [
          true
        ],
        description: "Determines whether or not this parameter is required or optional."
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "path"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  nonBodyParameter: {
    type: "object",
    required: [
      "name",
      "in",
      "type"
    ],
    oneOf: [
      {
        $ref: "#/definitions/headerParameterSubSchema"
      },
      {
        $ref: "#/definitions/formDataParameterSubSchema"
      },
      {
        $ref: "#/definitions/queryParameterSubSchema"
      },
      {
        $ref: "#/definitions/pathParameterSubSchema"
      }
    ]
  },
  parameter: {
    oneOf: [
      {
        $ref: "#/definitions/bodyParameter"
      },
      {
        $ref: "#/definitions/nonBodyParameter"
      }
    ]
  },
  schema: {
    type: "object",
    description: "A deterministic version of a JSON Schema object.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      $ref: {
        type: "string"
      },
      format: {
        type: "string"
      },
      title: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/title"
      },
      description: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/description"
      },
      default: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/default"
      },
      multipleOf: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
      },
      maximum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
      },
      exclusiveMaximum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
      },
      minimum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
      },
      exclusiveMinimum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
      },
      maxLength: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minLength: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      pattern: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
      },
      maxItems: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minItems: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      uniqueItems: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
      },
      maxProperties: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minProperties: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      required: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
      },
      enum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
      },
      additionalProperties: {
        anyOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            type: "boolean"
          }
        ],
        default: {}
      },
      type: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/type"
      },
      items: {
        anyOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            type: "array",
            minItems: 1,
            items: {
              $ref: "#/definitions/schema"
            }
          }
        ],
        default: {}
      },
      allOf: {
        type: "array",
        minItems: 1,
        items: {
          $ref: "#/definitions/schema"
        }
      },
      properties: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/schema"
        },
        default: {}
      },
      discriminator: {
        type: "string"
      },
      readOnly: {
        type: "boolean",
        default: false
      },
      xml: {
        $ref: "#/definitions/xml"
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      example: {}
    },
    additionalProperties: false
  },
  fileSchema: {
    type: "object",
    description: "A deterministic version of a JSON Schema object.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    required: [
      "type"
    ],
    properties: {
      format: {
        type: "string"
      },
      title: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/title"
      },
      description: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/description"
      },
      default: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/default"
      },
      required: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
      },
      type: {
        type: "string",
        enum: [
          "file"
        ]
      },
      readOnly: {
        type: "boolean",
        default: false
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      example: {}
    },
    additionalProperties: false
  },
  primitivesItems: {
    type: "object",
    additionalProperties: false,
    properties: {
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "integer",
          "boolean",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  security: {
    type: "array",
    items: {
      $ref: "#/definitions/securityRequirement"
    },
    uniqueItems: true
  },
  securityRequirement: {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: true
    }
  },
  xml: {
    type: "object",
    additionalProperties: false,
    properties: {
      name: {
        type: "string"
      },
      namespace: {
        type: "string"
      },
      prefix: {
        type: "string"
      },
      attribute: {
        type: "boolean",
        default: false
      },
      wrapped: {
        type: "boolean",
        default: false
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  tag: {
    type: "object",
    additionalProperties: false,
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  securityDefinitions: {
    type: "object",
    additionalProperties: {
      oneOf: [
        {
          $ref: "#/definitions/basicAuthenticationSecurity"
        },
        {
          $ref: "#/definitions/apiKeySecurity"
        },
        {
          $ref: "#/definitions/oauth2ImplicitSecurity"
        },
        {
          $ref: "#/definitions/oauth2PasswordSecurity"
        },
        {
          $ref: "#/definitions/oauth2ApplicationSecurity"
        },
        {
          $ref: "#/definitions/oauth2AccessCodeSecurity"
        }
      ]
    }
  },
  basicAuthenticationSecurity: {
    type: "object",
    additionalProperties: false,
    required: [
      "type"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "basic"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  apiKeySecurity: {
    type: "object",
    additionalProperties: false,
    required: [
      "type",
      "name",
      "in"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "apiKey"
        ]
      },
      name: {
        type: "string"
      },
      in: {
        type: "string",
        enum: [
          "header",
          "query"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2ImplicitSecurity: {
    type: "object",
    additionalProperties: false,
    required: [
      "type",
      "flow",
      "authorizationUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "implicit"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      authorizationUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2PasswordSecurity: {
    type: "object",
    additionalProperties: false,
    required: [
      "type",
      "flow",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "password"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2ApplicationSecurity: {
    type: "object",
    additionalProperties: false,
    required: [
      "type",
      "flow",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "application"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2AccessCodeSecurity: {
    type: "object",
    additionalProperties: false,
    required: [
      "type",
      "flow",
      "authorizationUrl",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "accessCode"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      authorizationUrl: {
        type: "string",
        format: "uri"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2Scopes: {
    type: "object",
    additionalProperties: {
      type: "string"
    }
  },
  mediaTypeList: {
    type: "array",
    items: {
      $ref: "#/definitions/mimeType"
    },
    uniqueItems: true
  },
  parametersList: {
    type: "array",
    description: "The parameters needed to send a valid API call.",
    additionalItems: false,
    items: {
      oneOf: [
        {
          $ref: "#/definitions/parameter"
        },
        {
          $ref: "#/definitions/jsonReference"
        }
      ]
    },
    uniqueItems: true
  },
  schemesList: {
    type: "array",
    description: "The transfer protocol of the API.",
    items: {
      type: "string",
      enum: [
        "http",
        "https",
        "ws",
        "wss"
      ]
    },
    uniqueItems: true
  },
  collectionFormat: {
    type: "string",
    enum: [
      "csv",
      "ssv",
      "tsv",
      "pipes"
    ],
    default: "csv"
  },
  collectionFormatWithMulti: {
    type: "string",
    enum: [
      "csv",
      "ssv",
      "tsv",
      "pipes",
      "multi"
    ],
    default: "csv"
  },
  title: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/title"
  },
  description: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/description"
  },
  default: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/default"
  },
  multipleOf: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
  },
  maximum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
  },
  exclusiveMaximum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
  },
  minimum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
  },
  exclusiveMinimum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
  },
  maxLength: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
  },
  maxItems: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
  },
  enum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
  },
  jsonReference: {
    type: "object",
    required: [
      "$ref"
    ],
    additionalProperties: false,
    properties: {
      $ref: {
        type: "string"
      }
    }
  }
}, ere = {
  title: Vte,
  id: Yte,
  $schema: Lte,
  type: Bte,
  required: zte,
  additionalProperties: Hte,
  patternProperties: Gte,
  properties: Kte,
  definitions: Jte
}, tre = "https://spec.openapis.org/oas/3.0/schema/2019-04-02", rre = "http://json-schema.org/draft-04/schema#", nre = "Validation schema for OpenAPI Specification 3.0.X.", ire = "object", ore = [
  "openapi",
  "info",
  "paths"
], sre = {
  openapi: {
    type: "string",
    pattern: "^3\\.0\\.\\d(-.+)?$"
  },
  info: {
    $ref: "#/definitions/Info"
  },
  externalDocs: {
    $ref: "#/definitions/ExternalDocumentation"
  },
  servers: {
    type: "array",
    items: {
      $ref: "#/definitions/Server"
    }
  },
  security: {
    type: "array",
    items: {
      $ref: "#/definitions/SecurityRequirement"
    }
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/definitions/Tag"
    },
    uniqueItems: true
  },
  paths: {
    $ref: "#/definitions/Paths"
  },
  components: {
    $ref: "#/definitions/Components"
  }
}, are = {
  "^x-": {}
}, lre = false, ure = {
  Reference: {
    type: "object",
    required: [
      "$ref"
    ],
    patternProperties: {
      "^\\$ref$": {
        type: "string",
        format: "uri-reference"
      }
    }
  },
  Info: {
    type: "object",
    required: [
      "title",
      "version"
    ],
    properties: {
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      termsOfService: {
        type: "string",
        format: "uri-reference"
      },
      contact: {
        $ref: "#/definitions/Contact"
      },
      license: {
        $ref: "#/definitions/License"
      },
      version: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  Contact: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      },
      email: {
        type: "string",
        format: "email"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  License: {
    type: "object",
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  Server: {
    type: "object",
    required: [
      "url"
    ],
    properties: {
      url: {
        type: "string"
      },
      description: {
        type: "string"
      },
      variables: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/ServerVariable"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  ServerVariable: {
    type: "object",
    required: [
      "default"
    ],
    properties: {
      enum: {
        type: "array",
        items: {
          type: "string"
        }
      },
      default: {
        type: "string"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  Components: {
    type: "object",
    properties: {
      schemas: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Schema"
              },
              {
                $ref: "#/definitions/Reference"
              }
            ]
          }
        }
      },
      responses: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Response"
              }
            ]
          }
        }
      },
      parameters: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Parameter"
              }
            ]
          }
        }
      },
      examples: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Example"
              }
            ]
          }
        }
      },
      requestBodies: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/RequestBody"
              }
            ]
          }
        }
      },
      headers: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Header"
              }
            ]
          }
        }
      },
      securitySchemes: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/SecurityScheme"
              }
            ]
          }
        }
      },
      links: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Link"
              }
            ]
          }
        }
      },
      callbacks: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Callback"
              }
            ]
          }
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  Schema: {
    type: "object",
    properties: {
      title: {
        type: "string"
      },
      multipleOf: {
        type: "number",
        minimum: 0,
        exclusiveMinimum: true
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "boolean",
        default: false
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "boolean",
        default: false
      },
      maxLength: {
        type: "integer",
        minimum: 0
      },
      minLength: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      pattern: {
        type: "string",
        format: "regex"
      },
      maxItems: {
        type: "integer",
        minimum: 0
      },
      minItems: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      uniqueItems: {
        type: "boolean",
        default: false
      },
      maxProperties: {
        type: "integer",
        minimum: 0
      },
      minProperties: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      required: {
        type: "array",
        items: {
          type: "string"
        },
        minItems: 1,
        uniqueItems: true
      },
      enum: {
        type: "array",
        items: {},
        minItems: 1,
        uniqueItems: false
      },
      type: {
        type: "string",
        enum: [
          "array",
          "boolean",
          "integer",
          "number",
          "object",
          "string"
        ]
      },
      not: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      allOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      oneOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      anyOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      items: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      properties: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      additionalProperties: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          },
          {
            type: "boolean"
          }
        ],
        default: true
      },
      description: {
        type: "string"
      },
      format: {
        type: "string"
      },
      default: {},
      nullable: {
        type: "boolean",
        default: false
      },
      discriminator: {
        $ref: "#/definitions/Discriminator"
      },
      readOnly: {
        type: "boolean",
        default: false
      },
      writeOnly: {
        type: "boolean",
        default: false
      },
      example: {},
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      },
      deprecated: {
        type: "boolean",
        default: false
      },
      xml: {
        $ref: "#/definitions/XML"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  Discriminator: {
    type: "object",
    required: [
      "propertyName"
    ],
    properties: {
      propertyName: {
        type: "string"
      },
      mapping: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    }
  },
  XML: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      namespace: {
        type: "string",
        format: "uri"
      },
      prefix: {
        type: "string"
      },
      attribute: {
        type: "boolean",
        default: false
      },
      wrapped: {
        type: "boolean",
        default: false
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  Response: {
    type: "object",
    required: [
      "description"
    ],
    properties: {
      description: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Header"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        }
      },
      links: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Link"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  MediaType: {
    type: "object",
    properties: {
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      encoding: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/Encoding"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false,
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      }
    ]
  },
  Example: {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      value: {},
      externalValue: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  Header: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      required: {
        type: "boolean",
        default: false
      },
      deprecated: {
        type: "boolean",
        default: false
      },
      allowEmptyValue: {
        type: "boolean",
        default: false
      },
      style: {
        type: "string",
        enum: [
          "simple"
        ],
        default: "simple"
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: false
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        },
        minProperties: 1,
        maxProperties: 1
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false,
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      },
      {
        $ref: "#/definitions/SchemaXORContent"
      }
    ]
  },
  Paths: {
    type: "object",
    patternProperties: {
      "^\\/": {
        $ref: "#/definitions/PathItem"
      },
      "^x-": {}
    },
    additionalProperties: false
  },
  PathItem: {
    type: "object",
    properties: {
      $ref: {
        type: "string"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/definitions/Server"
        }
      },
      parameters: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Parameter"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        },
        uniqueItems: true
      }
    },
    patternProperties: {
      "^(get|put|post|delete|options|head|patch|trace)$": {
        $ref: "#/definitions/Operation"
      },
      "^x-": {}
    },
    additionalProperties: false
  },
  Operation: {
    type: "object",
    required: [
      "responses"
    ],
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        }
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      },
      operationId: {
        type: "string"
      },
      parameters: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Parameter"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        },
        uniqueItems: true
      },
      requestBody: {
        oneOf: [
          {
            $ref: "#/definitions/RequestBody"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      responses: {
        $ref: "#/definitions/Responses"
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Callback"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      deprecated: {
        type: "boolean",
        default: false
      },
      security: {
        type: "array",
        items: {
          $ref: "#/definitions/SecurityRequirement"
        }
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/definitions/Server"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  Responses: {
    type: "object",
    properties: {
      default: {
        oneOf: [
          {
            $ref: "#/definitions/Response"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      }
    },
    patternProperties: {
      "^[1-5](?:\\d{2}|XX)$": {
        oneOf: [
          {
            $ref: "#/definitions/Response"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      "^x-": {}
    },
    minProperties: 1,
    additionalProperties: false
  },
  SecurityRequirement: {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  Tag: {
    type: "object",
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  ExternalDocumentation: {
    type: "object",
    required: [
      "url"
    ],
    properties: {
      description: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  ExampleXORExamples: {
    description: "Example and examples are mutually exclusive",
    not: {
      required: [
        "example",
        "examples"
      ]
    }
  },
  SchemaXORContent: {
    description: "Schema and content are mutually exclusive, at least one is required",
    not: {
      required: [
        "schema",
        "content"
      ]
    },
    oneOf: [
      {
        required: [
          "schema"
        ]
      },
      {
        required: [
          "content"
        ],
        description: "Some properties are not allowed if content is present",
        allOf: [
          {
            not: {
              required: [
                "style"
              ]
            }
          },
          {
            not: {
              required: [
                "explode"
              ]
            }
          },
          {
            not: {
              required: [
                "allowReserved"
              ]
            }
          },
          {
            not: {
              required: [
                "example"
              ]
            }
          },
          {
            not: {
              required: [
                "examples"
              ]
            }
          }
        ]
      }
    ]
  },
  Parameter: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      in: {
        type: "string"
      },
      description: {
        type: "string"
      },
      required: {
        type: "boolean",
        default: false
      },
      deprecated: {
        type: "boolean",
        default: false
      },
      allowEmptyValue: {
        type: "boolean",
        default: false
      },
      style: {
        type: "string"
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: false
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        },
        minProperties: 1,
        maxProperties: 1
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false,
    required: [
      "name",
      "in"
    ],
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      },
      {
        $ref: "#/definitions/SchemaXORContent"
      },
      {
        $ref: "#/definitions/ParameterLocation"
      }
    ]
  },
  ParameterLocation: {
    description: "Parameter location",
    oneOf: [
      {
        description: "Parameter in path",
        required: [
          "required"
        ],
        properties: {
          in: {
            enum: [
              "path"
            ]
          },
          style: {
            enum: [
              "matrix",
              "label",
              "simple"
            ],
            default: "simple"
          },
          required: {
            enum: [
              true
            ]
          }
        }
      },
      {
        description: "Parameter in query",
        properties: {
          in: {
            enum: [
              "query"
            ]
          },
          style: {
            enum: [
              "form",
              "spaceDelimited",
              "pipeDelimited",
              "deepObject"
            ],
            default: "form"
          }
        }
      },
      {
        description: "Parameter in header",
        properties: {
          in: {
            enum: [
              "header"
            ]
          },
          style: {
            enum: [
              "simple"
            ],
            default: "simple"
          }
        }
      },
      {
        description: "Parameter in cookie",
        properties: {
          in: {
            enum: [
              "cookie"
            ]
          },
          style: {
            enum: [
              "form"
            ],
            default: "form"
          }
        }
      }
    ]
  },
  RequestBody: {
    type: "object",
    required: [
      "content"
    ],
    properties: {
      description: {
        type: "string"
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        }
      },
      required: {
        type: "boolean",
        default: false
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  SecurityScheme: {
    oneOf: [
      {
        $ref: "#/definitions/APIKeySecurityScheme"
      },
      {
        $ref: "#/definitions/HTTPSecurityScheme"
      },
      {
        $ref: "#/definitions/OAuth2SecurityScheme"
      },
      {
        $ref: "#/definitions/OpenIdConnectSecurityScheme"
      }
    ]
  },
  APIKeySecurityScheme: {
    type: "object",
    required: [
      "type",
      "name",
      "in"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "apiKey"
        ]
      },
      name: {
        type: "string"
      },
      in: {
        type: "string",
        enum: [
          "header",
          "query",
          "cookie"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  HTTPSecurityScheme: {
    type: "object",
    required: [
      "scheme",
      "type"
    ],
    properties: {
      scheme: {
        type: "string"
      },
      bearerFormat: {
        type: "string"
      },
      description: {
        type: "string"
      },
      type: {
        type: "string",
        enum: [
          "http"
        ]
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false,
    oneOf: [
      {
        description: "Bearer",
        properties: {
          scheme: {
            enum: [
              "bearer"
            ]
          }
        }
      },
      {
        description: "Non Bearer",
        not: {
          required: [
            "bearerFormat"
          ]
        },
        properties: {
          scheme: {
            not: {
              enum: [
                "bearer"
              ]
            }
          }
        }
      }
    ]
  },
  OAuth2SecurityScheme: {
    type: "object",
    required: [
      "type",
      "flows"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flows: {
        $ref: "#/definitions/OAuthFlows"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  OpenIdConnectSecurityScheme: {
    type: "object",
    required: [
      "type",
      "openIdConnectUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "openIdConnect"
        ]
      },
      openIdConnectUrl: {
        type: "string",
        format: "uri-reference"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  OAuthFlows: {
    type: "object",
    properties: {
      implicit: {
        $ref: "#/definitions/ImplicitOAuthFlow"
      },
      password: {
        $ref: "#/definitions/PasswordOAuthFlow"
      },
      clientCredentials: {
        $ref: "#/definitions/ClientCredentialsFlow"
      },
      authorizationCode: {
        $ref: "#/definitions/AuthorizationCodeOAuthFlow"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  ImplicitOAuthFlow: {
    type: "object",
    required: [
      "authorizationUrl",
      "scopes"
    ],
    properties: {
      authorizationUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  PasswordOAuthFlow: {
    type: "object",
    required: [
      "tokenUrl"
    ],
    properties: {
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  ClientCredentialsFlow: {
    type: "object",
    required: [
      "tokenUrl"
    ],
    properties: {
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  AuthorizationCodeOAuthFlow: {
    type: "object",
    required: [
      "authorizationUrl",
      "tokenUrl"
    ],
    properties: {
      authorizationUrl: {
        type: "string",
        format: "uri-reference"
      },
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false
  },
  Link: {
    type: "object",
    properties: {
      operationId: {
        type: "string"
      },
      operationRef: {
        type: "string",
        format: "uri-reference"
      },
      parameters: {
        type: "object",
        additionalProperties: {}
      },
      requestBody: {},
      description: {
        type: "string"
      },
      server: {
        $ref: "#/definitions/Server"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: false,
    not: {
      description: "Operation Id and Operation Ref are mutually exclusive",
      required: [
        "operationId",
        "operationRef"
      ]
    }
  },
  Callback: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/PathItem"
    },
    patternProperties: {
      "^x-": {}
    }
  },
  Encoding: {
    type: "object",
    properties: {
      contentType: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/Header"
        }
      },
      style: {
        type: "string",
        enum: [
          "form",
          "spaceDelimited",
          "pipeDelimited",
          "deepObject"
        ]
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: false
      }
    },
    additionalProperties: false
  }
}, cre = {
  id: tre,
  $schema: rre,
  description: nre,
  type: ire,
  required: ore,
  properties: sre,
  patternProperties: are,
  additionalProperties: lre,
  definitions: ure
}, fre = "https://spec.openapis.org/oas/3.1/schema/2021-04-15", dre = "https://json-schema.org/draft/2020-12/schema", hre = "object", pre = {
  openapi: {
    type: "string",
    pattern: "^3\\.1\\.\\d+(-.+)?$"
  },
  info: {
    $ref: "#/$defs/info"
  },
  jsonSchemaDialect: {
    $ref: "#/$defs/uri",
    default: "https://spec.openapis.org/oas/3.1/dialect/base"
  },
  servers: {
    type: "array",
    items: {
      $ref: "#/$defs/server"
    }
  },
  paths: {
    $ref: "#/$defs/paths"
  },
  webhooks: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/path-item-or-reference"
    }
  },
  components: {
    $ref: "#/$defs/components"
  },
  security: {
    type: "array",
    items: {
      $ref: "#/$defs/security-requirement"
    }
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/$defs/tag"
    }
  },
  externalDocs: {
    $ref: "#/$defs/external-documentation"
  }
}, Ore = [
  "openapi",
  "info"
], mre = [
  {
    required: [
      "paths"
    ]
  },
  {
    required: [
      "components"
    ]
  },
  {
    required: [
      "webhooks"
    ]
  }
], gre = "#/$defs/specification-extensions", yre = false, vre = {
  info: {
    type: "object",
    properties: {
      title: {
        type: "string"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      termsOfService: {
        type: "string"
      },
      contact: {
        $ref: "#/$defs/contact"
      },
      license: {
        $ref: "#/$defs/license"
      },
      version: {
        type: "string"
      }
    },
    required: [
      "title",
      "version"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  contact: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string"
      },
      email: {
        type: "string"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  license: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      identifier: {
        type: "string"
      },
      url: {
        $ref: "#/$defs/uri"
      }
    },
    required: [
      "name"
    ],
    oneOf: [
      {
        required: [
          "identifier"
        ]
      },
      {
        required: [
          "url"
        ]
      }
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  server: {
    type: "object",
    properties: {
      url: {
        $ref: "#/$defs/uri"
      },
      description: {
        type: "string"
      },
      variables: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/server-variable"
        }
      }
    },
    required: [
      "url"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  "server-variable": {
    type: "object",
    properties: {
      enum: {
        type: "array",
        items: {
          type: "string"
        },
        minItems: 1
      },
      default: {
        type: "string"
      },
      descriptions: {
        type: "string"
      }
    },
    required: [
      "default"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  components: {
    type: "object",
    properties: {
      schemas: {
        type: "object",
        additionalProperties: {
          $dynamicRef: "#meta"
        }
      },
      responses: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/response-or-reference"
        }
      },
      parameters: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/parameter-or-reference"
        }
      },
      examples: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/example-or-reference"
        }
      },
      requestBodies: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/request-body-or-reference"
        }
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      securitySchemes: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/security-scheme-or-reference"
        }
      },
      links: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/link-or-reference"
        }
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/callbacks-or-reference"
        }
      },
      pathItems: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/path-item-or-reference"
        }
      }
    },
    patternProperties: {
      "^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$": {
        $comment: "Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
        propertyNames: {
          pattern: "^[a-zA-Z0-9._-]+$"
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  paths: {
    type: "object",
    patternProperties: {
      "^/": {
        $ref: "#/$defs/path-item"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  "path-item": {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/$defs/server"
        }
      },
      parameters: {
        type: "array",
        items: {
          $ref: "#/$defs/parameter-or-reference"
        }
      }
    },
    patternProperties: {
      "^(get|put|post|delete|options|head|patch|trace)$": {
        $ref: "#/$defs/operation"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  "path-item-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/path-item"
    }
  },
  operation: {
    type: "object",
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        }
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/$defs/external-documentation"
      },
      operationId: {
        type: "string"
      },
      parameters: {
        type: "array",
        items: {
          $ref: "#/$defs/parameter-or-reference"
        }
      },
      requestBody: {
        $ref: "#/$defs/request-body-or-reference"
      },
      responses: {
        $ref: "#/$defs/responses"
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/callbacks-or-reference"
        }
      },
      deprecated: {
        default: false,
        type: "boolean"
      },
      security: {
        type: "array",
        items: {
          $ref: "#/$defs/security-requirement"
        }
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/$defs/server"
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  "external-documentation": {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      url: {
        $ref: "#/$defs/uri"
      }
    },
    required: [
      "url"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  parameter: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      in: {
        enum: [
          "query",
          "header",
          "path",
          "cookie"
        ]
      },
      description: {
        type: "string"
      },
      required: {
        default: false,
        type: "boolean"
      },
      deprecated: {
        default: false,
        type: "boolean"
      },
      allowEmptyValue: {
        default: false,
        type: "boolean"
      },
      schema: {
        $dynamicRef: "#meta"
      },
      content: {
        $ref: "#/$defs/content"
      }
    },
    required: [
      "in"
    ],
    oneOf: [
      {
        required: [
          "schema"
        ]
      },
      {
        required: [
          "content"
        ]
      }
    ],
    dependentSchemas: {
      schema: {
        properties: {
          style: {
            type: "string"
          },
          explode: {
            type: "boolean"
          },
          allowReserved: {
            default: false,
            type: "boolean"
          }
        },
        allOf: [
          {
            $ref: "#/$defs/examples"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-form"
          }
        ],
        $defs: {
          "styles-for-path": {
            if: {
              properties: {
                in: {
                  const: "path"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "simple",
                  enum: [
                    "matrix",
                    "label",
                    "simple"
                  ]
                },
                required: {
                  const: true
                }
              },
              required: [
                "required"
              ]
            }
          },
          "styles-for-header": {
            if: {
              properties: {
                in: {
                  const: "header"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "simple",
                  enum: [
                    "simple"
                  ]
                }
              }
            }
          },
          "styles-for-query": {
            if: {
              properties: {
                in: {
                  const: "query"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "form",
                  enum: [
                    "form",
                    "spaceDelimited",
                    "pipeDelimited",
                    "deepObject"
                  ]
                }
              }
            }
          },
          "styles-for-cookie": {
            if: {
              properties: {
                in: {
                  const: "cookie"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "form",
                  enum: [
                    "form"
                  ]
                }
              }
            }
          },
          "styles-for-form": {
            if: {
              properties: {
                style: {
                  const: "form"
                }
              },
              required: [
                "style"
              ]
            },
            then: {
              properties: {
                explode: {
                  default: true
                }
              }
            },
            else: {
              properties: {
                explode: {
                  default: false
                }
              }
            }
          }
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  "parameter-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/parameter"
    }
  },
  "request-body": {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      content: {
        $ref: "#/$defs/content"
      },
      required: {
        default: false,
        type: "boolean"
      }
    },
    required: [
      "content"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  "request-body-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/request-body"
    }
  },
  content: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/media-type"
    },
    propertyNames: {
      format: "media-range"
    }
  },
  "media-type": {
    type: "object",
    properties: {
      schema: {
        $dynamicRef: "#meta"
      },
      encoding: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/encoding"
        }
      }
    },
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/examples"
      }
    ],
    unevaluatedProperties: false
  },
  encoding: {
    type: "object",
    properties: {
      contentType: {
        type: "string",
        format: "media-range"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      style: {
        default: "form",
        enum: [
          "form",
          "spaceDelimited",
          "pipeDelimited",
          "deepObject"
        ]
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        default: false,
        type: "boolean"
      }
    },
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/encoding/$defs/explode-default"
      }
    ],
    unevaluatedProperties: false,
    $defs: {
      "explode-default": {
        if: {
          properties: {
            style: {
              const: "form"
            }
          },
          required: [
            "style"
          ]
        },
        then: {
          properties: {
            explode: {
              default: true
            }
          }
        },
        else: {
          properties: {
            explode: {
              default: false
            }
          }
        }
      }
    }
  },
  responses: {
    type: "object",
    properties: {
      default: {
        $ref: "#/$defs/response-or-reference"
      }
    },
    patternProperties: {
      "^[1-5][0-9X]{2}$": {
        $ref: "#/$defs/response-or-reference"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  response: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      content: {
        $ref: "#/$defs/content"
      },
      links: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/link-or-reference"
        }
      }
    },
    required: [
      "description"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  "response-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/response"
    }
  },
  callbacks: {
    type: "object",
    $ref: "#/$defs/specification-extensions",
    additionalProperties: {
      $ref: "#/$defs/path-item-or-reference"
    }
  },
  "callbacks-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/callbacks"
    }
  },
  example: {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      value: true,
      externalValue: {
        $ref: "#/$defs/uri"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  "example-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/example"
    }
  },
  link: {
    type: "object",
    properties: {
      operationRef: {
        $ref: "#/$defs/uri"
      },
      operationId: true,
      parameters: {
        $ref: "#/$defs/map-of-strings"
      },
      requestBody: true,
      description: {
        type: "string"
      },
      body: {
        $ref: "#/$defs/server"
      }
    },
    oneOf: [
      {
        required: [
          "operationRef"
        ]
      },
      {
        required: [
          "operationId"
        ]
      }
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  "link-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/link"
    }
  },
  header: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      required: {
        default: false,
        type: "boolean"
      },
      deprecated: {
        default: false,
        type: "boolean"
      },
      allowEmptyValue: {
        default: false,
        type: "boolean"
      }
    },
    dependentSchemas: {
      schema: {
        properties: {
          style: {
            default: "simple",
            enum: [
              "simple"
            ]
          },
          explode: {
            default: false,
            type: "boolean"
          },
          allowReserved: {
            default: false,
            type: "boolean"
          },
          schema: {
            $dynamicRef: "#meta"
          }
        },
        $ref: "#/$defs/examples"
      },
      content: {
        properties: {
          content: {
            $ref: "#/$defs/content"
          }
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  "header-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/header"
    }
  },
  tag: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/$defs/external-documentation"
      }
    },
    required: [
      "name"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false
  },
  reference: {
    type: "object",
    properties: {
      $ref: {
        $ref: "#/$defs/uri"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      }
    },
    unevaluatedProperties: false
  },
  schema: {
    $dynamicAnchor: "meta",
    type: [
      "object",
      "boolean"
    ]
  },
  "security-scheme": {
    type: "object",
    properties: {
      type: {
        enum: [
          "apiKey",
          "http",
          "mutualTLS",
          "oauth2",
          "openIdConnect"
        ]
      },
      description: {
        type: "string"
      }
    },
    required: [
      "type"
    ],
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-apikey"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-http"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-http-bearer"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-oauth2"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-oidc"
      }
    ],
    unevaluatedProperties: false,
    $defs: {
      "type-apikey": {
        if: {
          properties: {
            type: {
              const: "apiKey"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            name: {
              type: "string"
            },
            in: {
              enum: [
                "query",
                "header",
                "cookie"
              ]
            }
          },
          required: [
            "name",
            "in"
          ]
        }
      },
      "type-http": {
        if: {
          properties: {
            type: {
              const: "http"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            scheme: {
              type: "string"
            }
          },
          required: [
            "scheme"
          ]
        }
      },
      "type-http-bearer": {
        if: {
          properties: {
            type: {
              const: "http"
            },
            scheme: {
              const: "bearer"
            }
          },
          required: [
            "type",
            "scheme"
          ]
        },
        then: {
          properties: {
            bearerFormat: {
              type: "string"
            }
          },
          required: [
            "scheme"
          ]
        }
      },
      "type-oauth2": {
        if: {
          properties: {
            type: {
              const: "oauth2"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            flows: {
              $ref: "#/$defs/oauth-flows"
            }
          },
          required: [
            "flows"
          ]
        }
      },
      "type-oidc": {
        if: {
          properties: {
            type: {
              const: "openIdConnect"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            openIdConnectUrl: {
              $ref: "#/$defs/uri"
            }
          },
          required: [
            "openIdConnectUrl"
          ]
        }
      }
    }
  },
  "security-scheme-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/security-scheme"
    }
  },
  "oauth-flows": {
    type: "object",
    properties: {
      implicit: {
        $ref: "#/$defs/oauth-flows/$defs/implicit"
      },
      password: {
        $ref: "#/$defs/oauth-flows/$defs/password"
      },
      clientCredentials: {
        $ref: "#/$defs/oauth-flows/$defs/client-credentials"
      },
      authorizationCode: {
        $ref: "#/$defs/oauth-flows/$defs/authorization-code"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: false,
    $defs: {
      implicit: {
        type: "object",
        properties: {
          authorizationUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "authorizationUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: false
      },
      password: {
        type: "object",
        properties: {
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: false
      },
      "client-credentials": {
        type: "object",
        properties: {
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: false
      },
      "authorization-code": {
        type: "object",
        properties: {
          authorizationUrl: {
            type: "string"
          },
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "authorizationUrl",
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: false
      }
    }
  },
  "security-requirement": {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  "specification-extensions": {
    patternProperties: {
      "^x-": true
    }
  },
  examples: {
    properties: {
      example: true,
      examples: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/example-or-reference"
        }
      }
    }
  },
  uri: {
    type: "string",
    format: "uri"
  },
  "map-of-strings": {
    type: "object",
    additionalProperties: {
      type: "string"
    }
  }
}, bre = {
  $id: fre,
  $schema: dre,
  type: hre,
  properties: pre,
  required: Ore,
  anyOf: mre,
  $ref: gre,
  unevaluatedProperties: yre,
  $defs: vre
};
(function(t10, e3) {
  Object.defineProperty(e3, "__esModule", { value: true }), e3.openapi = e3.openapiV31 = e3.openapiV3 = e3.openapiV2 = e3.openapiV1 = void 0, e3.openapiV1 = Wte, e3.openapiV2 = ere, e3.openapiV3 = cre, e3.openapiV31 = bre, e3.openapi = {
    v1: e3.openapiV1,
    v2: e3.openapiV2,
    v3: e3.openapiV3,
    v31: e3.openapiV31
  }, e3.default = e3.openapi, t10.exports = Object.assign(t10.exports.default, t10.exports);
})(Xm, Xm.exports);
var Sre = Xm.exports;
const $re = gs, { ono: wre } = fi, Pre = sJ, _re = Dte, { openapi: cp } = Sre;
var rk = xre;
function xre(t10) {
  let e3, r3;
  if (t10.swagger)
    r3 = cp.v2, e3 = fp();
  else if (t10.openapi.startsWith("3.1")) {
    r3 = cp.v31;
    const i3 = r3.$defs.schema;
    delete i3.$dynamicAnchor, r3.$defs.components.properties.schemas.additionalProperties = i3, r3.$defs.header.dependentSchemas.schema.properties.schema = i3, r3.$defs["media-type"].properties.schema = i3, r3.$defs.parameter.properties.schema = i3, e3 = fp(false);
  } else
    r3 = cp.v3, e3 = fp();
  if (!e3.validate(r3, t10)) {
    let i3 = e3.errors, o3 = `Swagger schema validation failed.
` + Qre(i3);
    throw wre.syntax(i3, { details: i3 }, o3);
  }
}
function fp(t10 = true) {
  const e3 = {
    allErrors: true,
    strict: false,
    validateFormats: false
  };
  return t10 ? new Pre(e3) : new _re(e3);
}
function Qre(t10, e3) {
  e3 = e3 || "  ";
  let r3 = "";
  for (let n3 of t10)
    r3 += $re.format(`${e3}#${n3.instancePath.length ? n3.instancePath : "/"} ${n3.message}
`);
  return r3;
}
var Tre = [
  "get",
  "put",
  "post",
  "delete",
  "options",
  "head",
  "patch"
];
const kre = gs, { ono: Sr } = fi, Ere = Tre, qm = ["array", "boolean", "integer", "number", "string"], nk = ["array", "boolean", "integer", "number", "string", "object", "null", void 0];
var ik = Cre;
function Cre(t10) {
  if (t10.openapi)
    return;
  let e3 = Object.keys(t10.paths || {}), r3 = [];
  for (let i3 of e3) {
    let o3 = t10.paths[i3], s3 = "/paths" + i3;
    o3 && i3.indexOf("/") === 0 && Rre(t10, o3, s3, r3);
  }
  let n3 = Object.keys(t10.definitions || {});
  for (let i3 of n3) {
    let o3 = t10.definitions[i3], s3 = "/definitions/" + i3;
    ok(o3, s3);
  }
}
function Rre(t10, e3, r3, n3) {
  for (let i3 of Ere) {
    let o3 = e3[i3], s3 = r3 + "/" + i3;
    if (o3) {
      let a3 = o3.operationId;
      if (a3)
        if (n3.indexOf(a3) === -1)
          n3.push(a3);
        else
          throw Sr.syntax(`Validation failed. Duplicate operation id '${a3}'`);
      Are(t10, e3, r3, o3, s3);
      let l3 = Object.keys(o3.responses || {});
      for (let u3 of l3) {
        let c3 = o3.responses[u3], f3 = s3 + "/responses/" + u3;
        jre(u3, c3 || {}, f3);
      }
    }
  }
}
function Are(t10, e3, r3, n3, i3) {
  let o3 = e3.parameters || [], s3 = n3.parameters || [];
  try {
    g$(o3);
  } catch (l3) {
    throw Sr.syntax(l3, `Validation failed. ${r3} has duplicate parameters`);
  }
  try {
    g$(s3);
  } catch (l3) {
    throw Sr.syntax(l3, `Validation failed. ${i3} has duplicate parameters`);
  }
  let a3 = o3.reduce((l3, u3) => (l3.some((f3) => f3.in === u3.in && f3.name === u3.name) || l3.push(u3), l3), s3.slice());
  Xre(a3, i3), qre(a3, r3, i3), Dre(a3, t10, n3, i3);
}
function Xre(t10, e3) {
  let r3 = t10.filter((i3) => i3.in === "body"), n3 = t10.filter((i3) => i3.in === "formData");
  if (r3.length > 1)
    throw Sr.syntax(
      `Validation failed. ${e3} has ${r3.length} body parameters. Only one is allowed.`
    );
  if (r3.length > 0 && n3.length > 0)
    throw Sr.syntax(
      `Validation failed. ${e3} has body parameters and formData parameters. Only one or the other is allowed.`
    );
}
function qre(t10, e3, r3) {
  let n3 = e3.match(kre.swaggerParamRegExp) || [];
  for (let i3 = 0; i3 < n3.length; i3++)
    for (let o3 = i3 + 1; o3 < n3.length; o3++)
      if (n3[i3] === n3[o3])
        throw Sr.syntax(
          `Validation failed. ${r3} has multiple path placeholders named ${n3[i3]}`
        );
  t10 = t10.filter((i3) => i3.in === "path");
  for (let i3 of t10) {
    if (i3.required !== true)
      throw Sr.syntax(
        `Validation failed. Path parameters cannot be optional. Set required=true for the "${i3.name}" parameter at ${r3}`
      );
    let o3 = n3.indexOf("{" + i3.name + "}");
    if (o3 === -1)
      throw Sr.syntax(
        `Validation failed. ${r3} has a path parameter named "${i3.name}", but there is no corresponding {${i3.name}} in the path string`
      );
    n3.splice(o3, 1);
  }
  if (n3.length > 0)
    throw Sr.syntax(`Validation failed. ${r3} is missing path parameter(s) for ${n3}`);
}
function Dre(t10, e3, r3, n3) {
  for (let i3 of t10) {
    let o3 = n3 + "/parameters/" + i3.name, s3, a3;
    switch (i3.in) {
      case "body":
        s3 = i3.schema, a3 = nk;
        break;
      case "formData":
        s3 = i3, a3 = qm.concat("file");
        break;
      default:
        s3 = i3, a3 = qm;
    }
    if (Dm(s3, o3, a3), ok(s3, o3), s3.type === "file") {
      let l3 = /multipart\/(.*\+)?form-data/, u3 = /application\/(.*\+)?x-www-form-urlencoded/;
      if (!(r3.consumes || e3.consumes || []).some((d3) => l3.test(d3) || u3.test(d3)))
        throw Sr.syntax(
          `Validation failed. ${n3} has a file parameter, so it must consume multipart/form-data or application/x-www-form-urlencoded`
        );
    }
  }
}
function g$(t10) {
  for (let e3 = 0; e3 < t10.length - 1; e3++) {
    let r3 = t10[e3];
    for (let n3 = e3 + 1; n3 < t10.length; n3++) {
      let i3 = t10[n3];
      if (r3.name === i3.name && r3.in === i3.in)
        throw Sr.syntax(`Validation failed. Found multiple ${r3.in} parameters named "${r3.name}"`);
    }
  }
}
function jre(t10, e3, r3) {
  if (t10 !== "default" && (t10 < 100 || t10 > 599))
    throw Sr.syntax(`Validation failed. ${r3} has an invalid response code (${t10})`);
  let n3 = Object.keys(e3.headers || {});
  for (let i3 of n3) {
    let o3 = e3.headers[i3], s3 = r3 + "/headers/" + i3;
    Dm(o3, s3, qm);
  }
  if (e3.schema) {
    let i3 = nk.concat("file");
    if (i3.indexOf(e3.schema.type) === -1)
      throw Sr.syntax(
        `Validation failed. ${r3} has an invalid response schema type (${e3.schema.type})`
      );
    Dm(e3.schema, r3 + "/schema", i3);
  }
}
function Dm(t10, e3, r3) {
  if (r3.indexOf(t10.type) === -1)
    throw Sr.syntax(
      `Validation failed. ${e3} has an invalid type (${t10.type})`
    );
  if (t10.type === "array" && !t10.items)
    throw Sr.syntax(`Validation failed. ${e3} is an array, so it must include an "items" schema`);
}
function ok(t10, e3) {
  function r3(n3, i3) {
    if (n3.properties)
      for (let o3 in n3.properties)
        n3.properties.hasOwnProperty(o3) && (i3[o3] = n3.properties[o3]);
    if (n3.allOf)
      for (let o3 of n3.allOf)
        r3(o3, i3);
  }
  if (t10.required && Array.isArray(t10.required)) {
    let n3 = {};
    r3(t10, n3);
    for (let i3 of t10.required)
      if (!n3[i3])
        throw Sr.syntax(
          `Validation failed. Property '${i3}' listed as required but does not exist in '${e3}'`
        );
  }
}
var Ht = {};
const { Ono: sk } = fi, { stripHash: ak, toFileSystemPath: Ure } = mn, Po = Ht.JSONParserError = class extends Error {
  constructor(e3, r3) {
    super(), this.code = "EUNKNOWN", this.message = e3, this.source = r3, this.path = null, sk.extend(this);
  }
};
_o(Po);
const lk = Ht.JSONParserErrorGroup = class uk extends Error {
  constructor(e3) {
    super(), this.files = e3, this.message = `${this.errors.length} error${this.errors.length > 1 ? "s" : ""} occurred while reading '${Ure(e3.$refs._root$Ref.path)}'`, sk.extend(this);
  }
  static getParserErrors(e3) {
    const r3 = [];
    for (const n3 of Object.values(e3.$refs._$refs))
      n3.errors && r3.push(...n3.errors);
    return r3;
  }
  get errors() {
    return uk.getParserErrors(this.files);
  }
};
_o(lk);
const Ire = Ht.ParserError = class extends Po {
  constructor(e3, r3) {
    super(`Error parsing ${r3}: ${e3}`, r3), this.code = "EPARSER";
  }
};
_o(Ire);
const Fre = Ht.UnmatchedParserError = class extends Po {
  constructor(e3) {
    super(`Could not find parser for "${e3}"`, e3), this.code = "EUNMATCHEDPARSER";
  }
};
_o(Fre);
const Zre = Ht.ResolverError = class extends Po {
  constructor(e3, r3) {
    super(e3.message || `Error reading file "${r3}"`, r3), this.code = "ERESOLVER", "code" in e3 && (this.ioErrorCode = String(e3.code));
  }
};
_o(Zre);
const Mre = Ht.UnmatchedResolverError = class extends Po {
  constructor(e3) {
    super(`Could not find resolver for "${e3}"`, e3), this.code = "EUNMATCHEDRESOLVER";
  }
};
_o(Mre);
const Nre = Ht.MissingPointerError = class extends Po {
  constructor(e3, r3) {
    super(`Token "${e3}" does not exist.`, ak(r3)), this.code = "EMISSINGPOINTER";
  }
};
_o(Nre);
const Wre = Ht.InvalidPointerError = class extends Po {
  constructor(e3, r3) {
    super(`Invalid $ref pointer "${e3}". Pointers must begin with "#/"`, ak(r3)), this.code = "EINVALIDPOINTER";
  }
};
_o(Wre);
function _o(t10) {
  Object.defineProperty(t10.prototype, "name", {
    value: t10.name,
    enumerable: true
  });
}
Ht.isHandledError = function(t10) {
  return t10 instanceof Po || t10 instanceof lk;
};
Ht.normalizeError = function(t10) {
  return t10.path === null && (t10.path = []), t10;
};
const { ParserError: Vre } = Ht;
var Yre = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 100,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   *
   * @type {boolean}
   */
  allowEmpty: true,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   *
   * @type {RegExp|string|string[]|function}
   */
  canParse: ".json",
  /**
   * Parses the given file as JSON
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Promise}
   */
  async parse(t10) {
    let e3 = t10.data;
    if ($e.Buffer.isBuffer(e3) && (e3 = e3.toString()), typeof e3 == "string") {
      if (e3.trim().length === 0)
        return;
      try {
        return JSON.parse(e3);
      } catch (r3) {
        throw new Vre(r3.message, t10.url);
      }
    } else
      return e3;
  }
}, jt = {}, xu = {}, gn = {};
function ck(t10) {
  return typeof t10 > "u" || t10 === null;
}
function Lre(t10) {
  return typeof t10 == "object" && t10 !== null;
}
function Bre(t10) {
  return Array.isArray(t10) ? t10 : ck(t10) ? [] : [t10];
}
function zre(t10, e3) {
  var r3, n3, i3, o3;
  if (e3)
    for (o3 = Object.keys(e3), r3 = 0, n3 = o3.length; r3 < n3; r3 += 1)
      i3 = o3[r3], t10[i3] = e3[i3];
  return t10;
}
function Hre(t10, e3) {
  var r3 = "", n3;
  for (n3 = 0; n3 < e3; n3 += 1)
    r3 += t10;
  return r3;
}
function Gre(t10) {
  return t10 === 0 && Number.NEGATIVE_INFINITY === 1 / t10;
}
gn.isNothing = ck;
gn.isObject = Lre;
gn.toArray = Bre;
gn.repeat = Hre;
gn.isNegativeZero = Gre;
gn.extend = zre;
function eu(t10, e3) {
  Error.call(this), this.name = "YAMLException", this.reason = t10, this.mark = e3, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
eu.prototype = Object.create(Error.prototype);
eu.prototype.constructor = eu;
eu.prototype.toString = function(e3) {
  var r3 = this.name + ": ";
  return r3 += this.reason || "(unknown reason)", !e3 && this.mark && (r3 += " " + this.mark.toString()), r3;
};
var Qu = eu, y$ = gn;
function l1(t10, e3, r3, n3, i3) {
  this.name = t10, this.buffer = e3, this.position = r3, this.line = n3, this.column = i3;
}
l1.prototype.getSnippet = function(e3, r3) {
  var n3, i3, o3, s3, a3;
  if (!this.buffer)
    return null;
  for (e3 = e3 || 4, r3 = r3 || 75, n3 = "", i3 = this.position; i3 > 0 && `\0\r
\u2028\u2029`.indexOf(this.buffer.charAt(i3 - 1)) === -1; )
    if (i3 -= 1, this.position - i3 > r3 / 2 - 1) {
      n3 = " ... ", i3 += 5;
      break;
    }
  for (o3 = "", s3 = this.position; s3 < this.buffer.length && `\0\r
\u2028\u2029`.indexOf(this.buffer.charAt(s3)) === -1; )
    if (s3 += 1, s3 - this.position > r3 / 2 - 1) {
      o3 = " ... ", s3 -= 5;
      break;
    }
  return a3 = this.buffer.slice(i3, s3), y$.repeat(" ", e3) + n3 + a3 + o3 + `
` + y$.repeat(" ", e3 + this.position - i3 + n3.length) + "^";
};
l1.prototype.toString = function(e3) {
  var r3, n3 = "";
  return this.name && (n3 += 'in "' + this.name + '" '), n3 += "at line " + (this.line + 1) + ", column " + (this.column + 1), e3 || (r3 = this.getSnippet(), r3 && (n3 += `:
` + r3)), n3;
};
var Kre = l1, v$ = Qu, Jre = [
  "kind",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "defaultStyle",
  "styleAliases"
], ene = [
  "scalar",
  "sequence",
  "mapping"
];
function tne(t10) {
  var e3 = {};
  return t10 !== null && Object.keys(t10).forEach(function(r3) {
    t10[r3].forEach(function(n3) {
      e3[String(n3)] = r3;
    });
  }), e3;
}
function rne(t10, e3) {
  if (e3 = e3 || {}, Object.keys(e3).forEach(function(r3) {
    if (Jre.indexOf(r3) === -1)
      throw new v$('Unknown option "' + r3 + '" is met in definition of "' + t10 + '" YAML type.');
  }), this.tag = t10, this.kind = e3.kind || null, this.resolve = e3.resolve || function() {
    return true;
  }, this.construct = e3.construct || function(r3) {
    return r3;
  }, this.instanceOf = e3.instanceOf || null, this.predicate = e3.predicate || null, this.represent = e3.represent || null, this.defaultStyle = e3.defaultStyle || null, this.styleAliases = tne(e3.styleAliases || null), ene.indexOf(this.kind) === -1)
    throw new v$('Unknown kind "' + this.kind + '" is specified for "' + t10 + '" YAML type.');
}
var ir = rne, b$ = gn, Ic = Qu, nne = ir;
function jm(t10, e3, r3) {
  var n3 = [];
  return t10.include.forEach(function(i3) {
    r3 = jm(i3, e3, r3);
  }), t10[e3].forEach(function(i3) {
    r3.forEach(function(o3, s3) {
      o3.tag === i3.tag && o3.kind === i3.kind && n3.push(s3);
    }), r3.push(i3);
  }), r3.filter(function(i3, o3) {
    return n3.indexOf(o3) === -1;
  });
}
function ine() {
  var t10 = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  }, e3, r3;
  function n3(i3) {
    t10[i3.kind][i3.tag] = t10.fallback[i3.tag] = i3;
  }
  for (e3 = 0, r3 = arguments.length; e3 < r3; e3 += 1)
    arguments[e3].forEach(n3);
  return t10;
}
function Ms(t10) {
  this.include = t10.include || [], this.implicit = t10.implicit || [], this.explicit = t10.explicit || [], this.implicit.forEach(function(e3) {
    if (e3.loadKind && e3.loadKind !== "scalar")
      throw new Ic("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
  }), this.compiledImplicit = jm(this, "implicit", []), this.compiledExplicit = jm(this, "explicit", []), this.compiledTypeMap = ine(this.compiledImplicit, this.compiledExplicit);
}
Ms.DEFAULT = null;
Ms.create = function() {
  var e3, r3;
  switch (arguments.length) {
    case 1:
      e3 = Ms.DEFAULT, r3 = arguments[0];
      break;
    case 2:
      e3 = arguments[0], r3 = arguments[1];
      break;
    default:
      throw new Ic("Wrong number of arguments for Schema.create function");
  }
  if (e3 = b$.toArray(e3), r3 = b$.toArray(r3), !e3.every(function(n3) {
    return n3 instanceof Ms;
  }))
    throw new Ic("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
  if (!r3.every(function(n3) {
    return n3 instanceof nne;
  }))
    throw new Ic("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  return new Ms({
    include: e3,
    explicit: r3
  });
};
var qa = Ms, one = ir, sne = new one("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(t10) {
    return t10 !== null ? t10 : "";
  }
}), ane = ir, lne = new ane("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(t10) {
    return t10 !== null ? t10 : [];
  }
}), une = ir, cne = new une("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(t10) {
    return t10 !== null ? t10 : {};
  }
}), fne = qa, u1 = new fne({
  explicit: [
    sne,
    lne,
    cne
  ]
}), dne = ir;
function hne(t10) {
  if (t10 === null)
    return true;
  var e3 = t10.length;
  return e3 === 1 && t10 === "~" || e3 === 4 && (t10 === "null" || t10 === "Null" || t10 === "NULL");
}
function pne() {
  return null;
}
function One(t10) {
  return t10 === null;
}
var mne = new dne("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: hne,
  construct: pne,
  predicate: One,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    }
  },
  defaultStyle: "lowercase"
}), gne = ir;
function yne(t10) {
  if (t10 === null)
    return false;
  var e3 = t10.length;
  return e3 === 4 && (t10 === "true" || t10 === "True" || t10 === "TRUE") || e3 === 5 && (t10 === "false" || t10 === "False" || t10 === "FALSE");
}
function vne(t10) {
  return t10 === "true" || t10 === "True" || t10 === "TRUE";
}
function bne(t10) {
  return Object.prototype.toString.call(t10) === "[object Boolean]";
}
var Sne = new gne("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: yne,
  construct: vne,
  predicate: bne,
  represent: {
    lowercase: function(t10) {
      return t10 ? "true" : "false";
    },
    uppercase: function(t10) {
      return t10 ? "TRUE" : "FALSE";
    },
    camelcase: function(t10) {
      return t10 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), $ne = gn, wne = ir;
function Pne(t10) {
  return 48 <= t10 && t10 <= 57 || 65 <= t10 && t10 <= 70 || 97 <= t10 && t10 <= 102;
}
function _ne(t10) {
  return 48 <= t10 && t10 <= 55;
}
function xne(t10) {
  return 48 <= t10 && t10 <= 57;
}
function Qne(t10) {
  if (t10 === null)
    return false;
  var e3 = t10.length, r3 = 0, n3 = false, i3;
  if (!e3)
    return false;
  if (i3 = t10[r3], (i3 === "-" || i3 === "+") && (i3 = t10[++r3]), i3 === "0") {
    if (r3 + 1 === e3)
      return true;
    if (i3 = t10[++r3], i3 === "b") {
      for (r3++; r3 < e3; r3++)
        if (i3 = t10[r3], i3 !== "_") {
          if (i3 !== "0" && i3 !== "1")
            return false;
          n3 = true;
        }
      return n3 && i3 !== "_";
    }
    if (i3 === "x") {
      for (r3++; r3 < e3; r3++)
        if (i3 = t10[r3], i3 !== "_") {
          if (!Pne(t10.charCodeAt(r3)))
            return false;
          n3 = true;
        }
      return n3 && i3 !== "_";
    }
    for (; r3 < e3; r3++)
      if (i3 = t10[r3], i3 !== "_") {
        if (!_ne(t10.charCodeAt(r3)))
          return false;
        n3 = true;
      }
    return n3 && i3 !== "_";
  }
  if (i3 === "_")
    return false;
  for (; r3 < e3; r3++)
    if (i3 = t10[r3], i3 !== "_") {
      if (i3 === ":")
        break;
      if (!xne(t10.charCodeAt(r3)))
        return false;
      n3 = true;
    }
  return !n3 || i3 === "_" ? false : i3 !== ":" ? true : /^(:[0-5]?[0-9])+$/.test(t10.slice(r3));
}
function Tne(t10) {
  var e3 = t10, r3 = 1, n3, i3, o3 = [];
  return e3.indexOf("_") !== -1 && (e3 = e3.replace(/_/g, "")), n3 = e3[0], (n3 === "-" || n3 === "+") && (n3 === "-" && (r3 = -1), e3 = e3.slice(1), n3 = e3[0]), e3 === "0" ? 0 : n3 === "0" ? e3[1] === "b" ? r3 * parseInt(e3.slice(2), 2) : e3[1] === "x" ? r3 * parseInt(e3, 16) : r3 * parseInt(e3, 8) : e3.indexOf(":") !== -1 ? (e3.split(":").forEach(function(s3) {
    o3.unshift(parseInt(s3, 10));
  }), e3 = 0, i3 = 1, o3.forEach(function(s3) {
    e3 += s3 * i3, i3 *= 60;
  }), r3 * e3) : r3 * parseInt(e3, 10);
}
function kne(t10) {
  return Object.prototype.toString.call(t10) === "[object Number]" && t10 % 1 === 0 && !$ne.isNegativeZero(t10);
}
var Ene = new wne("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: Qne,
  construct: Tne,
  predicate: kne,
  represent: {
    binary: function(t10) {
      return t10 >= 0 ? "0b" + t10.toString(2) : "-0b" + t10.toString(2).slice(1);
    },
    octal: function(t10) {
      return t10 >= 0 ? "0" + t10.toString(8) : "-0" + t10.toString(8).slice(1);
    },
    decimal: function(t10) {
      return t10.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(t10) {
      return t10 >= 0 ? "0x" + t10.toString(16).toUpperCase() : "-0x" + t10.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), fk = gn, Cne = ir, Rne = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function Ane(t10) {
  return !(t10 === null || !Rne.test(t10) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  t10[t10.length - 1] === "_");
}
function Xne(t10) {
  var e3, r3, n3, i3;
  return e3 = t10.replace(/_/g, "").toLowerCase(), r3 = e3[0] === "-" ? -1 : 1, i3 = [], "+-".indexOf(e3[0]) >= 0 && (e3 = e3.slice(1)), e3 === ".inf" ? r3 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e3 === ".nan" ? NaN : e3.indexOf(":") >= 0 ? (e3.split(":").forEach(function(o3) {
    i3.unshift(parseFloat(o3, 10));
  }), e3 = 0, n3 = 1, i3.forEach(function(o3) {
    e3 += o3 * n3, n3 *= 60;
  }), r3 * e3) : r3 * parseFloat(e3, 10);
}
var qne = /^[-+]?[0-9]+e/;
function Dne(t10, e3) {
  var r3;
  if (isNaN(t10))
    switch (e3) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t10)
    switch (e3) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t10)
    switch (e3) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (fk.isNegativeZero(t10))
    return "-0.0";
  return r3 = t10.toString(10), qne.test(r3) ? r3.replace("e", ".e") : r3;
}
function jne(t10) {
  return Object.prototype.toString.call(t10) === "[object Number]" && (t10 % 1 !== 0 || fk.isNegativeZero(t10));
}
var Une = new Cne("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: Ane,
  construct: Xne,
  predicate: jne,
  represent: Dne,
  defaultStyle: "lowercase"
}), Ine = qa, dk = new Ine({
  include: [
    u1
  ],
  implicit: [
    mne,
    Sne,
    Ene,
    Une
  ]
}), Fne = qa, hk = new Fne({
  include: [
    dk
  ]
}), Zne = ir, pk = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), Ok = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function Mne(t10) {
  return t10 === null ? false : pk.exec(t10) !== null || Ok.exec(t10) !== null;
}
function Nne(t10) {
  var e3, r3, n3, i3, o3, s3, a3, l3 = 0, u3 = null, c3, f3, d3;
  if (e3 = pk.exec(t10), e3 === null && (e3 = Ok.exec(t10)), e3 === null)
    throw new Error("Date resolve error");
  if (r3 = +e3[1], n3 = +e3[2] - 1, i3 = +e3[3], !e3[4])
    return new Date(Date.UTC(r3, n3, i3));
  if (o3 = +e3[4], s3 = +e3[5], a3 = +e3[6], e3[7]) {
    for (l3 = e3[7].slice(0, 3); l3.length < 3; )
      l3 += "0";
    l3 = +l3;
  }
  return e3[9] && (c3 = +e3[10], f3 = +(e3[11] || 0), u3 = (c3 * 60 + f3) * 6e4, e3[9] === "-" && (u3 = -u3)), d3 = new Date(Date.UTC(r3, n3, i3, o3, s3, a3, l3)), u3 && d3.setTime(d3.getTime() - u3), d3;
}
function Wne(t10) {
  return t10.toISOString();
}
var Vne = new Zne("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: Mne,
  construct: Nne,
  instanceOf: Date,
  represent: Wne
}), Yne = ir;
function Lne(t10) {
  return t10 === "<<" || t10 === null;
}
var Bne = new Yne("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: Lne
});
function mk(t10) {
  throw new Error('Could not dynamically require "' + t10 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Vo;
try {
  var zne = mk;
  Vo = zne("buffer").Buffer;
} catch {
}
var Hne = ir, c1 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function Gne(t10) {
  if (t10 === null)
    return false;
  var e3, r3, n3 = 0, i3 = t10.length, o3 = c1;
  for (r3 = 0; r3 < i3; r3++)
    if (e3 = o3.indexOf(t10.charAt(r3)), !(e3 > 64)) {
      if (e3 < 0)
        return false;
      n3 += 6;
    }
  return n3 % 8 === 0;
}
function Kne(t10) {
  var e3, r3, n3 = t10.replace(/[\r\n=]/g, ""), i3 = n3.length, o3 = c1, s3 = 0, a3 = [];
  for (e3 = 0; e3 < i3; e3++)
    e3 % 4 === 0 && e3 && (a3.push(s3 >> 16 & 255), a3.push(s3 >> 8 & 255), a3.push(s3 & 255)), s3 = s3 << 6 | o3.indexOf(n3.charAt(e3));
  return r3 = i3 % 4 * 6, r3 === 0 ? (a3.push(s3 >> 16 & 255), a3.push(s3 >> 8 & 255), a3.push(s3 & 255)) : r3 === 18 ? (a3.push(s3 >> 10 & 255), a3.push(s3 >> 2 & 255)) : r3 === 12 && a3.push(s3 >> 4 & 255), Vo ? Vo.from ? Vo.from(a3) : new Vo(a3) : a3;
}
function Jne(t10) {
  var e3 = "", r3 = 0, n3, i3, o3 = t10.length, s3 = c1;
  for (n3 = 0; n3 < o3; n3++)
    n3 % 3 === 0 && n3 && (e3 += s3[r3 >> 18 & 63], e3 += s3[r3 >> 12 & 63], e3 += s3[r3 >> 6 & 63], e3 += s3[r3 & 63]), r3 = (r3 << 8) + t10[n3];
  return i3 = o3 % 3, i3 === 0 ? (e3 += s3[r3 >> 18 & 63], e3 += s3[r3 >> 12 & 63], e3 += s3[r3 >> 6 & 63], e3 += s3[r3 & 63]) : i3 === 2 ? (e3 += s3[r3 >> 10 & 63], e3 += s3[r3 >> 4 & 63], e3 += s3[r3 << 2 & 63], e3 += s3[64]) : i3 === 1 && (e3 += s3[r3 >> 2 & 63], e3 += s3[r3 << 4 & 63], e3 += s3[64], e3 += s3[64]), e3;
}
function eie(t10) {
  return Vo && Vo.isBuffer(t10);
}
var tie = new Hne("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: Gne,
  construct: Kne,
  predicate: eie,
  represent: Jne
}), rie = ir, nie = Object.prototype.hasOwnProperty, iie = Object.prototype.toString;
function oie(t10) {
  if (t10 === null)
    return true;
  var e3 = [], r3, n3, i3, o3, s3, a3 = t10;
  for (r3 = 0, n3 = a3.length; r3 < n3; r3 += 1) {
    if (i3 = a3[r3], s3 = false, iie.call(i3) !== "[object Object]")
      return false;
    for (o3 in i3)
      if (nie.call(i3, o3))
        if (!s3)
          s3 = true;
        else
          return false;
    if (!s3)
      return false;
    if (e3.indexOf(o3) === -1)
      e3.push(o3);
    else
      return false;
  }
  return true;
}
function sie(t10) {
  return t10 !== null ? t10 : [];
}
var aie = new rie("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: oie,
  construct: sie
}), lie = ir, uie = Object.prototype.toString;
function cie(t10) {
  if (t10 === null)
    return true;
  var e3, r3, n3, i3, o3, s3 = t10;
  for (o3 = new Array(s3.length), e3 = 0, r3 = s3.length; e3 < r3; e3 += 1) {
    if (n3 = s3[e3], uie.call(n3) !== "[object Object]" || (i3 = Object.keys(n3), i3.length !== 1))
      return false;
    o3[e3] = [i3[0], n3[i3[0]]];
  }
  return true;
}
function fie(t10) {
  if (t10 === null)
    return [];
  var e3, r3, n3, i3, o3, s3 = t10;
  for (o3 = new Array(s3.length), e3 = 0, r3 = s3.length; e3 < r3; e3 += 1)
    n3 = s3[e3], i3 = Object.keys(n3), o3[e3] = [i3[0], n3[i3[0]]];
  return o3;
}
var die = new lie("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: cie,
  construct: fie
}), hie = ir, pie = Object.prototype.hasOwnProperty;
function Oie(t10) {
  if (t10 === null)
    return true;
  var e3, r3 = t10;
  for (e3 in r3)
    if (pie.call(r3, e3) && r3[e3] !== null)
      return false;
  return true;
}
function mie(t10) {
  return t10 !== null ? t10 : {};
}
var gie = new hie("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: Oie,
  construct: mie
}), yie = qa, Tu = new yie({
  include: [
    hk
  ],
  implicit: [
    Vne,
    Bne
  ],
  explicit: [
    tie,
    aie,
    die,
    gie
  ]
}), vie = ir;
function bie() {
  return true;
}
function Sie() {
}
function $ie() {
  return "";
}
function wie(t10) {
  return typeof t10 > "u";
}
var Pie = new vie("tag:yaml.org,2002:js/undefined", {
  kind: "scalar",
  resolve: bie,
  construct: Sie,
  predicate: wie,
  represent: $ie
}), _ie = ir;
function xie(t10) {
  if (t10 === null || t10.length === 0)
    return false;
  var e3 = t10, r3 = /\/([gim]*)$/.exec(t10), n3 = "";
  return !(e3[0] === "/" && (r3 && (n3 = r3[1]), n3.length > 3 || e3[e3.length - n3.length - 1] !== "/"));
}
function Qie(t10) {
  var e3 = t10, r3 = /\/([gim]*)$/.exec(t10), n3 = "";
  return e3[0] === "/" && (r3 && (n3 = r3[1]), e3 = e3.slice(1, e3.length - n3.length - 1)), new RegExp(e3, n3);
}
function Tie(t10) {
  var e3 = "/" + t10.source + "/";
  return t10.global && (e3 += "g"), t10.multiline && (e3 += "m"), t10.ignoreCase && (e3 += "i"), e3;
}
function kie(t10) {
  return Object.prototype.toString.call(t10) === "[object RegExp]";
}
var Eie = new _ie("tag:yaml.org,2002:js/regexp", {
  kind: "scalar",
  resolve: xie,
  construct: Qie,
  predicate: kie,
  represent: Tie
}), Xf;
try {
  var Cie = mk;
  Xf = Cie("esprima");
} catch {
  typeof window < "u" && (Xf = window.esprima);
}
var Rie = ir;
function Aie(t10) {
  if (t10 === null)
    return false;
  try {
    var e3 = "(" + t10 + ")", r3 = Xf.parse(e3, { range: true });
    return !(r3.type !== "Program" || r3.body.length !== 1 || r3.body[0].type !== "ExpressionStatement" || r3.body[0].expression.type !== "ArrowFunctionExpression" && r3.body[0].expression.type !== "FunctionExpression");
  } catch {
    return false;
  }
}
function Xie(t10) {
  var e3 = "(" + t10 + ")", r3 = Xf.parse(e3, { range: true }), n3 = [], i3;
  if (r3.type !== "Program" || r3.body.length !== 1 || r3.body[0].type !== "ExpressionStatement" || r3.body[0].expression.type !== "ArrowFunctionExpression" && r3.body[0].expression.type !== "FunctionExpression")
    throw new Error("Failed to resolve function");
  return r3.body[0].expression.params.forEach(function(o3) {
    n3.push(o3.name);
  }), i3 = r3.body[0].expression.body.range, r3.body[0].expression.body.type === "BlockStatement" ? new Function(n3, e3.slice(i3[0] + 1, i3[1] - 1)) : new Function(n3, "return " + e3.slice(i3[0], i3[1]));
}
function qie(t10) {
  return t10.toString();
}
function Die(t10) {
  return Object.prototype.toString.call(t10) === "[object Function]";
}
var jie = new Rie("tag:yaml.org,2002:js/function", {
  kind: "scalar",
  resolve: Aie,
  construct: Xie,
  predicate: Die,
  represent: qie
}), S$ = qa, jd = S$.DEFAULT = new S$({
  include: [
    Tu
  ],
  explicit: [
    Pie,
    Eie,
    jie
  ]
}), bi = gn, gk = Qu, Uie = Kre, yk = Tu, Iie = jd, go = Object.prototype.hasOwnProperty, qf = 1, vk = 2, bk = 3, Df = 4, dp = 1, Fie = 2, $$ = 3, Zie = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, Mie = /[\x85\u2028\u2029]/, Nie = /[,\[\]\{\}]/, Sk = /^(?:!|!!|![a-z\-]+!)$/i, $k = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function w$(t10) {
  return Object.prototype.toString.call(t10);
}
function si(t10) {
  return t10 === 10 || t10 === 13;
}
function ts(t10) {
  return t10 === 9 || t10 === 32;
}
function Ur(t10) {
  return t10 === 9 || t10 === 32 || t10 === 10 || t10 === 13;
}
function Ns(t10) {
  return t10 === 44 || t10 === 91 || t10 === 93 || t10 === 123 || t10 === 125;
}
function Wie(t10) {
  var e3;
  return 48 <= t10 && t10 <= 57 ? t10 - 48 : (e3 = t10 | 32, 97 <= e3 && e3 <= 102 ? e3 - 97 + 10 : -1);
}
function Vie(t10) {
  return t10 === 120 ? 2 : t10 === 117 ? 4 : t10 === 85 ? 8 : 0;
}
function Yie(t10) {
  return 48 <= t10 && t10 <= 57 ? t10 - 48 : -1;
}
function P$(t10) {
  return t10 === 48 ? "\0" : t10 === 97 ? "\x07" : t10 === 98 ? "\b" : t10 === 116 || t10 === 9 ? "	" : t10 === 110 ? `
` : t10 === 118 ? "\v" : t10 === 102 ? "\f" : t10 === 114 ? "\r" : t10 === 101 ? "\x1B" : t10 === 32 ? " " : t10 === 34 ? '"' : t10 === 47 ? "/" : t10 === 92 ? "\\" : t10 === 78 ? "" : t10 === 95 ? " " : t10 === 76 ? "\u2028" : t10 === 80 ? "\u2029" : "";
}
function Lie(t10) {
  return t10 <= 65535 ? String.fromCharCode(t10) : String.fromCharCode(
    (t10 - 65536 >> 10) + 55296,
    (t10 - 65536 & 1023) + 56320
  );
}
var wk = new Array(256), Pk = new Array(256);
for (var Es = 0; Es < 256; Es++)
  wk[Es] = P$(Es) ? 1 : 0, Pk[Es] = P$(Es);
function Bie(t10, e3) {
  this.input = t10, this.filename = e3.filename || null, this.schema = e3.schema || Iie, this.onWarning = e3.onWarning || null, this.legacy = e3.legacy || false, this.json = e3.json || false, this.listener = e3.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t10.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
}
function _k(t10, e3) {
  return new gk(
    e3,
    new Uie(t10.filename, t10.input, t10.position, t10.line, t10.position - t10.lineStart)
  );
}
function Fe(t10, e3) {
  throw _k(t10, e3);
}
function jf(t10, e3) {
  t10.onWarning && t10.onWarning.call(null, _k(t10, e3));
}
var _$ = {
  YAML: function(e3, r3, n3) {
    var i3, o3, s3;
    e3.version !== null && Fe(e3, "duplication of %YAML directive"), n3.length !== 1 && Fe(e3, "YAML directive accepts exactly one argument"), i3 = /^([0-9]+)\.([0-9]+)$/.exec(n3[0]), i3 === null && Fe(e3, "ill-formed argument of the YAML directive"), o3 = parseInt(i3[1], 10), s3 = parseInt(i3[2], 10), o3 !== 1 && Fe(e3, "unacceptable YAML version of the document"), e3.version = n3[0], e3.checkLineBreaks = s3 < 2, s3 !== 1 && s3 !== 2 && jf(e3, "unsupported YAML version of the document");
  },
  TAG: function(e3, r3, n3) {
    var i3, o3;
    n3.length !== 2 && Fe(e3, "TAG directive accepts exactly two arguments"), i3 = n3[0], o3 = n3[1], Sk.test(i3) || Fe(e3, "ill-formed tag handle (first argument) of the TAG directive"), go.call(e3.tagMap, i3) && Fe(e3, 'there is a previously declared suffix for "' + i3 + '" tag handle'), $k.test(o3) || Fe(e3, "ill-formed tag prefix (second argument) of the TAG directive"), e3.tagMap[i3] = o3;
  }
};
function ao(t10, e3, r3, n3) {
  var i3, o3, s3, a3;
  if (e3 < r3) {
    if (a3 = t10.input.slice(e3, r3), n3)
      for (i3 = 0, o3 = a3.length; i3 < o3; i3 += 1)
        s3 = a3.charCodeAt(i3), s3 === 9 || 32 <= s3 && s3 <= 1114111 || Fe(t10, "expected valid JSON character");
    else
      Zie.test(a3) && Fe(t10, "the stream contains non-printable characters");
    t10.result += a3;
  }
}
function x$(t10, e3, r3, n3) {
  var i3, o3, s3, a3;
  for (bi.isObject(r3) || Fe(t10, "cannot merge mappings; the provided source object is unacceptable"), i3 = Object.keys(r3), s3 = 0, a3 = i3.length; s3 < a3; s3 += 1)
    o3 = i3[s3], go.call(e3, o3) || (e3[o3] = r3[o3], n3[o3] = true);
}
function Ws(t10, e3, r3, n3, i3, o3, s3, a3) {
  var l3, u3;
  if (Array.isArray(i3))
    for (i3 = Array.prototype.slice.call(i3), l3 = 0, u3 = i3.length; l3 < u3; l3 += 1)
      Array.isArray(i3[l3]) && Fe(t10, "nested arrays are not supported inside keys"), typeof i3 == "object" && w$(i3[l3]) === "[object Object]" && (i3[l3] = "[object Object]");
  if (typeof i3 == "object" && w$(i3) === "[object Object]" && (i3 = "[object Object]"), i3 = String(i3), e3 === null && (e3 = {}), n3 === "tag:yaml.org,2002:merge")
    if (Array.isArray(o3))
      for (l3 = 0, u3 = o3.length; l3 < u3; l3 += 1)
        x$(t10, e3, o3[l3], r3);
    else
      x$(t10, e3, o3, r3);
  else
    !t10.json && !go.call(r3, i3) && go.call(e3, i3) && (t10.line = s3 || t10.line, t10.position = a3 || t10.position, Fe(t10, "duplicated mapping key")), e3[i3] = o3, delete r3[i3];
  return e3;
}
function f1(t10) {
  var e3;
  e3 = t10.input.charCodeAt(t10.position), e3 === 10 ? t10.position++ : e3 === 13 ? (t10.position++, t10.input.charCodeAt(t10.position) === 10 && t10.position++) : Fe(t10, "a line break is expected"), t10.line += 1, t10.lineStart = t10.position;
}
function Lt(t10, e3, r3) {
  for (var n3 = 0, i3 = t10.input.charCodeAt(t10.position); i3 !== 0; ) {
    for (; ts(i3); )
      i3 = t10.input.charCodeAt(++t10.position);
    if (e3 && i3 === 35)
      do
        i3 = t10.input.charCodeAt(++t10.position);
      while (i3 !== 10 && i3 !== 13 && i3 !== 0);
    if (si(i3))
      for (f1(t10), i3 = t10.input.charCodeAt(t10.position), n3++, t10.lineIndent = 0; i3 === 32; )
        t10.lineIndent++, i3 = t10.input.charCodeAt(++t10.position);
    else
      break;
  }
  return r3 !== -1 && n3 !== 0 && t10.lineIndent < r3 && jf(t10, "deficient indentation"), n3;
}
function Ud(t10) {
  var e3 = t10.position, r3;
  return r3 = t10.input.charCodeAt(e3), !!((r3 === 45 || r3 === 46) && r3 === t10.input.charCodeAt(e3 + 1) && r3 === t10.input.charCodeAt(e3 + 2) && (e3 += 3, r3 = t10.input.charCodeAt(e3), r3 === 0 || Ur(r3)));
}
function d1(t10, e3) {
  e3 === 1 ? t10.result += " " : e3 > 1 && (t10.result += bi.repeat(`
`, e3 - 1));
}
function zie(t10, e3, r3) {
  var n3, i3, o3, s3, a3, l3, u3, c3, f3 = t10.kind, d3 = t10.result, p10;
  if (p10 = t10.input.charCodeAt(t10.position), Ur(p10) || Ns(p10) || p10 === 35 || p10 === 38 || p10 === 42 || p10 === 33 || p10 === 124 || p10 === 62 || p10 === 39 || p10 === 34 || p10 === 37 || p10 === 64 || p10 === 96 || (p10 === 63 || p10 === 45) && (i3 = t10.input.charCodeAt(t10.position + 1), Ur(i3) || r3 && Ns(i3)))
    return false;
  for (t10.kind = "scalar", t10.result = "", o3 = s3 = t10.position, a3 = false; p10 !== 0; ) {
    if (p10 === 58) {
      if (i3 = t10.input.charCodeAt(t10.position + 1), Ur(i3) || r3 && Ns(i3))
        break;
    } else if (p10 === 35) {
      if (n3 = t10.input.charCodeAt(t10.position - 1), Ur(n3))
        break;
    } else {
      if (t10.position === t10.lineStart && Ud(t10) || r3 && Ns(p10))
        break;
      if (si(p10))
        if (l3 = t10.line, u3 = t10.lineStart, c3 = t10.lineIndent, Lt(t10, false, -1), t10.lineIndent >= e3) {
          a3 = true, p10 = t10.input.charCodeAt(t10.position);
          continue;
        } else {
          t10.position = s3, t10.line = l3, t10.lineStart = u3, t10.lineIndent = c3;
          break;
        }
    }
    a3 && (ao(t10, o3, s3, false), d1(t10, t10.line - l3), o3 = s3 = t10.position, a3 = false), ts(p10) || (s3 = t10.position + 1), p10 = t10.input.charCodeAt(++t10.position);
  }
  return ao(t10, o3, s3, false), t10.result ? true : (t10.kind = f3, t10.result = d3, false);
}
function Hie(t10, e3) {
  var r3, n3, i3;
  if (r3 = t10.input.charCodeAt(t10.position), r3 !== 39)
    return false;
  for (t10.kind = "scalar", t10.result = "", t10.position++, n3 = i3 = t10.position; (r3 = t10.input.charCodeAt(t10.position)) !== 0; )
    if (r3 === 39)
      if (ao(t10, n3, t10.position, true), r3 = t10.input.charCodeAt(++t10.position), r3 === 39)
        n3 = t10.position, t10.position++, i3 = t10.position;
      else
        return true;
    else
      si(r3) ? (ao(t10, n3, i3, true), d1(t10, Lt(t10, false, e3)), n3 = i3 = t10.position) : t10.position === t10.lineStart && Ud(t10) ? Fe(t10, "unexpected end of the document within a single quoted scalar") : (t10.position++, i3 = t10.position);
  Fe(t10, "unexpected end of the stream within a single quoted scalar");
}
function Gie(t10, e3) {
  var r3, n3, i3, o3, s3, a3;
  if (a3 = t10.input.charCodeAt(t10.position), a3 !== 34)
    return false;
  for (t10.kind = "scalar", t10.result = "", t10.position++, r3 = n3 = t10.position; (a3 = t10.input.charCodeAt(t10.position)) !== 0; ) {
    if (a3 === 34)
      return ao(t10, r3, t10.position, true), t10.position++, true;
    if (a3 === 92) {
      if (ao(t10, r3, t10.position, true), a3 = t10.input.charCodeAt(++t10.position), si(a3))
        Lt(t10, false, e3);
      else if (a3 < 256 && wk[a3])
        t10.result += Pk[a3], t10.position++;
      else if ((s3 = Vie(a3)) > 0) {
        for (i3 = s3, o3 = 0; i3 > 0; i3--)
          a3 = t10.input.charCodeAt(++t10.position), (s3 = Wie(a3)) >= 0 ? o3 = (o3 << 4) + s3 : Fe(t10, "expected hexadecimal character");
        t10.result += Lie(o3), t10.position++;
      } else
        Fe(t10, "unknown escape sequence");
      r3 = n3 = t10.position;
    } else
      si(a3) ? (ao(t10, r3, n3, true), d1(t10, Lt(t10, false, e3)), r3 = n3 = t10.position) : t10.position === t10.lineStart && Ud(t10) ? Fe(t10, "unexpected end of the document within a double quoted scalar") : (t10.position++, n3 = t10.position);
  }
  Fe(t10, "unexpected end of the stream within a double quoted scalar");
}
function Kie(t10, e3) {
  var r3 = true, n3, i3 = t10.tag, o3, s3 = t10.anchor, a3, l3, u3, c3, f3, d3 = {}, p10, h10, m10, O10;
  if (O10 = t10.input.charCodeAt(t10.position), O10 === 91)
    l3 = 93, f3 = false, o3 = [];
  else if (O10 === 123)
    l3 = 125, f3 = true, o3 = {};
  else
    return false;
  for (t10.anchor !== null && (t10.anchorMap[t10.anchor] = o3), O10 = t10.input.charCodeAt(++t10.position); O10 !== 0; ) {
    if (Lt(t10, true, e3), O10 = t10.input.charCodeAt(t10.position), O10 === l3)
      return t10.position++, t10.tag = i3, t10.anchor = s3, t10.kind = f3 ? "mapping" : "sequence", t10.result = o3, true;
    r3 || Fe(t10, "missed comma between flow collection entries"), h10 = p10 = m10 = null, u3 = c3 = false, O10 === 63 && (a3 = t10.input.charCodeAt(t10.position + 1), Ur(a3) && (u3 = c3 = true, t10.position++, Lt(t10, true, e3))), n3 = t10.line, ba(t10, e3, qf, false, true), h10 = t10.tag, p10 = t10.result, Lt(t10, true, e3), O10 = t10.input.charCodeAt(t10.position), (c3 || t10.line === n3) && O10 === 58 && (u3 = true, O10 = t10.input.charCodeAt(++t10.position), Lt(t10, true, e3), ba(t10, e3, qf, false, true), m10 = t10.result), f3 ? Ws(t10, o3, d3, h10, p10, m10) : u3 ? o3.push(Ws(t10, null, d3, h10, p10, m10)) : o3.push(p10), Lt(t10, true, e3), O10 = t10.input.charCodeAt(t10.position), O10 === 44 ? (r3 = true, O10 = t10.input.charCodeAt(++t10.position)) : r3 = false;
  }
  Fe(t10, "unexpected end of the stream within a flow collection");
}
function Jie(t10, e3) {
  var r3, n3, i3 = dp, o3 = false, s3 = false, a3 = e3, l3 = 0, u3 = false, c3, f3;
  if (f3 = t10.input.charCodeAt(t10.position), f3 === 124)
    n3 = false;
  else if (f3 === 62)
    n3 = true;
  else
    return false;
  for (t10.kind = "scalar", t10.result = ""; f3 !== 0; )
    if (f3 = t10.input.charCodeAt(++t10.position), f3 === 43 || f3 === 45)
      dp === i3 ? i3 = f3 === 43 ? $$ : Fie : Fe(t10, "repeat of a chomping mode identifier");
    else if ((c3 = Yie(f3)) >= 0)
      c3 === 0 ? Fe(t10, "bad explicit indentation width of a block scalar; it cannot be less than one") : s3 ? Fe(t10, "repeat of an indentation width identifier") : (a3 = e3 + c3 - 1, s3 = true);
    else
      break;
  if (ts(f3)) {
    do
      f3 = t10.input.charCodeAt(++t10.position);
    while (ts(f3));
    if (f3 === 35)
      do
        f3 = t10.input.charCodeAt(++t10.position);
      while (!si(f3) && f3 !== 0);
  }
  for (; f3 !== 0; ) {
    for (f1(t10), t10.lineIndent = 0, f3 = t10.input.charCodeAt(t10.position); (!s3 || t10.lineIndent < a3) && f3 === 32; )
      t10.lineIndent++, f3 = t10.input.charCodeAt(++t10.position);
    if (!s3 && t10.lineIndent > a3 && (a3 = t10.lineIndent), si(f3)) {
      l3++;
      continue;
    }
    if (t10.lineIndent < a3) {
      i3 === $$ ? t10.result += bi.repeat(`
`, o3 ? 1 + l3 : l3) : i3 === dp && o3 && (t10.result += `
`);
      break;
    }
    for (n3 ? ts(f3) ? (u3 = true, t10.result += bi.repeat(`
`, o3 ? 1 + l3 : l3)) : u3 ? (u3 = false, t10.result += bi.repeat(`
`, l3 + 1)) : l3 === 0 ? o3 && (t10.result += " ") : t10.result += bi.repeat(`
`, l3) : t10.result += bi.repeat(`
`, o3 ? 1 + l3 : l3), o3 = true, s3 = true, l3 = 0, r3 = t10.position; !si(f3) && f3 !== 0; )
      f3 = t10.input.charCodeAt(++t10.position);
    ao(t10, r3, t10.position, false);
  }
  return true;
}
function Q$(t10, e3) {
  var r3, n3 = t10.tag, i3 = t10.anchor, o3 = [], s3, a3 = false, l3;
  for (t10.anchor !== null && (t10.anchorMap[t10.anchor] = o3), l3 = t10.input.charCodeAt(t10.position); l3 !== 0 && !(l3 !== 45 || (s3 = t10.input.charCodeAt(t10.position + 1), !Ur(s3))); ) {
    if (a3 = true, t10.position++, Lt(t10, true, -1) && t10.lineIndent <= e3) {
      o3.push(null), l3 = t10.input.charCodeAt(t10.position);
      continue;
    }
    if (r3 = t10.line, ba(t10, e3, bk, false, true), o3.push(t10.result), Lt(t10, true, -1), l3 = t10.input.charCodeAt(t10.position), (t10.line === r3 || t10.lineIndent > e3) && l3 !== 0)
      Fe(t10, "bad indentation of a sequence entry");
    else if (t10.lineIndent < e3)
      break;
  }
  return a3 ? (t10.tag = n3, t10.anchor = i3, t10.kind = "sequence", t10.result = o3, true) : false;
}
function eoe(t10, e3, r3) {
  var n3, i3, o3, s3, a3 = t10.tag, l3 = t10.anchor, u3 = {}, c3 = {}, f3 = null, d3 = null, p10 = null, h10 = false, m10 = false, O10;
  for (t10.anchor !== null && (t10.anchorMap[t10.anchor] = u3), O10 = t10.input.charCodeAt(t10.position); O10 !== 0; ) {
    if (n3 = t10.input.charCodeAt(t10.position + 1), o3 = t10.line, s3 = t10.position, (O10 === 63 || O10 === 58) && Ur(n3))
      O10 === 63 ? (h10 && (Ws(t10, u3, c3, f3, d3, null), f3 = d3 = p10 = null), m10 = true, h10 = true, i3 = true) : h10 ? (h10 = false, i3 = true) : Fe(t10, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t10.position += 1, O10 = n3;
    else if (ba(t10, r3, vk, false, true))
      if (t10.line === o3) {
        for (O10 = t10.input.charCodeAt(t10.position); ts(O10); )
          O10 = t10.input.charCodeAt(++t10.position);
        if (O10 === 58)
          O10 = t10.input.charCodeAt(++t10.position), Ur(O10) || Fe(t10, "a whitespace character is expected after the key-value separator within a block mapping"), h10 && (Ws(t10, u3, c3, f3, d3, null), f3 = d3 = p10 = null), m10 = true, h10 = false, i3 = false, f3 = t10.tag, d3 = t10.result;
        else if (m10)
          Fe(t10, "can not read an implicit mapping pair; a colon is missed");
        else
          return t10.tag = a3, t10.anchor = l3, true;
      } else if (m10)
        Fe(t10, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return t10.tag = a3, t10.anchor = l3, true;
    else
      break;
    if ((t10.line === o3 || t10.lineIndent > e3) && (ba(t10, e3, Df, true, i3) && (h10 ? d3 = t10.result : p10 = t10.result), h10 || (Ws(t10, u3, c3, f3, d3, p10, o3, s3), f3 = d3 = p10 = null), Lt(t10, true, -1), O10 = t10.input.charCodeAt(t10.position)), t10.lineIndent > e3 && O10 !== 0)
      Fe(t10, "bad indentation of a mapping entry");
    else if (t10.lineIndent < e3)
      break;
  }
  return h10 && Ws(t10, u3, c3, f3, d3, null), m10 && (t10.tag = a3, t10.anchor = l3, t10.kind = "mapping", t10.result = u3), m10;
}
function toe(t10) {
  var e3, r3 = false, n3 = false, i3, o3, s3;
  if (s3 = t10.input.charCodeAt(t10.position), s3 !== 33)
    return false;
  if (t10.tag !== null && Fe(t10, "duplication of a tag property"), s3 = t10.input.charCodeAt(++t10.position), s3 === 60 ? (r3 = true, s3 = t10.input.charCodeAt(++t10.position)) : s3 === 33 ? (n3 = true, i3 = "!!", s3 = t10.input.charCodeAt(++t10.position)) : i3 = "!", e3 = t10.position, r3) {
    do
      s3 = t10.input.charCodeAt(++t10.position);
    while (s3 !== 0 && s3 !== 62);
    t10.position < t10.length ? (o3 = t10.input.slice(e3, t10.position), s3 = t10.input.charCodeAt(++t10.position)) : Fe(t10, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; s3 !== 0 && !Ur(s3); )
      s3 === 33 && (n3 ? Fe(t10, "tag suffix cannot contain exclamation marks") : (i3 = t10.input.slice(e3 - 1, t10.position + 1), Sk.test(i3) || Fe(t10, "named tag handle cannot contain such characters"), n3 = true, e3 = t10.position + 1)), s3 = t10.input.charCodeAt(++t10.position);
    o3 = t10.input.slice(e3, t10.position), Nie.test(o3) && Fe(t10, "tag suffix cannot contain flow indicator characters");
  }
  return o3 && !$k.test(o3) && Fe(t10, "tag name cannot contain such characters: " + o3), r3 ? t10.tag = o3 : go.call(t10.tagMap, i3) ? t10.tag = t10.tagMap[i3] + o3 : i3 === "!" ? t10.tag = "!" + o3 : i3 === "!!" ? t10.tag = "tag:yaml.org,2002:" + o3 : Fe(t10, 'undeclared tag handle "' + i3 + '"'), true;
}
function roe(t10) {
  var e3, r3;
  if (r3 = t10.input.charCodeAt(t10.position), r3 !== 38)
    return false;
  for (t10.anchor !== null && Fe(t10, "duplication of an anchor property"), r3 = t10.input.charCodeAt(++t10.position), e3 = t10.position; r3 !== 0 && !Ur(r3) && !Ns(r3); )
    r3 = t10.input.charCodeAt(++t10.position);
  return t10.position === e3 && Fe(t10, "name of an anchor node must contain at least one character"), t10.anchor = t10.input.slice(e3, t10.position), true;
}
function noe(t10) {
  var e3, r3, n3;
  if (n3 = t10.input.charCodeAt(t10.position), n3 !== 42)
    return false;
  for (n3 = t10.input.charCodeAt(++t10.position), e3 = t10.position; n3 !== 0 && !Ur(n3) && !Ns(n3); )
    n3 = t10.input.charCodeAt(++t10.position);
  return t10.position === e3 && Fe(t10, "name of an alias node must contain at least one character"), r3 = t10.input.slice(e3, t10.position), go.call(t10.anchorMap, r3) || Fe(t10, 'unidentified alias "' + r3 + '"'), t10.result = t10.anchorMap[r3], Lt(t10, true, -1), true;
}
function ba(t10, e3, r3, n3, i3) {
  var o3, s3, a3, l3 = 1, u3 = false, c3 = false, f3, d3, p10, h10, m10;
  if (t10.listener !== null && t10.listener("open", t10), t10.tag = null, t10.anchor = null, t10.kind = null, t10.result = null, o3 = s3 = a3 = Df === r3 || bk === r3, n3 && Lt(t10, true, -1) && (u3 = true, t10.lineIndent > e3 ? l3 = 1 : t10.lineIndent === e3 ? l3 = 0 : t10.lineIndent < e3 && (l3 = -1)), l3 === 1)
    for (; toe(t10) || roe(t10); )
      Lt(t10, true, -1) ? (u3 = true, a3 = o3, t10.lineIndent > e3 ? l3 = 1 : t10.lineIndent === e3 ? l3 = 0 : t10.lineIndent < e3 && (l3 = -1)) : a3 = false;
  if (a3 && (a3 = u3 || i3), (l3 === 1 || Df === r3) && (qf === r3 || vk === r3 ? h10 = e3 : h10 = e3 + 1, m10 = t10.position - t10.lineStart, l3 === 1 ? a3 && (Q$(t10, m10) || eoe(t10, m10, h10)) || Kie(t10, h10) ? c3 = true : (s3 && Jie(t10, h10) || Hie(t10, h10) || Gie(t10, h10) ? c3 = true : noe(t10) ? (c3 = true, (t10.tag !== null || t10.anchor !== null) && Fe(t10, "alias node should not have any properties")) : zie(t10, h10, qf === r3) && (c3 = true, t10.tag === null && (t10.tag = "?")), t10.anchor !== null && (t10.anchorMap[t10.anchor] = t10.result)) : l3 === 0 && (c3 = a3 && Q$(t10, m10))), t10.tag !== null && t10.tag !== "!")
    if (t10.tag === "?") {
      for (t10.result !== null && t10.kind !== "scalar" && Fe(t10, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t10.kind + '"'), f3 = 0, d3 = t10.implicitTypes.length; f3 < d3; f3 += 1)
        if (p10 = t10.implicitTypes[f3], p10.resolve(t10.result)) {
          t10.result = p10.construct(t10.result), t10.tag = p10.tag, t10.anchor !== null && (t10.anchorMap[t10.anchor] = t10.result);
          break;
        }
    } else
      go.call(t10.typeMap[t10.kind || "fallback"], t10.tag) ? (p10 = t10.typeMap[t10.kind || "fallback"][t10.tag], t10.result !== null && p10.kind !== t10.kind && Fe(t10, "unacceptable node kind for !<" + t10.tag + '> tag; it should be "' + p10.kind + '", not "' + t10.kind + '"'), p10.resolve(t10.result) ? (t10.result = p10.construct(t10.result), t10.anchor !== null && (t10.anchorMap[t10.anchor] = t10.result)) : Fe(t10, "cannot resolve a node with !<" + t10.tag + "> explicit tag")) : Fe(t10, "unknown tag !<" + t10.tag + ">");
  return t10.listener !== null && t10.listener("close", t10), t10.tag !== null || t10.anchor !== null || c3;
}
function ioe(t10) {
  var e3 = t10.position, r3, n3, i3, o3 = false, s3;
  for (t10.version = null, t10.checkLineBreaks = t10.legacy, t10.tagMap = {}, t10.anchorMap = {}; (s3 = t10.input.charCodeAt(t10.position)) !== 0 && (Lt(t10, true, -1), s3 = t10.input.charCodeAt(t10.position), !(t10.lineIndent > 0 || s3 !== 37)); ) {
    for (o3 = true, s3 = t10.input.charCodeAt(++t10.position), r3 = t10.position; s3 !== 0 && !Ur(s3); )
      s3 = t10.input.charCodeAt(++t10.position);
    for (n3 = t10.input.slice(r3, t10.position), i3 = [], n3.length < 1 && Fe(t10, "directive name must not be less than one character in length"); s3 !== 0; ) {
      for (; ts(s3); )
        s3 = t10.input.charCodeAt(++t10.position);
      if (s3 === 35) {
        do
          s3 = t10.input.charCodeAt(++t10.position);
        while (s3 !== 0 && !si(s3));
        break;
      }
      if (si(s3))
        break;
      for (r3 = t10.position; s3 !== 0 && !Ur(s3); )
        s3 = t10.input.charCodeAt(++t10.position);
      i3.push(t10.input.slice(r3, t10.position));
    }
    s3 !== 0 && f1(t10), go.call(_$, n3) ? _$[n3](t10, n3, i3) : jf(t10, 'unknown document directive "' + n3 + '"');
  }
  if (Lt(t10, true, -1), t10.lineIndent === 0 && t10.input.charCodeAt(t10.position) === 45 && t10.input.charCodeAt(t10.position + 1) === 45 && t10.input.charCodeAt(t10.position + 2) === 45 ? (t10.position += 3, Lt(t10, true, -1)) : o3 && Fe(t10, "directives end mark is expected"), ba(t10, t10.lineIndent - 1, Df, false, true), Lt(t10, true, -1), t10.checkLineBreaks && Mie.test(t10.input.slice(e3, t10.position)) && jf(t10, "non-ASCII line breaks are interpreted as content"), t10.documents.push(t10.result), t10.position === t10.lineStart && Ud(t10)) {
    t10.input.charCodeAt(t10.position) === 46 && (t10.position += 3, Lt(t10, true, -1));
    return;
  }
  if (t10.position < t10.length - 1)
    Fe(t10, "end of the stream or a document separator is expected");
  else
    return;
}
function xk(t10, e3) {
  t10 = String(t10), e3 = e3 || {}, t10.length !== 0 && (t10.charCodeAt(t10.length - 1) !== 10 && t10.charCodeAt(t10.length - 1) !== 13 && (t10 += `
`), t10.charCodeAt(0) === 65279 && (t10 = t10.slice(1)));
  var r3 = new Bie(t10, e3), n3 = t10.indexOf("\0");
  for (n3 !== -1 && (r3.position = n3, Fe(r3, "null byte is not allowed in input")), r3.input += "\0"; r3.input.charCodeAt(r3.position) === 32; )
    r3.lineIndent += 1, r3.position += 1;
  for (; r3.position < r3.length - 1; )
    ioe(r3);
  return r3.documents;
}
function Qk(t10, e3, r3) {
  e3 !== null && typeof e3 == "object" && typeof r3 > "u" && (r3 = e3, e3 = null);
  var n3 = xk(t10, r3);
  if (typeof e3 != "function")
    return n3;
  for (var i3 = 0, o3 = n3.length; i3 < o3; i3 += 1)
    e3(n3[i3]);
}
function Tk(t10, e3) {
  var r3 = xk(t10, e3);
  if (r3.length !== 0) {
    if (r3.length === 1)
      return r3[0];
    throw new gk("expected a single document in the stream, but found more");
  }
}
function ooe(t10, e3, r3) {
  return typeof e3 == "object" && e3 !== null && typeof r3 > "u" && (r3 = e3, e3 = null), Qk(t10, e3, bi.extend({ schema: yk }, r3));
}
function soe(t10, e3) {
  return Tk(t10, bi.extend({ schema: yk }, e3));
}
xu.loadAll = Qk;
xu.load = Tk;
xu.safeLoadAll = ooe;
xu.safeLoad = soe;
var h1 = {}, ku = gn, Eu = Qu, aoe = jd, loe = Tu, kk = Object.prototype.toString, Ek = Object.prototype.hasOwnProperty, uoe = 9, tu = 10, coe = 13, foe = 32, doe = 33, hoe = 34, Ck = 35, poe = 37, Ooe = 38, moe = 39, goe = 42, Rk = 44, yoe = 45, Ak = 58, voe = 61, boe = 62, Soe = 63, $oe = 64, Xk = 91, qk = 93, woe = 96, Dk = 123, Poe = 124, jk = 125, _r = {};
_r[0] = "\\0";
_r[7] = "\\a";
_r[8] = "\\b";
_r[9] = "\\t";
_r[10] = "\\n";
_r[11] = "\\v";
_r[12] = "\\f";
_r[13] = "\\r";
_r[27] = "\\e";
_r[34] = '\\"';
_r[92] = "\\\\";
_r[133] = "\\N";
_r[160] = "\\_";
_r[8232] = "\\L";
_r[8233] = "\\P";
var _oe = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
function xoe(t10, e3) {
  var r3, n3, i3, o3, s3, a3, l3;
  if (e3 === null)
    return {};
  for (r3 = {}, n3 = Object.keys(e3), i3 = 0, o3 = n3.length; i3 < o3; i3 += 1)
    s3 = n3[i3], a3 = String(e3[s3]), s3.slice(0, 2) === "!!" && (s3 = "tag:yaml.org,2002:" + s3.slice(2)), l3 = t10.compiledTypeMap.fallback[s3], l3 && Ek.call(l3.styleAliases, a3) && (a3 = l3.styleAliases[a3]), r3[s3] = a3;
  return r3;
}
function T$(t10) {
  var e3, r3, n3;
  if (e3 = t10.toString(16).toUpperCase(), t10 <= 255)
    r3 = "x", n3 = 2;
  else if (t10 <= 65535)
    r3 = "u", n3 = 4;
  else if (t10 <= 4294967295)
    r3 = "U", n3 = 8;
  else
    throw new Eu("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r3 + ku.repeat("0", n3 - e3.length) + e3;
}
function Qoe(t10) {
  this.schema = t10.schema || aoe, this.indent = Math.max(1, t10.indent || 2), this.noArrayIndent = t10.noArrayIndent || false, this.skipInvalid = t10.skipInvalid || false, this.flowLevel = ku.isNothing(t10.flowLevel) ? -1 : t10.flowLevel, this.styleMap = xoe(this.schema, t10.styles || null), this.sortKeys = t10.sortKeys || false, this.lineWidth = t10.lineWidth || 80, this.noRefs = t10.noRefs || false, this.noCompatMode = t10.noCompatMode || false, this.condenseFlow = t10.condenseFlow || false, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function k$(t10, e3) {
  for (var r3 = ku.repeat(" ", e3), n3 = 0, i3 = -1, o3 = "", s3, a3 = t10.length; n3 < a3; )
    i3 = t10.indexOf(`
`, n3), i3 === -1 ? (s3 = t10.slice(n3), n3 = a3) : (s3 = t10.slice(n3, i3 + 1), n3 = i3 + 1), s3.length && s3 !== `
` && (o3 += r3), o3 += s3;
  return o3;
}
function Um(t10, e3) {
  return `
` + ku.repeat(" ", t10.indent * e3);
}
function Toe(t10, e3) {
  var r3, n3, i3;
  for (r3 = 0, n3 = t10.implicitTypes.length; r3 < n3; r3 += 1)
    if (i3 = t10.implicitTypes[r3], i3.resolve(e3))
      return true;
  return false;
}
function p1(t10) {
  return t10 === foe || t10 === uoe;
}
function Sa(t10) {
  return 32 <= t10 && t10 <= 126 || 161 <= t10 && t10 <= 55295 && t10 !== 8232 && t10 !== 8233 || 57344 <= t10 && t10 <= 65533 && t10 !== 65279 || 65536 <= t10 && t10 <= 1114111;
}
function koe(t10) {
  return Sa(t10) && !p1(t10) && t10 !== 65279 && t10 !== coe && t10 !== tu;
}
function E$(t10, e3) {
  return Sa(t10) && t10 !== 65279 && t10 !== Rk && t10 !== Xk && t10 !== qk && t10 !== Dk && t10 !== jk && t10 !== Ak && (t10 !== Ck || e3 && koe(e3));
}
function Eoe(t10) {
  return Sa(t10) && t10 !== 65279 && !p1(t10) && t10 !== yoe && t10 !== Soe && t10 !== Ak && t10 !== Rk && t10 !== Xk && t10 !== qk && t10 !== Dk && t10 !== jk && t10 !== Ck && t10 !== Ooe && t10 !== goe && t10 !== doe && t10 !== Poe && t10 !== voe && t10 !== boe && t10 !== moe && t10 !== hoe && t10 !== poe && t10 !== $oe && t10 !== woe;
}
function Uk(t10) {
  var e3 = /^\n* /;
  return e3.test(t10);
}
var Ik = 1, Fk = 2, Zk = 3, Mk = 4, Fc = 5;
function Coe(t10, e3, r3, n3, i3) {
  var o3, s3, a3, l3 = false, u3 = false, c3 = n3 !== -1, f3 = -1, d3 = Eoe(t10.charCodeAt(0)) && !p1(t10.charCodeAt(t10.length - 1));
  if (e3)
    for (o3 = 0; o3 < t10.length; o3++) {
      if (s3 = t10.charCodeAt(o3), !Sa(s3))
        return Fc;
      a3 = o3 > 0 ? t10.charCodeAt(o3 - 1) : null, d3 = d3 && E$(s3, a3);
    }
  else {
    for (o3 = 0; o3 < t10.length; o3++) {
      if (s3 = t10.charCodeAt(o3), s3 === tu)
        l3 = true, c3 && (u3 = u3 || // Foldable line = too long, and not more-indented.
        o3 - f3 - 1 > n3 && t10[f3 + 1] !== " ", f3 = o3);
      else if (!Sa(s3))
        return Fc;
      a3 = o3 > 0 ? t10.charCodeAt(o3 - 1) : null, d3 = d3 && E$(s3, a3);
    }
    u3 = u3 || c3 && o3 - f3 - 1 > n3 && t10[f3 + 1] !== " ";
  }
  return !l3 && !u3 ? d3 && !i3(t10) ? Ik : Fk : r3 > 9 && Uk(t10) ? Fc : u3 ? Mk : Zk;
}
function Roe(t10, e3, r3, n3) {
  t10.dump = function() {
    if (e3.length === 0)
      return "''";
    if (!t10.noCompatMode && _oe.indexOf(e3) !== -1)
      return "'" + e3 + "'";
    var i3 = t10.indent * Math.max(1, r3), o3 = t10.lineWidth === -1 ? -1 : Math.max(Math.min(t10.lineWidth, 40), t10.lineWidth - i3), s3 = n3 || t10.flowLevel > -1 && r3 >= t10.flowLevel;
    function a3(l3) {
      return Toe(t10, l3);
    }
    switch (Coe(e3, s3, t10.indent, o3, a3)) {
      case Ik:
        return e3;
      case Fk:
        return "'" + e3.replace(/'/g, "''") + "'";
      case Zk:
        return "|" + C$(e3, t10.indent) + R$(k$(e3, i3));
      case Mk:
        return ">" + C$(e3, t10.indent) + R$(k$(Aoe(e3, o3), i3));
      case Fc:
        return '"' + Xoe(e3) + '"';
      default:
        throw new Eu("impossible error: invalid scalar style");
    }
  }();
}
function C$(t10, e3) {
  var r3 = Uk(t10) ? String(e3) : "", n3 = t10[t10.length - 1] === `
`, i3 = n3 && (t10[t10.length - 2] === `
` || t10 === `
`), o3 = i3 ? "+" : n3 ? "" : "-";
  return r3 + o3 + `
`;
}
function R$(t10) {
  return t10[t10.length - 1] === `
` ? t10.slice(0, -1) : t10;
}
function Aoe(t10, e3) {
  for (var r3 = /(\n+)([^\n]*)/g, n3 = function() {
    var u3 = t10.indexOf(`
`);
    return u3 = u3 !== -1 ? u3 : t10.length, r3.lastIndex = u3, A$(t10.slice(0, u3), e3);
  }(), i3 = t10[0] === `
` || t10[0] === " ", o3, s3; s3 = r3.exec(t10); ) {
    var a3 = s3[1], l3 = s3[2];
    o3 = l3[0] === " ", n3 += a3 + (!i3 && !o3 && l3 !== "" ? `
` : "") + A$(l3, e3), i3 = o3;
  }
  return n3;
}
function A$(t10, e3) {
  if (t10 === "" || t10[0] === " ")
    return t10;
  for (var r3 = / [^ ]/g, n3, i3 = 0, o3, s3 = 0, a3 = 0, l3 = ""; n3 = r3.exec(t10); )
    a3 = n3.index, a3 - i3 > e3 && (o3 = s3 > i3 ? s3 : a3, l3 += `
` + t10.slice(i3, o3), i3 = o3 + 1), s3 = a3;
  return l3 += `
`, t10.length - i3 > e3 && s3 > i3 ? l3 += t10.slice(i3, s3) + `
` + t10.slice(s3 + 1) : l3 += t10.slice(i3), l3.slice(1);
}
function Xoe(t10) {
  for (var e3 = "", r3, n3, i3, o3 = 0; o3 < t10.length; o3++) {
    if (r3 = t10.charCodeAt(o3), r3 >= 55296 && r3 <= 56319 && (n3 = t10.charCodeAt(o3 + 1), n3 >= 56320 && n3 <= 57343)) {
      e3 += T$((r3 - 55296) * 1024 + n3 - 56320 + 65536), o3++;
      continue;
    }
    i3 = _r[r3], e3 += !i3 && Sa(r3) ? t10[o3] : i3 || T$(r3);
  }
  return e3;
}
function qoe(t10, e3, r3) {
  var n3 = "", i3 = t10.tag, o3, s3;
  for (o3 = 0, s3 = r3.length; o3 < s3; o3 += 1)
    cs(t10, e3, r3[o3], false, false) && (o3 !== 0 && (n3 += "," + (t10.condenseFlow ? "" : " ")), n3 += t10.dump);
  t10.tag = i3, t10.dump = "[" + n3 + "]";
}
function Doe(t10, e3, r3, n3) {
  var i3 = "", o3 = t10.tag, s3, a3;
  for (s3 = 0, a3 = r3.length; s3 < a3; s3 += 1)
    cs(t10, e3 + 1, r3[s3], true, true) && ((!n3 || s3 !== 0) && (i3 += Um(t10, e3)), t10.dump && tu === t10.dump.charCodeAt(0) ? i3 += "-" : i3 += "- ", i3 += t10.dump);
  t10.tag = o3, t10.dump = i3 || "[]";
}
function joe(t10, e3, r3) {
  var n3 = "", i3 = t10.tag, o3 = Object.keys(r3), s3, a3, l3, u3, c3;
  for (s3 = 0, a3 = o3.length; s3 < a3; s3 += 1)
    c3 = "", s3 !== 0 && (c3 += ", "), t10.condenseFlow && (c3 += '"'), l3 = o3[s3], u3 = r3[l3], cs(t10, e3, l3, false, false) && (t10.dump.length > 1024 && (c3 += "? "), c3 += t10.dump + (t10.condenseFlow ? '"' : "") + ":" + (t10.condenseFlow ? "" : " "), cs(t10, e3, u3, false, false) && (c3 += t10.dump, n3 += c3));
  t10.tag = i3, t10.dump = "{" + n3 + "}";
}
function Uoe(t10, e3, r3, n3) {
  var i3 = "", o3 = t10.tag, s3 = Object.keys(r3), a3, l3, u3, c3, f3, d3;
  if (t10.sortKeys === true)
    s3.sort();
  else if (typeof t10.sortKeys == "function")
    s3.sort(t10.sortKeys);
  else if (t10.sortKeys)
    throw new Eu("sortKeys must be a boolean or a function");
  for (a3 = 0, l3 = s3.length; a3 < l3; a3 += 1)
    d3 = "", (!n3 || a3 !== 0) && (d3 += Um(t10, e3)), u3 = s3[a3], c3 = r3[u3], cs(t10, e3 + 1, u3, true, true, true) && (f3 = t10.tag !== null && t10.tag !== "?" || t10.dump && t10.dump.length > 1024, f3 && (t10.dump && tu === t10.dump.charCodeAt(0) ? d3 += "?" : d3 += "? "), d3 += t10.dump, f3 && (d3 += Um(t10, e3)), cs(t10, e3 + 1, c3, true, f3) && (t10.dump && tu === t10.dump.charCodeAt(0) ? d3 += ":" : d3 += ": ", d3 += t10.dump, i3 += d3));
  t10.tag = o3, t10.dump = i3 || "{}";
}
function X$(t10, e3, r3) {
  var n3, i3, o3, s3, a3, l3;
  for (i3 = r3 ? t10.explicitTypes : t10.implicitTypes, o3 = 0, s3 = i3.length; o3 < s3; o3 += 1)
    if (a3 = i3[o3], (a3.instanceOf || a3.predicate) && (!a3.instanceOf || typeof e3 == "object" && e3 instanceof a3.instanceOf) && (!a3.predicate || a3.predicate(e3))) {
      if (t10.tag = r3 ? a3.tag : "?", a3.represent) {
        if (l3 = t10.styleMap[a3.tag] || a3.defaultStyle, kk.call(a3.represent) === "[object Function]")
          n3 = a3.represent(e3, l3);
        else if (Ek.call(a3.represent, l3))
          n3 = a3.represent[l3](e3, l3);
        else
          throw new Eu("!<" + a3.tag + '> tag resolver accepts not "' + l3 + '" style');
        t10.dump = n3;
      }
      return true;
    }
  return false;
}
function cs(t10, e3, r3, n3, i3, o3) {
  t10.tag = null, t10.dump = r3, X$(t10, r3, false) || X$(t10, r3, true);
  var s3 = kk.call(t10.dump);
  n3 && (n3 = t10.flowLevel < 0 || t10.flowLevel > e3);
  var a3 = s3 === "[object Object]" || s3 === "[object Array]", l3, u3;
  if (a3 && (l3 = t10.duplicates.indexOf(r3), u3 = l3 !== -1), (t10.tag !== null && t10.tag !== "?" || u3 || t10.indent !== 2 && e3 > 0) && (i3 = false), u3 && t10.usedDuplicates[l3])
    t10.dump = "*ref_" + l3;
  else {
    if (a3 && u3 && !t10.usedDuplicates[l3] && (t10.usedDuplicates[l3] = true), s3 === "[object Object]")
      n3 && Object.keys(t10.dump).length !== 0 ? (Uoe(t10, e3, t10.dump, i3), u3 && (t10.dump = "&ref_" + l3 + t10.dump)) : (joe(t10, e3, t10.dump), u3 && (t10.dump = "&ref_" + l3 + " " + t10.dump));
    else if (s3 === "[object Array]") {
      var c3 = t10.noArrayIndent && e3 > 0 ? e3 - 1 : e3;
      n3 && t10.dump.length !== 0 ? (Doe(t10, c3, t10.dump, i3), u3 && (t10.dump = "&ref_" + l3 + t10.dump)) : (qoe(t10, c3, t10.dump), u3 && (t10.dump = "&ref_" + l3 + " " + t10.dump));
    } else if (s3 === "[object String]")
      t10.tag !== "?" && Roe(t10, t10.dump, e3, o3);
    else {
      if (t10.skipInvalid)
        return false;
      throw new Eu("unacceptable kind of an object to dump " + s3);
    }
    t10.tag !== null && t10.tag !== "?" && (t10.dump = "!<" + t10.tag + "> " + t10.dump);
  }
  return true;
}
function Ioe(t10, e3) {
  var r3 = [], n3 = [], i3, o3;
  for (Im(t10, r3, n3), i3 = 0, o3 = n3.length; i3 < o3; i3 += 1)
    e3.duplicates.push(r3[n3[i3]]);
  e3.usedDuplicates = new Array(o3);
}
function Im(t10, e3, r3) {
  var n3, i3, o3;
  if (t10 !== null && typeof t10 == "object")
    if (i3 = e3.indexOf(t10), i3 !== -1)
      r3.indexOf(i3) === -1 && r3.push(i3);
    else if (e3.push(t10), Array.isArray(t10))
      for (i3 = 0, o3 = t10.length; i3 < o3; i3 += 1)
        Im(t10[i3], e3, r3);
    else
      for (n3 = Object.keys(t10), i3 = 0, o3 = n3.length; i3 < o3; i3 += 1)
        Im(t10[n3[i3]], e3, r3);
}
function Nk(t10, e3) {
  e3 = e3 || {};
  var r3 = new Qoe(e3);
  return r3.noRefs || Ioe(t10, r3), cs(r3, 0, t10, true, true) ? r3.dump + `
` : "";
}
function Foe(t10, e3) {
  return Nk(t10, ku.extend({ schema: loe }, e3));
}
h1.dump = Nk;
h1.safeDump = Foe;
var Id = xu, Wk = h1;
function Fd(t10) {
  return function() {
    throw new Error("Function " + t10 + " is deprecated and cannot be used.");
  };
}
jt.Type = ir;
jt.Schema = qa;
jt.FAILSAFE_SCHEMA = u1;
jt.JSON_SCHEMA = dk;
jt.CORE_SCHEMA = hk;
jt.DEFAULT_SAFE_SCHEMA = Tu;
jt.DEFAULT_FULL_SCHEMA = jd;
jt.load = Id.load;
jt.loadAll = Id.loadAll;
jt.safeLoad = Id.safeLoad;
jt.safeLoadAll = Id.safeLoadAll;
jt.dump = Wk.dump;
jt.safeDump = Wk.safeDump;
jt.YAMLException = Qu;
jt.MINIMAL_SCHEMA = u1;
jt.SAFE_SCHEMA = Tu;
jt.DEFAULT_SCHEMA = jd;
jt.scan = Fd("scan");
jt.parse = Fd("parse");
jt.compose = Fd("compose");
jt.addConstructor = Fd("addConstructor");
var Zoe = jt, Moe = Zoe;
const { ParserError: Noe } = Ht, Woe = Moe;
var Voe = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 200,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   *
   * @type {boolean}
   */
  allowEmpty: true,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   *
   * @type {RegExp|string[]|function}
   */
  canParse: [".yaml", ".yml", ".json"],
  // JSON is valid YAML
  /**
   * Parses the given file as YAML
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Promise}
   */
  async parse(t10) {
    let e3 = t10.data;
    if ($e.Buffer.isBuffer(e3) && (e3 = e3.toString()), typeof e3 == "string")
      try {
        return Woe.safeLoad(e3);
      } catch (r3) {
        throw new Noe(r3.message, t10.url);
      }
    else
      return e3;
  }
};
const { ParserError: Yoe } = Ht;
let Loe = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
var Boe = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 300,
  /**
   * Whether to allow "empty" files (zero bytes).
   *
   * @type {boolean}
   */
  allowEmpty: true,
  /**
   * The encoding that the text is expected to be in.
   *
   * @type {string}
   */
  encoding: "utf8",
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {boolean}
   */
  canParse(t10) {
    return (typeof t10.data == "string" || $e.Buffer.isBuffer(t10.data)) && Loe.test(t10.url);
  },
  /**
   * Parses the given file as text
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {string}
   */
  parse(t10) {
    if (typeof t10.data == "string")
      return t10.data;
    if ($e.Buffer.isBuffer(t10.data))
      return t10.data.toString(this.encoding);
    throw new Yoe("data is not text", t10.url);
  }
};
let zoe = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
var Hoe = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 400,
  /**
   * Whether to allow "empty" files (zero bytes).
   *
   * @type {boolean}
   */
  allowEmpty: true,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {boolean}
   */
  canParse(t10) {
    return $e.Buffer.isBuffer(t10.data) && zoe.test(t10.url);
  },
  /**
   * Parses the given data as a Buffer (byte array).
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Buffer}
   */
  parse(t10) {
    return $e.Buffer.isBuffer(t10.data) ? t10.data : $e.Buffer.from(t10.data);
  }
};
const Goe = {}, Koe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Goe
}, Symbol.toStringTag, { value: "Module" })), Joe = /* @__PURE__ */ ug(Koe), ese = Joe, { ono: hp } = fi, q$ = mn, { ResolverError: pp } = Ht;
var tse = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   *
   * @type {number}
   */
  order: 100,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried, in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {boolean}
   */
  canRead(t10) {
    return q$.isFileSystemPath(t10.url);
  },
  /**
   * Reads the given file and returns its raw contents as a Buffer.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {Promise<Buffer>}
   */
  read(t10) {
    return new Promise((e3, r3) => {
      let n3;
      try {
        n3 = q$.toFileSystemPath(t10.url);
      } catch (i3) {
        r3(new pp(hp.uri(i3, `Malformed URI: ${t10.url}`), t10.url));
      }
      try {
        ese.readFile(n3, (i3, o3) => {
          i3 ? r3(new pp(hp(i3, `Error opening file "${n3}"`), n3)) : e3(o3);
        });
      } catch (i3) {
        r3(new pp(hp(i3, `Error opening file "${n3}"`), n3));
      }
    });
  }
}, O1 = {}, Vk = { exports: {} }, m1 = {};
(function(t10) {
  t10.fetch = i3(yt.fetch) && i3(yt.ReadableStream), t10.writableStream = i3(yt.WritableStream), t10.abortController = i3(yt.AbortController);
  var e3;
  function r3() {
    if (e3 !== void 0)
      return e3;
    if (yt.XMLHttpRequest) {
      e3 = new yt.XMLHttpRequest();
      try {
        e3.open("GET", yt.XDomainRequest ? "/" : "https://example.com");
      } catch {
        e3 = null;
      }
    } else
      e3 = null;
    return e3;
  }
  function n3(o3) {
    var s3 = r3();
    if (!s3)
      return false;
    try {
      return s3.responseType = o3, s3.responseType === o3;
    } catch {
    }
    return false;
  }
  t10.arraybuffer = t10.fetch || n3("arraybuffer"), t10.msstream = !t10.fetch && n3("ms-stream"), t10.mozchunkedarraybuffer = !t10.fetch && n3("moz-chunked-arraybuffer"), t10.overrideMimeType = t10.fetch || (r3() ? i3(r3().overrideMimeType) : false);
  function i3(o3) {
    return typeof o3 == "function";
  }
  e3 = null;
})(m1);
var Zd = {}, Fm = { exports: {} }, g1 = { exports: {} }, ia = typeof Reflect == "object" ? Reflect : null, D$ = ia && typeof ia.apply == "function" ? ia.apply : function(e3, r3, n3) {
  return Function.prototype.apply.call(e3, r3, n3);
}, Zc;
ia && typeof ia.ownKeys == "function" ? Zc = ia.ownKeys : Object.getOwnPropertySymbols ? Zc = function(e3) {
  return Object.getOwnPropertyNames(e3).concat(Object.getOwnPropertySymbols(e3));
} : Zc = function(e3) {
  return Object.getOwnPropertyNames(e3);
};
function rse(t10) {
  console && console.warn && console.warn(t10);
}
var Yk = Number.isNaN || function(e3) {
  return e3 !== e3;
};
function Ot() {
  Ot.init.call(this);
}
g1.exports = Ot;
g1.exports.once = sse;
Ot.EventEmitter = Ot;
Ot.prototype._events = void 0;
Ot.prototype._eventsCount = 0;
Ot.prototype._maxListeners = void 0;
var j$ = 10;
function Md(t10) {
  if (typeof t10 != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t10);
}
Object.defineProperty(Ot, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return j$;
  },
  set: function(t10) {
    if (typeof t10 != "number" || t10 < 0 || Yk(t10))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t10 + ".");
    j$ = t10;
  }
});
Ot.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Ot.prototype.setMaxListeners = function(e3) {
  if (typeof e3 != "number" || e3 < 0 || Yk(e3))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e3 + ".");
  return this._maxListeners = e3, this;
};
function Lk(t10) {
  return t10._maxListeners === void 0 ? Ot.defaultMaxListeners : t10._maxListeners;
}
Ot.prototype.getMaxListeners = function() {
  return Lk(this);
};
Ot.prototype.emit = function(e3) {
  for (var r3 = [], n3 = 1; n3 < arguments.length; n3++)
    r3.push(arguments[n3]);
  var i3 = e3 === "error", o3 = this._events;
  if (o3 !== void 0)
    i3 = i3 && o3.error === void 0;
  else if (!i3)
    return false;
  if (i3) {
    var s3;
    if (r3.length > 0 && (s3 = r3[0]), s3 instanceof Error)
      throw s3;
    var a3 = new Error("Unhandled error." + (s3 ? " (" + s3.message + ")" : ""));
    throw a3.context = s3, a3;
  }
  var l3 = o3[e3];
  if (l3 === void 0)
    return false;
  if (typeof l3 == "function")
    D$(l3, this, r3);
  else
    for (var u3 = l3.length, c3 = Kk(l3, u3), n3 = 0; n3 < u3; ++n3)
      D$(c3[n3], this, r3);
  return true;
};
function Bk(t10, e3, r3, n3) {
  var i3, o3, s3;
  if (Md(r3), o3 = t10._events, o3 === void 0 ? (o3 = t10._events = /* @__PURE__ */ Object.create(null), t10._eventsCount = 0) : (o3.newListener !== void 0 && (t10.emit(
    "newListener",
    e3,
    r3.listener ? r3.listener : r3
  ), o3 = t10._events), s3 = o3[e3]), s3 === void 0)
    s3 = o3[e3] = r3, ++t10._eventsCount;
  else if (typeof s3 == "function" ? s3 = o3[e3] = n3 ? [r3, s3] : [s3, r3] : n3 ? s3.unshift(r3) : s3.push(r3), i3 = Lk(t10), i3 > 0 && s3.length > i3 && !s3.warned) {
    s3.warned = true;
    var a3 = new Error("Possible EventEmitter memory leak detected. " + s3.length + " " + String(e3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a3.name = "MaxListenersExceededWarning", a3.emitter = t10, a3.type = e3, a3.count = s3.length, rse(a3);
  }
  return t10;
}
Ot.prototype.addListener = function(e3, r3) {
  return Bk(this, e3, r3, false);
};
Ot.prototype.on = Ot.prototype.addListener;
Ot.prototype.prependListener = function(e3, r3) {
  return Bk(this, e3, r3, true);
};
function nse() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function zk(t10, e3, r3) {
  var n3 = { fired: false, wrapFn: void 0, target: t10, type: e3, listener: r3 }, i3 = nse.bind(n3);
  return i3.listener = r3, n3.wrapFn = i3, i3;
}
Ot.prototype.once = function(e3, r3) {
  return Md(r3), this.on(e3, zk(this, e3, r3)), this;
};
Ot.prototype.prependOnceListener = function(e3, r3) {
  return Md(r3), this.prependListener(e3, zk(this, e3, r3)), this;
};
Ot.prototype.removeListener = function(e3, r3) {
  var n3, i3, o3, s3, a3;
  if (Md(r3), i3 = this._events, i3 === void 0)
    return this;
  if (n3 = i3[e3], n3 === void 0)
    return this;
  if (n3 === r3 || n3.listener === r3)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i3[e3], i3.removeListener && this.emit("removeListener", e3, n3.listener || r3));
  else if (typeof n3 != "function") {
    for (o3 = -1, s3 = n3.length - 1; s3 >= 0; s3--)
      if (n3[s3] === r3 || n3[s3].listener === r3) {
        a3 = n3[s3].listener, o3 = s3;
        break;
      }
    if (o3 < 0)
      return this;
    o3 === 0 ? n3.shift() : ise(n3, o3), n3.length === 1 && (i3[e3] = n3[0]), i3.removeListener !== void 0 && this.emit("removeListener", e3, a3 || r3);
  }
  return this;
};
Ot.prototype.off = Ot.prototype.removeListener;
Ot.prototype.removeAllListeners = function(e3) {
  var r3, n3, i3;
  if (n3 = this._events, n3 === void 0)
    return this;
  if (n3.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n3[e3] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[e3]), this;
  if (arguments.length === 0) {
    var o3 = Object.keys(n3), s3;
    for (i3 = 0; i3 < o3.length; ++i3)
      s3 = o3[i3], s3 !== "removeListener" && this.removeAllListeners(s3);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r3 = n3[e3], typeof r3 == "function")
    this.removeListener(e3, r3);
  else if (r3 !== void 0)
    for (i3 = r3.length - 1; i3 >= 0; i3--)
      this.removeListener(e3, r3[i3]);
  return this;
};
function Hk(t10, e3, r3) {
  var n3 = t10._events;
  if (n3 === void 0)
    return [];
  var i3 = n3[e3];
  return i3 === void 0 ? [] : typeof i3 == "function" ? r3 ? [i3.listener || i3] : [i3] : r3 ? ose(i3) : Kk(i3, i3.length);
}
Ot.prototype.listeners = function(e3) {
  return Hk(this, e3, true);
};
Ot.prototype.rawListeners = function(e3) {
  return Hk(this, e3, false);
};
Ot.listenerCount = function(t10, e3) {
  return typeof t10.listenerCount == "function" ? t10.listenerCount(e3) : Gk.call(t10, e3);
};
Ot.prototype.listenerCount = Gk;
function Gk(t10) {
  var e3 = this._events;
  if (e3 !== void 0) {
    var r3 = e3[t10];
    if (typeof r3 == "function")
      return 1;
    if (r3 !== void 0)
      return r3.length;
  }
  return 0;
}
Ot.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Zc(this._events) : [];
};
function Kk(t10, e3) {
  for (var r3 = new Array(e3), n3 = 0; n3 < e3; ++n3)
    r3[n3] = t10[n3];
  return r3;
}
function ise(t10, e3) {
  for (; e3 + 1 < t10.length; e3++)
    t10[e3] = t10[e3 + 1];
  t10.pop();
}
function ose(t10) {
  for (var e3 = new Array(t10.length), r3 = 0; r3 < e3.length; ++r3)
    e3[r3] = t10[r3].listener || t10[r3];
  return e3;
}
function sse(t10, e3) {
  return new Promise(function(r3, n3) {
    function i3(s3) {
      t10.removeListener(e3, o3), n3(s3);
    }
    function o3() {
      typeof t10.removeListener == "function" && t10.removeListener("error", i3), r3([].slice.call(arguments));
    }
    Jk(t10, e3, o3, { once: true }), e3 !== "error" && ase(t10, i3, { once: true });
  });
}
function ase(t10, e3, r3) {
  typeof t10.on == "function" && Jk(t10, "error", e3, r3);
}
function Jk(t10, e3, r3, n3) {
  if (typeof t10.on == "function")
    n3.once ? t10.once(e3, r3) : t10.on(e3, r3);
  else if (typeof t10.addEventListener == "function")
    t10.addEventListener(e3, function i3(o3) {
      n3.once && t10.removeEventListener(e3, i3), r3(o3);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t10);
}
var e5 = g1.exports, t52 = e5.EventEmitter, Op, U$;
function lse() {
  if (U$)
    return Op;
  U$ = 1;
  function t10(h10, m10) {
    var O10 = Object.keys(h10);
    if (Object.getOwnPropertySymbols) {
      var g = Object.getOwnPropertySymbols(h10);
      m10 && (g = g.filter(function(v10) {
        return Object.getOwnPropertyDescriptor(h10, v10).enumerable;
      })), O10.push.apply(O10, g);
    }
    return O10;
  }
  function e3(h10) {
    for (var m10 = 1; m10 < arguments.length; m10++) {
      var O10 = arguments[m10] != null ? arguments[m10] : {};
      m10 % 2 ? t10(Object(O10), true).forEach(function(g) {
        r3(h10, g, O10[g]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(h10, Object.getOwnPropertyDescriptors(O10)) : t10(Object(O10)).forEach(function(g) {
        Object.defineProperty(h10, g, Object.getOwnPropertyDescriptor(O10, g));
      });
    }
    return h10;
  }
  function r3(h10, m10, O10) {
    return m10 = s3(m10), m10 in h10 ? Object.defineProperty(h10, m10, { value: O10, enumerable: true, configurable: true, writable: true }) : h10[m10] = O10, h10;
  }
  function n3(h10, m10) {
    if (!(h10 instanceof m10))
      throw new TypeError("Cannot call a class as a function");
  }
  function i3(h10, m10) {
    for (var O10 = 0; O10 < m10.length; O10++) {
      var g = m10[O10];
      g.enumerable = g.enumerable || false, g.configurable = true, "value" in g && (g.writable = true), Object.defineProperty(h10, s3(g.key), g);
    }
  }
  function o3(h10, m10, O10) {
    return m10 && i3(h10.prototype, m10), O10 && i3(h10, O10), Object.defineProperty(h10, "prototype", { writable: false }), h10;
  }
  function s3(h10) {
    var m10 = a3(h10, "string");
    return typeof m10 == "symbol" ? m10 : String(m10);
  }
  function a3(h10, m10) {
    if (typeof h10 != "object" || h10 === null)
      return h10;
    var O10 = h10[Symbol.toPrimitive];
    if (O10 !== void 0) {
      var g = O10.call(h10, m10 || "default");
      if (typeof g != "object")
        return g;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (m10 === "string" ? String : Number)(h10);
  }
  var l3 = Pa, u3 = l3.Buffer, c3 = yu, f3 = c3.inspect, d3 = f3 && f3.custom || "inspect";
  function p10(h10, m10, O10) {
    u3.prototype.copy.call(h10, m10, O10);
  }
  return Op = /* @__PURE__ */ function() {
    function h10() {
      n3(this, h10), this.head = null, this.tail = null, this.length = 0;
    }
    return o3(h10, [{
      key: "push",
      value: function(O10) {
        var g = {
          data: O10,
          next: null
        };
        this.length > 0 ? this.tail.next = g : this.head = g, this.tail = g, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(O10) {
        var g = {
          data: O10,
          next: this.head
        };
        this.length === 0 && (this.tail = g), this.head = g, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var O10 = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, O10;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(O10) {
        if (this.length === 0)
          return "";
        for (var g = this.head, v10 = "" + g.data; g = g.next; )
          v10 += O10 + g.data;
        return v10;
      }
    }, {
      key: "concat",
      value: function(O10) {
        if (this.length === 0)
          return u3.alloc(0);
        for (var g = u3.allocUnsafe(O10 >>> 0), v10 = this.head, S10 = 0; v10; )
          p10(v10.data, g, S10), S10 += v10.data.length, v10 = v10.next;
        return g;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(O10, g) {
        var v10;
        return O10 < this.head.data.length ? (v10 = this.head.data.slice(0, O10), this.head.data = this.head.data.slice(O10)) : O10 === this.head.data.length ? v10 = this.shift() : v10 = g ? this._getString(O10) : this._getBuffer(O10), v10;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(O10) {
        var g = this.head, v10 = 1, S10 = g.data;
        for (O10 -= S10.length; g = g.next; ) {
          var $10 = g.data, _10 = O10 > $10.length ? $10.length : O10;
          if (_10 === $10.length ? S10 += $10 : S10 += $10.slice(0, O10), O10 -= _10, O10 === 0) {
            _10 === $10.length ? (++v10, g.next ? this.head = g.next : this.head = this.tail = null) : (this.head = g, g.data = $10.slice(_10));
            break;
          }
          ++v10;
        }
        return this.length -= v10, S10;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(O10) {
        var g = u3.allocUnsafe(O10), v10 = this.head, S10 = 1;
        for (v10.data.copy(g), O10 -= v10.data.length; v10 = v10.next; ) {
          var $10 = v10.data, _10 = O10 > $10.length ? $10.length : O10;
          if ($10.copy(g, g.length - O10, 0, _10), O10 -= _10, O10 === 0) {
            _10 === $10.length ? (++S10, v10.next ? this.head = v10.next : this.head = this.tail = null) : (this.head = v10, v10.data = $10.slice(_10));
            break;
          }
          ++S10;
        }
        return this.length -= S10, g;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: d3,
      value: function(O10, g) {
        return f3(this, e3(e3({}, g), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]), h10;
  }(), Op;
}
function use(t10, e3) {
  var r3 = this, n3 = this._readableState && this._readableState.destroyed, i3 = this._writableState && this._writableState.destroyed;
  return n3 || i3 ? (e3 ? e3(t10) : t10 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, $e.process.nextTick(Zm, this, t10)) : $e.process.nextTick(Zm, this, t10)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t10 || null, function(o3) {
    !e3 && o3 ? r3._writableState ? r3._writableState.errorEmitted ? $e.process.nextTick(Mc, r3) : (r3._writableState.errorEmitted = true, $e.process.nextTick(I$, r3, o3)) : $e.process.nextTick(I$, r3, o3) : e3 ? ($e.process.nextTick(Mc, r3), e3(o3)) : $e.process.nextTick(Mc, r3);
  }), this);
}
function I$(t10, e3) {
  Zm(t10, e3), Mc(t10);
}
function Mc(t10) {
  t10._writableState && !t10._writableState.emitClose || t10._readableState && !t10._readableState.emitClose || t10.emit("close");
}
function cse() {
  this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
}
function Zm(t10, e3) {
  t10.emit("error", e3);
}
function fse(t10, e3) {
  var r3 = t10._readableState, n3 = t10._writableState;
  r3 && r3.autoDestroy || n3 && n3.autoDestroy ? t10.destroy(e3) : t10.emit("error", e3);
}
var r5 = {
  destroy: use,
  undestroy: cse,
  errorOrDestroy: fse
}, ys = {};
function dse(t10, e3) {
  t10.prototype = Object.create(e3.prototype), t10.prototype.constructor = t10, t10.__proto__ = e3;
}
var n5 = {};
function yn(t10, e3, r3) {
  r3 || (r3 = Error);
  function n3(o3, s3, a3) {
    return typeof e3 == "string" ? e3 : e3(o3, s3, a3);
  }
  var i3 = /* @__PURE__ */ function(o3) {
    dse(s3, o3);
    function s3(a3, l3, u3) {
      return o3.call(this, n3(a3, l3, u3)) || this;
    }
    return s3;
  }(r3);
  i3.prototype.name = r3.name, i3.prototype.code = t10, n5[t10] = i3;
}
function F$(t10, e3) {
  if (Array.isArray(t10)) {
    var r3 = t10.length;
    return t10 = t10.map(function(n3) {
      return String(n3);
    }), r3 > 2 ? "one of ".concat(e3, " ").concat(t10.slice(0, r3 - 1).join(", "), ", or ") + t10[r3 - 1] : r3 === 2 ? "one of ".concat(e3, " ").concat(t10[0], " or ").concat(t10[1]) : "of ".concat(e3, " ").concat(t10[0]);
  } else
    return "of ".concat(e3, " ").concat(String(t10));
}
function hse(t10, e3, r3) {
  return t10.substr(!r3 || r3 < 0 ? 0 : +r3, e3.length) === e3;
}
function pse(t10, e3, r3) {
  return (r3 === void 0 || r3 > t10.length) && (r3 = t10.length), t10.substring(r3 - e3.length, r3) === e3;
}
function Ose(t10, e3, r3) {
  return typeof r3 != "number" && (r3 = 0), r3 + e3.length > t10.length ? false : t10.indexOf(e3, r3) !== -1;
}
yn("ERR_INVALID_OPT_VALUE", function(t10, e3) {
  return 'The value "' + e3 + '" is invalid for option "' + t10 + '"';
}, TypeError);
yn("ERR_INVALID_ARG_TYPE", function(t10, e3, r3) {
  var n3;
  typeof e3 == "string" && hse(e3, "not ") ? (n3 = "must not be", e3 = e3.replace(/^not /, "")) : n3 = "must be";
  var i3;
  if (pse(t10, " argument"))
    i3 = "The ".concat(t10, " ").concat(n3, " ").concat(F$(e3, "type"));
  else {
    var o3 = Ose(t10, ".") ? "property" : "argument";
    i3 = 'The "'.concat(t10, '" ').concat(o3, " ").concat(n3, " ").concat(F$(e3, "type"));
  }
  return i3 += ". Received type ".concat(typeof r3), i3;
}, TypeError);
yn("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
yn("ERR_METHOD_NOT_IMPLEMENTED", function(t10) {
  return "The " + t10 + " method is not implemented";
});
yn("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
yn("ERR_STREAM_DESTROYED", function(t10) {
  return "Cannot call " + t10 + " after a stream was destroyed";
});
yn("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
yn("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
yn("ERR_STREAM_WRITE_AFTER_END", "write after end");
yn("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
yn("ERR_UNKNOWN_ENCODING", function(t10) {
  return "Unknown encoding: " + t10;
}, TypeError);
yn("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
ys.codes = n5;
var mse = ys.codes.ERR_INVALID_OPT_VALUE;
function gse(t10, e3, r3) {
  return t10.highWaterMark != null ? t10.highWaterMark : e3 ? t10[r3] : null;
}
function yse(t10, e3, r3, n3) {
  var i3 = gse(e3, n3, r3);
  if (i3 != null) {
    if (!(isFinite(i3) && Math.floor(i3) === i3) || i3 < 0) {
      var o3 = n3 ? r3 : "highWaterMark";
      throw new mse(o3, i3);
    }
    return Math.floor(i3);
  }
  return t10.objectMode ? 16 : 16 * 1024;
}
var i5 = {
  getHighWaterMark: yse
}, vse = bse;
function bse(t10, e3) {
  if (mp("noDeprecation"))
    return t10;
  var r3 = false;
  function n3() {
    if (!r3) {
      if (mp("throwDeprecation"))
        throw new Error(e3);
      mp("traceDeprecation") ? console.trace(e3) : console.warn(e3), r3 = true;
    }
    return t10.apply(this, arguments);
  }
  return n3;
}
function mp(t10) {
  try {
    if (!yt.localStorage)
      return false;
  } catch {
    return false;
  }
  var e3 = yt.localStorage[t10];
  return e3 == null ? false : String(e3).toLowerCase() === "true";
}
var gp, Z$;
function o5() {
  if (Z$)
    return gp;
  Z$ = 1, gp = N5;
  function t10(T10) {
    var F5 = this;
    this.next = null, this.entry = null, this.finish = function() {
      U10(F5, T10);
    };
  }
  var e3;
  N5.WritableState = P10;
  var r3 = {
    deprecate: vse
  }, n3 = t52, i3 = Pa.Buffer, o3 = (typeof yt < "u" ? yt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s3(T10) {
    return i3.from(T10);
  }
  function a3(T10) {
    return i3.isBuffer(T10) || T10 instanceof o3;
  }
  var l3 = r5, u3 = i5, c3 = u3.getHighWaterMark, f3 = ys.codes, d3 = f3.ERR_INVALID_ARG_TYPE, p10 = f3.ERR_METHOD_NOT_IMPLEMENTED, h10 = f3.ERR_MULTIPLE_CALLBACK, m10 = f3.ERR_STREAM_CANNOT_PIPE, O10 = f3.ERR_STREAM_DESTROYED, g = f3.ERR_STREAM_NULL_VALUES, v10 = f3.ERR_STREAM_WRITE_AFTER_END, S10 = f3.ERR_UNKNOWN_ENCODING, $10 = l3.errorOrDestroy;
  $o(N5, n3);
  function _10() {
  }
  function P10(T10, F5, V3) {
    e3 = e3 || $a(), T10 = T10 || {}, typeof V3 != "boolean" && (V3 = F5 instanceof e3), this.objectMode = !!T10.objectMode, V3 && (this.objectMode = this.objectMode || !!T10.writableObjectMode), this.highWaterMark = c3(this, T10, "writableHighWaterMark", V3), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var ie2 = T10.decodeStrings === false;
    this.decodeStrings = !ie2, this.defaultEncoding = T10.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(ce2) {
      qe(F5, ce2);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = T10.emitClose !== false, this.autoDestroy = !!T10.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t10(this);
  }
  P10.prototype.getBuffer = function() {
    for (var F5 = this.bufferedRequest, V3 = []; F5; )
      V3.push(F5), F5 = F5.next;
    return V3;
  }, function() {
    try {
      Object.defineProperty(P10.prototype, "buffer", {
        get: r3.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var q5;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (q5 = Function.prototype[Symbol.hasInstance], Object.defineProperty(N5, Symbol.hasInstance, {
    value: function(F5) {
      return q5.call(this, F5) ? true : this !== N5 ? false : F5 && F5._writableState instanceof P10;
    }
  })) : q5 = function(F5) {
    return F5 instanceof this;
  };
  function N5(T10) {
    e3 = e3 || $a();
    var F5 = this instanceof e3;
    if (!F5 && !q5.call(N5, this))
      return new N5(T10);
    this._writableState = new P10(T10, this, F5), this.writable = true, T10 && (typeof T10.write == "function" && (this._write = T10.write), typeof T10.writev == "function" && (this._writev = T10.writev), typeof T10.destroy == "function" && (this._destroy = T10.destroy), typeof T10.final == "function" && (this._final = T10.final)), n3.call(this);
  }
  N5.prototype.pipe = function() {
    $10(this, new m10());
  };
  function B5(T10, F5) {
    var V3 = new v10();
    $10(T10, V3), $e.process.nextTick(F5, V3);
  }
  function H10(T10, F5, V3, ie2) {
    var ce2;
    return V3 === null ? ce2 = new g() : typeof V3 != "string" && !F5.objectMode && (ce2 = new d3("chunk", ["string", "Buffer"], V3)), ce2 ? ($10(T10, ce2), $e.process.nextTick(ie2, ce2), false) : true;
  }
  N5.prototype.write = function(T10, F5, V3) {
    var ie2 = this._writableState, ce2 = false, E = !ie2.objectMode && a3(T10);
    return E && !i3.isBuffer(T10) && (T10 = s3(T10)), typeof F5 == "function" && (V3 = F5, F5 = null), E ? F5 = "buffer" : F5 || (F5 = ie2.defaultEncoding), typeof V3 != "function" && (V3 = _10), ie2.ending ? B5(this, V3) : (E || H10(this, ie2, T10, V3)) && (ie2.pendingcb++, ce2 = re2(this, ie2, E, T10, F5, V3)), ce2;
  }, N5.prototype.cork = function() {
    this._writableState.corked++;
  }, N5.prototype.uncork = function() {
    var T10 = this._writableState;
    T10.corked && (T10.corked--, !T10.writing && !T10.corked && !T10.bufferProcessing && T10.bufferedRequest && je2(this, T10));
  }, N5.prototype.setDefaultEncoding = function(F5) {
    if (typeof F5 == "string" && (F5 = F5.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((F5 + "").toLowerCase()) > -1))
      throw new S10(F5);
    return this._writableState.defaultEncoding = F5, this;
  }, Object.defineProperty(N5.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function ne(T10, F5, V3) {
    return !T10.objectMode && T10.decodeStrings !== false && typeof F5 == "string" && (F5 = i3.from(F5, V3)), F5;
  }
  Object.defineProperty(N5.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function re2(T10, F5, V3, ie2, ce2, E) {
    if (!V3) {
      var D5 = ne(F5, ie2, ce2);
      ie2 !== D5 && (V3 = true, ce2 = "buffer", ie2 = D5);
    }
    var se = F5.objectMode ? 1 : ie2.length;
    F5.length += se;
    var ye = F5.length < F5.highWaterMark;
    if (ye || (F5.needDrain = true), F5.writing || F5.corked) {
      var Ye = F5.lastBufferedRequest;
      F5.lastBufferedRequest = {
        chunk: ie2,
        encoding: ce2,
        isBuf: V3,
        callback: E,
        next: null
      }, Ye ? Ye.next = F5.lastBufferedRequest : F5.bufferedRequest = F5.lastBufferedRequest, F5.bufferedRequestCount += 1;
    } else
      fe(T10, F5, false, se, ie2, ce2, E);
    return ye;
  }
  function fe(T10, F5, V3, ie2, ce2, E, D5) {
    F5.writelen = ie2, F5.writecb = D5, F5.writing = true, F5.sync = true, F5.destroyed ? F5.onwrite(new O10("write")) : V3 ? T10._writev(ce2, F5.onwrite) : T10._write(ce2, E, F5.onwrite), F5.sync = false;
  }
  function pe(T10, F5, V3, ie2, ce2) {
    --F5.pendingcb, V3 ? ($e.process.nextTick(ce2, ie2), $e.process.nextTick(X10, T10, F5), T10._writableState.errorEmitted = true, $10(T10, ie2)) : (ce2(ie2), T10._writableState.errorEmitted = true, $10(T10, ie2), X10(T10, F5));
  }
  function Ee2(T10) {
    T10.writing = false, T10.writecb = null, T10.length -= T10.writelen, T10.writelen = 0;
  }
  function qe(T10, F5) {
    var V3 = T10._writableState, ie2 = V3.sync, ce2 = V3.writecb;
    if (typeof ce2 != "function")
      throw new h10();
    if (Ee2(V3), F5)
      pe(T10, V3, ie2, F5, ce2);
    else {
      var E = G(V3) || T10.destroyed;
      !E && !V3.corked && !V3.bufferProcessing && V3.bufferedRequest && je2(T10, V3), ie2 ? $e.process.nextTick(_e, T10, V3, E, ce2) : _e(T10, V3, E, ce2);
    }
  }
  function _e(T10, F5, V3, ie2) {
    V3 || Ie(T10, F5), F5.pendingcb--, ie2(), X10(T10, F5);
  }
  function Ie(T10, F5) {
    F5.length === 0 && F5.needDrain && (F5.needDrain = false, T10.emit("drain"));
  }
  function je2(T10, F5) {
    F5.bufferProcessing = true;
    var V3 = F5.bufferedRequest;
    if (T10._writev && V3 && V3.next) {
      var ie2 = F5.bufferedRequestCount, ce2 = new Array(ie2), E = F5.corkedRequestsFree;
      E.entry = V3;
      for (var D5 = 0, se = true; V3; )
        ce2[D5] = V3, V3.isBuf || (se = false), V3 = V3.next, D5 += 1;
      ce2.allBuffers = se, fe(T10, F5, true, F5.length, ce2, "", E.finish), F5.pendingcb++, F5.lastBufferedRequest = null, E.next ? (F5.corkedRequestsFree = E.next, E.next = null) : F5.corkedRequestsFree = new t10(F5), F5.bufferedRequestCount = 0;
    } else {
      for (; V3; ) {
        var ye = V3.chunk, Ye = V3.encoding, xe2 = V3.callback, Ge = F5.objectMode ? 1 : ye.length;
        if (fe(T10, F5, false, Ge, ye, Ye, xe2), V3 = V3.next, F5.bufferedRequestCount--, F5.writing)
          break;
      }
      V3 === null && (F5.lastBufferedRequest = null);
    }
    F5.bufferedRequest = V3, F5.bufferProcessing = false;
  }
  N5.prototype._write = function(T10, F5, V3) {
    V3(new p10("_write()"));
  }, N5.prototype._writev = null, N5.prototype.end = function(T10, F5, V3) {
    var ie2 = this._writableState;
    return typeof T10 == "function" ? (V3 = T10, T10 = null, F5 = null) : typeof F5 == "function" && (V3 = F5, F5 = null), T10 != null && this.write(T10, F5), ie2.corked && (ie2.corked = 1, this.uncork()), ie2.ending || w10(this, ie2, V3), this;
  }, Object.defineProperty(N5.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.length;
    }
  });
  function G(T10) {
    return T10.ending && T10.length === 0 && T10.bufferedRequest === null && !T10.finished && !T10.writing;
  }
  function Z(T10, F5) {
    T10._final(function(V3) {
      F5.pendingcb--, V3 && $10(T10, V3), F5.prefinished = true, T10.emit("prefinish"), X10(T10, F5);
    });
  }
  function C10(T10, F5) {
    !F5.prefinished && !F5.finalCalled && (typeof T10._final == "function" && !F5.destroyed ? (F5.pendingcb++, F5.finalCalled = true, $e.process.nextTick(Z, T10, F5)) : (F5.prefinished = true, T10.emit("prefinish")));
  }
  function X10(T10, F5) {
    var V3 = G(F5);
    if (V3 && (C10(T10, F5), F5.pendingcb === 0 && (F5.finished = true, T10.emit("finish"), F5.autoDestroy))) {
      var ie2 = T10._readableState;
      (!ie2 || ie2.autoDestroy && ie2.endEmitted) && T10.destroy();
    }
    return V3;
  }
  function w10(T10, F5, V3) {
    F5.ending = true, X10(T10, F5), V3 && (F5.finished ? $e.process.nextTick(V3) : T10.once("finish", V3)), F5.ended = true, T10.writable = false;
  }
  function U10(T10, F5, V3) {
    var ie2 = T10.entry;
    for (T10.entry = null; ie2; ) {
      var ce2 = ie2.callback;
      F5.pendingcb--, ce2(V3), ie2 = ie2.next;
    }
    F5.corkedRequestsFree.next = T10;
  }
  return Object.defineProperty(N5.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState === void 0 ? false : this._writableState.destroyed;
    },
    set: function(F5) {
      this._writableState && (this._writableState.destroyed = F5);
    }
  }), N5.prototype.destroy = l3.destroy, N5.prototype._undestroy = l3.undestroy, N5.prototype._destroy = function(T10, F5) {
    F5(T10);
  }, gp;
}
var yp, M$;
function $a() {
  if (M$)
    return yp;
  M$ = 1;
  var t10 = Object.keys || function(u3) {
    var c3 = [];
    for (var f3 in u3)
      c3.push(f3);
    return c3;
  };
  yp = s3;
  var e3 = a5(), r3 = o5();
  $o(s3, e3);
  for (var n3 = t10(r3.prototype), i3 = 0; i3 < n3.length; i3++) {
    var o3 = n3[i3];
    s3.prototype[o3] || (s3.prototype[o3] = r3.prototype[o3]);
  }
  function s3(u3) {
    if (!(this instanceof s3))
      return new s3(u3);
    e3.call(this, u3), r3.call(this, u3), this.allowHalfOpen = true, u3 && (u3.readable === false && (this.readable = false), u3.writable === false && (this.writable = false), u3.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", a3)));
  }
  Object.defineProperty(s3.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(s3.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(s3.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.length;
    }
  });
  function a3() {
    this._writableState.ended || $e.process.nextTick(l3, this);
  }
  function l3(u3) {
    u3.end();
  }
  return Object.defineProperty(s3.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(c3) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = c3, this._writableState.destroyed = c3);
    }
  }), yp;
}
var vp = {}, lc = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var N$;
function Sse() {
  return N$ || (N$ = 1, function(t10, e3) {
    var r3 = Pa, n3 = r3.Buffer;
    function i3(s3, a3) {
      for (var l3 in s3)
        a3[l3] = s3[l3];
    }
    n3.from && n3.alloc && n3.allocUnsafe && n3.allocUnsafeSlow ? t10.exports = r3 : (i3(r3, e3), e3.Buffer = o3);
    function o3(s3, a3, l3) {
      return n3(s3, a3, l3);
    }
    o3.prototype = Object.create(n3.prototype), i3(n3, o3), o3.from = function(s3, a3, l3) {
      if (typeof s3 == "number")
        throw new TypeError("Argument must not be a number");
      return n3(s3, a3, l3);
    }, o3.alloc = function(s3, a3, l3) {
      if (typeof s3 != "number")
        throw new TypeError("Argument must be a number");
      var u3 = n3(s3);
      return a3 !== void 0 ? typeof l3 == "string" ? u3.fill(a3, l3) : u3.fill(a3) : u3.fill(0), u3;
    }, o3.allocUnsafe = function(s3) {
      if (typeof s3 != "number")
        throw new TypeError("Argument must be a number");
      return n3(s3);
    }, o3.allocUnsafeSlow = function(s3) {
      if (typeof s3 != "number")
        throw new TypeError("Argument must be a number");
      return r3.SlowBuffer(s3);
    };
  }(lc, lc.exports)), lc.exports;
}
var W$;
function V$() {
  if (W$)
    return vp;
  W$ = 1;
  var t10 = Sse().Buffer, e3 = t10.isEncoding || function(g) {
    switch (g = "" + g, g && g.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function r3(g) {
    if (!g)
      return "utf8";
    for (var v10; ; )
      switch (g) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return g;
        default:
          if (v10)
            return;
          g = ("" + g).toLowerCase(), v10 = true;
      }
  }
  function n3(g) {
    var v10 = r3(g);
    if (typeof v10 != "string" && (t10.isEncoding === e3 || !e3(g)))
      throw new Error("Unknown encoding: " + g);
    return v10 || g;
  }
  vp.StringDecoder = i3;
  function i3(g) {
    this.encoding = n3(g);
    var v10;
    switch (this.encoding) {
      case "utf16le":
        this.text = f3, this.end = d3, v10 = 4;
        break;
      case "utf8":
        this.fillLast = l3, v10 = 4;
        break;
      case "base64":
        this.text = p10, this.end = h10, v10 = 3;
        break;
      default:
        this.write = m10, this.end = O10;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t10.allocUnsafe(v10);
  }
  i3.prototype.write = function(g) {
    if (g.length === 0)
      return "";
    var v10, S10;
    if (this.lastNeed) {
      if (v10 = this.fillLast(g), v10 === void 0)
        return "";
      S10 = this.lastNeed, this.lastNeed = 0;
    } else
      S10 = 0;
    return S10 < g.length ? v10 ? v10 + this.text(g, S10) : this.text(g, S10) : v10 || "";
  }, i3.prototype.end = c3, i3.prototype.text = u3, i3.prototype.fillLast = function(g) {
    if (this.lastNeed <= g.length)
      return g.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    g.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, g.length), this.lastNeed -= g.length;
  };
  function o3(g) {
    return g <= 127 ? 0 : g >> 5 === 6 ? 2 : g >> 4 === 14 ? 3 : g >> 3 === 30 ? 4 : g >> 6 === 2 ? -1 : -2;
  }
  function s3(g, v10, S10) {
    var $10 = v10.length - 1;
    if ($10 < S10)
      return 0;
    var _10 = o3(v10[$10]);
    return _10 >= 0 ? (_10 > 0 && (g.lastNeed = _10 - 1), _10) : --$10 < S10 || _10 === -2 ? 0 : (_10 = o3(v10[$10]), _10 >= 0 ? (_10 > 0 && (g.lastNeed = _10 - 2), _10) : --$10 < S10 || _10 === -2 ? 0 : (_10 = o3(v10[$10]), _10 >= 0 ? (_10 > 0 && (_10 === 2 ? _10 = 0 : g.lastNeed = _10 - 3), _10) : 0));
  }
  function a3(g, v10, S10) {
    if ((v10[0] & 192) !== 128)
      return g.lastNeed = 0, "�";
    if (g.lastNeed > 1 && v10.length > 1) {
      if ((v10[1] & 192) !== 128)
        return g.lastNeed = 1, "�";
      if (g.lastNeed > 2 && v10.length > 2 && (v10[2] & 192) !== 128)
        return g.lastNeed = 2, "�";
    }
  }
  function l3(g) {
    var v10 = this.lastTotal - this.lastNeed, S10 = a3(this, g);
    if (S10 !== void 0)
      return S10;
    if (this.lastNeed <= g.length)
      return g.copy(this.lastChar, v10, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    g.copy(this.lastChar, v10, 0, g.length), this.lastNeed -= g.length;
  }
  function u3(g, v10) {
    var S10 = s3(this, g, v10);
    if (!this.lastNeed)
      return g.toString("utf8", v10);
    this.lastTotal = S10;
    var $10 = g.length - (S10 - this.lastNeed);
    return g.copy(this.lastChar, 0, $10), g.toString("utf8", v10, $10);
  }
  function c3(g) {
    var v10 = g && g.length ? this.write(g) : "";
    return this.lastNeed ? v10 + "�" : v10;
  }
  function f3(g, v10) {
    if ((g.length - v10) % 2 === 0) {
      var S10 = g.toString("utf16le", v10);
      if (S10) {
        var $10 = S10.charCodeAt(S10.length - 1);
        if ($10 >= 55296 && $10 <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = g[g.length - 2], this.lastChar[1] = g[g.length - 1], S10.slice(0, -1);
      }
      return S10;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = g[g.length - 1], g.toString("utf16le", v10, g.length - 1);
  }
  function d3(g) {
    var v10 = g && g.length ? this.write(g) : "";
    if (this.lastNeed) {
      var S10 = this.lastTotal - this.lastNeed;
      return v10 + this.lastChar.toString("utf16le", 0, S10);
    }
    return v10;
  }
  function p10(g, v10) {
    var S10 = (g.length - v10) % 3;
    return S10 === 0 ? g.toString("base64", v10) : (this.lastNeed = 3 - S10, this.lastTotal = 3, S10 === 1 ? this.lastChar[0] = g[g.length - 1] : (this.lastChar[0] = g[g.length - 2], this.lastChar[1] = g[g.length - 1]), g.toString("base64", v10, g.length - S10));
  }
  function h10(g) {
    var v10 = g && g.length ? this.write(g) : "";
    return this.lastNeed ? v10 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : v10;
  }
  function m10(g) {
    return g.toString(this.encoding);
  }
  function O10(g) {
    return g && g.length ? this.write(g) : "";
  }
  return vp;
}
var Y$ = ys.codes.ERR_STREAM_PREMATURE_CLOSE;
function $se(t10) {
  var e3 = false;
  return function() {
    if (!e3) {
      e3 = true;
      for (var r3 = arguments.length, n3 = new Array(r3), i3 = 0; i3 < r3; i3++)
        n3[i3] = arguments[i3];
      t10.apply(this, n3);
    }
  };
}
function wse() {
}
function Pse(t10) {
  return t10.setHeader && typeof t10.abort == "function";
}
function s5(t10, e3, r3) {
  if (typeof e3 == "function")
    return s5(t10, null, e3);
  e3 || (e3 = {}), r3 = $se(r3 || wse);
  var n3 = e3.readable || e3.readable !== false && t10.readable, i3 = e3.writable || e3.writable !== false && t10.writable, o3 = function() {
    t10.writable || a3();
  }, s3 = t10._writableState && t10._writableState.finished, a3 = function() {
    i3 = false, s3 = true, n3 || r3.call(t10);
  }, l3 = t10._readableState && t10._readableState.endEmitted, u3 = function() {
    n3 = false, l3 = true, i3 || r3.call(t10);
  }, c3 = function(h10) {
    r3.call(t10, h10);
  }, f3 = function() {
    var h10;
    if (n3 && !l3)
      return (!t10._readableState || !t10._readableState.ended) && (h10 = new Y$()), r3.call(t10, h10);
    if (i3 && !s3)
      return (!t10._writableState || !t10._writableState.ended) && (h10 = new Y$()), r3.call(t10, h10);
  }, d3 = function() {
    t10.req.on("finish", a3);
  };
  return Pse(t10) ? (t10.on("complete", a3), t10.on("abort", f3), t10.req ? d3() : t10.on("request", d3)) : i3 && !t10._writableState && (t10.on("end", o3), t10.on("close", o3)), t10.on("end", u3), t10.on("finish", a3), e3.error !== false && t10.on("error", c3), t10.on("close", f3), function() {
    t10.removeListener("complete", a3), t10.removeListener("abort", f3), t10.removeListener("request", d3), t10.req && t10.req.removeListener("finish", a3), t10.removeListener("end", o3), t10.removeListener("close", o3), t10.removeListener("finish", a3), t10.removeListener("end", u3), t10.removeListener("error", c3), t10.removeListener("close", f3);
  };
}
var y1 = s5, bp, L$;
function _se() {
  if (L$)
    return bp;
  L$ = 1;
  var t10;
  function e3(S10, $10, _10) {
    return $10 = r3($10), $10 in S10 ? Object.defineProperty(S10, $10, { value: _10, enumerable: true, configurable: true, writable: true }) : S10[$10] = _10, S10;
  }
  function r3(S10) {
    var $10 = n3(S10, "string");
    return typeof $10 == "symbol" ? $10 : String($10);
  }
  function n3(S10, $10) {
    if (typeof S10 != "object" || S10 === null)
      return S10;
    var _10 = S10[Symbol.toPrimitive];
    if (_10 !== void 0) {
      var P10 = _10.call(S10, $10 || "default");
      if (typeof P10 != "object")
        return P10;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ($10 === "string" ? String : Number)(S10);
  }
  var i3 = y1, o3 = Symbol("lastResolve"), s3 = Symbol("lastReject"), a3 = Symbol("error"), l3 = Symbol("ended"), u3 = Symbol("lastPromise"), c3 = Symbol("handlePromise"), f3 = Symbol("stream");
  function d3(S10, $10) {
    return {
      value: S10,
      done: $10
    };
  }
  function p10(S10) {
    var $10 = S10[o3];
    if ($10 !== null) {
      var _10 = S10[f3].read();
      _10 !== null && (S10[u3] = null, S10[o3] = null, S10[s3] = null, $10(d3(_10, false)));
    }
  }
  function h10(S10) {
    $e.process.nextTick(p10, S10);
  }
  function m10(S10, $10) {
    return function(_10, P10) {
      S10.then(function() {
        if ($10[l3]) {
          _10(d3(void 0, true));
          return;
        }
        $10[c3](_10, P10);
      }, P10);
    };
  }
  var O10 = Object.getPrototypeOf(function() {
  }), g = Object.setPrototypeOf((t10 = {
    get stream() {
      return this[f3];
    },
    next: function() {
      var $10 = this, _10 = this[a3];
      if (_10 !== null)
        return Promise.reject(_10);
      if (this[l3])
        return Promise.resolve(d3(void 0, true));
      if (this[f3].destroyed)
        return new Promise(function(B5, H10) {
          $e.process.nextTick(function() {
            $10[a3] ? H10($10[a3]) : B5(d3(void 0, true));
          });
        });
      var P10 = this[u3], q5;
      if (P10)
        q5 = new Promise(m10(P10, this));
      else {
        var N5 = this[f3].read();
        if (N5 !== null)
          return Promise.resolve(d3(N5, false));
        q5 = new Promise(this[c3]);
      }
      return this[u3] = q5, q5;
    }
  }, e3(t10, Symbol.asyncIterator, function() {
    return this;
  }), e3(t10, "return", function() {
    var $10 = this;
    return new Promise(function(_10, P10) {
      $10[f3].destroy(null, function(q5) {
        if (q5) {
          P10(q5);
          return;
        }
        _10(d3(void 0, true));
      });
    });
  }), t10), O10), v10 = function($10) {
    var _10, P10 = Object.create(g, (_10 = {}, e3(_10, f3, {
      value: $10,
      writable: true
    }), e3(_10, o3, {
      value: null,
      writable: true
    }), e3(_10, s3, {
      value: null,
      writable: true
    }), e3(_10, a3, {
      value: null,
      writable: true
    }), e3(_10, l3, {
      value: $10._readableState.endEmitted,
      writable: true
    }), e3(_10, c3, {
      value: function(N5, B5) {
        var H10 = P10[f3].read();
        H10 ? (P10[u3] = null, P10[o3] = null, P10[s3] = null, N5(d3(H10, false))) : (P10[o3] = N5, P10[s3] = B5);
      },
      writable: true
    }), _10));
    return P10[u3] = null, i3($10, function(q5) {
      if (q5 && q5.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var N5 = P10[s3];
        N5 !== null && (P10[u3] = null, P10[o3] = null, P10[s3] = null, N5(q5)), P10[a3] = q5;
        return;
      }
      var B5 = P10[o3];
      B5 !== null && (P10[u3] = null, P10[o3] = null, P10[s3] = null, B5(d3(void 0, true))), P10[l3] = true;
    }), $10.on("readable", h10.bind(null, P10)), P10;
  };
  return bp = v10, bp;
}
var Sp, B$;
function xse() {
  return B$ || (B$ = 1, Sp = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Sp;
}
var $p, z$;
function a5() {
  if (z$)
    return $p;
  z$ = 1, $p = B5;
  var t10;
  B5.ReadableState = N5, e5.EventEmitter;
  var e3 = function(D5, se) {
    return D5.listeners(se).length;
  }, r3 = t52, n3 = Pa.Buffer, i3 = (typeof yt < "u" ? yt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o3(E) {
    return n3.from(E);
  }
  function s3(E) {
    return n3.isBuffer(E) || E instanceof i3;
  }
  var a3 = yu, l3;
  a3 && a3.debuglog ? l3 = a3.debuglog("stream") : l3 = function() {
  };
  var u3 = lse(), c3 = r5, f3 = i5, d3 = f3.getHighWaterMark, p10 = ys.codes, h10 = p10.ERR_INVALID_ARG_TYPE, m10 = p10.ERR_STREAM_PUSH_AFTER_EOF, O10 = p10.ERR_METHOD_NOT_IMPLEMENTED, g = p10.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, v10, S10, $10;
  $o(B5, r3);
  var _10 = c3.errorOrDestroy, P10 = ["error", "close", "destroy", "pause", "resume"];
  function q5(E, D5, se) {
    if (typeof E.prependListener == "function")
      return E.prependListener(D5, se);
    !E._events || !E._events[D5] ? E.on(D5, se) : Array.isArray(E._events[D5]) ? E._events[D5].unshift(se) : E._events[D5] = [se, E._events[D5]];
  }
  function N5(E, D5, se) {
    t10 = t10 || $a(), E = E || {}, typeof se != "boolean" && (se = D5 instanceof t10), this.objectMode = !!E.objectMode, se && (this.objectMode = this.objectMode || !!E.readableObjectMode), this.highWaterMark = d3(this, E, "readableHighWaterMark", se), this.buffer = new u3(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = E.emitClose !== false, this.autoDestroy = !!E.autoDestroy, this.destroyed = false, this.defaultEncoding = E.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, E.encoding && (v10 || (v10 = V$().StringDecoder), this.decoder = new v10(E.encoding), this.encoding = E.encoding);
  }
  function B5(E) {
    if (t10 = t10 || $a(), !(this instanceof B5))
      return new B5(E);
    var D5 = this instanceof t10;
    this._readableState = new N5(E, this, D5), this.readable = true, E && (typeof E.read == "function" && (this._read = E.read), typeof E.destroy == "function" && (this._destroy = E.destroy)), r3.call(this);
  }
  Object.defineProperty(B5.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState === void 0 ? false : this._readableState.destroyed;
    },
    set: function(D5) {
      this._readableState && (this._readableState.destroyed = D5);
    }
  }), B5.prototype.destroy = c3.destroy, B5.prototype._undestroy = c3.undestroy, B5.prototype._destroy = function(E, D5) {
    D5(E);
  }, B5.prototype.push = function(E, D5) {
    var se = this._readableState, ye;
    return se.objectMode ? ye = true : typeof E == "string" && (D5 = D5 || se.defaultEncoding, D5 !== se.encoding && (E = n3.from(E, D5), D5 = ""), ye = true), H10(this, E, D5, false, ye);
  }, B5.prototype.unshift = function(E) {
    return H10(this, E, null, true, false);
  };
  function H10(E, D5, se, ye, Ye) {
    l3("readableAddChunk", D5);
    var xe2 = E._readableState;
    if (D5 === null)
      xe2.reading = false, qe(E, xe2);
    else {
      var Ge;
      if (Ye || (Ge = re2(xe2, D5)), Ge)
        _10(E, Ge);
      else if (xe2.objectMode || D5 && D5.length > 0)
        if (typeof D5 != "string" && !xe2.objectMode && Object.getPrototypeOf(D5) !== n3.prototype && (D5 = o3(D5)), ye)
          xe2.endEmitted ? _10(E, new g()) : ne(E, xe2, D5, true);
        else if (xe2.ended)
          _10(E, new m10());
        else {
          if (xe2.destroyed)
            return false;
          xe2.reading = false, xe2.decoder && !se ? (D5 = xe2.decoder.write(D5), xe2.objectMode || D5.length !== 0 ? ne(E, xe2, D5, false) : je2(E, xe2)) : ne(E, xe2, D5, false);
        }
      else
        ye || (xe2.reading = false, je2(E, xe2));
    }
    return !xe2.ended && (xe2.length < xe2.highWaterMark || xe2.length === 0);
  }
  function ne(E, D5, se, ye) {
    D5.flowing && D5.length === 0 && !D5.sync ? (D5.awaitDrain = 0, E.emit("data", se)) : (D5.length += D5.objectMode ? 1 : se.length, ye ? D5.buffer.unshift(se) : D5.buffer.push(se), D5.needReadable && _e(E)), je2(E, D5);
  }
  function re2(E, D5) {
    var se;
    return !s3(D5) && typeof D5 != "string" && D5 !== void 0 && !E.objectMode && (se = new h10("chunk", ["string", "Buffer", "Uint8Array"], D5)), se;
  }
  B5.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  }, B5.prototype.setEncoding = function(E) {
    v10 || (v10 = V$().StringDecoder);
    var D5 = new v10(E);
    this._readableState.decoder = D5, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var se = this._readableState.buffer.head, ye = ""; se !== null; )
      ye += D5.write(se.data), se = se.next;
    return this._readableState.buffer.clear(), ye !== "" && this._readableState.buffer.push(ye), this._readableState.length = ye.length, this;
  };
  var fe = 1073741824;
  function pe(E) {
    return E >= fe ? E = fe : (E--, E |= E >>> 1, E |= E >>> 2, E |= E >>> 4, E |= E >>> 8, E |= E >>> 16, E++), E;
  }
  function Ee2(E, D5) {
    return E <= 0 || D5.length === 0 && D5.ended ? 0 : D5.objectMode ? 1 : E !== E ? D5.flowing && D5.length ? D5.buffer.head.data.length : D5.length : (E > D5.highWaterMark && (D5.highWaterMark = pe(E)), E <= D5.length ? E : D5.ended ? D5.length : (D5.needReadable = true, 0));
  }
  B5.prototype.read = function(E) {
    l3("read", E), E = parseInt(E, 10);
    var D5 = this._readableState, se = E;
    if (E !== 0 && (D5.emittedReadable = false), E === 0 && D5.needReadable && ((D5.highWaterMark !== 0 ? D5.length >= D5.highWaterMark : D5.length > 0) || D5.ended))
      return l3("read: emitReadable", D5.length, D5.ended), D5.length === 0 && D5.ended ? V3(this) : _e(this), null;
    if (E = Ee2(E, D5), E === 0 && D5.ended)
      return D5.length === 0 && V3(this), null;
    var ye = D5.needReadable;
    l3("need readable", ye), (D5.length === 0 || D5.length - E < D5.highWaterMark) && (ye = true, l3("length less than watermark", ye)), D5.ended || D5.reading ? (ye = false, l3("reading or ended", ye)) : ye && (l3("do read"), D5.reading = true, D5.sync = true, D5.length === 0 && (D5.needReadable = true), this._read(D5.highWaterMark), D5.sync = false, D5.reading || (E = Ee2(se, D5)));
    var Ye;
    return E > 0 ? Ye = F5(E, D5) : Ye = null, Ye === null ? (D5.needReadable = D5.length <= D5.highWaterMark, E = 0) : (D5.length -= E, D5.awaitDrain = 0), D5.length === 0 && (D5.ended || (D5.needReadable = true), se !== E && D5.ended && V3(this)), Ye !== null && this.emit("data", Ye), Ye;
  };
  function qe(E, D5) {
    if (l3("onEofChunk"), !D5.ended) {
      if (D5.decoder) {
        var se = D5.decoder.end();
        se && se.length && (D5.buffer.push(se), D5.length += D5.objectMode ? 1 : se.length);
      }
      D5.ended = true, D5.sync ? _e(E) : (D5.needReadable = false, D5.emittedReadable || (D5.emittedReadable = true, Ie(E)));
    }
  }
  function _e(E) {
    var D5 = E._readableState;
    l3("emitReadable", D5.needReadable, D5.emittedReadable), D5.needReadable = false, D5.emittedReadable || (l3("emitReadable", D5.flowing), D5.emittedReadable = true, $e.process.nextTick(Ie, E));
  }
  function Ie(E) {
    var D5 = E._readableState;
    l3("emitReadable_", D5.destroyed, D5.length, D5.ended), !D5.destroyed && (D5.length || D5.ended) && (E.emit("readable"), D5.emittedReadable = false), D5.needReadable = !D5.flowing && !D5.ended && D5.length <= D5.highWaterMark, T10(E);
  }
  function je2(E, D5) {
    D5.readingMore || (D5.readingMore = true, $e.process.nextTick(G, E, D5));
  }
  function G(E, D5) {
    for (; !D5.reading && !D5.ended && (D5.length < D5.highWaterMark || D5.flowing && D5.length === 0); ) {
      var se = D5.length;
      if (l3("maybeReadMore read 0"), E.read(0), se === D5.length)
        break;
    }
    D5.readingMore = false;
  }
  B5.prototype._read = function(E) {
    _10(this, new O10("_read()"));
  }, B5.prototype.pipe = function(E, D5) {
    var se = this, ye = this._readableState;
    switch (ye.pipesCount) {
      case 0:
        ye.pipes = E;
        break;
      case 1:
        ye.pipes = [ye.pipes, E];
        break;
      default:
        ye.pipes.push(E);
        break;
    }
    ye.pipesCount += 1, l3("pipe count=%d opts=%j", ye.pipesCount, D5);
    var Ye = (!D5 || D5.end !== false) && E !== $e.process.stdout && E !== $e.process.stderr, xe2 = Ye ? or : xr2;
    ye.endEmitted ? $e.process.nextTick(xe2) : se.once("end", xe2), E.on("unpipe", Ge);
    function Ge(x10, y10) {
      l3("onunpipe"), x10 === se && y10 && y10.hasUnpiped === false && (y10.hasUnpiped = true, Vr2());
    }
    function or() {
      l3("onend"), E.end();
    }
    var le = Z(se);
    E.on("drain", le);
    var qr = false;
    function Vr2() {
      l3("cleanup"), E.removeListener("close", on), E.removeListener("finish", Jt2), E.removeListener("drain", le), E.removeListener("error", Xt2), E.removeListener("unpipe", Ge), se.removeListener("end", or), se.removeListener("end", xr2), se.removeListener("data", Tt), qr = true, ye.awaitDrain && (!E._writableState || E._writableState.needDrain) && le();
    }
    se.on("data", Tt);
    function Tt(x10) {
      l3("ondata");
      var y10 = E.write(x10);
      l3("dest.write", y10), y10 === false && ((ye.pipesCount === 1 && ye.pipes === E || ye.pipesCount > 1 && ce2(ye.pipes, E) !== -1) && !qr && (l3("false write response, pause", ye.awaitDrain), ye.awaitDrain++), se.pause());
    }
    function Xt2(x10) {
      l3("onerror", x10), xr2(), E.removeListener("error", Xt2), e3(E, "error") === 0 && _10(E, x10);
    }
    q5(E, "error", Xt2);
    function on() {
      E.removeListener("finish", Jt2), xr2();
    }
    E.once("close", on);
    function Jt2() {
      l3("onfinish"), E.removeListener("close", on), xr2();
    }
    E.once("finish", Jt2);
    function xr2() {
      l3("unpipe"), se.unpipe(E);
    }
    return E.emit("pipe", se), ye.flowing || (l3("pipe resume"), se.resume()), E;
  };
  function Z(E) {
    return function() {
      var se = E._readableState;
      l3("pipeOnDrain", se.awaitDrain), se.awaitDrain && se.awaitDrain--, se.awaitDrain === 0 && e3(E, "data") && (se.flowing = true, T10(E));
    };
  }
  B5.prototype.unpipe = function(E) {
    var D5 = this._readableState, se = {
      hasUnpiped: false
    };
    if (D5.pipesCount === 0)
      return this;
    if (D5.pipesCount === 1)
      return E && E !== D5.pipes ? this : (E || (E = D5.pipes), D5.pipes = null, D5.pipesCount = 0, D5.flowing = false, E && E.emit("unpipe", this, se), this);
    if (!E) {
      var ye = D5.pipes, Ye = D5.pipesCount;
      D5.pipes = null, D5.pipesCount = 0, D5.flowing = false;
      for (var xe2 = 0; xe2 < Ye; xe2++)
        ye[xe2].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var Ge = ce2(D5.pipes, E);
    return Ge === -1 ? this : (D5.pipes.splice(Ge, 1), D5.pipesCount -= 1, D5.pipesCount === 1 && (D5.pipes = D5.pipes[0]), E.emit("unpipe", this, se), this);
  }, B5.prototype.on = function(E, D5) {
    var se = r3.prototype.on.call(this, E, D5), ye = this._readableState;
    return E === "data" ? (ye.readableListening = this.listenerCount("readable") > 0, ye.flowing !== false && this.resume()) : E === "readable" && !ye.endEmitted && !ye.readableListening && (ye.readableListening = ye.needReadable = true, ye.flowing = false, ye.emittedReadable = false, l3("on readable", ye.length, ye.reading), ye.length ? _e(this) : ye.reading || $e.process.nextTick(X10, this)), se;
  }, B5.prototype.addListener = B5.prototype.on, B5.prototype.removeListener = function(E, D5) {
    var se = r3.prototype.removeListener.call(this, E, D5);
    return E === "readable" && $e.process.nextTick(C10, this), se;
  }, B5.prototype.removeAllListeners = function(E) {
    var D5 = r3.prototype.removeAllListeners.apply(this, arguments);
    return (E === "readable" || E === void 0) && $e.process.nextTick(C10, this), D5;
  };
  function C10(E) {
    var D5 = E._readableState;
    D5.readableListening = E.listenerCount("readable") > 0, D5.resumeScheduled && !D5.paused ? D5.flowing = true : E.listenerCount("data") > 0 && E.resume();
  }
  function X10(E) {
    l3("readable nexttick read 0"), E.read(0);
  }
  B5.prototype.resume = function() {
    var E = this._readableState;
    return E.flowing || (l3("resume"), E.flowing = !E.readableListening, w10(this, E)), E.paused = false, this;
  };
  function w10(E, D5) {
    D5.resumeScheduled || (D5.resumeScheduled = true, $e.process.nextTick(U10, E, D5));
  }
  function U10(E, D5) {
    l3("resume", D5.reading), D5.reading || E.read(0), D5.resumeScheduled = false, E.emit("resume"), T10(E), D5.flowing && !D5.reading && E.read(0);
  }
  B5.prototype.pause = function() {
    return l3("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (l3("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function T10(E) {
    var D5 = E._readableState;
    for (l3("flow", D5.flowing); D5.flowing && E.read() !== null; )
      ;
  }
  B5.prototype.wrap = function(E) {
    var D5 = this, se = this._readableState, ye = false;
    E.on("end", function() {
      if (l3("wrapped end"), se.decoder && !se.ended) {
        var Ge = se.decoder.end();
        Ge && Ge.length && D5.push(Ge);
      }
      D5.push(null);
    }), E.on("data", function(Ge) {
      if (l3("wrapped data"), se.decoder && (Ge = se.decoder.write(Ge)), !(se.objectMode && Ge == null) && !(!se.objectMode && (!Ge || !Ge.length))) {
        var or = D5.push(Ge);
        or || (ye = true, E.pause());
      }
    });
    for (var Ye in E)
      this[Ye] === void 0 && typeof E[Ye] == "function" && (this[Ye] = function(or) {
        return function() {
          return E[or].apply(E, arguments);
        };
      }(Ye));
    for (var xe2 = 0; xe2 < P10.length; xe2++)
      E.on(P10[xe2], this.emit.bind(this, P10[xe2]));
    return this._read = function(Ge) {
      l3("wrapped _read", Ge), ye && (ye = false, E.resume());
    }, this;
  }, typeof Symbol == "function" && (B5.prototype[Symbol.asyncIterator] = function() {
    return S10 === void 0 && (S10 = _se()), S10(this);
  }), Object.defineProperty(B5.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(B5.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(B5.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(D5) {
      this._readableState && (this._readableState.flowing = D5);
    }
  }), B5._fromList = F5, Object.defineProperty(B5.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.length;
    }
  });
  function F5(E, D5) {
    if (D5.length === 0)
      return null;
    var se;
    return D5.objectMode ? se = D5.buffer.shift() : !E || E >= D5.length ? (D5.decoder ? se = D5.buffer.join("") : D5.buffer.length === 1 ? se = D5.buffer.first() : se = D5.buffer.concat(D5.length), D5.buffer.clear()) : se = D5.buffer.consume(E, D5.decoder), se;
  }
  function V3(E) {
    var D5 = E._readableState;
    l3("endReadable", D5.endEmitted), D5.endEmitted || (D5.ended = true, $e.process.nextTick(ie2, D5, E));
  }
  function ie2(E, D5) {
    if (l3("endReadableNT", E.endEmitted, E.length), !E.endEmitted && E.length === 0 && (E.endEmitted = true, D5.readable = false, D5.emit("end"), E.autoDestroy)) {
      var se = D5._writableState;
      (!se || se.autoDestroy && se.finished) && D5.destroy();
    }
  }
  typeof Symbol == "function" && (B5.from = function(E, D5) {
    return $10 === void 0 && ($10 = xse()), $10(B5, E, D5);
  });
  function ce2(E, D5) {
    for (var se = 0, ye = E.length; se < ye; se++)
      if (E[se] === D5)
        return se;
    return -1;
  }
  return $p;
}
var l5 = Ii, Nd = ys.codes, Qse = Nd.ERR_METHOD_NOT_IMPLEMENTED, Tse = Nd.ERR_MULTIPLE_CALLBACK, kse = Nd.ERR_TRANSFORM_ALREADY_TRANSFORMING, Ese = Nd.ERR_TRANSFORM_WITH_LENGTH_0, Wd = $a();
$o(Ii, Wd);
function Cse(t10, e3) {
  var r3 = this._transformState;
  r3.transforming = false;
  var n3 = r3.writecb;
  if (n3 === null)
    return this.emit("error", new Tse());
  r3.writechunk = null, r3.writecb = null, e3 != null && this.push(e3), n3(t10);
  var i3 = this._readableState;
  i3.reading = false, (i3.needReadable || i3.length < i3.highWaterMark) && this._read(i3.highWaterMark);
}
function Ii(t10) {
  if (!(this instanceof Ii))
    return new Ii(t10);
  Wd.call(this, t10), this._transformState = {
    afterTransform: Cse.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = true, this._readableState.sync = false, t10 && (typeof t10.transform == "function" && (this._transform = t10.transform), typeof t10.flush == "function" && (this._flush = t10.flush)), this.on("prefinish", Rse);
}
function Rse() {
  var t10 = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e3, r3) {
    H$(t10, e3, r3);
  }) : H$(this, null, null);
}
Ii.prototype.push = function(t10, e3) {
  return this._transformState.needTransform = false, Wd.prototype.push.call(this, t10, e3);
};
Ii.prototype._transform = function(t10, e3, r3) {
  r3(new Qse("_transform()"));
};
Ii.prototype._write = function(t10, e3, r3) {
  var n3 = this._transformState;
  if (n3.writecb = r3, n3.writechunk = t10, n3.writeencoding = e3, !n3.transforming) {
    var i3 = this._readableState;
    (n3.needTransform || i3.needReadable || i3.length < i3.highWaterMark) && this._read(i3.highWaterMark);
  }
};
Ii.prototype._read = function(t10) {
  var e3 = this._transformState;
  e3.writechunk !== null && !e3.transforming ? (e3.transforming = true, this._transform(e3.writechunk, e3.writeencoding, e3.afterTransform)) : e3.needTransform = true;
};
Ii.prototype._destroy = function(t10, e3) {
  Wd.prototype._destroy.call(this, t10, function(r3) {
    e3(r3);
  });
};
function H$(t10, e3, r3) {
  if (e3)
    return t10.emit("error", e3);
  if (r3 != null && t10.push(r3), t10._writableState.length)
    throw new Ese();
  if (t10._transformState.transforming)
    throw new kse();
  return t10.push(null);
}
var Ase = ru, u5 = l5;
$o(ru, u5);
function ru(t10) {
  if (!(this instanceof ru))
    return new ru(t10);
  u5.call(this, t10);
}
ru.prototype._transform = function(t10, e3, r3) {
  r3(null, t10);
};
var wp;
function Xse(t10) {
  var e3 = false;
  return function() {
    e3 || (e3 = true, t10.apply(void 0, arguments));
  };
}
var c5 = ys.codes, qse = c5.ERR_MISSING_ARGS, Dse = c5.ERR_STREAM_DESTROYED;
function G$(t10) {
  if (t10)
    throw t10;
}
function jse(t10) {
  return t10.setHeader && typeof t10.abort == "function";
}
function Use(t10, e3, r3, n3) {
  n3 = Xse(n3);
  var i3 = false;
  t10.on("close", function() {
    i3 = true;
  }), wp === void 0 && (wp = y1), wp(t10, {
    readable: e3,
    writable: r3
  }, function(s3) {
    if (s3)
      return n3(s3);
    i3 = true, n3();
  });
  var o3 = false;
  return function(s3) {
    if (!i3 && !o3) {
      if (o3 = true, jse(t10))
        return t10.abort();
      if (typeof t10.destroy == "function")
        return t10.destroy();
      n3(s3 || new Dse("pipe"));
    }
  };
}
function K$(t10) {
  t10();
}
function Ise(t10, e3) {
  return t10.pipe(e3);
}
function Fse(t10) {
  return !t10.length || typeof t10[t10.length - 1] != "function" ? G$ : t10.pop();
}
function Zse() {
  for (var t10 = arguments.length, e3 = new Array(t10), r3 = 0; r3 < t10; r3++)
    e3[r3] = arguments[r3];
  var n3 = Fse(e3);
  if (Array.isArray(e3[0]) && (e3 = e3[0]), e3.length < 2)
    throw new qse("streams");
  var i3, o3 = e3.map(function(s3, a3) {
    var l3 = a3 < e3.length - 1, u3 = a3 > 0;
    return Use(s3, l3, u3, function(c3) {
      i3 || (i3 = c3), c3 && o3.forEach(K$), !l3 && (o3.forEach(K$), n3(i3));
    });
  });
  return e3.reduce(Ise);
}
var Mse = Zse;
(function(t10, e3) {
  e3 = t10.exports = a5(), e3.Stream = e3, e3.Readable = e3, e3.Writable = o5(), e3.Duplex = $a(), e3.Transform = l5, e3.PassThrough = Ase, e3.finished = y1, e3.pipeline = Mse;
})(Fm, Fm.exports);
var f5 = Fm.exports, J$ = m1, Nse = $o, d5 = f5, uc = Zd.readyStates = {
  UNSENT: 0,
  OPENED: 1,
  HEADERS_RECEIVED: 2,
  LOADING: 3,
  DONE: 4
}, v1 = Zd.IncomingMessage = function(t10, e3, r3, n3) {
  var i3 = this;
  if (d5.Readable.call(i3), i3._mode = r3, i3.headers = {}, i3.rawHeaders = [], i3.trailers = {}, i3.rawTrailers = [], i3.on("end", function() {
    $e.process.nextTick(function() {
      i3.emit("close");
    });
  }), r3 === "fetch") {
    let c3 = function() {
      s3.read().then(function(f3) {
        if (!i3._destroyed) {
          if (n3(f3.done), f3.done) {
            i3.push(null);
            return;
          }
          i3.push($e.Buffer.from(f3.value)), c3();
        }
      }).catch(function(f3) {
        n3(true), i3._destroyed || i3.emit("error", f3);
      });
    };
    if (i3._fetchResponse = e3, i3.url = e3.url, i3.statusCode = e3.status, i3.statusMessage = e3.statusText, e3.headers.forEach(function(f3, d3) {
      i3.headers[d3.toLowerCase()] = f3, i3.rawHeaders.push(d3, f3);
    }), J$.writableStream) {
      var o3 = new WritableStream({
        write: function(f3) {
          return n3(false), new Promise(function(d3, p10) {
            i3._destroyed ? p10() : i3.push($e.Buffer.from(f3)) ? d3() : i3._resumeFetch = d3;
          });
        },
        close: function() {
          n3(true), i3._destroyed || i3.push(null);
        },
        abort: function(f3) {
          n3(true), i3._destroyed || i3.emit("error", f3);
        }
      });
      try {
        e3.body.pipeTo(o3).catch(function(f3) {
          n3(true), i3._destroyed || i3.emit("error", f3);
        });
        return;
      } catch {
      }
    }
    var s3 = e3.body.getReader();
    c3();
  } else {
    i3._xhr = t10, i3._pos = 0, i3.url = t10.responseURL, i3.statusCode = t10.status, i3.statusMessage = t10.statusText;
    var a3 = t10.getAllResponseHeaders().split(/\r?\n/);
    if (a3.forEach(function(c3) {
      var f3 = c3.match(/^([^:]+):\s*(.*)/);
      if (f3) {
        var d3 = f3[1].toLowerCase();
        d3 === "set-cookie" ? (i3.headers[d3] === void 0 && (i3.headers[d3] = []), i3.headers[d3].push(f3[2])) : i3.headers[d3] !== void 0 ? i3.headers[d3] += ", " + f3[2] : i3.headers[d3] = f3[2], i3.rawHeaders.push(f3[1], f3[2]);
      }
    }), i3._charset = "x-user-defined", !J$.overrideMimeType) {
      var l3 = i3.rawHeaders["mime-type"];
      if (l3) {
        var u3 = l3.match(/;\s*charset=([^;])(;|$)/);
        u3 && (i3._charset = u3[1].toLowerCase());
      }
      i3._charset || (i3._charset = "utf-8");
    }
  }
};
Nse(v1, d5.Readable);
v1.prototype._read = function() {
  var t10 = this, e3 = t10._resumeFetch;
  e3 && (t10._resumeFetch = null, e3());
};
v1.prototype._onXHRProgress = function(t10) {
  var e3 = this, r3 = e3._xhr, n3 = null;
  switch (e3._mode) {
    case "text":
      if (n3 = r3.responseText, n3.length > e3._pos) {
        var i3 = n3.substr(e3._pos);
        if (e3._charset === "x-user-defined") {
          for (var o3 = $e.Buffer.alloc(i3.length), s3 = 0; s3 < i3.length; s3++)
            o3[s3] = i3.charCodeAt(s3) & 255;
          e3.push(o3);
        } else
          e3.push(i3, e3._charset);
        e3._pos = n3.length;
      }
      break;
    case "arraybuffer":
      if (r3.readyState !== uc.DONE || !r3.response)
        break;
      n3 = r3.response, e3.push($e.Buffer.from(new Uint8Array(n3)));
      break;
    case "moz-chunked-arraybuffer":
      if (n3 = r3.response, r3.readyState !== uc.LOADING || !n3)
        break;
      e3.push($e.Buffer.from(new Uint8Array(n3)));
      break;
    case "ms-stream":
      if (n3 = r3.response, r3.readyState !== uc.LOADING)
        break;
      var a3 = new yt.MSStreamReader();
      a3.onprogress = function() {
        a3.result.byteLength > e3._pos && (e3.push($e.Buffer.from(new Uint8Array(a3.result.slice(e3._pos)))), e3._pos = a3.result.byteLength);
      }, a3.onload = function() {
        t10(true), e3.push(null);
      }, a3.readAsArrayBuffer(n3);
      break;
  }
  e3._xhr.readyState === uc.DONE && e3._mode !== "ms-stream" && (t10(true), e3.push(null));
};
var Yo = m1, Wse = $o, h5 = Zd, b1 = f5, Vse = h5.IncomingMessage, ew = h5.readyStates;
function Yse(t10, e3) {
  return Yo.fetch && e3 ? "fetch" : Yo.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : Yo.msstream ? "ms-stream" : Yo.arraybuffer && t10 ? "arraybuffer" : "text";
}
var wr = Vk.exports = function(t10) {
  var e3 = this;
  b1.Writable.call(e3), e3._opts = t10, e3._body = [], e3._headers = {}, t10.auth && e3.setHeader("Authorization", "Basic " + $e.Buffer.from(t10.auth).toString("base64")), Object.keys(t10.headers).forEach(function(i3) {
    e3.setHeader(i3, t10.headers[i3]);
  });
  var r3, n3 = true;
  if (t10.mode === "disable-fetch" || "requestTimeout" in t10 && !Yo.abortController)
    n3 = false, r3 = true;
  else if (t10.mode === "prefer-streaming")
    r3 = false;
  else if (t10.mode === "allow-wrong-content-type")
    r3 = !Yo.overrideMimeType;
  else if (!t10.mode || t10.mode === "default" || t10.mode === "prefer-fast")
    r3 = true;
  else
    throw new Error("Invalid value for opts.mode");
  e3._mode = Yse(r3, n3), e3._fetchTimer = null, e3._socketTimeout = null, e3._socketTimer = null, e3.on("finish", function() {
    e3._onFinish();
  });
};
Wse(wr, b1.Writable);
wr.prototype.setHeader = function(t10, e3) {
  var r3 = this, n3 = t10.toLowerCase();
  Bse.indexOf(n3) === -1 && (r3._headers[n3] = {
    name: t10,
    value: e3
  });
};
wr.prototype.getHeader = function(t10) {
  var e3 = this._headers[t10.toLowerCase()];
  return e3 ? e3.value : null;
};
wr.prototype.removeHeader = function(t10) {
  var e3 = this;
  delete e3._headers[t10.toLowerCase()];
};
wr.prototype._onFinish = function() {
  var t10 = this;
  if (!t10._destroyed) {
    var e3 = t10._opts;
    "timeout" in e3 && e3.timeout !== 0 && t10.setTimeout(e3.timeout);
    var r3 = t10._headers, n3 = null;
    e3.method !== "GET" && e3.method !== "HEAD" && (n3 = new Blob(t10._body, {
      type: (r3["content-type"] || {}).value || ""
    }));
    var i3 = [];
    if (Object.keys(r3).forEach(function(l3) {
      var u3 = r3[l3].name, c3 = r3[l3].value;
      Array.isArray(c3) ? c3.forEach(function(f3) {
        i3.push([u3, f3]);
      }) : i3.push([u3, c3]);
    }), t10._mode === "fetch") {
      var o3 = null;
      if (Yo.abortController) {
        var s3 = new AbortController();
        o3 = s3.signal, t10._fetchAbortController = s3, "requestTimeout" in e3 && e3.requestTimeout !== 0 && (t10._fetchTimer = yt.setTimeout(function() {
          t10.emit("requestTimeout"), t10._fetchAbortController && t10._fetchAbortController.abort();
        }, e3.requestTimeout));
      }
      yt.fetch(t10._opts.url, {
        method: t10._opts.method,
        headers: i3,
        body: n3 || void 0,
        mode: "cors",
        credentials: e3.withCredentials ? "include" : "same-origin",
        signal: o3
      }).then(function(l3) {
        t10._fetchResponse = l3, t10._resetTimers(false), t10._connect();
      }, function(l3) {
        t10._resetTimers(true), t10._destroyed || t10.emit("error", l3);
      });
    } else {
      var a3 = t10._xhr = new yt.XMLHttpRequest();
      try {
        a3.open(t10._opts.method, t10._opts.url, true);
      } catch (l3) {
        $e.process.nextTick(function() {
          t10.emit("error", l3);
        });
        return;
      }
      "responseType" in a3 && (a3.responseType = t10._mode), "withCredentials" in a3 && (a3.withCredentials = !!e3.withCredentials), t10._mode === "text" && "overrideMimeType" in a3 && a3.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in e3 && (a3.timeout = e3.requestTimeout, a3.ontimeout = function() {
        t10.emit("requestTimeout");
      }), i3.forEach(function(l3) {
        a3.setRequestHeader(l3[0], l3[1]);
      }), t10._response = null, a3.onreadystatechange = function() {
        switch (a3.readyState) {
          case ew.LOADING:
          case ew.DONE:
            t10._onXHRProgress();
            break;
        }
      }, t10._mode === "moz-chunked-arraybuffer" && (a3.onprogress = function() {
        t10._onXHRProgress();
      }), a3.onerror = function() {
        t10._destroyed || (t10._resetTimers(true), t10.emit("error", new Error("XHR error")));
      };
      try {
        a3.send(n3);
      } catch (l3) {
        $e.process.nextTick(function() {
          t10.emit("error", l3);
        });
        return;
      }
    }
  }
};
function Lse(t10) {
  try {
    var e3 = t10.status;
    return e3 !== null && e3 !== 0;
  } catch {
    return false;
  }
}
wr.prototype._onXHRProgress = function() {
  var t10 = this;
  t10._resetTimers(false), !(!Lse(t10._xhr) || t10._destroyed) && (t10._response || t10._connect(), t10._response._onXHRProgress(t10._resetTimers.bind(t10)));
};
wr.prototype._connect = function() {
  var t10 = this;
  t10._destroyed || (t10._response = new Vse(t10._xhr, t10._fetchResponse, t10._mode, t10._resetTimers.bind(t10)), t10._response.on("error", function(e3) {
    t10.emit("error", e3);
  }), t10.emit("response", t10._response));
};
wr.prototype._write = function(t10, e3, r3) {
  var n3 = this;
  n3._body.push(t10), r3();
};
wr.prototype._resetTimers = function(t10) {
  var e3 = this;
  yt.clearTimeout(e3._socketTimer), e3._socketTimer = null, t10 ? (yt.clearTimeout(e3._fetchTimer), e3._fetchTimer = null) : e3._socketTimeout && (e3._socketTimer = yt.setTimeout(function() {
    e3.emit("timeout");
  }, e3._socketTimeout));
};
wr.prototype.abort = wr.prototype.destroy = function(t10) {
  var e3 = this;
  e3._destroyed = true, e3._resetTimers(true), e3._response && (e3._response._destroyed = true), e3._xhr ? e3._xhr.abort() : e3._fetchAbortController && e3._fetchAbortController.abort(), t10 && e3.emit("error", t10);
};
wr.prototype.end = function(t10, e3, r3) {
  var n3 = this;
  typeof t10 == "function" && (r3 = t10, t10 = void 0), b1.Writable.prototype.end.call(n3, t10, e3, r3);
};
wr.prototype.setTimeout = function(t10, e3) {
  var r3 = this;
  e3 && r3.once("timeout", e3), r3._socketTimeout = t10, r3._resetTimers(false);
};
wr.prototype.flushHeaders = function() {
};
wr.prototype.setNoDelay = function() {
};
wr.prototype.setSocketKeepAlive = function() {
};
var Bse = [
  "accept-charset",
  "accept-encoding",
  "access-control-request-headers",
  "access-control-request-method",
  "connection",
  "content-length",
  "cookie",
  "cookie2",
  "date",
  "dnt",
  "expect",
  "host",
  "keep-alive",
  "origin",
  "referer",
  "te",
  "trailer",
  "transfer-encoding",
  "upgrade",
  "via"
], zse = Vk.exports, Hse = Kse, Gse = Object.prototype.hasOwnProperty;
function Kse() {
  for (var t10 = {}, e3 = 0; e3 < arguments.length; e3++) {
    var r3 = arguments[e3];
    for (var n3 in r3)
      Gse.call(r3, n3) && (t10[n3] = r3[n3]);
  }
  return t10;
}
var Jse = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Unordered Collection",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
(function(t10) {
  var e3 = zse, r3 = Zd, n3 = Hse, i3 = Jse, o3 = Tf, s3 = t10;
  s3.request = function(a3, l3) {
    typeof a3 == "string" ? a3 = o3.parse(a3) : a3 = n3(a3);
    var u3 = yt.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", c3 = a3.protocol || u3, f3 = a3.hostname || a3.host, d3 = a3.port, p10 = a3.path || "/";
    f3 && f3.indexOf(":") !== -1 && (f3 = "[" + f3 + "]"), a3.url = (f3 ? c3 + "//" + f3 : "") + (d3 ? ":" + d3 : "") + p10, a3.method = (a3.method || "GET").toUpperCase(), a3.headers = a3.headers || {};
    var h10 = new e3(a3);
    return l3 && h10.on("response", l3), h10;
  }, s3.get = function(l3, u3) {
    var c3 = s3.request(l3, u3);
    return c3.end(), c3;
  }, s3.ClientRequest = e3, s3.IncomingMessage = r3.IncomingMessage, s3.Agent = function() {
  }, s3.Agent.defaultMaxSockets = 4, s3.globalAgent = new s3.Agent(), s3.STATUS_CODES = i3, s3.METHODS = [
    "CHECKOUT",
    "CONNECT",
    "COPY",
    "DELETE",
    "GET",
    "HEAD",
    "LOCK",
    "M-SEARCH",
    "MERGE",
    "MKACTIVITY",
    "MKCOL",
    "MOVE",
    "NOTIFY",
    "OPTIONS",
    "PATCH",
    "POST",
    "PROPFIND",
    "PROPPATCH",
    "PURGE",
    "PUT",
    "REPORT",
    "SEARCH",
    "SUBSCRIBE",
    "TRACE",
    "UNLOCK",
    "UNSUBSCRIBE"
  ];
})(O1);
var p5 = { exports: {} };
(function(t10) {
  var e3 = O1, r3 = Tf, n3 = t10.exports;
  for (var i3 in e3)
    e3.hasOwnProperty(i3) && (n3[i3] = e3[i3]);
  n3.request = function(s3, a3) {
    return s3 = o3(s3), e3.request.call(this, s3, a3);
  }, n3.get = function(s3, a3) {
    return s3 = o3(s3), e3.get.call(this, s3, a3);
  };
  function o3(s3) {
    if (typeof s3 == "string" && (s3 = r3.parse(s3)), s3.protocol || (s3.protocol = "https:"), s3.protocol !== "https:")
      throw new Error('Protocol "' + s3.protocol + '" not supported. Expected "https:"');
    return s3;
  }
})(p5);
var eae = p5.exports;
const tae = O1, rae = eae, { ono: cc } = fi, _l = mn, { ResolverError: tw } = Ht;
var nae = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   *
   * @type {number}
   */
  order: 200,
  /**
   * HTTP headers to send when downloading files.
   *
   * @example:
   * {
   *   "User-Agent": "JSON Schema $Ref Parser",
   *   Accept: "application/json"
   * }
   *
   * @type {object}
   */
  headers: null,
  /**
   * HTTP request timeout (in milliseconds).
   *
   * @type {number}
   */
  timeout: 5e3,
  // 5 seconds
  /**
   * The maximum number of HTTP redirects to follow.
   * To disable automatic following of redirects, set this to zero.
   *
   * @type {number}
   */
  redirects: 5,
  /**
   * The `withCredentials` option of XMLHttpRequest.
   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
   *
   * @type {boolean}
   */
  withCredentials: false,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {boolean}
   */
  canRead(t10) {
    return _l.isHttp(t10.url);
  },
  /**
   * Reads the given URL and returns its raw contents as a Buffer.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {Promise<Buffer>}
   */
  read(t10) {
    let e3 = _l.parse(t10.url);
    return $e.process.browser && !e3.protocol && (e3.protocol = _l.parse(location.href).protocol), O5(e3, this);
  }
};
function O5(t10, e3, r3) {
  return new Promise((n3, i3) => {
    t10 = _l.parse(t10), r3 = r3 || [], r3.push(t10.href), iae(t10, e3).then((o3) => {
      if (o3.statusCode >= 400)
        throw cc({ status: o3.statusCode }, `HTTP ERROR ${o3.statusCode}`);
      if (o3.statusCode >= 300)
        if (r3.length > e3.redirects)
          i3(new tw(cc(
            { status: o3.statusCode },
            `Error downloading ${r3[0]}. 
Too many redirects: 
  ${r3.join(` 
  `)}`
          )));
        else if (o3.headers.location) {
          let s3 = _l.resolve(t10, o3.headers.location);
          O5(s3, e3, r3).then(n3, i3);
        } else
          throw cc({ status: o3.statusCode }, `HTTP ${o3.statusCode} redirect with no location header`);
      else
        n3(o3.body || $e.Buffer.alloc(0));
    }).catch((o3) => {
      i3(new tw(cc(o3, `Error downloading ${t10.href}`), t10.href));
    });
  });
}
function iae(t10, e3) {
  return new Promise((r3, n3) => {
    let o3 = (t10.protocol === "https:" ? rae : tae).get({
      hostname: t10.hostname,
      port: t10.port,
      path: t10.path,
      auth: t10.auth,
      protocol: t10.protocol,
      headers: e3.headers || {},
      withCredentials: e3.withCredentials
    });
    typeof o3.setTimeout == "function" && o3.setTimeout(e3.timeout), o3.on("timeout", () => {
      o3.abort();
    }), o3.on("error", n3), o3.once("response", (s3) => {
      s3.body = $e.Buffer.alloc(0), s3.on("data", (a3) => {
        s3.body = $e.Buffer.concat([s3.body, $e.Buffer.from(a3)]);
      }), s3.on("error", n3), s3.on("end", () => {
        r3(s3);
      });
    });
  });
}
const oae = Yre, sae = Voe, aae = Boe, lae = Hoe, uae = tse, cae = nae;
var m5 = S1;
function S1(t10) {
  Mm(this, S1.defaults), Mm(this, t10);
}
S1.defaults = {
  /**
   * Determines how different types of files will be parsed.
   *
   * You can add additional parsers of your own, replace an existing one with
   * your own implementation, or disable any parser by setting it to false.
   */
  parse: {
    json: oae,
    yaml: sae,
    text: aae,
    binary: lae
  },
  /**
   * Determines how JSON References will be resolved.
   *
   * You can add additional resolvers of your own, replace an existing one with
   * your own implementation, or disable any resolver by setting it to false.
   */
  resolve: {
    file: uae,
    http: cae,
    /**
     * Determines whether external $ref pointers will be resolved.
     * If this option is disabled, then none of above resolvers will be called.
     * Instead, external $ref pointers will simply be ignored.
     *
     * @type {boolean}
     */
    external: true
  },
  /**
   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
   * causes it to keep processing as much as possible and then throw a single error that contains all errors
   * that were encountered.
  */
  continueOnError: false,
  /**
   * Determines the types of JSON references that are allowed.
   */
  dereference: {
    /**
     * Dereference circular (recursive) JSON references?
     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
     * If "ignore", then circular references will not be dereferenced.
     *
     * @type {boolean|string}
     */
    circular: true
  }
};
function Mm(t10, e3) {
  if (rw(e3)) {
    let r3 = Object.keys(e3);
    for (let n3 = 0; n3 < r3.length; n3++) {
      let i3 = r3[n3], o3 = e3[i3], s3 = t10[i3];
      rw(o3) ? t10[i3] = Mm(s3 || {}, o3) : o3 !== void 0 && (t10[i3] = o3);
    }
  }
  return t10;
}
function rw(t10) {
  return t10 && typeof t10 == "object" && !Array.isArray(t10) && !(t10 instanceof RegExp) && !(t10 instanceof Date);
}
const nw = m5;
var g5 = fae;
function fae(t10) {
  let e3, r3, n3, i3;
  return t10 = Array.prototype.slice.call(t10), typeof t10[t10.length - 1] == "function" && (i3 = t10.pop()), typeof t10[0] == "string" ? (e3 = t10[0], typeof t10[2] == "object" ? (r3 = t10[1], n3 = t10[2]) : (r3 = void 0, n3 = t10[1])) : (e3 = "", r3 = t10[0], n3 = t10[1]), n3 instanceof nw || (n3 = new nw(n3)), {
    path: e3,
    schema: r3,
    options: n3,
    callback: i3
  };
}
const Nm = m5, dae = rk, hae = ik, pae = yu;
var Oae = Vd;
function Vd(t10) {
  Nm.call(this, Vd.defaults), Nm.apply(this, arguments);
}
Vd.defaults = {
  /**
   * Determines how the API definition will be validated.
   *
   * You can add additional validators of your own, replace an existing one with
   * your own implemenation, or disable any validator by setting it to false.
   */
  validate: {
    schema: dae,
    spec: hae
  }
};
pae.inherits(Vd, Nm);
function mae() {
  return typeof $e.process == "object" && typeof $e.process.nextTick == "function" ? $e.process.nextTick : typeof setImmediate == "function" ? setImmediate : function(e3) {
    setTimeout(e3, 0);
  };
}
var gae = mae(), iw = gae, y5 = function(e3, r3) {
  if (e3) {
    r3.then(function(n3) {
      iw(function() {
        e3(null, n3);
      });
    }, function(n3) {
      iw(function() {
        e3(n3);
      });
    });
    return;
  } else
    return r3;
}, di = { exports: {} }, Pp, ow;
function Yd() {
  if (ow)
    return Pp;
  ow = 1, Pp = c3;
  const t10 = Cu(), e3 = mn, { JSONParserError: r3, InvalidPointerError: n3, MissingPointerError: i3, isHandledError: o3 } = Ht, s3 = /\//g, a3 = /~/g, l3 = /~1/g, u3 = /~0/g;
  function c3(h10, m10, O10) {
    this.$ref = h10, this.path = m10, this.originalPath = O10 || m10, this.value = void 0, this.circular = false, this.indirections = 0;
  }
  c3.prototype.resolve = function(h10, m10, O10) {
    let g = c3.parse(this.path, this.originalPath);
    this.value = p10(h10);
    for (let v10 = 0; v10 < g.length; v10++) {
      if (f3(this, m10) && (this.path = c3.join(this.path, g.slice(v10))), typeof this.value == "object" && this.value !== null && "$ref" in this.value)
        return this;
      let S10 = g[v10];
      if (this.value[S10] === void 0 || this.value[S10] === null)
        throw this.value = null, new i3(S10, this.originalPath);
      this.value = this.value[S10];
    }
    return (!this.value || this.value.$ref && e3.resolve(this.path, this.value.$ref) !== O10) && f3(this, m10), this;
  }, c3.prototype.set = function(h10, m10, O10) {
    let g = c3.parse(this.path), v10;
    if (g.length === 0)
      return this.value = m10, m10;
    this.value = p10(h10);
    for (let S10 = 0; S10 < g.length - 1; S10++)
      f3(this, O10), v10 = g[S10], this.value && this.value[v10] !== void 0 ? this.value = this.value[v10] : this.value = d3(this, v10, {});
    return f3(this, O10), v10 = g[g.length - 1], d3(this, v10, m10), h10;
  }, c3.parse = function(h10, m10) {
    let O10 = e3.getHash(h10).substr(1);
    if (!O10)
      return [];
    O10 = O10.split("/");
    for (let g = 0; g < O10.length; g++)
      O10[g] = decodeURIComponent(O10[g].replace(l3, "/").replace(u3, "~"));
    if (O10[0] !== "")
      throw new n3(O10, m10 === void 0 ? h10 : m10);
    return O10.slice(1);
  }, c3.join = function(h10, m10) {
    h10.indexOf("#") === -1 && (h10 += "#"), m10 = Array.isArray(m10) ? m10 : [m10];
    for (let O10 = 0; O10 < m10.length; O10++) {
      let g = m10[O10];
      h10 += "/" + encodeURIComponent(g.replace(a3, "~0").replace(s3, "~1"));
    }
    return h10;
  };
  function f3(h10, m10) {
    if (t10.isAllowed$Ref(h10.value, m10)) {
      let O10 = e3.resolve(h10.path, h10.value.$ref);
      if (O10 === h10.path)
        h10.circular = true;
      else {
        let g = h10.$ref.$refs._resolve(O10, h10.path, m10);
        return h10.indirections += g.indirections + 1, t10.isExtended$Ref(h10.value) ? (h10.value = t10.dereference(h10.value, g.value), false) : (h10.$ref = g.$ref, h10.path = g.path, h10.value = g.value, true);
      }
    }
  }
  function d3(h10, m10, O10) {
    if (h10.value && typeof h10.value == "object")
      m10 === "-" && Array.isArray(h10.value) ? h10.value.push(O10) : h10.value[m10] = O10;
    else
      throw new r3(`Error assigning $ref pointer "${h10.path}". 
Cannot set "${m10}" of a non-object.`);
    return O10;
  }
  function p10(h10) {
    if (o3(h10))
      throw h10;
    return h10;
  }
  return Pp;
}
var _p, sw;
function Cu() {
  if (sw)
    return _p;
  sw = 1, _p = a3;
  const t10 = Yd(), { InvalidPointerError: e3, isHandledError: r3, normalizeError: n3 } = Ht, { safePointerToPath: i3, stripHash: o3, getHash: s3 } = mn;
  function a3() {
    this.path = void 0, this.value = void 0, this.$refs = void 0, this.pathType = void 0, this.errors = void 0;
  }
  return a3.prototype.addError = function(l3) {
    this.errors === void 0 && (this.errors = []), Array.isArray(l3.errors) ? this.errors.push(...l3.errors.map(n3)) : this.errors.push(n3(l3));
  }, a3.prototype.exists = function(l3, u3) {
    try {
      return this.resolve(l3, u3), true;
    } catch {
      return false;
    }
  }, a3.prototype.get = function(l3, u3) {
    return this.resolve(l3, u3).value;
  }, a3.prototype.resolve = function(l3, u3, c3, f3) {
    let d3 = new t10(this, l3, c3);
    try {
      return d3.resolve(this.value, u3, f3);
    } catch (p10) {
      if (!u3 || !u3.continueOnError || !r3(p10))
        throw p10;
      return p10.path === null && (p10.path = i3(s3(f3))), p10 instanceof e3 && (p10.source = o3(f3)), this.addError(p10), null;
    }
  }, a3.prototype.set = function(l3, u3) {
    let c3 = new t10(this, l3);
    this.value = c3.set(this.value, u3);
  }, a3.is$Ref = function(l3) {
    return l3 && typeof l3 == "object" && typeof l3.$ref == "string" && l3.$ref.length > 0;
  }, a3.isExternal$Ref = function(l3) {
    return a3.is$Ref(l3) && l3.$ref[0] !== "#";
  }, a3.isAllowed$Ref = function(l3, u3) {
    if (a3.is$Ref(l3)) {
      if (l3.$ref.substr(0, 2) === "#/" || l3.$ref === "#")
        return true;
      if (l3.$ref[0] !== "#" && (!u3 || u3.resolve.external))
        return true;
    }
  }, a3.isExtended$Ref = function(l3) {
    return a3.is$Ref(l3) && Object.keys(l3).length > 1;
  }, a3.dereference = function(l3, u3) {
    if (u3 && typeof u3 == "object" && a3.isExtended$Ref(l3)) {
      let c3 = {};
      for (let f3 of Object.keys(l3))
        f3 !== "$ref" && (c3[f3] = l3[f3]);
      for (let f3 of Object.keys(u3))
        f3 in c3 || (c3[f3] = u3[f3]);
      return c3;
    } else
      return u3;
  }, _p;
}
const { ono: v5 } = fi, yae = Cu(), yo = mn;
var vae = Rn;
function Rn() {
  this.circular = false, this._$refs = {}, this._root$Ref = null;
}
Rn.prototype.paths = function(t10) {
  return b5(this._$refs, arguments).map((r3) => r3.decoded);
};
Rn.prototype.values = function(t10) {
  let e3 = this._$refs;
  return b5(e3, arguments).reduce((n3, i3) => (n3[i3.decoded] = e3[i3.encoded].value, n3), {});
};
Rn.prototype.toJSON = Rn.prototype.values;
Rn.prototype.exists = function(t10, e3) {
  try {
    return this._resolve(t10, "", e3), true;
  } catch {
    return false;
  }
};
Rn.prototype.get = function(t10, e3) {
  return this._resolve(t10, "", e3).value;
};
Rn.prototype.set = function(t10, e3) {
  let r3 = yo.resolve(this._root$Ref.path, t10), n3 = yo.stripHash(r3), i3 = this._$refs[n3];
  if (!i3)
    throw v5(`Error resolving $ref pointer "${t10}". 
"${n3}" not found.`);
  i3.set(r3, e3);
};
Rn.prototype._add = function(t10) {
  let e3 = yo.stripHash(t10), r3 = new yae();
  return r3.path = e3, r3.$refs = this, this._$refs[e3] = r3, this._root$Ref = this._root$Ref || r3, r3;
};
Rn.prototype._resolve = function(t10, e3, r3) {
  let n3 = yo.resolve(this._root$Ref.path, t10), i3 = yo.stripHash(n3), o3 = this._$refs[i3];
  if (!o3)
    throw v5(`Error resolving $ref pointer "${t10}". 
"${i3}" not found.`);
  return o3.resolve(n3, r3, t10, e3);
};
Rn.prototype._get$Ref = function(t10) {
  t10 = yo.resolve(this._root$Ref.path, t10);
  let e3 = yo.stripHash(t10);
  return this._$refs[e3];
};
function b5(t10, e3) {
  let r3 = Object.keys(t10);
  return e3 = Array.isArray(e3[0]) ? e3[0] : Array.prototype.slice.call(e3), e3.length > 0 && e3[0] && (r3 = r3.filter((n3) => e3.indexOf(t10[n3].pathType) !== -1)), r3.map((n3) => ({
    encoded: n3,
    decoded: t10[n3].pathType === "file" ? yo.toFileSystemPath(n3, true) : n3
  }));
}
var Ru = {};
Ru.all = function(t10) {
  return Object.keys(t10).filter((e3) => typeof t10[e3] == "object").map((e3) => (t10[e3].name = e3, t10[e3]));
};
Ru.filter = function(t10, e3, r3) {
  return t10.filter((n3) => !!S5(n3, e3, r3));
};
Ru.sort = function(t10) {
  for (let e3 of t10)
    e3.order = e3.order || Number.MAX_SAFE_INTEGER;
  return t10.sort((e3, r3) => e3.order - r3.order);
};
Ru.run = function(t10, e3, r3, n3) {
  let i3, o3, s3 = 0;
  return new Promise((a3, l3) => {
    u3();
    function u3() {
      if (i3 = t10[s3++], !i3)
        return l3(o3);
      try {
        let p10 = S5(i3, e3, r3, c3, n3);
        if (p10 && typeof p10.then == "function")
          p10.then(f3, d3);
        else if (p10 !== void 0)
          f3(p10);
        else if (s3 === t10.length)
          throw new Error("No promise has been returned or callback has been called.");
      } catch (p10) {
        d3(p10);
      }
    }
    function c3(p10, h10) {
      p10 ? d3(p10) : f3(h10);
    }
    function f3(p10) {
      a3({
        plugin: i3,
        result: p10
      });
    }
    function d3(p10) {
      o3 = {
        plugin: i3,
        error: p10
      }, u3();
    }
  });
};
function S5(t10, e3, r3, n3, i3) {
  let o3 = t10[e3];
  if (typeof o3 == "function")
    return o3.apply(t10, [r3, n3, i3]);
  if (!n3) {
    if (o3 instanceof RegExp)
      return o3.test(r3.url);
    if (typeof o3 == "string")
      return o3 === r3.extension;
    if (Array.isArray(o3))
      return o3.indexOf(r3.extension) !== -1;
  }
  return o3;
}
const { ono: Wm } = fi, aw = mn, io = Ru, { ResolverError: lw, ParserError: uw, UnmatchedParserError: bae, UnmatchedResolverError: Sae, isHandledError: $ae } = Ht;
var $5 = wae;
async function wae(t10, e3, r3) {
  t10 = aw.stripHash(t10);
  let n3 = e3._add(t10), i3 = {
    url: t10,
    extension: aw.getExtension(t10)
  };
  try {
    const o3 = await Pae(i3, r3, e3);
    n3.pathType = o3.plugin.name, i3.data = o3.result;
    const s3 = await _ae(i3, r3, e3);
    return n3.value = s3.result, s3.result;
  } catch (o3) {
    throw $ae(o3) && (n3.value = o3), o3;
  }
}
function Pae(t10, e3, r3) {
  return new Promise((n3, i3) => {
    let o3 = io.all(e3.resolve);
    o3 = io.filter(o3, "canRead", t10), io.sort(o3), io.run(o3, "read", t10, r3).then(n3, s3);
    function s3(a3) {
      !a3 && e3.continueOnError ? i3(new Sae(t10.url)) : !a3 || !("error" in a3) ? i3(Wm.syntax(`Unable to resolve $ref pointer "${t10.url}"`)) : a3.error instanceof lw ? i3(a3.error) : i3(new lw(a3, t10.url));
    }
  });
}
function _ae(t10, e3, r3) {
  return new Promise((n3, i3) => {
    let o3 = io.all(e3.parse), s3 = io.filter(o3, "canParse", t10), a3 = s3.length > 0 ? s3 : o3;
    io.sort(a3), io.run(a3, "parse", t10, r3).then(l3, u3);
    function l3(c3) {
      !c3.plugin.allowEmpty && xae(c3.result) ? i3(Wm.syntax(`Error parsing "${t10.url}" as ${c3.plugin.name}. 
Parsed value is empty`)) : n3(c3);
    }
    function u3(c3) {
      !c3 && e3.continueOnError ? i3(new bae(t10.url)) : !c3 || !("error" in c3) ? i3(Wm.syntax(`Unable to parse ${t10.url}`)) : c3.error instanceof uw ? i3(c3.error) : i3(new uw(c3.error.message, t10.url));
    }
  });
}
function xae(t10) {
  return t10 === void 0 || typeof t10 == "object" && Object.keys(t10).length === 0 || typeof t10 == "string" && t10.trim().length === 0 || $e.Buffer.isBuffer(t10) && t10.length === 0;
}
const cw = Cu(), Qae = Yd(), Tae = $5, rl = mn, { isHandledError: kae } = Ht;
var Eae = Cae;
function Cae(t10, e3) {
  if (!e3.resolve.external)
    return Promise.resolve();
  try {
    let r3 = $1(t10.schema, t10.$refs._root$Ref.path + "#", t10.$refs, e3);
    return Promise.all(r3);
  } catch (r3) {
    return Promise.reject(r3);
  }
}
function $1(t10, e3, r3, n3) {
  let i3 = [];
  if (t10 && typeof t10 == "object" && !ArrayBuffer.isView(t10))
    if (cw.isExternal$Ref(t10))
      i3.push(fw(t10, e3, r3, n3));
    else
      for (let o3 of Object.keys(t10)) {
        let s3 = Qae.join(e3, o3), a3 = t10[o3];
        cw.isExternal$Ref(a3) ? i3.push(fw(a3, s3, r3, n3)) : i3 = i3.concat($1(a3, s3, r3, n3));
      }
  return i3;
}
async function fw(t10, e3, r3, n3) {
  let i3 = rl.resolve(e3, t10.$ref), o3 = rl.stripHash(i3);
  if (t10 = r3._$refs[o3], t10)
    return Promise.resolve(t10.value);
  try {
    const s3 = await Tae(i3, r3, n3);
    let a3 = $1(s3, o3 + "#", r3, n3);
    return Promise.all(a3);
  } catch (s3) {
    if (!n3.continueOnError || !kae(s3))
      throw s3;
    return r3._$refs[o3] && (s3.source = rl.stripHash(e3), s3.path = rl.safePointerToPath(rl.getHash(e3))), [];
  }
}
const Uf = Cu(), nu = Yd(), xp = mn;
var Rae = Aae;
function Aae(t10, e3) {
  let r3 = [];
  w1(t10, "schema", t10.$refs._root$Ref.path + "#", "#", 0, r3, t10.$refs, e3), Xae(r3);
}
function w1(t10, e3, r3, n3, i3, o3, s3, a3) {
  let l3 = e3 === null ? t10 : t10[e3];
  if (l3 && typeof l3 == "object" && !ArrayBuffer.isView(l3))
    if (Uf.isAllowed$Ref(l3))
      dw(t10, e3, r3, n3, i3, o3, s3, a3);
    else {
      let u3 = Object.keys(l3).sort((c3, f3) => c3 === "definitions" ? -1 : f3 === "definitions" ? 1 : c3.length - f3.length);
      for (let c3 of u3) {
        let f3 = nu.join(r3, c3), d3 = nu.join(n3, c3), p10 = l3[c3];
        Uf.isAllowed$Ref(p10) ? dw(l3, c3, r3, d3, i3, o3, s3, a3) : w1(l3, c3, f3, d3, i3, o3, s3, a3);
      }
    }
}
function dw(t10, e3, r3, n3, i3, o3, s3, a3) {
  let l3 = e3 === null ? t10 : t10[e3], u3 = xp.resolve(r3, l3.$ref), c3 = s3._resolve(u3, n3, a3);
  if (c3 === null)
    return;
  let f3 = nu.parse(n3).length, d3 = xp.stripHash(c3.path), p10 = xp.getHash(c3.path), h10 = d3 !== s3._root$Ref.path, m10 = Uf.isExtended$Ref(l3);
  i3 += c3.indirections;
  let O10 = qae(o3, t10, e3);
  if (O10)
    if (f3 < O10.depth || i3 < O10.indirections)
      Dae(o3, O10);
    else
      return;
  o3.push({
    $ref: l3,
    // The JSON Reference (e.g. {$ref: string})
    parent: t10,
    // The object that contains this $ref pointer
    key: e3,
    // The key in `parent` that is the $ref pointer
    pathFromRoot: n3,
    // The path to the $ref pointer, from the JSON Schema root
    depth: f3,
    // How far from the JSON Schema root is this $ref pointer?
    file: d3,
    // The file that the $ref pointer resolves to
    hash: p10,
    // The hash within `file` that the $ref pointer resolves to
    value: c3.value,
    // The resolved value of the $ref pointer
    circular: c3.circular,
    // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)
    extended: m10,
    // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to "$ref")
    external: h10,
    // Does this $ref pointer point to a file other than the main JSON Schema file?
    indirections: i3
    // The number of indirect references that were traversed to resolve the value
  }), O10 || w1(c3.value, null, c3.path, n3, i3 + 1, o3, s3, a3);
}
function Xae(t10) {
  t10.sort((i3, o3) => {
    if (i3.file !== o3.file)
      return i3.file < o3.file ? -1 : 1;
    if (i3.hash !== o3.hash)
      return i3.hash < o3.hash ? -1 : 1;
    if (i3.circular !== o3.circular)
      return i3.circular ? -1 : 1;
    if (i3.extended !== o3.extended)
      return i3.extended ? 1 : -1;
    if (i3.indirections !== o3.indirections)
      return i3.indirections - o3.indirections;
    if (i3.depth !== o3.depth)
      return i3.depth - o3.depth;
    {
      let s3 = i3.pathFromRoot.lastIndexOf("/definitions"), a3 = o3.pathFromRoot.lastIndexOf("/definitions");
      return s3 !== a3 ? a3 - s3 : i3.pathFromRoot.length - o3.pathFromRoot.length;
    }
  });
  let e3, r3, n3;
  for (let i3 of t10)
    i3.external ? i3.file === e3 && i3.hash === r3 ? i3.$ref.$ref = n3 : i3.file === e3 && i3.hash.indexOf(r3 + "/") === 0 ? i3.$ref.$ref = nu.join(n3, nu.parse(i3.hash.replace(r3, "#"))) : (e3 = i3.file, r3 = i3.hash, n3 = i3.pathFromRoot, i3.$ref = i3.parent[i3.key] = Uf.dereference(i3.$ref, i3.value), i3.circular && (i3.$ref.$ref = i3.pathFromRoot)) : i3.$ref.$ref = i3.hash;
}
function qae(t10, e3, r3) {
  for (let n3 = 0; n3 < t10.length; n3++) {
    let i3 = t10[n3];
    if (i3.parent === e3 && i3.key === r3)
      return i3;
  }
}
function Dae(t10, e3) {
  let r3 = t10.indexOf(e3);
  t10.splice(r3, 1);
}
const Vm = Cu(), hw = Yd(), { ono: jae } = fi, Uae = mn;
var w5 = Iae;
function Iae(t10, e3) {
  let r3 = P1(t10.schema, t10.$refs._root$Ref.path, "#", [], [], {}, t10.$refs, e3);
  t10.$refs.circular = r3.circular, t10.schema = r3.value;
}
function P1(t10, e3, r3, n3, i3, o3, s3, a3) {
  let l3, u3 = {
    value: t10,
    circular: false
  };
  if ((a3.dereference.circular === "ignore" || i3.indexOf(t10) === -1) && t10 && typeof t10 == "object" && !ArrayBuffer.isView(t10)) {
    if (n3.push(t10), i3.push(t10), Vm.isAllowed$Ref(t10, a3))
      l3 = pw(t10, e3, r3, n3, i3, o3, s3, a3), u3.circular = l3.circular, u3.value = l3.value;
    else
      for (let c3 of Object.keys(t10)) {
        let f3 = hw.join(e3, c3), d3 = hw.join(r3, c3), p10 = t10[c3], h10 = false;
        Vm.isAllowed$Ref(p10, a3) ? (l3 = pw(p10, f3, d3, n3, i3, o3, s3, a3), h10 = l3.circular, t10[c3] !== l3.value && (t10[c3] = l3.value)) : n3.indexOf(p10) === -1 ? (l3 = P1(p10, f3, d3, n3, i3, o3, s3, a3), h10 = l3.circular, t10[c3] !== l3.value && (t10[c3] = l3.value)) : h10 = P5(f3, s3, a3), u3.circular = u3.circular || h10;
      }
    n3.pop();
  }
  return u3;
}
function pw(t10, e3, r3, n3, i3, o3, s3, a3) {
  let l3 = Uae.resolve(e3, t10.$ref);
  if (o3[l3]) {
    const h10 = o3[l3], m10 = Object.keys(t10);
    if (m10.length > 1) {
      const O10 = {};
      for (let g of m10)
        g !== "$ref" && !(g in h10.value) && (O10[g] = t10[g]);
      return {
        circular: h10.circular,
        value: Object.assign({}, h10.value, O10)
      };
    }
    return h10;
  }
  let u3 = s3._resolve(l3, e3, a3);
  if (u3 === null)
    return {
      circular: false,
      value: null
    };
  let c3 = u3.circular, f3 = c3 || n3.indexOf(u3.value) !== -1;
  f3 && P5(e3, s3, a3);
  let d3 = Vm.dereference(t10, u3.value);
  if (!f3) {
    let h10 = P1(d3, u3.path, r3, n3, i3, o3, s3, a3);
    f3 = h10.circular, d3 = h10.value;
  }
  f3 && !c3 && a3.dereference.circular === "ignore" && (d3 = t10), c3 && (d3.$ref = r3);
  const p10 = {
    circular: f3,
    value: d3
  };
  return Object.keys(t10).length === 1 && (o3[l3] = p10), p10;
}
function P5(t10, e3, r3) {
  if (e3.circular = true, !r3.dereference.circular)
    throw jae.reference(`Circular $ref pointer found at ${t10}`);
  return true;
}
const _5 = vae, Fae = $5, Ld = g5, Zae = Eae, Mae = Rae, Nae = w5, Cs = mn, { JSONParserError: Wae, InvalidPointerError: Vae, MissingPointerError: Yae, ResolverError: Lae, ParserError: Bae, UnmatchedParserError: zae, UnmatchedResolverError: Hae, isHandledError: Gae, JSONParserErrorGroup: Ow } = Ht, xn = y5, { ono: mw } = fi;
di.exports = hi;
di.exports.default = hi;
di.exports.JSONParserError = Wae;
di.exports.InvalidPointerError = Vae;
di.exports.MissingPointerError = Yae;
di.exports.ResolverError = Lae;
di.exports.ParserError = Bae;
di.exports.UnmatchedParserError = zae;
di.exports.UnmatchedResolverError = Hae;
function hi() {
  this.schema = null, this.$refs = new _5();
}
hi.parse = function(e3, r3, n3, i3) {
  let o3 = this, s3 = new o3();
  return s3.parse.apply(s3, arguments);
};
hi.prototype.parse = async function(e3, r3, n3, i3) {
  let o3 = Ld(arguments), s3;
  if (!o3.path && !o3.schema) {
    let u3 = mw(`Expected a file path, URL, or object. Got ${o3.path || o3.schema}`);
    return xn(o3.callback, Promise.reject(u3));
  }
  this.schema = null, this.$refs = new _5();
  let a3 = "http";
  if (Cs.isFileSystemPath(o3.path) && (o3.path = Cs.fromFileSystemPath(o3.path), a3 = "file"), o3.path = Cs.resolve(Cs.cwd(), o3.path), o3.schema && typeof o3.schema == "object") {
    let u3 = this.$refs._add(o3.path);
    u3.value = o3.schema, u3.pathType = a3, s3 = Promise.resolve(o3.schema);
  } else
    s3 = Fae(o3.path, this.$refs, o3.options);
  let l3 = this;
  try {
    let u3 = await s3;
    if (u3 !== null && typeof u3 == "object" && !$e.Buffer.isBuffer(u3))
      return l3.schema = u3, xn(o3.callback, Promise.resolve(l3.schema));
    if (o3.options.continueOnError)
      return l3.schema = null, xn(o3.callback, Promise.resolve(l3.schema));
    throw mw.syntax(`"${l3.$refs._root$Ref.path || u3}" is not a valid JSON Schema`);
  } catch (u3) {
    return !o3.options.continueOnError || !Gae(u3) ? xn(o3.callback, Promise.reject(u3)) : (this.$refs._$refs[Cs.stripHash(o3.path)] && this.$refs._$refs[Cs.stripHash(o3.path)].addError(u3), xn(o3.callback, Promise.resolve(null)));
  }
};
hi.resolve = function(e3, r3, n3, i3) {
  let o3 = this, s3 = new o3();
  return s3.resolve.apply(s3, arguments);
};
hi.prototype.resolve = async function(e3, r3, n3, i3) {
  let o3 = this, s3 = Ld(arguments);
  try {
    return await this.parse(s3.path, s3.schema, s3.options), await Zae(o3, s3.options), _1(o3), xn(s3.callback, Promise.resolve(o3.$refs));
  } catch (a3) {
    return xn(s3.callback, Promise.reject(a3));
  }
};
hi.bundle = function(e3, r3, n3, i3) {
  let o3 = this, s3 = new o3();
  return s3.bundle.apply(s3, arguments);
};
hi.prototype.bundle = async function(e3, r3, n3, i3) {
  let o3 = this, s3 = Ld(arguments);
  try {
    return await this.resolve(s3.path, s3.schema, s3.options), Mae(o3, s3.options), _1(o3), xn(s3.callback, Promise.resolve(o3.schema));
  } catch (a3) {
    return xn(s3.callback, Promise.reject(a3));
  }
};
hi.dereference = function(e3, r3, n3, i3) {
  let o3 = this, s3 = new o3();
  return s3.dereference.apply(s3, arguments);
};
hi.prototype.dereference = async function(e3, r3, n3, i3) {
  let o3 = this, s3 = Ld(arguments);
  try {
    return await this.resolve(s3.path, s3.schema, s3.options), Nae(o3, s3.options), _1(o3), xn(s3.callback, Promise.resolve(o3.schema));
  } catch (a3) {
    return xn(s3.callback, Promise.reject(a3));
  }
};
function _1(t10) {
  if (Ow.getParserErrors(t10).length > 0)
    throw new Ow(t10);
}
var Kae = di.exports;
const Jae = rk, ele = ik, x5 = g5, Q5 = gs, T5 = Oae, If = y5, { ono: Sn } = fi, vs = Kae, tle = w5;
function pi() {
  vs.apply(this, arguments);
}
Q5.inherits(pi, vs);
pi.parse = vs.parse;
pi.resolve = vs.resolve;
pi.bundle = vs.bundle;
pi.dereference = vs.dereference;
Object.defineProperty(pi.prototype, "api", {
  configurable: true,
  enumerable: true,
  get() {
    return this.schema;
  }
});
pi.prototype.parse = async function(t10, e3, r3, n3) {
  let i3 = x5(arguments);
  i3.options = new T5(i3.options);
  try {
    let o3 = await vs.prototype.parse.call(this, i3.path, i3.schema, i3.options);
    if (o3.swagger) {
      if (o3.swagger === void 0 || o3.info === void 0 || o3.paths === void 0)
        throw Sn.syntax(`${i3.path || i3.schema} is not a valid Swagger API definition`);
      if (typeof o3.swagger == "number")
        throw Sn.syntax('Swagger version number must be a string (e.g. "2.0") not a number.');
      if (typeof o3.info.version == "number")
        throw Sn.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
      if (o3.swagger !== "2.0")
        throw Sn.syntax(`Unrecognized Swagger version: ${o3.swagger}. Expected 2.0`);
    } else {
      let s3 = ["3.0.0", "3.0.1", "3.0.2", "3.0.3", "3.1.0"];
      if (o3.openapi === void 0 || o3.info === void 0)
        throw Sn.syntax(`${i3.path || i3.schema} is not a valid Openapi API definition`);
      if (o3.paths === void 0)
        if (o3.openapi === "3.1.0") {
          if (o3.webhooks === void 0)
            throw Sn.syntax(`${i3.path || i3.schema} is not a valid Openapi API definition`);
        } else
          throw Sn.syntax(`${i3.path || i3.schema} is not a valid Openapi API definition`);
      else {
        if (typeof o3.openapi == "number")
          throw Sn.syntax('Openapi version number must be a string (e.g. "3.0.0") not a number.');
        if (typeof o3.info.version == "number")
          throw Sn.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
        if (s3.indexOf(o3.openapi) === -1)
          throw Sn.syntax(
            `Unsupported OpenAPI version: ${o3.openapi}. Swagger Parser only supports versions ${s3.join(", ")}`
          );
      }
      Q5.fixOasRelativeServers(o3, i3.path);
    }
    return If(i3.callback, Promise.resolve(o3));
  } catch (o3) {
    return If(i3.callback, Promise.reject(o3));
  }
};
pi.validate = function(t10, e3, r3, n3) {
  let i3 = this, o3 = new i3();
  return o3.validate.apply(o3, arguments);
};
pi.prototype.validate = async function(t10, e3, r3, n3) {
  let i3 = this, o3 = x5(arguments);
  o3.options = new T5(o3.options);
  let s3 = o3.options.dereference.circular;
  o3.options.validate.schema && (o3.options.dereference.circular = "ignore");
  try {
    if (await this.dereference(o3.path, o3.schema, o3.options), o3.options.dereference.circular = s3, o3.options.validate.schema && (Jae(i3.api), i3.$refs.circular)) {
      if (s3 === true)
        tle(i3, o3.options);
      else if (s3 === false)
        throw Sn.reference("The API contains circular references");
    }
    return o3.options.validate.spec && ele(i3.api), If(o3.callback, Promise.resolve(i3.schema));
  } catch (a3) {
    return If(o3.callback, Promise.reject(a3));
  }
};
function cle(t10) {
  const e3 = ref(null);
  return onMounted(() => {
    e3.value = t10();
  }), e3;
}
ref("");
const k5 = /* @__PURE__ */ defineComponent({
  __name: "IntersectionObserver",
  props: {
    id: {},
    is: {}
  },
  emits: ["intersecting"],
  setup(t10, { emit: e3 }) {
    const r3 = t10, { setSidebarIdVisibility: n3 } = hs(), i3 = ref();
    return onMounted(() => {
      zE(
        i3,
        ([{ isIntersecting: o3 }]) => {
          if (r3.id && (n3(r3.id, o3), o3)) {
            e3("intersecting");
            const s3 = `${window.location.origin}${window.location.pathname}#${r3.id}`;
            window.history.replaceState({}, "", s3);
          }
        },
        {
          rootMargin: "0px 0px 50% 0px",
          threshold: 0.1
        }
      );
    }), (o3, s3) => (openBlock(), createBlock(resolveDynamicComponent(o3.is ?? "div"), {
      id: o3.id,
      ref_key: "intersectionObserverRef",
      ref: i3
    }, {
      default: withCtx(() => [
        renderSlot(o3.$slots, "default")
      ]),
      _: 3
    }, 8, ["id"]));
  }
}), dle = /* @__PURE__ */ defineComponent({
  __name: "Section",
  props: {
    id: {},
    label: {}
  },
  setup(t10) {
    const e3 = t10, { setBreadcrumb: r3 } = hs();
    function n3() {
      e3.label && r3(e3.label);
    }
    return (i3, o3) => (openBlock(), createBlock(k5, {
      is: "section",
      id: i3.id,
      class: "section",
      onIntersecting: n3
    }, {
      default: withCtx(() => [
        renderSlot(i3.$slots, "default", {}, void 0, true)
      ]),
      _: 3
    }, 8, ["id"]));
  }
});
const Bd = /* @__PURE__ */ Re(dle, [["__scopeId", "data-v-30f8611d"]]);
const hle = {}, ple = { class: "section-column" };
function Ole(t10, e3) {
  return openBlock(), createElementBlock("div", ple, [
    renderSlot(t10.$slots, "default", {}, void 0, true)
  ]);
}
const wa = /* @__PURE__ */ Re(hle, [["render", Ole], ["__scopeId", "data-v-7e657da0"]]);
const mle = {}, gle = { class: "section-columns" };
function yle(t10, e3) {
  return openBlock(), createElementBlock("div", gle, [
    renderSlot(t10.$slots, "default", {}, void 0, true)
  ]);
}
const x1 = /* @__PURE__ */ Re(mle, [["render", yle], ["__scopeId", "data-v-0bd51848"]]);
const vle = {}, ble = { class: "section-container" };
function Sle(t10, e3) {
  return openBlock(), createElementBlock("div", ble, [
    renderSlot(t10.$slots, "default", {}, void 0, true)
  ]);
}
const Q1 = /* @__PURE__ */ Re(vle, [["render", Sle], ["__scopeId", "data-v-a27b5d0a"]]), $le = /* @__PURE__ */ defineComponent({
  __name: "LoadingSkeleton",
  props: {
    lines: { default: 1 }
  },
  setup(t10) {
    return (e3, r3) => (openBlock(true), createElementBlock(Fragment, null, renderList([...Array(e3.lines).keys()], (n3) => (openBlock(), createElementBlock("div", {
      key: n3,
      class: normalizeClass(["loading", { "single-line": e3.lines === 1 }])
    }, null, 2))), 128));
  }
});
const E5 = /* @__PURE__ */ Re($le, [["__scopeId", "data-v-99d52311"]]), wle = { class: "section-content" }, Ple = /* @__PURE__ */ defineComponent({
  __name: "SectionContent",
  props: {
    loading: { type: Boolean, default: false }
  },
  setup(t10) {
    return (e3, r3) => (openBlock(), createElementBlock("div", wle, [
      e3.loading ? (openBlock(), createBlock(E5, {
        key: 1,
        lines: 8
      })) : renderSlot(e3.$slots, "default", { key: 0 }, void 0, true)
    ]));
  }
});
const zd = /* @__PURE__ */ Re(Ple, [["__scopeId", "data-v-bba63beb"]]), _le = /* @__PURE__ */ defineComponent({
  __name: "SectionHeader",
  props: {
    loading: { type: Boolean, default: false },
    tight: { type: Boolean, default: false },
    level: { default: 1 }
  },
  setup(t10) {
    return (e3, r3) => e3.loading ? (openBlock(), createBlock(E5, { key: 0 })) : (openBlock(), createBlock(resolveDynamicComponent(`h${e3.level}`), {
      key: 1,
      class: normalizeClass(["section-header", { tight: e3.tight }])
    }, {
      default: withCtx(() => [
        renderSlot(e3.$slots, "default", {}, void 0, true)
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
const Hd = /* @__PURE__ */ Re(_le, [["__scopeId", "data-v-566623fe"]]), { addToast: xle } = ZQ(), Gd = () => ({
  copyToClipboard: (e3) => {
    navigator.clipboard.writeText(e3).then(() => {
      xle({ title: "Copied to the clipboard" }, { timeout: 2e3 });
    });
  }
}), Qle = (t10) => (pushScopeId("data-v-41f5d83a"), t10 = t10(), popScopeId(), t10), Tle = { class: "label" }, kle = { class: "anchor" }, Ele = /* @__PURE__ */ Qle(() => /* @__PURE__ */ createElementVNode("span", null, "​", -1)), Cle = { class: "sr-only" }, Rle = /* @__PURE__ */ defineComponent({
  __name: "Anchor",
  props: {
    id: {}
  },
  setup(t10) {
    const { copyToClipboard: e3 } = Gd(), r3 = (n3) => {
      const i3 = new URL(window.location.href);
      return i3.hash = n3, i3.toString();
    };
    return (n3, i3) => (openBlock(), createElementBlock("span", Tle, [
      renderSlot(n3.$slots, "default", {}, void 0, true),
      createElementVNode("span", kle, [
        Ele,
        createElementVNode("button", {
          class: "anchor-copy",
          type: "button",
          onClick: i3[0] || (i3[0] = (o3) => unref(e3)(r3(n3.id)))
        }, [
          createTextVNode(" # "),
          createElementVNode("span", Cle, [
            createTextVNode('Copy link to "'),
            renderSlot(n3.$slots, "default", {}, void 0, true),
            createTextVNode('"')
          ])
        ])
      ])
    ]));
  }
});
const T1 = /* @__PURE__ */ Re(Rle, [["__scopeId", "data-v-41f5d83a"]]);
const Ale = {}, Xle = { class: "scalar-card" };
function qle(t10, e3) {
  return openBlock(), createElementBlock("div", Xle, [
    renderSlot(t10.$slots, "default", {}, void 0, true)
  ]);
}
const Da = /* @__PURE__ */ Re(Ale, [["render", qle], ["__scopeId", "data-v-dbd5ab78"]]), Dle = /* @__PURE__ */ defineComponent({
  __name: "CardContent",
  props: {
    muted: { type: Boolean, default: false },
    contrast: { type: Boolean, default: false },
    frameless: { type: Boolean, default: false },
    transparent: { type: Boolean, default: false },
    borderless: { type: Boolean, default: false }
  },
  setup(t10) {
    return (e3, r3) => (openBlock(), createElementBlock("div", {
      class: normalizeClass({
        "scalar-card-content": true,
        "scalar-card--muted": e3.muted,
        "scalar-card--contrast": e3.contrast,
        "scalar-card--frameless": e3.frameless,
        "scalar-card--transparent": e3.transparent,
        "scalar-card--borderless": e3.borderless
      })
    }, [
      renderSlot(e3.$slots, "default", {}, void 0, true)
    ], 2));
  }
});
const Fi = /* @__PURE__ */ Re(Dle, [["__scopeId", "data-v-4dc9c56e"]]), jle = { class: "scalar-card-header-slots" }, Ule = { class: "scalar-card-header-slot scalar-card-header-title" }, Ile = { class: "scalar-card-header-slot scalar-card-header-actions" }, Fle = /* @__PURE__ */ defineComponent({
  __name: "CardHeader",
  setup(t10) {
    return (e3, r3) => (openBlock(), createBlock(Fi, { class: "scalar-card-header" }, {
      default: withCtx(() => [
        createElementVNode("div", jle, [
          createElementVNode("div", Ule, [
            renderSlot(e3.$slots, "default", {}, void 0, true)
          ]),
          createElementVNode("div", Ile, [
            renderSlot(e3.$slots, "actions", {}, void 0, true)
          ])
        ])
      ]),
      _: 3
    }));
  }
});
const ja = /* @__PURE__ */ Re(Fle, [["__scopeId", "data-v-a8e4ead5"]]), Zle = /* @__PURE__ */ defineComponent({
  __name: "CardFooter",
  setup(t10) {
    return (e3, r3) => (openBlock(), createBlock(Fi, null, {
      default: withCtx(() => [
        renderSlot(e3.$slots, "default", {}, void 0, true)
      ]),
      _: 3
    }));
  }
});
const k1 = /* @__PURE__ */ Re(Zle, [["__scopeId", "data-v-5d002776"]]), Mle = /* @__PURE__ */ defineComponent({
  __name: "CardTabHeader",
  emits: ["change"],
  setup(t10, { emit: e3 }) {
    const r3 = (n3) => {
      e3("change", n3);
    };
    return (n3, i3) => (openBlock(), createBlock(ja, null, {
      actions: withCtx(() => [
        renderSlot(n3.$slots, "actions", {}, void 0, true)
      ]),
      default: withCtx(() => [
        createVNode(unref(Hw), { onChange: r3 }, {
          default: withCtx(() => [
            createVNode(unref(Gw), { class: "tab-list" }, {
              default: withCtx(() => [
                renderSlot(n3.$slots, "default", {}, void 0, true)
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
});
const Nle = /* @__PURE__ */ Re(Mle, [["__scopeId", "data-v-b81067df"]]), Wle = /* @__PURE__ */ defineComponent({
  __name: "CardTab",
  setup(t10) {
    return (e3, r3) => (openBlock(), createBlock(unref(qp), { as: "template" }, {
      default: withCtx(({ selected: n3 }) => [
        createElementVNode("button", {
          class: normalizeClass({ tab: true, "tab-selected": n3 }),
          type: "button"
        }, [
          createElementVNode("span", null, [
            renderSlot(e3.$slots, "default", {}, void 0, true)
          ])
        ], 2)
      ]),
      _: 3
    }));
  }
});
const Vle = /* @__PURE__ */ Re(Wle, [["__scopeId", "data-v-d044c876"]]), Yle = ["innerHTML"], Lle = /* @__PURE__ */ defineComponent({
  __name: "MarkdownRenderer",
  props: {
    value: {}
  },
  setup(t10) {
    const e3 = t10, r3 = ref("");
    return watch(
      () => e3.value,
      async () => {
        L$2(e3.value).then((n3) => {
          r3.value = String(n3);
        });
      },
      { immediate: true }
    ), (n3, i3) => (openBlock(), createElementBlock("div", {
      class: "markdown",
      innerHTML: r3.value
    }, null, 8, Yle));
  }
});
const fs = /* @__PURE__ */ Re(Lle, [["__scopeId", "data-v-26c60f56"]]), Ble = { class: "endpoints custom-scroll" }, zle = ["onClick"], Hle = /* @__PURE__ */ defineComponent({
  __name: "EndpointsOverview",
  props: {
    tag: {}
  },
  setup(t10) {
    const e3 = t10, { setCollapsedSidebarItem: r3 } = Zr();
    async function n3(i3) {
      r3(Tn(e3.tag), true), await nextTick(), Js(ss(i3, e3.tag));
    }
    return (i3, o3) => (openBlock(), createBlock(unref(Bd), {
      id: unref(Tn)(i3.tag),
      label: i3.tag.name.toUpperCase()
    }, {
      default: withCtx(() => [
        createVNode(unref(zd), null, {
          default: withCtx(() => [
            createVNode(unref(x1), null, {
              default: withCtx(() => [
                createVNode(unref(wa), null, {
                  default: withCtx(() => [
                    createVNode(unref(Hd), { level: 2 }, {
                      default: withCtx(() => [
                        createVNode(unref(T1), {
                          id: unref(Tn)(i3.tag)
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(i3.tag.name), 1)
                          ]),
                          _: 1
                        }, 8, ["id"])
                      ]),
                      _: 1
                    }),
                    createVNode(fs, {
                      value: i3.tag.description
                    }, null, 8, ["value"])
                  ]),
                  _: 1
                }),
                createVNode(unref(wa), null, {
                  default: withCtx(() => {
                    var s3;
                    return [
                      ((s3 = i3.tag.operations) == null ? void 0 : s3.length) > 0 ? (openBlock(), createBlock(unref(Da), { key: 0 }, {
                        default: withCtx(() => [
                          createVNode(unref(ja), { muted: "" }, {
                            default: withCtx(() => [
                              createTextVNode("Endpoints")
                            ]),
                            _: 1
                          }),
                          createVNode(unref(Fi), { muted: "" }, {
                            default: withCtx(() => [
                              createElementVNode("div", Ble, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(i3.tag.operations, (a3) => (openBlock(), createElementBlock("a", {
                                  key: unref(ss)(a3, i3.tag),
                                  class: "endpoint",
                                  onClick: (l3) => n3(a3)
                                }, [
                                  createElementVNode("span", {
                                    class: normalizeClass(a3.httpVerb)
                                  }, toDisplayString(a3.httpVerb), 3),
                                  createElementVNode("span", null, toDisplayString(a3.path), 1)
                                ], 8, zle))), 128))
                              ])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })) : createCommentVNode("", true)
                    ];
                  }),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["id", "label"]));
  }
});
const Gle = /* @__PURE__ */ Re(Hle, [["__scopeId", "data-v-46127622"]]), Kd = (t10) => (pushScopeId("data-v-931785ef"), t10 = t10(), popScopeId(), t10), Kle = {
  key: 0,
  class: "security-scheme"
}, Jle = { key: 0 }, eue = { key: 1 }, tue = { class: "input" }, rue = ["for"], nue = ["id", "value"], iue = { key: 2 }, oue = { key: 0 }, sue = { class: "input" }, aue = /* @__PURE__ */ Kd(() => /* @__PURE__ */ createElementVNode("label", { for: "http.basic.username" }, "Username", -1)), lue = ["value"], uue = { class: "input" }, cue = /* @__PURE__ */ Kd(() => /* @__PURE__ */ createElementVNode("label", { for: "http.basic.password" }, "Password", -1)), fue = ["value"], due = { key: 1 }, hue = { class: "input" }, pue = /* @__PURE__ */ Kd(() => /* @__PURE__ */ createElementVNode("label", { for: "http.bearer.token" }, "Token", -1)), Oue = ["value"], mue = {
  key: 3,
  class: "work-in-progress"
}, gue = /* @__PURE__ */ Kd(() => /* @__PURE__ */ createElementVNode("h3", { class: "work-in-progress-title" }, "Work in Progress", -1)), yue = /* @__PURE__ */ defineComponent({
  __name: "SecurityScheme",
  props: {
    value: {}
  },
  setup(t10) {
    const { authentication: e3, setAuthentication: r3 } = Ui(), n3 = (a3) => {
      r3({
        apiKey: {
          ...e3.apiKey,
          token: a3.target.value
        }
      });
    }, i3 = (a3) => {
      r3({
        http: {
          ...e3.http,
          basic: {
            ...e3.http.basic,
            username: a3.target.value
          }
        }
      });
    }, o3 = (a3) => {
      r3({
        http: {
          ...e3.http,
          basic: {
            ...e3.http.basic,
            password: a3.target.value
          }
        }
      });
    }, s3 = (a3) => {
      r3({
        http: {
          ...e3.http,
          bearer: {
            ...e3.http.bearer,
            token: a3.target.value
          }
        }
      });
    };
    return (a3, l3) => a3.value ? (openBlock(), createElementBlock("div", Kle, [
      createElementVNode("form", null, [
        a3.value.type ? a3.value.type === "apiKey" ? (openBlock(), createElementBlock("div", eue, [
          createElementVNode("div", tue, [
            createElementVNode("label", {
              for: `security-scheme-${a3.value.name}`
            }, toDisplayString(a3.value.in.charAt(0).toUpperCase() + a3.value.in.slice(1)) + " API Key ", 9, rue),
            createElementVNode("input", {
              id: `security-scheme-${a3.value.name}`,
              autocomplete: "off",
              placeholder: "Token",
              spellcheck: "false",
              type: "text",
              value: unref(e3).apiKey.token,
              onInput: n3
            }, null, 40, nue)
          ])
        ])) : a3.value.type === "http" || a3.value.type === "basic" ? (openBlock(), createElementBlock("div", iue, [
          a3.value.type === "basic" || a3.value.scheme === "basic" ? (openBlock(), createElementBlock("div", oue, [
            createElementVNode("div", sue, [
              aue,
              createElementVNode("input", {
                id: "http.basic.username",
                autocomplete: "off",
                placeholder: "Username",
                spellcheck: "false",
                type: "text",
                value: unref(e3).http.basic.username,
                onInput: i3
              }, null, 40, lue)
            ]),
            createElementVNode("div", uue, [
              cue,
              createElementVNode("input", {
                id: "http.basic.password",
                autocomplete: "off",
                placeholder: "Password",
                spellcheck: "false",
                type: "password",
                value: unref(e3).http.basic.password,
                onInput: o3
              }, null, 40, fue)
            ])
          ])) : a3.value.scheme === "bearer" ? (openBlock(), createElementBlock("div", due, [
            createElementVNode("div", hue, [
              pue,
              createElementVNode("input", {
                id: "http.bearer.token",
                autocomplete: "off",
                placeholder: "Token",
                spellcheck: "false",
                type: "text",
                value: unref(e3).http.bearer.token,
                onInput: s3
              }, null, 40, Oue)
            ])
          ])) : createCommentVNode("", true)
        ])) : (openBlock(), createElementBlock("div", mue, [
          gue,
          createElementVNode("p", null, "The given security scheme (" + toDisplayString(a3.value.type) + ") is not supported.", 1)
        ])) : (openBlock(), createElementBlock("div", Jle))
      ])
    ])) : createCommentVNode("", true);
  }
});
const vue = /* @__PURE__ */ Re(yue, [["__scopeId", "data-v-931785ef"]]), bue = {
  key: 1,
  class: "security-scheme-selector"
}, Sue = ["value"], $ue = /* @__PURE__ */ defineComponent({
  __name: "SecuritySchemeSelector",
  props: {
    value: {}
  },
  emits: ["input"],
  setup(t10, { emit: e3 }) {
    const r3 = t10, { authentication: n3, setAuthentication: i3 } = Ui(), o3 = (h10) => {
      s3(h10.target.value);
    };
    onMounted(() => {
      s3(Object.keys(r3.value)[0] ?? null);
    });
    const s3 = (h10) => {
      i3({
        securitySchemeKey: h10
      }), e3("input", h10);
    }, a3 = (h10) => !(h10 != null && h10.type), l3 = (h10) => h10.type.toLowerCase() === "apikey", u3 = (h10) => h10.type === "http" && h10.scheme.toLowerCase() === "basic" || h10.type.toLowerCase() === "basic", c3 = (h10) => h10.type === "http" && h10.scheme.toLowerCase() === "bearer", f3 = (h10) => h10.type.toLowerCase() === "oauth2", d3 = (h10) => a3(h10) ? "No Authentication" : l3(h10) ? "API Key" : u3(h10) ? "Basic Authentication" : c3(h10) ? "Bearer Authentication" : f3(h10) ? "OAuth 2.0" : `${h10.type} (not yet supported)`, p10 = computed(() => Object.keys(r3.value));
    return (h10, m10) => p10.value.length === 1 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createTextVNode(toDisplayString(d3(h10.value[p10.value[0]])), 1)
    ], 64)) : p10.value.length > 1 ? (openBlock(), createElementBlock("div", bue, [
      createElementVNode("span", null, toDisplayString(unref(n3).securitySchemeKey ? d3(h10.value[unref(n3).securitySchemeKey]) : ""), 1),
      createVNode(unref(So), { icon: "ChevronDown" }),
      createElementVNode("select", {
        onInput: o3,
        onValue: m10[0] || (m10[0] = //@ts-ignore
        (...O10) => unref(n3).securitySchemeKey && unref(n3).securitySchemeKey(...O10))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(p10.value, (O10) => (openBlock(), createElementBlock("option", {
          key: O10,
          value: O10 ?? null
        }, toDisplayString(d3(h10.value[O10])), 9, Sue))), 128))
      ], 32)
    ])) : createCommentVNode("", true);
  }
});
const wue = /* @__PURE__ */ Re($ue, [["__scopeId", "data-v-6dd8f6a0"]]), Pue = { class: "selector" }, _ue = /* @__PURE__ */ defineComponent({
  __name: "Authentication",
  props: {
    parsedSpec: {}
  },
  setup(t10) {
    const e3 = t10, { authentication: r3, setAuthentication: n3 } = Ui(), i3 = computed(() => {
      var s3, a3, l3;
      if (!r3.securitySchemeKey)
        return false;
      const o3 = (l3 = (a3 = (s3 = e3.parsedSpec) == null ? void 0 : s3.components) == null ? void 0 : a3.securitySchemes) == null ? void 0 : l3[r3.securitySchemeKey];
      return !!(o3 != null && o3.type);
    });
    return watch(
      () => {
        var o3, s3;
        return (s3 = (o3 = e3.parsedSpec) == null ? void 0 : o3.components) == null ? void 0 : s3.securitySchemes;
      },
      () => {
        var o3, s3;
        n3({
          // @ts-ignore
          securitySchemes: (s3 = (o3 = e3.parsedSpec) == null ? void 0 : o3.components) == null ? void 0 : s3.securitySchemes
        });
      },
      { deep: true, immediate: true }
    ), (o3, s3) => unref(TF)(o3.parsedSpec) ? (openBlock(), createBlock(unref(Da), { key: 0 }, {
      default: withCtx(() => [
        createVNode(unref(ja), { transparent: "" }, {
          actions: withCtx(() => {
            var a3, l3;
            return [
              createElementVNode("div", Pue, [
                createVNode(wue, {
                  value: (l3 = (a3 = o3.parsedSpec) == null ? void 0 : a3.components) == null ? void 0 : l3.securitySchemes
                }, null, 8, ["value"])
              ])
            ];
          }),
          default: withCtx(() => [
            createTextVNode(" Authentication ")
          ]),
          _: 1
        }),
        i3.value ? (openBlock(), createBlock(unref(Fi), {
          key: 0,
          transparent: ""
        }, {
          default: withCtx(() => {
            var a3, l3, u3;
            return [
              unref(r3).securitySchemeKey ? (openBlock(), createBlock(vue, {
                key: 0,
                value: (u3 = (l3 = (a3 = o3.parsedSpec) == null ? void 0 : a3.components) == null ? void 0 : l3.securitySchemes) == null ? void 0 : u3[unref(r3).securitySchemeKey]
              }, null, 8, ["value"])) : createCommentVNode("", true)
            ];
          }),
          _: 1
        })) : createCommentVNode("", true)
      ]),
      _: 1
    })) : createCommentVNode("", true);
  }
});
const xue = /* @__PURE__ */ Re(_ue, [["__scopeId", "data-v-102a910e"]]), C5 = (t10) => (pushScopeId("data-v-07617be9"), t10 = t10(), popScopeId(), t10), Que = { class: "client-libraries-content" }, Tue = ["onClick"], kue = ["value"], Eue = ["label"], Cue = ["value"], Rue = { class: "code-languages-background code-languages-icon__more" }, Aue = {
  key: 1,
  class: "code-languages-icon",
  height: "50",
  viewBox: "0 0 50 50",
  width: "50",
  xmlns: "http://www.w3.org/2000/svg"
}, Xue = /* @__PURE__ */ C5(() => /* @__PURE__ */ createElementVNode("g", {
  fill: "currentColor",
  "fill-rule": "nonzero"
}, [
  /* @__PURE__ */ createElementVNode("path", { d: "M10.71 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0M21.13 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0M31.55 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0" })
], -1)), que = [
  Xue
], Due = /* @__PURE__ */ C5(() => /* @__PURE__ */ createElementVNode("span", null, "More", -1)), jue = /* @__PURE__ */ defineComponent({
  __name: "ClientSelector",
  setup(t10) {
    const { state: e3, setItem: r3, getClientTitle: n3, getTargetTitle: i3 } = Zr(), o3 = (f3) => {
      r3("selectedClient", f3), !a3.value.filter((p10) => u3(p10)).length && (a3.value = [
        ...a3.value.slice(1),
        e3.selectedClient
      ]);
    }, s3 = au("(max-width: 1000px)"), a3 = ref(
      s3.value ? (
        // Mobile
        [
          {
            targetKey: "shell",
            clientKey: "curl"
          },
          {
            targetKey: "ruby",
            clientKey: "native"
          },
          {
            targetKey: "node",
            clientKey: "fetch"
          },
          {
            targetKey: "python",
            clientKey: "python3"
          }
        ]
      ) : (
        // Desktop
        [
          {
            targetKey: "shell",
            clientKey: "curl"
          },
          {
            targetKey: "ruby",
            clientKey: "native"
          },
          {
            targetKey: "node",
            clientKey: "fetch"
          },
          {
            targetKey: "php",
            clientKey: "guzzle"
          },
          {
            targetKey: "python",
            clientKey: "python3"
          },
          {
            targetKey: "c",
            clientKey: "libcurl"
          }
        ]
      )
    ), l3 = (f3) => `brand/programming-language-${{
      javascript: "javascript-js"
    }[f3] ?? f3}`, u3 = (f3) => f3.targetKey === e3.selectedClient.targetKey && f3.clientKey === e3.selectedClient.clientKey;
    function c3(f3) {
      return a3.value.some((d3) => d3.targetKey === f3.targetKey && d3.clientKey === f3.clientKey);
    }
    return (f3, d3) => (openBlock(), createElementBlock("div", Que, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(a3.value, (p10) => (openBlock(), createElementBlock("div", {
        key: p10.clientKey,
        class: normalizeClass(["code-languages rendered-code-sdks", {
          "code-languages__active": u3(p10)
        }]),
        onClick: () => o3(p10)
      }, [
        createElementVNode("div", {
          class: normalizeClass(["code-languages-background", `code-languages-icon__${p10.targetKey}`])
        }, [
          createVNode(unref(as), {
            class: "code-languages-icon",
            src: l3(p10.targetKey)
          }, null, 8, ["src"])
        ], 2),
        createElementVNode("span", null, toDisplayString(unref(i3)(p10)), 1)
      ], 10, Tue))), 128)),
      createElementVNode("div", {
        class: normalizeClass(["code-languages code-languages__select", {
          "code-languages__active": unref(e3).selectedClient && !c3(unref(e3).selectedClient)
        }])
      }, [
        createElementVNode("select", {
          class: "language-select",
          value: JSON.stringify(unref(e3).selectedClient),
          onInput: d3[0] || (d3[0] = (p10) => unref(r3)(
            "selectedClient",
            JSON.parse(p10.target.value)
          ))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(yd)(), (p10) => (openBlock(), createElementBlock("optgroup", {
            key: p10.key,
            label: p10.title
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(p10.clients, (h10) => (openBlock(), createElementBlock("option", {
              key: h10.key,
              value: JSON.stringify({
                targetKey: p10.key,
                clientKey: h10.key
              })
            }, toDisplayString(unref(n3)({
              targetKey: p10.key,
              clientKey: h10.key
            })), 9, Cue))), 128))
          ], 8, Eue))), 128))
        ], 40, kue),
        createElementVNode("div", Rue, [
          unref(e3).selectedClient && !c3(unref(e3).selectedClient) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["code-languages-background", `code-languages-icon__${unref(e3).selectedClient.targetKey}`])
          }, [
            createVNode(unref(as), {
              class: "code-languages-icon",
              src: l3(unref(e3).selectedClient.targetKey)
            }, null, 8, ["src"])
          ], 2)) : (openBlock(), createElementBlock("svg", Aue, que))
        ]),
        Due
      ], 2)
    ]));
  }
});
const Uue = /* @__PURE__ */ Re(jue, [["__scopeId", "data-v-07617be9"]]), Iue = /* @__PURE__ */ defineComponent({
  __name: "Description",
  props: {
    value: {}
  },
  setup(t10) {
    const e3 = t10, r3 = LE(
      async () => {
        if (!e3.value)
          return [];
        const n3 = await HO(e3.value), i3 = Zx(n3);
        return await Promise.all(
          EF(e3.value, i3).map(
            async (o3) => ({
              heading: (await HO(o3))[0],
              content: o3
            })
          )
        );
      },
      []
      // initial state
    );
    return (n3, i3) => n3.value ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(r3), (o3, s3) => (openBlock(), createElementBlock("div", { key: s3 }, [
      o3.heading ? (openBlock(), createBlock(k5, {
        key: 0,
        id: unref(Fx)(o3.heading)
      }, {
        default: withCtx(() => [
          createVNode(fs, {
            value: o3.content
          }, null, 8, ["value"])
        ]),
        _: 2
      }, 1032, ["id"])) : (openBlock(), createBlock(fs, {
        key: 1,
        value: o3.content
      }, null, 8, ["value"]))
    ]))), 128)) : createCommentVNode("", true);
  }
}), Fue = {
  key: 0,
  class: "download"
}, Zue = { class: "download-cta" }, Mue = ["download", "href"], Nue = /* @__PURE__ */ defineComponent({
  __name: "DownloadSpec",
  props: {
    value: {}
  },
  setup(t10) {
    function e3(i3) {
      const o3 = tS(i3) ? new Blob([i3], {
        type: "application/json"
      }) : new Blob([i3], {
        type: "application/x-yaml"
      });
      return URL.createObjectURL(o3);
    }
    function r3(i3) {
      return tS(i3) ? "spec.json" : "spec.yaml";
    }
    function n3(i3) {
      return `${window.location.origin}/${r3(i3)}`;
    }
    return (i3, o3) => i3.value ? (openBlock(), createElementBlock("div", Fue, [
      createElementVNode("div", Zue, [
        createElementVNode("a", {
          download: r3(i3.value),
          href: e3(i3.value)
        }, toDisplayString(n3(i3.value)), 9, Mue)
      ])
    ])) : createCommentVNode("", true);
  }
});
const Wue = /* @__PURE__ */ Re(Nue, [["__scopeId", "data-v-fa6b3604"]]), Vue = ["title", "innerHTML"], Yue = /* @__PURE__ */ defineComponent({
  __name: "ServerItem",
  props: {
    value: {},
    variables: {}
  },
  setup(t10) {
    const e3 = t10, { copyToClipboard: r3 } = Gd(), n3 = computed(() => {
      var s3;
      const o3 = (((s3 = e3.value) == null ? void 0 : s3.url) ?? "").replace(/(<([^>]+)>)/gi, "");
      return Nx(o3, (a3) => {
        var u3;
        const l3 = (u3 = e3.variables) == null ? void 0 : u3.find(
          (c3) => c3.name === a3
        );
        return `<span class="base-url-variable">${((l3 == null ? void 0 : l3.value) ?? "") !== "" ? l3 == null ? void 0 : l3.value : `{${a3}}`}</span>`;
      });
    });
    return (i3, o3) => i3.value ? (openBlock(), createElementBlock("a", {
      key: 0,
      class: "base-url",
      title: i3.value.description,
      onClick: o3[0] || (o3[0] = (s3) => unref(r3)(i3.value.url)),
      innerHTML: n3.value
    }, null, 8, Vue)) : createCommentVNode("", true);
  }
});
const Lue = /* @__PURE__ */ Re(Yue, [["__scopeId", "data-v-5ca0a51c"]]), Bue = { key: 0 }, zue = ["for"], Hue = ["id", "value", "onInput"], Gue = ["value"], Kue = { class: "input-value" }, Jue = ["id", "value", "onInput"], ece = /* @__PURE__ */ defineComponent({
  __name: "ServerVariables",
  props: {
    value: {}
  },
  setup(t10) {
    const { server: e3, setServer: r3 } = Ui(), n3 = (o3, s3) => {
      const a3 = s3.target.value, l3 = [...e3.variables], u3 = l3.findIndex((c3) => c3.name === o3);
      l3[u3].value = a3, r3({
        variables: l3
      });
    }, i3 = (o3) => {
      const s3 = e3.variables.findIndex((a3) => a3.name === o3);
      return e3.variables[s3].value ?? "";
    };
    return (o3, s3) => o3.value ? (openBlock(), createElementBlock("div", Bue, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(o3.value, (a3) => (openBlock(), createElementBlock("div", {
        key: a3.name,
        class: "input"
      }, [
        createElementVNode("label", {
          for: `variable-${a3.name}`
        }, [
          createElementVNode("code", null, toDisplayString(a3.name), 1)
        ], 8, zue),
        a3.enum ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createElementVNode("select", {
            id: `variable-${a3.name}`,
            value: i3(a3.name),
            onInput: (l3) => n3(a3.name, l3)
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(a3.enum, (l3) => (openBlock(), createElementBlock("option", {
              key: l3,
              value: l3
            }, toDisplayString(l3), 9, Gue))), 128))
          ], 40, Hue),
          createElementVNode("div", Kue, toDisplayString(a3.default), 1)
        ], 64)) : (openBlock(), createElementBlock("input", {
          key: 1,
          id: `variable-${a3.name}`,
          autocomplete: "off",
          placeholder: "value",
          spellcheck: "false",
          type: "text",
          value: i3(a3.name),
          onInput: (l3) => n3(a3.name, l3)
        }, null, 40, Jue))
      ]))), 128))
    ])) : createCommentVNode("", true);
  }
});
const tce = /* @__PURE__ */ Re(ece, [["__scopeId", "data-v-a157de95"]]), rce = { class: "scalar-card-serverlist-container" }, nce = { class: "server-item" }, ice = { class: "server-selector" }, oce = ["value"], sce = ["value"], ace = { class: "description" }, lce = /* @__PURE__ */ defineComponent({
  __name: "ServerList",
  props: {
    value: {}
  },
  setup(t10) {
    const e3 = t10, { server: r3, setServer: n3 } = Ui(), i3 = ref(0);
    return watch(
      i3,
      () => {
        var l3, u3, c3;
        const o3 = ((l3 = e3.value[i3.value]) == null ? void 0 : l3.variables) ?? {}, s3 = o3 ? Object.keys(o3).map((f3) => {
          var d3;
          return {
            name: f3,
            value: ((d3 = o3[f3].default) == null ? void 0 : d3.toString()) ?? ""
          };
        }) : [];
        Vq(
          (u3 = e3.value[i3.value]) == null ? void 0 : u3.url
        ).filter((f3) => !o3[f3]).forEach((f3) => {
          s3.push({
            name: f3,
            value: ""
          });
        }), n3({
          selectedServer: i3.value,
          description: (c3 = e3.value[i3.value]) == null ? void 0 : c3.description,
          servers: e3.value,
          variables: s3
        });
      },
      {
        immediate: true
      }
    ), watch(
      () => e3.value,
      () => {
        n3({
          servers: e3.value
        });
      }
    ), (o3, s3) => o3.value.length > 0 ? (openBlock(), createBlock(unref(Da), { key: 0 }, {
      default: withCtx(() => [
        createVNode(unref(ja), { muted: "" }, {
          default: withCtx(() => [
            createTextVNode("Base URL")
          ]),
          _: 1
        }),
        createVNode(unref(Fi), { class: "scalar-card-serverlist" }, {
          default: withCtx(() => [
            createElementVNode("div", rce, [
              createElementVNode("div", nce, [
                createElementVNode("div", ice, [
                  o3.value.length > 1 ? (openBlock(), createElementBlock("select", {
                    key: 0,
                    value: i3.value,
                    onInput: s3[0] || (s3[0] = (a3) => i3.value = parseInt(
                      a3.target.value,
                      10
                    ))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(o3.value, (a3, l3) => (openBlock(), createElementBlock("option", {
                      key: l3,
                      value: l3
                    }, toDisplayString(a3.url), 9, sce))), 128))
                  ], 40, oce)) : createCommentVNode("", true),
                  createVNode(Lue, {
                    value: o3.value[i3.value],
                    variables: unref(r3).variables
                  }, null, 8, ["value", "variables"]),
                  o3.value.length > 1 ? (openBlock(), createBlock(unref(So), {
                    key: 1,
                    icon: "ChevronDown"
                  })) : createCommentVNode("", true)
                ])
              ]),
              createVNode(tce, {
                value: unref(r3).variables
              }, null, 8, ["value"])
            ])
          ]),
          _: 1
        }),
        unref(r3).description ? (openBlock(), createBlock(unref(Fi), {
          key: 0,
          muted: ""
        }, {
          default: withCtx(() => [
            createElementVNode("div", ace, [
              createVNode(fs, {
                value: unref(r3).description
              }, null, 8, ["value"])
            ])
          ]),
          _: 1
        })) : createCommentVNode("", true)
      ]),
      _: 1
    })) : createCommentVNode("", true);
  }
});
const uce = /* @__PURE__ */ Re(lce, [["__scopeId", "data-v-7734c88f"]]), cce = {
  key: 0,
  class: "section-version"
}, fce = {
  key: 1,
  class: "section-oas"
}, dce = { class: "sticky-cards flex-col gap-1" }, hce = /* @__PURE__ */ defineComponent({
  __name: "Introduction",
  props: {
    info: {},
    servers: {},
    parsedSpec: {},
    rawSpec: {}
  },
  setup(t10) {
    const e3 = t10, { state: r3, getClientTitle: n3, getTargetTitle: i3 } = Zr(), o3 = computed(() => e3.parsedSpec.openapi ?? e3.parsedSpec.swagger ?? "");
    return (s3, a3) => (openBlock(), createBlock(unref(Q1), null, {
      default: withCtx(() => [
        createVNode(unref(Bd), null, {
          default: withCtx(() => [
            createVNode(unref(zd), {
              loading: !s3.info.description && !s3.info.title
            }, {
              default: withCtx(() => [
                createVNode(unref(x1), null, {
                  default: withCtx(() => [
                    createVNode(unref(wa), null, {
                      default: withCtx(() => [
                        s3.info.version ? (openBlock(), createElementBlock("span", cce, toDisplayString(s3.info.version), 1)) : createCommentVNode("", true),
                        o3.value ? (openBlock(), createElementBlock("span", fce, " OAS " + toDisplayString(o3.value), 1)) : createCommentVNode("", true),
                        createVNode(unref(Hd), {
                          level: 1,
                          loading: !s3.info.title,
                          tight: ""
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(s3.info.title), 1)
                          ]),
                          _: 1
                        }, 8, ["loading"]),
                        createVNode(Wue, { value: s3.rawSpec }, null, 8, ["value"]),
                        createVNode(Iue, {
                          value: s3.info.description
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    createVNode(unref(wa), null, {
                      default: withCtx(() => [
                        createElementVNode("div", dce, [
                          createVNode(uce, { value: s3.servers }, null, 8, ["value"]),
                          createVNode(unref(Da), null, {
                            default: withCtx(() => [
                              createVNode(unref(ja), { transparent: "" }, {
                                default: withCtx(() => [
                                  createTextVNode("Client Libraries")
                                ]),
                                _: 1
                              }),
                              createVNode(unref(Fi), {
                                frameless: "",
                                transparent: ""
                              }, {
                                default: withCtx(() => [
                                  createVNode(Uue)
                                ]),
                                _: 1
                              }),
                              createVNode(unref(k1), {
                                class: "font-mono card-footer",
                                muted: ""
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(unref(i3)(unref(r3).selectedClient)) + " " + toDisplayString(unref(n3)(unref(r3).selectedClient)), 1)
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }),
                          createVNode(unref(xue), { parsedSpec: s3.parsedSpec }, null, 8, ["parsedSpec"])
                        ])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["loading"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
});
const pce = /* @__PURE__ */ Re(hce, [["__scopeId", "data-v-37c3f0ff"]]), Oce = { class: "property" }, mce = { class: "property-information" }, gce = {
  key: 0,
  class: "property-name"
}, yce = {
  key: 1,
  class: "required"
}, vce = {
  key: 2,
  class: "property-type"
}, bce = {
  key: 3,
  class: "property-example"
}, Sce = { class: "property-example-value" }, $ce = {
  key: 0,
  class: "property-rule"
}, wce = {
  key: 4,
  class: "property-read-only"
}, Pce = {
  key: 5,
  class: "property-nullable"
}, _ce = {
  key: 0,
  class: "property-description"
}, xce = {
  key: 1,
  class: "property-description"
}, Qce = {
  key: 2,
  class: "property-enum"
}, Tce = { class: "property-enum-values" }, kce = {
  key: 3,
  class: "children"
}, Ece = {
  key: 1,
  class: "too-deep"
}, Cce = {
  key: 0,
  class: "children"
}, Rce = {
  key: 1,
  class: "too-deep"
}, Ace = {
  key: 0,
  class: "rule"
}, Xce = /* @__PURE__ */ defineComponent({
  __name: "SchemaProperty",
  props: {
    value: {},
    level: { default: 0 },
    name: {},
    required: { type: Boolean, default: false }
  },
  setup(t10) {
    const e3 = {
      number: {
        _default: "Any numbers.",
        float: "Floating-point numbers.",
        double: "Floating-point numbers with double precision."
      },
      integer: {
        _default: "Integer numbers.",
        int32: "Signed 32-bit integers (commonly used integer type).",
        int64: "Signed 64-bit integers (long type)."
      },
      string: {
        date: "full-date notation as defined by RFC 3339, section 5.6, for example, 2017-07-21",
        "date-time": "the date-time notation as defined by RFC 3339, section 5.6, for example, 2017-07-21T17:32:28Z",
        password: "a hint to UIs to mask the input",
        byte: "base64-encoded characters, for example, U3dhZ2dlciByb2Nrcw==",
        binary: "binary data, used to describe files"
      }
    }, r3 = function(i3) {
      return !i3 || !e3[i3.type] ? null : e3[i3.type][i3.format || "_default"];
    }, n3 = ["oneOf", "anyOf", "allOf", "not"];
    return (i3, o3) => {
      var s3, a3, l3, u3, c3, f3, d3, p10, h10;
      return openBlock(), createElementBlock("div", Oce, [
        createElementVNode("div", mce, [
          i3.name ? (openBlock(), createElementBlock("div", gce, toDisplayString(i3.name), 1)) : createCommentVNode("", true),
          i3.required ? (openBlock(), createElementBlock("div", yce, " required ")) : createCommentVNode("", true),
          (s3 = i3.value) != null && s3.type ? (openBlock(), createElementBlock("div", vce, [
            i3.value.type !== "object" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              (a3 = i3.value) != null && a3.items && !["object"].includes(i3.value.items.type) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString(i3.value.type) + " " + toDisplayString(i3.value.items.type) + "[] ", 1)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(i3.value.type), 1)
              ], 64)),
              i3.value.minItems || i3.value.maxItems ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                createTextVNode(toDisplayString(i3.value.minItems) + ".." + toDisplayString(i3.value.maxItems), 1)
              ], 64)) : createCommentVNode("", true),
              i3.value.uniqueItems ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
                createTextVNode(" unique! ")
              ], 64)) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true),
            i3.value.format ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(" · " + toDisplayString(i3.value.format), 1)
            ], 64)) : createCommentVNode("", true),
            i3.value.enum ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              createTextVNode(" · enum ")
            ], 64)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          ((l3 = i3.value) == null ? void 0 : l3.example) !== void 0 ? (openBlock(), createElementBlock("div", bce, [
            createElementVNode("code", Sce, " example: " + toDisplayString(i3.value.example), 1)
          ])) : createCommentVNode("", true),
          (openBlock(), createElementBlock(Fragment, null, renderList(n3, (m10) => {
            var O10;
            return openBlock(), createElementBlock(Fragment, { key: m10 }, [
              (O10 = i3.value) != null && O10[m10] ? (openBlock(), createElementBlock("div", $ce, toDisplayString(m10), 1)) : createCommentVNode("", true)
            ], 64);
          }), 64)),
          (u3 = i3.value) != null && u3.readOnly ? (openBlock(), createElementBlock("div", wce, " read-only ")) : createCommentVNode("", true),
          (c3 = i3.value) != null && c3.readOnly ? (openBlock(), createElementBlock("div", Pce, " nullable ")) : createCommentVNode("", true)
        ]),
        (f3 = i3.value) != null && f3.description ? (openBlock(), createElementBlock("div", _ce, toDisplayString(i3.value.description), 1)) : r3(i3.value) ? (openBlock(), createElementBlock("div", xce, toDisplayString(r3(i3.value)), 1)) : createCommentVNode("", true),
        (d3 = i3.value) != null && d3.enum ? (openBlock(), createElementBlock("div", Qce, [
          createElementVNode("ul", Tce, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(i3.value.enum, (m10) => (openBlock(), createElementBlock("li", {
              key: m10,
              class: "property-enum-value"
            }, toDisplayString(m10), 1))), 128))
          ])
        ])) : createCommentVNode("", true),
        (p10 = i3.value) != null && p10.properties ? (openBlock(), createElementBlock("div", kce, [
          i3.level < 3 ? (openBlock(), createBlock(Nc, {
            key: 0,
            level: i3.level + 1,
            value: i3.value
          }, null, 8, ["level", "value"])) : (openBlock(), createElementBlock("div", Ece, " … "))
        ])) : createCommentVNode("", true),
        (h10 = i3.value) != null && h10.items ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
          ["object"].includes(i3.value.items.type) ? (openBlock(), createElementBlock("div", Cce, [
            i3.level < 3 ? (openBlock(), createBlock(Nc, {
              key: 0,
              level: i3.level + 1,
              value: i3.value.items
            }, null, 8, ["level", "value"])) : (openBlock(), createElementBlock("div", Rce, " … "))
          ])) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true),
        (openBlock(), createElementBlock(Fragment, null, renderList(n3, (m10) => {
          var O10;
          return openBlock(), createElementBlock(Fragment, { key: m10 }, [
            (O10 = i3.value) != null && O10[m10] ? (openBlock(), createElementBlock("div", Ace, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(i3.value[m10], (g, v10) => (openBlock(), createBlock(Nc, {
                key: v10,
                level: i3.level + 1,
                value: g
              }, null, 8, ["level", "value"]))), 128))
            ])) : createCommentVNode("", true)
          ], 64);
        }), 64))
      ]);
    };
  }
});
const gw = /* @__PURE__ */ Re(Xce, [["__scopeId", "data-v-ce036666"]]), qce = { class: "schema" }, Dce = {
  key: 0,
  class: "properties"
}, jce = { class: "type" }, Uce = ["title"], Ice = {
  key: 1,
  class: "properties"
}, Fce = /* @__PURE__ */ defineComponent({
  __name: "Schema",
  props: {
    value: {},
    level: { default: 0 },
    name: {}
  },
  setup(t10) {
    return (e3, r3) => {
      var n3, i3, o3, s3, a3, l3, u3;
      return openBlock(), createElementBlock("div", qce, [
        (n3 = e3.value) != null && n3.properties ? (openBlock(), createElementBlock("div", Dce, [
          createElementVNode("div", jce, [
            createElementVNode("span", {
              class: "type-icon",
              title: e3.value.type
            }, [
              e3.value.type === "object" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(" {} ")
              ], 64)) : createCommentVNode("", true),
              e3.value.type === "array" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(" [] ")
              ], 64)) : createCommentVNode("", true)
            ], 8, Uce),
            (o3 = (i3 = e3.value) == null ? void 0 : i3.xml) != null && o3.name && ((a3 = (s3 = e3.value) == null ? void 0 : s3.xml) == null ? void 0 : a3.name) !== "##default" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(" <" + toDisplayString((u3 = (l3 = e3.value) == null ? void 0 : l3.xml) == null ? void 0 : u3.name) + " /> ", 1)
            ], 64)) : e3.name ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(e3.name), 1)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              createTextVNode(toDisplayString(e3.value.type), 1)
            ], 64))
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(Object.keys(e3.value.properties), (c3) => (openBlock(), createBlock(gw, {
            key: c3,
            level: e3.level,
            name: c3,
            required: e3.value.required && e3.value.required.length && e3.value.required.includes(c3),
            value: e3.value.properties[c3]
          }, null, 8, ["level", "name", "required", "value"]))), 128))
        ])) : (openBlock(), createElementBlock("div", Ice, [
          createVNode(gw, {
            level: e3.level,
            value: e3.value
          }, null, 8, ["level", "value"])
        ]))
      ]);
    };
  }
});
const Nc = /* @__PURE__ */ Re(Fce, [["__scopeId", "data-v-495e1c81"]]), Zce = /* @__PURE__ */ defineComponent({
  __name: "ShowMoreButton",
  props: {
    id: {}
  },
  setup(t10) {
    const { setCollapsedSidebarItem: e3 } = Zr();
    return (r3, n3) => (openBlock(), createElementBlock("button", {
      class: "show-more",
      type: "button",
      onClick: n3[0] || (n3[0] = (i3) => unref(e3)(r3.id, true))
    }, [
      createTextVNode(" Show More "),
      createVNode(unref(So), {
        class: "show-more-icon",
        icon: "ChevronDown"
      })
    ]));
  }
});
const Mce = /* @__PURE__ */ Re(Zce, [["__scopeId", "data-v-5ac202a8"]]), Nce = /* @__PURE__ */ defineComponent({
  __name: "Models",
  props: {
    components: {}
  },
  setup(t10) {
    const e3 = t10, { state: r3 } = Zr(), n3 = computed(
      () => {
        var o3;
        return Object.keys(((o3 = e3.components) == null ? void 0 : o3.schemas) ?? {}).length <= 3 || r3.collapsedSidebarItems[Wo()];
      }
    ), i3 = computed(() => {
      var s3;
      const o3 = Object.keys(((s3 = e3.components) == null ? void 0 : s3.schemas) ?? {});
      return n3.value ? o3 : o3.slice(0, 3);
    });
    return (o3, s3) => o3.components ? (openBlock(), createBlock(unref(Q1), { key: 0 }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(i3.value, (a3, l3) => (openBlock(), createBlock(unref(Bd), {
          id: unref(Wo)(a3),
          key: a3,
          label: a3
        }, {
          default: withCtx(() => {
            var u3, c3;
            return [
              (c3 = (u3 = o3.components) == null ? void 0 : u3.schemas) != null && c3[a3] ? (openBlock(), createBlock(unref(zd), { key: 0 }, {
                default: withCtx(() => {
                  var f3, d3;
                  return [
                    createVNode(unref(Hd), { level: 2 }, {
                      default: withCtx(() => [
                        createVNode(unref(T1), {
                          id: unref(Wo)(a3)
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(a3), 1)
                          ]),
                          _: 2
                        }, 1032, ["id"])
                      ]),
                      _: 2
                    }, 1024),
                    createVNode(Nc, {
                      name: a3,
                      value: (d3 = (f3 = o3.components) == null ? void 0 : f3.schemas) == null ? void 0 : d3[a3]
                    }, null, 8, ["name", "value"]),
                    !n3.value && l3 === i3.value.length - 1 ? (openBlock(), createBlock(Mce, {
                      key: 0,
                      id: unref(Wo)()
                    }, null, 8, ["id"])) : createCommentVNode("", true)
                  ];
                }),
                _: 2
              }, 1024)) : createCommentVNode("", true)
            ];
          }),
          _: 2
        }, 1032, ["id", "label"]))), 128))
      ]),
      _: 1
    })) : createCommentVNode("", true);
  }
}), Wce = { class: "parameter-name" }, Vce = {
  key: 1,
  class: "parameter-type"
}, Yce = /* @__PURE__ */ defineComponent({
  __name: "ParameterItem",
  props: {
    parameter: {}
  },
  setup(t10) {
    return (e3, r3) => {
      var n3, i3;
      return openBlock(), createElementBlock("li", null, [
        createElementVNode("span", Wce, toDisplayString(e3.parameter.name), 1),
        e3.parameter.required !== void 0 ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(["parameter-required", e3.parameter.required ? "parameter__required" : ""])
        }, toDisplayString(e3.parameter.required ? "required" : "optional"), 3)) : createCommentVNode("", true),
        (n3 = e3.parameter.schema) != null && n3.type ? (openBlock(), createElementBlock("span", Vce, toDisplayString((i3 = e3.parameter.schema) == null ? void 0 : i3.type), 1)) : createCommentVNode("", true),
        e3.parameter.description ? (openBlock(), createBlock(fs, {
          key: 2,
          class: "parameter-description",
          value: e3.parameter.description
        }, null, 8, ["value"])) : createCommentVNode("", true)
      ]);
    };
  }
}), Lce = {
  key: 0,
  class: "parameters-container"
}, Bce = { class: "endpoint-title" }, zce = { class: "title" }, Hce = { class: "parameter" }, Gce = /* @__PURE__ */ defineComponent({
  __name: "Parameters",
  props: {
    parameters: {},
    title: {}
  },
  setup(t10) {
    return (e3, r3) => {
      var n3;
      return (n3 = e3.parameters) != null && n3.length ? (openBlock(), createElementBlock("div", Lce, [
        createElementVNode("div", Bce, [
          createElementVNode("h5", zce, toDisplayString(e3.title), 1)
        ]),
        createElementVNode("ul", Hce, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(e3.parameters, (i3) => (openBlock(), createBlock(Yce, {
            key: i3.name,
            parameter: i3
          }, null, 8, ["parameter"]))), 128))
        ])
      ])) : createCommentVNode("", true);
    };
  }
});
const fc = /* @__PURE__ */ Re(Gce, [["__scopeId", "data-v-d173780f"]]), Kce = { class: "param-editor" }, Jce = { class: "param-editor-flex" }, efe = { class: "parameter-name" }, tfe = { class: "parameter-type" }, rfe = {
  key: 0,
  class: "parameter-description"
}, nfe = {
  key: 1,
  class: "parameter-child parameter-child__on"
}, ife = /* @__PURE__ */ createElementVNode("div", { class: "parameter-child-trigger" }, [
  /* @__PURE__ */ createElementVNode("svg", {
    fill: "currentColor",
    height: "14",
    viewBox: "0 0 14 14",
    width: "14",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createElementVNode("polygon", {
      "fill-rule": "nonzero",
      points: "14 8 8 8 8 14 6 14 6 8 0 8 0 6 6 6 6 0 8 0 8 6 14 6"
    })
  ]),
  /* @__PURE__ */ createElementVNode("span", null, "Child Attributes")
], -1), ofe = [
  ife
], sfe = /* @__PURE__ */ defineComponent({
  __name: "RequestBodyPropertiesChild",
  props: {
    contentProperties: {}
  },
  setup(t10) {
    return (e3, r3) => (openBlock(true), createElementBlock(Fragment, null, renderList(e3.contentProperties, (n3, i3) => (openBlock(), createElementBlock("li", { key: i3 }, [
      createElementVNode("div", Kce, [
        createElementVNode("div", Jce, [
          createElementVNode("span", efe, toDisplayString(i3), 1),
          createElementVNode("span", tfe, toDisplayString(n3.type), 1)
        ]),
        n3.description ? (openBlock(), createElementBlock("p", rfe, toDisplayString(n3.description), 1)) : createCommentVNode("", true),
        n3.type === "object" ? (openBlock(), createElementBlock("div", nfe, ofe)) : createCommentVNode("", true)
      ])
    ]))), 128));
  }
}), afe = { class: "parameter-name" }, lfe = { class: "parameter-type" }, ufe = {
  key: 0,
  class: "parameter-description"
}, cfe = /* @__PURE__ */ createElementVNode("svg", {
  fill: "currentColor",
  height: "14",
  viewBox: "0 0 14 14",
  width: "14",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ createElementVNode("polygon", {
    "fill-rule": "nonzero",
    points: "14 8 8 8 8 14 6 14 6 8 0 8 0 6 6 6 6 0 8 0 8 6 14 6"
  })
], -1), ffe = /* @__PURE__ */ createElementVNode("span", null, "Child Attributes", -1), dfe = [
  cfe,
  ffe
], hfe = { class: "parameter" }, pfe = /* @__PURE__ */ defineComponent({
  __name: "RequestBodyProperties",
  props: {
    contentProperties: {},
    required: {}
  },
  setup(t10) {
    const e3 = ref(true);
    return (r3, n3) => (openBlock(true), createElementBlock(Fragment, null, renderList(Object.keys(r3.contentProperties || {}), (i3) => {
      var o3, s3;
      return openBlock(), createElementBlock("li", {
        key: r3.contentProperties[i3].type
      }, [
        createElementVNode("span", afe, toDisplayString(i3), 1),
        createElementVNode("span", {
          class: normalizeClass(["parameter-required", (o3 = r3.required) != null && o3.includes(i3) ? "parameter__required" : ""])
        }, toDisplayString((s3 = r3.required) != null && s3.includes(i3) ? "required" : "optional"), 3),
        createElementVNode("span", lfe, toDisplayString(r3.contentProperties[i3].type), 1),
        r3.contentProperties[i3].description ? (openBlock(), createElementBlock("p", ufe, toDisplayString(r3.contentProperties[i3].description), 1)) : createCommentVNode("", true),
        Object.keys(r3.contentProperties[i3].properties || {}).length > 0 ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["parameter-child", { "parameter-child__open": e3.value }])
        }, [
          createElementVNode("div", {
            class: "parameter-child-trigger",
            onClick: n3[0] || (n3[0] = (a3) => e3.value = !e3.value)
          }, dfe),
          withDirectives(createElementVNode("ul", hfe, [
            createVNode(sfe, {
              contentProperties: r3.contentProperties[i3].properties || {}
            }, null, 8, ["contentProperties"])
          ], 512), [
            [vShow, e3.value]
          ])
        ], 2)) : createCommentVNode("", true)
      ]);
    }), 128));
  }
}), Ofe = (t10) => (pushScopeId("data-v-28fef31c"), t10 = t10(), popScopeId(), t10), mfe = {
  key: 0,
  class: "body-container"
}, gfe = /* @__PURE__ */ Ofe(() => /* @__PURE__ */ createElementVNode("div", { class: "endpoint-title" }, [
  /* @__PURE__ */ createElementVNode("h5", { class: "title" }, "Body")
], -1)), yfe = {
  key: 0,
  class: "parameter"
}, vfe = /* @__PURE__ */ defineComponent({
  __name: "RequestBody",
  props: {
    requestBody: {}
  },
  setup(t10) {
    return (e3, r3) => {
      var n3, i3;
      return e3.requestBody && ((n3 = e3.requestBody.content) != null && n3["application/json"]) ? (openBlock(), createElementBlock("div", mfe, [
        gfe,
        (i3 = e3.requestBody.content) != null && i3["application/json"] ? (openBlock(), createElementBlock("ul", yfe, [
          createVNode(pfe, {
            contentProperties: e3.requestBody.content["application/json"].schema.properties || {},
            required: e3.requestBody.content["application/json"].schema.required || []
          }, null, 8, ["contentProperties", "required"])
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true);
    };
  }
});
const bfe = /* @__PURE__ */ Re(vfe, [["__scopeId", "data-v-28fef31c"]]), Sfe = { class: "copy" }, $fe = { class: "description" }, wfe = /* @__PURE__ */ defineComponent({
  __name: "Copy",
  props: {
    operation: {}
  },
  setup(t10) {
    const e3 = t10, { parameterMap: r3 } = MQ(e3), n3 = computed(() => {
      const { responses: i3 } = e3.operation.information, o3 = [];
      return i3 && Object.keys(i3).forEach((s3) => {
        o3.push({
          name: s3,
          description: i3[s3].description
        });
      }), o3;
    });
    return (i3, o3) => {
      var s3;
      return openBlock(), createElementBlock("div", Sfe, [
        createElementVNode("div", $fe, [
          createVNode(fs, {
            value: i3.operation.description
          }, null, 8, ["value"])
        ]),
        createVNode(fc, {
          parameters: unref(r3).path,
          title: "Path Parameters"
        }, null, 8, ["parameters"]),
        createVNode(fc, {
          parameters: unref(r3).query,
          title: "Query Parameters"
        }, null, 8, ["parameters"]),
        createVNode(fc, {
          parameters: unref(r3).header,
          title: "Headers"
        }, null, 8, ["parameters"]),
        createVNode(bfe, {
          requestBody: (s3 = i3.operation.information) == null ? void 0 : s3.requestBody
        }, null, 8, ["requestBody"]),
        createVNode(fc, {
          parameters: n3.value,
          title: "Responses"
        }, null, 8, ["parameters"])
      ]);
    };
  }
});
const Pfe = /* @__PURE__ */ Re(wfe, [["__scopeId", "data-v-b9582b00"]]), _fe = (t10) => (pushScopeId("data-v-39f0b6b9"), t10 = t10(), popScopeId(), t10), xfe = { class: "request" }, Qfe = ["innerHTML"], Tfe = { class: "language-select" }, kfe = ["value"], Efe = ["label"], Cfe = ["value"], Rfe = /* @__PURE__ */ _fe(() => /* @__PURE__ */ createElementVNode("span", null, "Test Request", -1)), Afe = /* @__PURE__ */ defineComponent({
  __name: "ExampleRequest",
  props: {
    operation: {}
  },
  setup(t10) {
    const e3 = t10, r3 = ref(""), { copyToClipboard: n3 } = Gd(), { setActiveRequest: i3 } = Nr(), { toggleApiClient: o3 } = hs(), { state: s3, setItem: a3, getClientTitle: l3, getTargetTitle: u3 } = Zr(), { configuration: c3 } = Ui(), { server: f3, authentication: d3 } = Ui(), p10 = computed(() => [s3.selectedClient.targetKey]), h10 = async () => {
      const g = Ix(
        {
          url: KO(f3) ?? window.location.origin
        },
        GO(e3.operation, {
          replaceVariables: true
        }),
        Mx(d3)
      );
      try {
        return await new kW(g).convert(
          s3.selectedClient.targetKey,
          s3.selectedClient.clientKey
        );
      } catch (v10) {
        return console.error("[ExampleRequest]", v10), "";
      }
    };
    watch(
      [
        // Update snippet when a different client is selected
        () => s3.selectedClient,
        // … or the global server state changed
        () => f3,
        // … or the global authentication state changed
        () => d3
      ],
      async () => {
        r3.value = await h10();
      },
      {
        deep: true,
        immediate: true
      }
    );
    const m10 = () => {
      const g = zO({
        serverState: f3,
        authenticationState: d3,
        operation: e3.operation
      });
      i3(g), o3();
    };
    computed(() => zO({
      serverState: f3,
      authenticationState: d3,
      operation: e3.operation
    }));
    const O10 = computed(() => e3.operation.path.replace(/(<([^>]+)>)/gi, "").replace(/{([^}]+)}/g, '<span class="request-path-variable">{$1}</span>'));
    return (g, v10) => (openBlock(), createBlock(unref(Da), { class: "dark-mode" }, {
      default: withCtx(() => [
        createVNode(unref(ja), { muted: "" }, {
          actions: withCtx(() => [
            createElementVNode("div", Tfe, [
              createElementVNode("span", null, toDisplayString(unref(u3)(unref(s3).selectedClient)) + " " + toDisplayString(unref(l3)(unref(s3).selectedClient)), 1),
              createElementVNode("select", {
                value: JSON.stringify(unref(s3).selectedClient),
                onInput: v10[0] || (v10[0] = (S10) => unref(a3)(
                  "selectedClient",
                  JSON.parse(S10.target.value)
                ))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(yd)(), (S10) => (openBlock(), createElementBlock("optgroup", {
                  key: S10.key,
                  label: S10.title
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(S10.clients, ($10) => (openBlock(), createElementBlock("option", {
                    key: $10.key,
                    value: JSON.stringify({
                      targetKey: S10.key,
                      clientKey: $10.key
                    })
                  }, toDisplayString($10.title), 9, Cfe))), 128))
                ], 8, Efe))), 128))
              ], 40, kfe)
            ]),
            createElementVNode("button", {
              class: "copy-button",
              type: "button",
              onClick: v10[1] || (v10[1] = (S10) => unref(n3)(r3.value))
            }, [
              createVNode(unref(as), {
                src: "solid/interface-copy-clipboard",
                width: "10px"
              })
            ])
          ]),
          default: withCtx(() => [
            createElementVNode("div", xfe, [
              createElementVNode("span", {
                class: normalizeClass(`request-method request-method--${g.operation.httpVerb}`)
              }, toDisplayString(g.operation.httpVerb), 3),
              createElementVNode("span", {
                class: "request-path",
                innerHTML: O10.value
              }, null, 8, Qfe)
            ])
          ]),
          _: 1
        }),
        createVNode(unref(Fi), {
          borderless: "",
          class: "custom-scroll",
          frameless: ""
        }, {
          default: withCtx(() => [
            createVNode(unref(Pn), {
              content: r3.value,
              forceDarkMode: true,
              languages: p10.value,
              lineNumbers: "",
              readOnly: ""
            }, null, 8, ["content", "languages"])
          ]),
          _: 1
        }),
        unref(c3).withApiClient ? (openBlock(), createBlock(unref(k1), {
          key: 0,
          class: "scalar-card-footer",
          contrast: ""
        }, {
          default: withCtx(() => [
            createElementVNode("button", {
              class: normalizeClass(["show-api-client-button", `show-api-client-button--${g.operation.httpVerb}`]),
              type: "button",
              onClick: m10
            }, [
              Rfe,
              createVNode(unref(as), { src: "solid/mail-send-email-paper-airplane" })
            ], 2)
          ]),
          _: 1
        })) : createCommentVNode("", true)
      ]),
      _: 1
    }));
  }
});
const Xfe = /* @__PURE__ */ Re(Afe, [["__scopeId", "data-v-39f0b6b9"]]), qfe = (t10) => (pushScopeId("data-v-a88a80af"), t10 = t10(), popScopeId(), t10), Dfe = { class: "example-switcher" }, jfe = /* @__PURE__ */ qfe(() => /* @__PURE__ */ createElementVNode("label", {
  class: "listbox-label",
  for: "listbox-button"
}, " Select Example ", -1)), Ufe = { class: "listbox-button-content" }, Ife = { class: "listbox-button-label" }, Ffe = /* @__PURE__ */ defineComponent({
  __name: "SelectExample",
  props: {
    examples: {}
  },
  setup(t10) {
    const r3 = o0(t10.examples, "scalarExampleName"), n3 = ref(r3[0]);
    return (i3, o3) => (openBlock(), createElementBlock("div", Dfe, [
      jfe,
      createVNode(unref(gE), {
        modelValue: n3.value,
        "onUpdate:modelValue": o3[0] || (o3[0] = (s3) => n3.value = s3)
      }, {
        default: withCtx(() => [
          createVNode(unref(yE), {
            id: "listbox-button",
            class: "listbox-button"
          }, {
            default: withCtx(() => [
              createElementVNode("div", Ufe, [
                createElementVNode("div", Ife, toDisplayString(n3.value.value.summary ?? n3.value.key ?? n3.value.scalarExampleName), 1),
                createElementVNode("div", null, [
                  createVNode(unref(as), {
                    class: "icon",
                    src: "line/arrow-chevron-down"
                  })
                ])
              ])
            ]),
            _: 1
          }),
          createVNode(unref(vE), { class: "listbox-options" }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(r3), (s3) => (openBlock(), createBlock(unref(bE), {
                key: s3.key,
                class: "listbox-option",
                value: s3
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(s3.value.summary ?? s3.key ?? s3.scalarExampleName), 1)
                ]),
                _: 2
              }, 1032, ["value"]))), 128))
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue"]),
      createVNode(unref(Pn), {
        content: JSON.stringify(n3.value.value.value, null, 2),
        languages: ["json"],
        readOnly: ""
      }, null, 8, ["content"])
    ]));
  }
});
const Zfe = /* @__PURE__ */ Re(Ffe, [["__scopeId", "data-v-a88a80af"]]), Mfe = { class: "scalar-card-container custom-scroll" }, Nfe = { key: 0 }, Wfe = { key: 1 }, Vfe = {
  key: 0,
  class: "rule"
}, Yfe = { class: "rule-title" }, Lfe = { class: "rule-items" }, Bfe = {
  key: 2,
  class: "scalar-api-reference__empty-state"
}, zfe = { class: "description" }, Hfe = /* @__PURE__ */ defineComponent({
  __name: "ExampleResponses",
  props: {
    operation: {}
  },
  setup(t10) {
    const e3 = t10, { copyToClipboard: r3 } = Gd(), n3 = computed(() => {
      var c3, f3;
      return Object.keys(((f3 = (c3 = e3 == null ? void 0 : e3.operation) == null ? void 0 : c3.information) == null ? void 0 : f3.responses) ?? {}).sort(
        (d3) => d3 === "default" ? -1 : 0
      );
    }), i3 = ref(0), o3 = computed(() => {
      var f3;
      const c3 = n3.value[i3.value];
      return (f3 = e3.operation.information) == null ? void 0 : f3.responses[c3];
    }), s3 = computed(
      () => {
        var c3;
        return (c3 = o3.value.content) == null ? void 0 : c3["application/json"];
      }
    ), a3 = (c3) => {
      i3.value = c3;
    }, l3 = ["oneOf", "anyOf", "not"], u3 = (c3) => c3.reduce((f3, d3) => ({
      ...f3,
      ...d3
    }), {});
    return (c3, f3) => n3.value.length ? (openBlock(), createBlock(unref(Da), { key: 0 }, {
      default: withCtx(() => {
        var d3;
        return [
          createVNode(unref(Nle), {
            muted: "",
            onChange: a3
          }, {
            actions: withCtx(() => {
              var p10;
              return [
                (p10 = s3.value) != null && p10.example ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  class: "code-copy",
                  type: "button",
                  onClick: f3[0] || (f3[0] = () => {
                    var h10;
                    return unref(r3)((h10 = s3.value) == null ? void 0 : h10.example);
                  })
                }, [
                  createVNode(unref(as), {
                    src: "solid/interface-copy-clipboard",
                    width: "10px"
                  })
                ])) : createCommentVNode("", true)
              ];
            }),
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(n3.value, (p10) => (openBlock(), createBlock(unref(Vle), { key: p10 }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(p10), 1)
                ]),
                _: 2
              }, 1024))), 128))
            ]),
            _: 1
          }),
          createElementVNode("div", Mfe, [
            createVNode(unref(Fi), { muted: "" }, {
              default: withCtx(() => {
                var p10, h10, m10, O10, g, v10, S10, $10, _10, P10, q5, N5, B5, H10, ne;
                return [
                  (p10 = s3.value) != null && p10.examples && Object.keys((h10 = s3.value) == null ? void 0 : h10.examples).length > 1 ? (openBlock(), createBlock(Zfe, {
                    key: 0,
                    examples: (m10 = s3.value) == null ? void 0 : m10.examples
                  }, null, 8, ["examples"])) : (O10 = s3.value) != null && O10.examples && Object.keys((g = s3.value) == null ? void 0 : g.examples).length === 1 ? (openBlock(), createBlock(unref(Pn), {
                    key: 1,
                    content: unref(_s)(
                      unref(o0)((v10 = s3.value) == null ? void 0 : v10.examples)[0].value.value
                    ),
                    languages: ["json"],
                    readOnly: ""
                  }, null, 8, ["content"])) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    (S10 = s3.value) != null && S10.example ? (openBlock(), createElementBlock("div", Nfe, [
                      createVNode(unref(Pn), {
                        content: unref(_s)(($10 = s3.value) == null ? void 0 : $10.example),
                        languages: ["json"],
                        readOnly: ""
                      }, null, 8, ["content"])
                    ])) : (_10 = s3.value) != null && _10.schema ? (openBlock(), createElementBlock("div", Wfe, [
                      (P10 = s3.value) != null && P10.schema.type ? (openBlock(), createBlock(unref(Pn), {
                        key: 0,
                        content: unref(_s)(
                          unref(Hr)(
                            (q5 = s3.value) == null ? void 0 : q5.schema,
                            {
                              emptyString: "…"
                            }
                          )
                        ),
                        languages: ["json"],
                        readOnly: ""
                      }, null, 8, ["content"])) : createCommentVNode("", true),
                      (openBlock(), createElementBlock(Fragment, null, renderList(l3, (re2) => {
                        var fe, pe, Ee2, qe, _e, Ie;
                        return openBlock(), createElementBlock(Fragment, { key: re2 }, [
                          (fe = s3.value) != null && fe.schema[re2] && (((pe = s3.value) == null ? void 0 : pe.schema[re2].length) > 1 || re2 === "not") ? (openBlock(), createElementBlock("div", Vfe, [
                            createElementVNode("div", Yfe, toDisplayString(re2), 1),
                            createElementVNode("ol", Lfe, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList((Ee2 = s3.value) == null ? void 0 : Ee2.schema[re2], (je2, G) => (openBlock(), createElementBlock("li", {
                                key: G,
                                class: "rule-item"
                              }, [
                                createVNode(unref(Pn), {
                                  content: unref(_s)(
                                    unref(Hr)(je2, {
                                      emptyString: "…"
                                    })
                                  ),
                                  languages: ["json"],
                                  readOnly: ""
                                }, null, 8, ["content"])
                              ]))), 128))
                            ])
                          ])) : (qe = s3.value) != null && qe.schema[re2] && ((_e = s3.value) == null ? void 0 : _e.schema[re2].length) === 1 ? (openBlock(), createBlock(unref(Pn), {
                            key: 1,
                            content: unref(_s)(
                              unref(Hr)((Ie = s3.value) == null ? void 0 : Ie.schema[re2][0], {
                                emptyString: "…"
                              })
                            ),
                            languages: ["json"],
                            readOnly: ""
                          }, null, 8, ["content"])) : createCommentVNode("", true)
                        ], 64);
                      }), 64)),
                      (N5 = s3.value) != null && N5.schema.allOf ? (openBlock(), createBlock(unref(Pn), {
                        key: 1,
                        content: unref(_s)(
                          u3(
                            (B5 = s3.value) == null ? void 0 : B5.schema.allOf.map(
                              (re2) => unref(Hr)(re2, {
                                emptyString: "…"
                              })
                            )
                          )
                        ),
                        languages: ["json"],
                        readOnly: ""
                      }, null, 8, ["content"])) : createCommentVNode("", true)
                    ])) : createCommentVNode("", true),
                    !((H10 = s3.value) != null && H10.example) && !((ne = s3.value) != null && ne.schema) ? (openBlock(), createElementBlock("div", Bfe, " No Body ")) : createCommentVNode("", true)
                  ], 64))
                ];
              }),
              _: 1
            })
          ]),
          (d3 = o3.value) != null && d3.description ? (openBlock(), createBlock(unref(k1), {
            key: 0,
            class: "scalar-card-footer",
            muted: ""
          }, {
            default: withCtx(() => [
              createElementVNode("div", zfe, [
                createVNode(fs, {
                  class: "markdown",
                  value: o3.value.description
                }, null, 8, ["value"])
              ])
            ]),
            _: 1
          })) : createCommentVNode("", true)
        ];
      }),
      _: 1
    })) : createCommentVNode("", true);
  }
});
const Gfe = /* @__PURE__ */ Re(Hfe, [["__scopeId", "data-v-d49d8496"]]), Kfe = { class: "examples" }, Jfe = /* @__PURE__ */ defineComponent({
  __name: "ReferenceEndpoint",
  props: {
    operation: {},
    tag: {}
  },
  setup(t10) {
    return (e3, r3) => (openBlock(), createBlock(unref(Bd), {
      id: unref(ss)(e3.operation, e3.tag),
      label: e3.operation.name
    }, {
      default: withCtx(() => [
        createVNode(unref(zd), null, {
          default: withCtx(() => [
            createVNode(unref(x1), null, {
              default: withCtx(() => [
                createVNode(unref(wa), null, {
                  default: withCtx(() => [
                    createVNode(unref(Hd), { level: 3 }, {
                      default: withCtx(() => [
                        createVNode(unref(T1), {
                          id: unref(ss)(e3.operation, e3.tag)
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(e3.operation.name), 1)
                          ]),
                          _: 1
                        }, 8, ["id"])
                      ]),
                      _: 1
                    }),
                    createVNode(Pfe, { operation: e3.operation }, null, 8, ["operation"])
                  ]),
                  _: 1
                }),
                createVNode(unref(wa), null, {
                  default: withCtx(() => [
                    createElementVNode("div", Kfe, [
                      createVNode(Xfe, { operation: e3.operation }, null, 8, ["operation"]),
                      createVNode(unref(Gfe), {
                        operation: e3.operation,
                        style: { "margin-top": "12px" }
                      }, null, 8, ["operation"])
                    ])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["id", "label"]));
  }
});
const ede = /* @__PURE__ */ Re(Jfe, [["__scopeId", "data-v-8afe4f0f"]]);
const tde = {}, Jd = (t10) => (pushScopeId("data-v-16147dd7"), t10 = t10(), popScopeId(), t10), rde = { class: "scalar-logo-animation scalar-logo-animation-load" }, nde = /* @__PURE__ */ Jd(() => /* @__PURE__ */ createElementVNode("i", { class: "line line-1" }, null, -1)), ide = /* @__PURE__ */ Jd(() => /* @__PURE__ */ createElementVNode("i", { class: "line line-2" }, null, -1)), ode = /* @__PURE__ */ Jd(() => /* @__PURE__ */ createElementVNode("i", { class: "line line-3" }, null, -1)), sde = /* @__PURE__ */ Jd(() => /* @__PURE__ */ createElementVNode("i", { class: "line line-4" }, null, -1)), ade = [
  nde,
  ide,
  ode,
  sde
];
function lde(t10, e3) {
  return openBlock(), createElementBlock("span", rde, ade);
}
const ude = /* @__PURE__ */ Re(tde, [["render", lde], ["__scopeId", "data-v-16147dd7"]]), cde = ["onClick"], fde = {
  key: 1,
  class: "render-loading"
}, dde = /* @__PURE__ */ defineComponent({
  __name: "Content",
  props: {
    ready: { type: Boolean },
    parsedSpec: {},
    rawSpec: {}
  },
  setup(t10) {
    const e3 = t10, r3 = ref(null), n3 = ref(true);
    pg(
      r3,
      (u3) => n3.value = u3[0].contentRect.width < 900
    );
    const { state: i3, setCollapsedSidebarItem: o3 } = Zr();
    onMounted(() => {
      var u3;
      (u3 = e3.parsedSpec.tags) != null && u3.length && o3(e3.parsedSpec.tags[0].name, true);
    });
    const s3 = cle(() => ({
      url: window.location.origin
    })), a3 = computed(() => e3.parsedSpec.servers && e3.parsedSpec.servers.length > 0 ? e3.parsedSpec.servers : e3.parsedSpec.host && e3.parsedSpec.schemes && e3.parsedSpec.schemes.length > 0 ? [
      { url: `${e3.parsedSpec.schemes[0]}://${e3.parsedSpec.host}` }
    ] : s3.value ? [s3.value] : [{ url: "" }]), l3 = (u3) => {
      var c3, f3;
      return ((f3 = (c3 = e3.parsedSpec) == null ? void 0 : c3.tags) == null ? void 0 : f3.length) !== 1 || (u3 == null ? void 0 : u3.name) !== "default" || (u3 == null ? void 0 : u3.description) !== "";
    };
    return (u3, c3) => (openBlock(), createElementBlock("div", {
      ref_key: "referenceEl",
      ref: r3,
      class: normalizeClass({
        "references-narrow": n3.value
      })
    }, [
      u3.ready ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        u3.parsedSpec.info.title || u3.parsedSpec.info.description ? (openBlock(), createBlock(unref(pce), {
          key: 0,
          info: u3.parsedSpec.info,
          parsedSpec: u3.parsedSpec,
          rawSpec: u3.rawSpec,
          servers: a3.value
        }, null, 8, ["info", "parsedSpec", "rawSpec", "servers"])) : renderSlot(u3.$slots, "empty-state", { key: 1 }, void 0, true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(u3.parsedSpec.tags, (f3, d3) => (openBlock(), createElementBlock(Fragment, {
          key: f3.id
        }, [
          f3.operations && f3.operations.length > 0 ? (openBlock(), createBlock(unref(Q1), { key: 0 }, {
            default: withCtx(() => {
              var p10, h10;
              return [
                l3(f3) ? (openBlock(), createBlock(Gle, {
                  key: 0,
                  tag: f3
                }, null, 8, ["tag"])) : createCommentVNode("", true),
                d3 !== 0 && !unref(i3).collapsedSidebarItems[unref(Tn)(f3)] && ((p10 = f3.operations) == null ? void 0 : p10.length) > 1 ? (openBlock(), createElementBlock("button", {
                  key: 1,
                  class: "show-more",
                  type: "button",
                  onClick: (m10) => unref(o3)(unref(Tn)(f3), true)
                }, [
                  createTextVNode(" Show More "),
                  createVNode(unref(So), {
                    class: "show-more-icon",
                    icon: "ChevronDown"
                  })
                ], 8, cde)) : createCommentVNode("", true),
                d3 === 0 || unref(i3).collapsedSidebarItems[unref(Tn)(f3)] || ((h10 = f3.operations) == null ? void 0 : h10.length) === 1 ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(f3.operations, (m10) => (openBlock(), createBlock(unref(ede), {
                  key: `${m10.httpVerb}-${m10.operationId}`,
                  operation: m10,
                  server: a3.value[0],
                  tag: f3
                }, null, 8, ["operation", "server", "tag"]))), 128)) : createCommentVNode("", true)
              ];
            }),
            _: 2
          }, 1024)) : createCommentVNode("", true)
        ], 64))), 128)),
        unref(Wx)(u3.parsedSpec) ? (openBlock(), createBlock(Nce, {
          key: 2,
          components: u3.parsedSpec.components
        }, null, 8, ["components"])) : createCommentVNode("", true)
      ], 64)) : (openBlock(), createElementBlock("div", fde, [
        createVNode(ude)
      ]))
    ], 2));
  }
});
const hde = /* @__PURE__ */ Re(dde, [["__scopeId", "data-v-f2471d33"]]);
function Zi(t10) {
  return Array.isArray ? Array.isArray(t10) : X5(t10) === "[object Array]";
}
const pde = 1 / 0;
function Ode(t10) {
  if (typeof t10 == "string")
    return t10;
  let e3 = t10 + "";
  return e3 == "0" && 1 / t10 == -pde ? "-0" : e3;
}
function mde(t10) {
  return t10 == null ? "" : Ode(t10);
}
function ri(t10) {
  return typeof t10 == "string";
}
function R5(t10) {
  return typeof t10 == "number";
}
function gde(t10) {
  return t10 === true || t10 === false || yde(t10) && X5(t10) == "[object Boolean]";
}
function A5(t10) {
  return typeof t10 == "object";
}
function yde(t10) {
  return A5(t10) && t10 !== null;
}
function Gr(t10) {
  return t10 != null;
}
function X5(t10) {
  return t10 == null ? t10 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(t10);
}
const Sde = (t10) => `Pattern length exceeds max of ${t10}.`;
function _de(t10, e3) {
  let r3 = [], n3 = false;
  const i3 = (o3, s3, a3) => {
    if (Gr(o3))
      if (!s3[a3])
        r3.push(o3);
      else {
        let l3 = s3[a3];
        const u3 = o3[l3];
        if (!Gr(u3))
          return;
        if (a3 === s3.length - 1 && (ri(u3) || R5(u3) || gde(u3)))
          r3.push(mde(u3));
        else if (Zi(u3)) {
          n3 = true;
          for (let c3 = 0, f3 = u3.length; c3 < f3; c3 += 1)
            i3(u3[c3], s3, a3 + 1);
        } else
          s3.length && i3(u3, s3, a3 + 1);
      }
  };
  return i3(t10, ri(e3) ? e3.split(".") : e3, 0), n3 ? r3 : r3[0];
}
const xde = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
}, Qde = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (t10, e3) => t10.score === e3.score ? t10.idx < e3.idx ? -1 : 1 : t10.score < e3.score ? -1 : 1
}, Tde = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
}, kde = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: _de,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var We = {
  ...Qde,
  ...xde,
  ...Tde,
  ...kde
};
function dc(t10, {
  errors: e3 = 0,
  currentLocation: r3 = 0,
  expectedLocation: n3 = 0,
  distance: i3 = We.distance,
  ignoreLocation: o3 = We.ignoreLocation
} = {}) {
  const s3 = e3 / t10.length;
  if (o3)
    return s3;
  const a3 = Math.abs(n3 - r3);
  return i3 ? s3 + a3 / i3 : a3 ? 1 : s3;
}
function Ade(t10 = [], e3 = We.minMatchCharLength) {
  let r3 = [], n3 = -1, i3 = -1, o3 = 0;
  for (let s3 = t10.length; o3 < s3; o3 += 1) {
    let a3 = t10[o3];
    a3 && n3 === -1 ? n3 = o3 : !a3 && n3 !== -1 && (i3 = o3 - 1, i3 - n3 + 1 >= e3 && r3.push([n3, i3]), n3 = -1);
  }
  return t10[o3 - 1] && o3 - n3 >= e3 && r3.push([n3, o3 - 1]), r3;
}
const Uo = 32;
function Xde(t10, e3, r3, {
  location: n3 = We.location,
  distance: i3 = We.distance,
  threshold: o3 = We.threshold,
  findAllMatches: s3 = We.findAllMatches,
  minMatchCharLength: a3 = We.minMatchCharLength,
  includeMatches: l3 = We.includeMatches,
  ignoreLocation: u3 = We.ignoreLocation
} = {}) {
  if (e3.length > Uo)
    throw new Error(Sde(Uo));
  const c3 = e3.length, f3 = t10.length, d3 = Math.max(0, Math.min(n3, f3));
  let p10 = o3, h10 = d3;
  const m10 = a3 > 1 || l3, O10 = m10 ? Array(f3) : [];
  let g;
  for (; (g = t10.indexOf(e3, h10)) > -1; ) {
    let q5 = dc(e3, {
      currentLocation: g,
      expectedLocation: d3,
      distance: i3,
      ignoreLocation: u3
    });
    if (p10 = Math.min(q5, p10), h10 = g + c3, m10) {
      let N5 = 0;
      for (; N5 < c3; )
        O10[g + N5] = 1, N5 += 1;
    }
  }
  h10 = -1;
  let v10 = [], S10 = 1, $10 = c3 + f3;
  const _10 = 1 << c3 - 1;
  for (let q5 = 0; q5 < c3; q5 += 1) {
    let N5 = 0, B5 = $10;
    for (; N5 < B5; )
      dc(e3, {
        errors: q5,
        currentLocation: d3 + B5,
        expectedLocation: d3,
        distance: i3,
        ignoreLocation: u3
      }) <= p10 ? N5 = B5 : $10 = B5, B5 = Math.floor(($10 - N5) / 2 + N5);
    $10 = B5;
    let H10 = Math.max(1, d3 - B5 + 1), ne = s3 ? f3 : Math.min(d3 + B5, f3) + c3, re2 = Array(ne + 2);
    re2[ne + 1] = (1 << q5) - 1;
    for (let pe = ne; pe >= H10; pe -= 1) {
      let Ee2 = pe - 1, qe = r3[t10.charAt(Ee2)];
      if (m10 && (O10[Ee2] = +!!qe), re2[pe] = (re2[pe + 1] << 1 | 1) & qe, q5 && (re2[pe] |= (v10[pe + 1] | v10[pe]) << 1 | 1 | v10[pe + 1]), re2[pe] & _10 && (S10 = dc(e3, {
        errors: q5,
        currentLocation: Ee2,
        expectedLocation: d3,
        distance: i3,
        ignoreLocation: u3
      }), S10 <= p10)) {
        if (p10 = S10, h10 = Ee2, h10 <= d3)
          break;
        H10 = Math.max(1, 2 * d3 - h10);
      }
    }
    if (dc(e3, {
      errors: q5 + 1,
      currentLocation: d3,
      expectedLocation: d3,
      distance: i3,
      ignoreLocation: u3
    }) > p10)
      break;
    v10 = re2;
  }
  const P10 = {
    isMatch: h10 >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, S10)
  };
  if (m10) {
    const q5 = Ade(O10, a3);
    q5.length ? l3 && (P10.indices = q5) : P10.isMatch = false;
  }
  return P10;
}
function qde(t10) {
  let e3 = {};
  for (let r3 = 0, n3 = t10.length; r3 < n3; r3 += 1) {
    const i3 = t10.charAt(r3);
    e3[i3] = (e3[i3] || 0) | 1 << n3 - r3 - 1;
  }
  return e3;
}
class j5 {
  constructor(e3, {
    location: r3 = We.location,
    threshold: n3 = We.threshold,
    distance: i3 = We.distance,
    includeMatches: o3 = We.includeMatches,
    findAllMatches: s3 = We.findAllMatches,
    minMatchCharLength: a3 = We.minMatchCharLength,
    isCaseSensitive: l3 = We.isCaseSensitive,
    ignoreLocation: u3 = We.ignoreLocation
  } = {}) {
    if (this.options = {
      location: r3,
      threshold: n3,
      distance: i3,
      includeMatches: o3,
      findAllMatches: s3,
      minMatchCharLength: a3,
      isCaseSensitive: l3,
      ignoreLocation: u3
    }, this.pattern = l3 ? e3 : e3.toLowerCase(), this.chunks = [], !this.pattern.length)
      return;
    const c3 = (d3, p10) => {
      this.chunks.push({
        pattern: d3,
        alphabet: qde(d3),
        startIndex: p10
      });
    }, f3 = this.pattern.length;
    if (f3 > Uo) {
      let d3 = 0;
      const p10 = f3 % Uo, h10 = f3 - p10;
      for (; d3 < h10; )
        c3(this.pattern.substr(d3, Uo), d3), d3 += Uo;
      if (p10) {
        const m10 = f3 - Uo;
        c3(this.pattern.substr(m10), m10);
      }
    } else
      c3(this.pattern, 0);
  }
  searchIn(e3) {
    const { isCaseSensitive: r3, includeMatches: n3 } = this.options;
    if (r3 || (e3 = e3.toLowerCase()), this.pattern === e3) {
      let h10 = {
        isMatch: true,
        score: 0
      };
      return n3 && (h10.indices = [[0, e3.length - 1]]), h10;
    }
    const {
      location: i3,
      distance: o3,
      threshold: s3,
      findAllMatches: a3,
      minMatchCharLength: l3,
      ignoreLocation: u3
    } = this.options;
    let c3 = [], f3 = 0, d3 = false;
    this.chunks.forEach(({ pattern: h10, alphabet: m10, startIndex: O10 }) => {
      const { isMatch: g, score: v10, indices: S10 } = Xde(e3, h10, m10, {
        location: i3 + O10,
        distance: o3,
        threshold: s3,
        findAllMatches: a3,
        minMatchCharLength: l3,
        includeMatches: n3,
        ignoreLocation: u3
      });
      g && (d3 = true), f3 += v10, g && S10 && (c3 = [...c3, ...S10]);
    });
    let p10 = {
      isMatch: d3,
      score: d3 ? f3 / this.chunks.length : 1
    };
    return d3 && n3 && (p10.indices = c3), p10;
  }
}
class xo {
  constructor(e3) {
    this.pattern = e3;
  }
  static isMultiMatch(e3) {
    return bw(e3, this.multiRegex);
  }
  static isSingleMatch(e3) {
    return bw(e3, this.singleRegex);
  }
  search() {
  }
}
function bw(t10, e3) {
  const r3 = t10.match(e3);
  return r3 ? r3[1] : null;
}
class Dde extends xo {
  constructor(e3) {
    super(e3);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(e3) {
    const r3 = e3 === this.pattern;
    return {
      isMatch: r3,
      score: r3 ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class jde extends xo {
  constructor(e3) {
    super(e3);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(e3) {
    const n3 = e3.indexOf(this.pattern) === -1;
    return {
      isMatch: n3,
      score: n3 ? 0 : 1,
      indices: [0, e3.length - 1]
    };
  }
}
class Ude extends xo {
  constructor(e3) {
    super(e3);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(e3) {
    const r3 = e3.startsWith(this.pattern);
    return {
      isMatch: r3,
      score: r3 ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class Ide extends xo {
  constructor(e3) {
    super(e3);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(e3) {
    const r3 = !e3.startsWith(this.pattern);
    return {
      isMatch: r3,
      score: r3 ? 0 : 1,
      indices: [0, e3.length - 1]
    };
  }
}
class Fde extends xo {
  constructor(e3) {
    super(e3);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(e3) {
    const r3 = e3.endsWith(this.pattern);
    return {
      isMatch: r3,
      score: r3 ? 0 : 1,
      indices: [e3.length - this.pattern.length, e3.length - 1]
    };
  }
}
class Zde extends xo {
  constructor(e3) {
    super(e3);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(e3) {
    const r3 = !e3.endsWith(this.pattern);
    return {
      isMatch: r3,
      score: r3 ? 0 : 1,
      indices: [0, e3.length - 1]
    };
  }
}
class U5 extends xo {
  constructor(e3, {
    location: r3 = We.location,
    threshold: n3 = We.threshold,
    distance: i3 = We.distance,
    includeMatches: o3 = We.includeMatches,
    findAllMatches: s3 = We.findAllMatches,
    minMatchCharLength: a3 = We.minMatchCharLength,
    isCaseSensitive: l3 = We.isCaseSensitive,
    ignoreLocation: u3 = We.ignoreLocation
  } = {}) {
    super(e3), this._bitapSearch = new j5(e3, {
      location: r3,
      threshold: n3,
      distance: i3,
      includeMatches: o3,
      findAllMatches: s3,
      minMatchCharLength: a3,
      isCaseSensitive: l3,
      ignoreLocation: u3
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(e3) {
    return this._bitapSearch.searchIn(e3);
  }
}
class I5 extends xo {
  constructor(e3) {
    super(e3);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(e3) {
    let r3 = 0, n3;
    const i3 = [], o3 = this.pattern.length;
    for (; (n3 = e3.indexOf(this.pattern, r3)) > -1; )
      r3 = n3 + o3, i3.push([n3, r3 - 1]);
    const s3 = !!i3.length;
    return {
      isMatch: s3,
      score: s3 ? 0 : 1,
      indices: i3
    };
  }
}
const Bm = [
  Dde,
  I5,
  Ude,
  Ide,
  Zde,
  Fde,
  jde,
  U5
], Sw = Bm.length, Mde = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, Nde = "|";
function Wde(t10, e3 = {}) {
  return t10.split(Nde).map((r3) => {
    let n3 = r3.trim().split(Mde).filter((o3) => o3 && !!o3.trim()), i3 = [];
    for (let o3 = 0, s3 = n3.length; o3 < s3; o3 += 1) {
      const a3 = n3[o3];
      let l3 = false, u3 = -1;
      for (; !l3 && ++u3 < Sw; ) {
        const c3 = Bm[u3];
        let f3 = c3.isMultiMatch(a3);
        f3 && (i3.push(new c3(f3, e3)), l3 = true);
      }
      if (!l3)
        for (u3 = -1; ++u3 < Sw; ) {
          const c3 = Bm[u3];
          let f3 = c3.isSingleMatch(a3);
          if (f3) {
            i3.push(new c3(f3, e3));
            break;
          }
        }
    }
    return i3;
  });
}
const Vde = /* @__PURE__ */ new Set([U5.type, I5.type]);
class Yde {
  constructor(e3, {
    isCaseSensitive: r3 = We.isCaseSensitive,
    includeMatches: n3 = We.includeMatches,
    minMatchCharLength: i3 = We.minMatchCharLength,
    ignoreLocation: o3 = We.ignoreLocation,
    findAllMatches: s3 = We.findAllMatches,
    location: a3 = We.location,
    threshold: l3 = We.threshold,
    distance: u3 = We.distance
  } = {}) {
    this.query = null, this.options = {
      isCaseSensitive: r3,
      includeMatches: n3,
      minMatchCharLength: i3,
      findAllMatches: s3,
      ignoreLocation: o3,
      location: a3,
      threshold: l3,
      distance: u3
    }, this.pattern = r3 ? e3 : e3.toLowerCase(), this.query = Wde(this.pattern, this.options);
  }
  static condition(e3, r3) {
    return r3.useExtendedSearch;
  }
  searchIn(e3) {
    const r3 = this.query;
    if (!r3)
      return {
        isMatch: false,
        score: 1
      };
    const { includeMatches: n3, isCaseSensitive: i3 } = this.options;
    e3 = i3 ? e3 : e3.toLowerCase();
    let o3 = 0, s3 = [], a3 = 0;
    for (let l3 = 0, u3 = r3.length; l3 < u3; l3 += 1) {
      const c3 = r3[l3];
      s3.length = 0, o3 = 0;
      for (let f3 = 0, d3 = c3.length; f3 < d3; f3 += 1) {
        const p10 = c3[f3], { isMatch: h10, indices: m10, score: O10 } = p10.search(e3);
        if (h10) {
          if (o3 += 1, a3 += O10, n3) {
            const g = p10.constructor.type;
            Vde.has(g) ? s3 = [...s3, ...m10] : s3.push(m10);
          }
        } else {
          a3 = 0, o3 = 0, s3.length = 0;
          break;
        }
      }
      if (o3) {
        let f3 = {
          isMatch: true,
          score: a3 / o3
        };
        return n3 && (f3.indices = s3), f3;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const zm = [];
function Lde(...t10) {
  zm.push(...t10);
}
Lde(Yde);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  __ssrInlineRender: true,
  setup(__props) {
    const reactiveSpec = reactive({
      info: {
        title: "",
        description: "",
        termsOfService: "",
        version: "",
        license: {
          name: "",
          url: ""
        },
        contact: {
          email: ""
        }
      },
      externalDocs: {
        description: "",
        url: ""
      },
      servers: [],
      tags: []
    });
    onMounted(() => {
      console.log(L$2("# HI"));
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(_attrs)}>`);
      _push(ssrRenderComponent(unref(fm), {
        isDarkMode: true,
        parsedSpec: reactiveSpec,
        onToggleDarkMode: () => {
        }
      }, null, _parent));
      _push(ssrRenderComponent(unref(hde), {
        class: "references-rendered",
        parsedSpec: reactiveSpec,
        rawSpec: "",
        ready: true
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("src/App.vue");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const style = "";
const createApp = ViteSSG(_sfc_main);
export {
  createApp
};
